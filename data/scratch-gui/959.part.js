/* 959 */\n (function(module, exports, __webpack_require__) {\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nvar EventEmitter = __webpack_require__(91);\nvar Blocks = __webpack_require__(135);\nvar Variable = __webpack_require__(114);\nvar Comment = __webpack_require__(297);\nvar uid = __webpack_require__(94);\nvar _require = __webpack_require__(181),\n    Map = _require.Map;\nvar log = __webpack_require__(39);\nvar StringUtil = __webpack_require__(102);\nvar VariableUtil = __webpack_require__(442);\n/**\n * @fileoverview\n * A Target is an abstract \"code-running\" object for the Scratch VM.\n * Examples include sprites/clones or potentially physical-world devices.\n */\nvar Target = function (_EventEmitter) {\n  _inherits(Target, _EventEmitter);\n  var _super = _createSuper(Target);\n  /**\n   * @param {Runtime} runtime Reference to the runtime.\n   * @param {?Blocks} blocks Blocks instance for the blocks owned by this target.\n   * @constructor\n   */\n  function Target(runtime, blocks) {\n    var _this;\n    _classCallCheck(this, Target);\n    _this = _super.call(this);\n    if (!blocks) {\n      blocks = new Blocks(runtime);\n    }\n    /**\n     * Reference to the runtime.\n     * @type {Runtime}\n     */\n    _this.runtime = runtime;\n    /**\n     * A unique ID for this target.\n     * @type {string}\n     */\n    _this.id = uid();\n    /**\n     * Blocks run as code for this target.\n     * @type {!Blocks}\n     */\n    _this.blocks = blocks;\n    /**\n     * Dictionary of variables and their values for this target.\n     * Key is the variable id.\n     * @type {Object.<string,*>}\n     */\n    _this.variables = {};\n    /**\n     * Dictionary of comments for this target.\n     * Key is the comment id.\n     * @type {Object.<string,*>}\n     */\n    _this.comments = {};\n    /**\n     * Dictionary of custom state for this target.\n     * This can be used to store target-specific custom state for blocks which need it.\n     * TODO: do we want to persist this in SB3 files?\n     * @type {Object.<string,*>}\n     */\n    _this._customState = {};\n    /**\n     * Currently known values for edge-activated hats.\n     * Keys are block ID for the hat; values are the currently known values.\n     * @type {Object.<string, *>}\n     */\n    _this._edgeActivatedHatValues = {};\n    return _this;\n  }\n  /**\n   * Called when the project receives a \"green flag.\"\n   * @abstract\n   */\n  _createClass(Target, [{\n    key: \"onGreenFlag\",\n    value: function onGreenFlag() {}\n    /**\n     * Return a human-readable name for this target.\n     * Target implementations should override this.\n     * @abstract\n     * @returns {string} Human-readable name for the target.\n     */\n  }, {\n    key: \"getName\",\n    value: function getName() {\n      return this.id;\n    }\n    /**\n     * Update an edge-activated hat block value.\n     * @param {!string} blockId ID of hat to store value for.\n     * @param {*} newValue Value to store for edge-activated hat.\n     * @return {*} The old value for the edge-activated hat.\n     */\n  }, {\n    key: \"updateEdgeActivatedValue\",\n    value: function updateEdgeActivatedValue(blockId, newValue) {\n      var oldValue = this._edgeActivatedHatValues[blockId];\n      this._edgeActivatedHatValues[blockId] = newValue;\n      return oldValue;\n    }\n  }, {\n    key: \"hasEdgeActivatedValue\",\n    value: function hasEdgeActivatedValue(blockId) {\n      return this._edgeActivatedHatValues.hasOwnProperty(blockId);\n    }\n    /**\n     * Clear all edge-activaed hat values.\n     */\n  }, {\n    key: \"clearEdgeActivatedValues\",\n    value: function clearEdgeActivatedValues() {\n      this._edgeActivatedHatValues = {};\n    }\n    /**\n     * Look up a variable object, first by id, and then by name if the id is not found.\n     * Create a new variable if both lookups fail.\n     * @param {string} id Id of the variable.\n     * @param {string} name Name of the variable.\n     * @return {!Variable} Variable object.\n     */\n  }, {\n    key: \"lookupOrCreateVariable\",\n    value: function lookupOrCreateVariable(id, name) {\n      var variable = this.lookupVariableById(id);\n      if (variable) return variable;\n      variable = this.lookupVariableByNameAndType(name, Variable.SCALAR_TYPE);\n      if (variable) return variable; // No variable with this name exists - create it locally.\n      var newVariable = new Variable(id, name, Variable.SCALAR_TYPE, false);\n      this.variables[id] = newVariable;\n      return newVariable;\n    }\n    /**\n     * Look up a broadcast message object with the given id and return it\n     * if it exists.\n     * @param {string} id Id of the variable.\n     * @param {string} name Name of the variable.\n     * @return {?Variable} Variable object.\n     */\n  }, {\n    key: \"lookupBroadcastMsg\",\n    value: function lookupBroadcastMsg(id, name) {\n      var broadcastMsg;\n      if (id) {\n        broadcastMsg = this.lookupVariableById(id);\n      } else if (name) {\n        broadcastMsg = this.lookupBroadcastByInputValue(name);\n      } else {\n        log.error('Cannot find broadcast message if neither id nor name are provided.');\n      }\n      if (broadcastMsg) {\n        if (name && broadcastMsg.name.toLowerCase() !== name.toLowerCase()) {\n          log.error(\"Found broadcast message with id: \".concat(id, \", but\") + \"its name, \".concat(broadcastMsg.name, \" did not match expected name \").concat(name, \".\"));\n        }\n        if (broadcastMsg.type !== Variable.BROADCAST_MESSAGE_TYPE) {\n          log.error(\"Found variable with id: \".concat(id, \", but its type \").concat(broadcastMsg.type) + \"did not match expected type \".concat(Variable.BROADCAST_MESSAGE_TYPE));\n        }\n        return broadcastMsg;\n      }\n    }\n    /**\n     * Look up a broadcast message with the given name and return the variable\n     * if it exists. Does not create a new broadcast message variable if\n     * it doesn't exist.\n     * @param {string} name Name of the variable.\n     * @return {?Variable} Variable object.\n     */\n  }, {\n    key: \"lookupBroadcastByInputValue\",\n    value: function lookupBroadcastByInputValue(name) {\n      var vars = this.variables;\n      for (var propName in vars) {\n        if (vars[propName].type === Variable.BROADCAST_MESSAGE_TYPE && vars[propName].name.toLowerCase() === name.toLowerCase()) {\n          return vars[propName];\n        }\n      }\n    }\n    /**\n     * Look up a variable object.\n     * Search begins for local variables; then look for globals.\n     * @param {string} id Id of the variable.\n     * @param {string} name Name of the variable.\n     * @return {!Variable} Variable object.\n     */\n  }, {\n    key: \"lookupVariableById\",\n    value: function lookupVariableById(id) {\n      // If we have a local copy, return it.\n      if (this.variables.hasOwnProperty(id)) {\n        return this.variables[id];\n      } // If the stage has a global copy, return it.\n      if (this.runtime && !this.isStage) {\n        var stage = this.runtime.getTargetForStage();\n        if (stage && stage.variables.hasOwnProperty(id)) {\n          return stage.variables[id];\n        }\n      }\n    }\n    /**\n     * Look up a variable object by its name and variable type.\n     * Search begins with local variables; then global variables if a local one\n     * was not found.\n     * @param {string} name Name of the variable.\n     * @param {string} type Type of the variable. Defaults to Variable.SCALAR_TYPE.\n     * @param {?bool} skipStage Optional flag to skip checking the stage\n     * @return {?Variable} Variable object if found, or null if not.\n     */\n  }, {\n    key: \"lookupVariableByNameAndType\",\n    value: function lookupVariableByNameAndType(name, type, skipStage) {\n      if (typeof name !== 'string') return;\n      if (typeof type !== 'string') type = Variable.SCALAR_TYPE;\n      skipStage = skipStage || false;\n      for (var varId in this.variables) {\n        var currVar = this.variables[varId];\n        if (currVar.name === name && currVar.type === type) {\n          return currVar;\n        }\n      }\n      if (!skipStage && this.runtime && !this.isStage) {\n        var stage = this.runtime.getTargetForStage();\n        if (stage) {\n          for (var _varId in stage.variables) {\n            var _currVar = stage.variables[_varId];\n            if (_currVar.name === name && _currVar.type === type) {\n              return _currVar;\n            }\n          }\n        }\n      }\n      return null;\n    }\n    /**\n    * Look up a list object for this target, and create it if one doesn't exist.\n    * Search begins for local lists; then look for globals.\n    * @param {!string} id Id of the list.\n    * @param {!string} name Name of the list.\n    * @return {!Varible} Variable object representing the found/created list.\n     */\n  }, {\n    key: \"lookupOrCreateList\",\n    value: function lookupOrCreateList(id, name) {\n      var list = this.lookupVariableById(id);\n      if (list) return list;\n      list = this.lookupVariableByNameAndType(name, Variable.LIST_TYPE);\n      if (list) return list; // No variable with this name exists - create it locally.\n      var newList = new Variable(id, name, Variable.LIST_TYPE, false);\n      this.variables[id] = newList;\n      return newList;\n    }\n    /**\n     * Creates a variable with the given id and name and adds it to the\n     * dictionary of variables.\n     * @param {string} id Id of variable\n     * @param {string} name Name of variable.\n     * @param {string} type Type of variable, '', 'broadcast_msg', or 'list'\n     * @param {boolean} isCloud Whether the variable to create has the isCloud flag set.\n     * Additional checks are made that the variable can be created as a cloud variable.\n     */\n  }, {\n    key: \"createVariable\",\n    value: function createVariable(id, name, type, isCloud) {\n      if (!this.variables.hasOwnProperty(id)) {\n        var newVariable = new Variable(id, name, type, false);\n        if (isCloud && this.isStage && this.runtime.canAddCloudVariable()) {\n          newVariable.isCloud = true;\n          this.runtime.addCloudVariable();\n          this.runtime.ioDevices.cloud.requestCreateVariable(newVariable);\n        }\n        this.variables[id] = newVariable;\n      }\n    }\n    /**\n     * Creates a comment with the given properties.\n     * @param {string} id Id of the comment.\n     * @param {string} blockId Optional id of the block the comment is attached\n     * to if it is a block comment.\n     * @param {string} text The text the comment contains.\n     * @param {number} x The x coordinate of the comment on the workspace.\n     * @param {number} y The y coordinate of the comment on the workspace.\n     * @param {number} width The width of the comment when it is full size\n     * @param {number} height The height of the comment when it is full size\n     * @param {boolean} minimized Whether the comment is minimized.\n     */\n  }, {\n    key: \"createComment\",\n    value: function createComment(id, blockId, text, x, y, width, height, minimized) {\n      if (!this.comments.hasOwnProperty(id)) {\n        var newComment = new Comment(id, text, x, y, width, height, minimized);\n        if (blockId) {\n          newComment.blockId = blockId;\n          var blockWithComment = this.blocks.getBlock(blockId);\n          if (blockWithComment) {\n            blockWithComment.comment = id;\n          } else {\n            log.warn(\"Could not find block with id \".concat(blockId, \" associated with commentId: \").concat(id));\n          }\n        }\n        this.comments[id] = newComment;\n      }\n    }\n    /**\n     * Renames the variable with the given id to newName.\n     * @param {string} id Id of variable to rename.\n     * @param {string} newName New name for the variable.\n     */\n  }, {\n    key: \"renameVariable\",\n    value: function renameVariable(id, newName) {\n      var _this2 = this;\n      if (this.variables.hasOwnProperty(id)) {\n        var variable = this.variables[id];\n        if (variable.id === id) {\n          var oldName = variable.name;\n          variable.name = newName;\n          if (this.runtime) {\n            if (variable.isCloud && this.isStage) {\n              this.runtime.ioDevices.cloud.requestRenameVariable(oldName, newName);\n            }\n            if (variable.type === Variable.SCALAR_TYPE) {\n              // sensing__of may be referencing to this variable.\n              // Change the reference.\n              var blockUpdated = false;\n              this.runtime.targets.forEach(function (t) {\n                blockUpdated = t.blocks.updateSensingOfReference(oldName, newName, _this2.isStage ? '_stage_' : _this2.getName()) || blockUpdated;\n              }); // Request workspace change only if sensing_of blocks were actually updated.\n              if (blockUpdated) this.runtime.requestBlocksUpdate();\n            }\n            var blocks = this.runtime.monitorBlocks;\n            blocks.changeBlock({\n              id: id,\n              element: 'field',\n              name: variable.type === Variable.LIST_TYPE ? 'LIST' : 'VARIABLE',\n              value: id\n            }, this.runtime);\n            var monitorBlock = blocks.getBlock(variable.id);\n            if (monitorBlock) {\n              this.runtime.requestUpdateMonitor(Map({\n                id: id,\n                params: blocks._getBlockParams(monitorBlock)\n              }));\n            }\n          }\n        }\n      }\n    }\n    /**\n     * Removes the variable with the given id from the dictionary of variables.\n     * @param {string} id Id of variable to delete.\n     */\n  }, {\n    key: \"deleteVariable\",\n    value: function deleteVariable(id) {\n      if (this.variables.hasOwnProperty(id)) {\n        // Get info about the variable before deleting it\n        var deletedVariableName = this.variables[id].name;\n        var deletedVariableWasCloud = this.variables[id].isCloud;\n        delete this.variables[id];\n        if (this.runtime) {\n          if (deletedVariableWasCloud && this.isStage) {\n            this.runtime.ioDevices.cloud.requestDeleteVariable(deletedVariableName);\n            this.runtime.removeCloudVariable();\n          }\n          this.runtime.monitorBlocks.deleteBlock(id);\n          this.runtime.requestRemoveMonitor(id);\n        }\n      }\n    }\n    /**\n     * Remove this target's monitors from the runtime state and remove the\n     * target-specific monitored blocks (e.g. local variables, global variables for the stage, x-position).\n     * NOTE: This does not delete any of the stage monitors like backdrop name.\n     */\n  }, {\n    key: \"deleteMonitors\",\n    value: function deleteMonitors() {\n      var _this3 = this;\n      this.runtime.requestRemoveMonitorByTargetId(this.id);\n      var targetSpecificMonitorBlockIds;\n      if (this.isStage) {\n        // This only deletes global variables and not other stage monitors like backdrop number.\n        targetSpecificMonitorBlockIds = Object.keys(this.variables);\n      } else {\n        targetSpecificMonitorBlockIds = Object.keys(this.runtime.monitorBlocks._blocks).filter(function (key) {\n          return _this3.runtime.monitorBlocks._blocks[key].targetId === _this3.id;\n        });\n      }\n      var _iterator = _createForOfIteratorHelper(targetSpecificMonitorBlockIds),\n          _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var blockId = _step.value;\n          this.runtime.monitorBlocks.deleteBlock(blockId);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    /**\n     * Create a clone of the variable with the given id from the dictionary of\n     * this target's variables.\n     * @param {string} id Id of variable to duplicate.\n     * @param {boolean=} optKeepOriginalId Optional flag to keep the original variable ID\n     * for the duplicate variable. This is necessary when cloning a sprite, for example.\n     * @return {?Variable} The duplicated variable, or null if\n     * the original variable was not found.\n     */\n  }, {\n    key: \"duplicateVariable\",\n    value: function duplicateVariable(id, optKeepOriginalId) {\n      if (this.variables.hasOwnProperty(id)) {\n        var originalVariable = this.variables[id];\n        var newVariable = new Variable(optKeepOriginalId ? id : null, // conditionally keep original id or generate a new one\n        originalVariable.name, originalVariable.type, originalVariable.isCloud);\n        if (newVariable.type === Variable.LIST_TYPE) {\n          newVariable.value = originalVariable.value.slice(0);\n        } else {\n          newVariable.value = originalVariable.value;\n        }\n        return newVariable;\n      }\n      return null;\n    }\n    /**\n     * Duplicate the dictionary of this target's variables as part of duplicating.\n     * this target or making a clone.\n     * @param {object=} optBlocks Optional block container for the target being duplicated.\n     * If provided, new variables will be generated with new UIDs and any variable references\n     * in this blocks container will be updated to refer to the corresponding new IDs.\n     * @return {object} The duplicated dictionary of variables\n     */\n  }, {\n    key: \"duplicateVariables\",\n    value: function duplicateVariables(optBlocks) {\n      var _this4 = this;\n      var allVarRefs;\n      if (optBlocks) {\n        allVarRefs = optBlocks.getAllVariableAndListReferences();\n      }\n      return Object.keys(this.variables).reduce(function (accum, varId) {\n        var newVariable = _this4.duplicateVariable(varId, !optBlocks);\n        accum[newVariable.id] = newVariable;\n        if (optBlocks && allVarRefs) {\n          var currVarRefs = allVarRefs[varId];\n          if (currVarRefs) {\n            _this4.mergeVariables(varId, newVariable.id, currVarRefs);\n          }\n        }\n        return accum;\n      }, {});\n    }\n    /**\n     * Post/edit sprite info.\n     * @param {object} data An object with sprite info data to set.\n     * @abstract\n     */\n  }, {\n    key: \"postSpriteInfo\",\n    value: function postSpriteInfo() {}\n    /**\n     * Retrieve custom state associated with this target and the provided state ID.\n     * @param {string} stateId - specify which piece of state to retrieve.\n     * @returns {*} the associated state, if any was found.\n     */\n  }, {\n    key: \"getCustomState\",\n    value: function getCustomState(stateId) {\n      return this._customState[stateId];\n    }\n    /**\n     * Store custom state associated with this target and the provided state ID.\n     * @param {string} stateId - specify which piece of state to store on this target.\n     * @param {*} newValue - the state value to store.\n     */\n  }, {\n    key: \"setCustomState\",\n    value: function setCustomState(stateId, newValue) {\n      this._customState[stateId] = newValue;\n    }\n    /**\n     * Call to destroy a target.\n     * @abstract\n     */\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this._customState = {};\n      if (this.runtime) {\n        this.runtime.removeExecutable(this);\n      }\n    } // Variable Conflict Resolution Helpers\n    /**\n     * Get the names of all the variables of the given type that are in scope for this target.\n     * For targets that are not the stage, this includes any target-specific\n     * variables as well as any stage variables unless the skipStage flag is true.\n     * For the stage, this is all stage variables.\n     * @param {string} type The variable type to search for; defaults to Variable.SCALAR_TYPE\n     * @param {?bool} skipStage Optional flag to skip the stage.\n     * @return {Array<string>} A list of variable names\n     */\n  }, {\n    key: \"getAllVariableNamesInScopeByType\",\n    value: function getAllVariableNamesInScopeByType(type, skipStage) {\n      if (typeof type !== 'string') type = Variable.SCALAR_TYPE;\n      skipStage = skipStage || false;\n      var targetVariables = Object.values(this.variables).filter(function (v) {\n        return v.type === type;\n      }).map(function (variable) {\n        return variable.name;\n      });\n      if (skipStage || this.isStage || !this.runtime) {\n        return targetVariables;\n      }\n      var stage = this.runtime.getTargetForStage();\n      var stageVariables = stage.getAllVariableNamesInScopeByType(type);\n      return targetVariables.concat(stageVariables);\n    }\n    /**\n     * Merge variable references with another variable.\n     * @param {string} idToBeMerged ID of the variable whose references need to be updated\n     * @param {string} idToMergeWith ID of the variable that the old references should be replaced with\n     * @param {?Array<Object>} optReferencesToUpdate Optional context of the change.\n     * Defaults to all the blocks in this target.\n     * @param {?string} optNewName New variable name to merge with. The old\n     * variable name in the references being updated should be replaced with this new name.\n     * If this parameter is not provided or is '', no name change occurs.\n     */\n  }, {\n    key: \"mergeVariables\",\n    value: function mergeVariables(idToBeMerged, idToMergeWith, optReferencesToUpdate, optNewName) {\n      var referencesToChange = optReferencesToUpdate || // TODO should there be a separate helper function that traverses the blocks\n      // for all references for a given ID instead of doing the below..?\n      this.blocks.getAllVariableAndListReferences()[idToBeMerged];\n      VariableUtil.updateVariableIdentifiers(referencesToChange, idToMergeWith, optNewName);\n    }\n    /**\n     * Share a local variable (and given references for that variable) to the stage.\n     * @param {string} varId The ID of the variable to share.\n     * @param {Array<object>} varRefs The list of variable references being shared,\n     * that reference the given variable ID. The names and IDs of these variable\n     * references will be updated to refer to the new (or pre-existing) global variable.\n     */\n  }, {\n    key: \"shareLocalVariableToStage\",\n    value: function shareLocalVariableToStage(varId, varRefs) {\n      if (!this.runtime) return;\n      var variable = this.variables[varId];\n      if (!variable) {\n        log.warn(\"Cannot share a local variable to the stage if it's not local.\");\n        return;\n      }\n      var stage = this.runtime.getTargetForStage(); // If a local var is being shared with the stage,\n      // sharing will make the variable global, resulting in a conflict\n      // with the existing local variable. Preemptively Resolve this conflict\n      // by renaming the new global variable.\n      // First check if we've already done the local to global transition for this\n      // variable. If we have, merge it with the global variable we've already created.\n      var varIdForStage = \"StageVarFromLocal_\".concat(varId);\n      var stageVar = stage.lookupVariableById(varIdForStage); // If a global var doesn't already exist, create a new one with a fresh name.\n      // Use the ID we created above so that we can lookup this new variable in the\n      // future if we decide to share this same variable again.\n      if (!stageVar) {\n        var varName = variable.name;\n        var varType = variable.type;\n        var newStageName = \"Stage: \".concat(varName);\n        stageVar = this.runtime.createNewGlobalVariable(newStageName, varIdForStage, varType);\n      } // Update all variable references to use the new name and ID\n      this.mergeVariables(varId, stageVar.id, varRefs, stageVar.name);\n    }\n    /**\n     * Share a local variable with a sprite, merging with one of the same name and\n     * type if it already exists on the sprite, or create a new one.\n     * @param {string} varId Id of the variable to share\n     * @param {Target} sprite The sprite to share the variable with\n     * @param {Array<object>} varRefs A list of all the variable references currently being shared.\n     */\n  }, {\n    key: \"shareLocalVariableToSprite\",\n    value: function shareLocalVariableToSprite(varId, sprite, varRefs) {\n      if (!this.runtime) return;\n      if (this.isStage) return;\n      var variable = this.variables[varId];\n      if (!variable) {\n        log.warn(\"Tried to call 'shareLocalVariableToSprite' with a non-local variable.\");\n        return;\n      }\n      var varName = variable.name;\n      var varType = variable.type; // Check if the receiving sprite already has a variable of the same name and type\n      // and use the existing variable, otherwise create a new one.\n      var existingLocalVar = sprite.lookupVariableByNameAndType(varName, varType);\n      var newVarId;\n      if (existingLocalVar) {\n        newVarId = existingLocalVar.id;\n      } else {\n        var newVar = new Variable(null, varName, varType);\n        newVarId = newVar.id;\n        sprite.variables[newVarId] = newVar;\n      } // Merge with the local variable on the new sprite.\n      this.mergeVariables(varId, newVarId, varRefs);\n    }\n    /**\n     * Given a list of variable referencing fields, shares those variables with\n     * the target with the provided id, resolving any variable conflicts that arise\n     * using the following rules:\n     *\n     * If this target is the stage, exit. There are no conflicts that arise\n     * from sharing variables from the stage to another sprite. The variables\n     * already exist globally, so no further action is needed.\n     *\n     * If a variable being referenced is a global variable, do nothing. The\n     * global variable already exists so no further action is needed.\n     *\n     * If a variable being referenced is local, and\n     * 1) The receiving target is a sprite:\n     * create a new local variable or merge with an existing local variable\n     * of the same name and type. Update all the referencing fields\n     * for the original variable to reference the new variable.\n     * 2) The receiving target is the stage:\n     * Create a new global variable with a fresh name and update all the referencing\n     * fields to reference the new variable.\n     *\n     * @param {Array<object>} blocks The blocks containing\n     * potential conflicting references to variables.\n     * @param {Target} receivingTarget The target receiving the variables\n     */\n  }, {\n    key: \"resolveVariableSharingConflictsWithTarget\",\n    value: function resolveVariableSharingConflictsWithTarget(blocks, receivingTarget) {\n      if (this.isStage) return; // Get all the variable references in the given list of blocks\n      var allVarListRefs = this.blocks.getAllVariableAndListReferences(blocks); // For all the variables being referenced, check for which ones are local\n      // to this target, and resolve conflicts based on whether the receiving target\n      // is a sprite (with a conflicting local variable) or whether it is\n      // the stage (which cannot have local variables)\n      for (var varId in allVarListRefs) {\n        var currVar = this.variables[varId];\n        if (!currVar) continue; // The current variable is global, there shouldn't be any conflicts here, skip it.\n        // Get the list of references for the current variable id\n        var currVarListRefs = allVarListRefs[varId];\n        if (receivingTarget.isStage) {\n          this.shareLocalVariableToStage(varId, currVarListRefs);\n        } else {\n          this.shareLocalVariableToSprite(varId, receivingTarget, currVarListRefs);\n        }\n      }\n    }\n    /**\n     * Fixes up variable references in this target avoiding conflicts with\n     * pre-existing variables in the same scope.\n     * This is used when uploading this target as a new sprite into an existing\n     * project, where the new sprite may contain references\n     * to variable names that already exist as global variables in the project\n     * (and thus are in scope for variable references in the given sprite).\n     *\n     * If this target has a block that references an existing global variable and that\n     * variable *does not* exist in this target (e.g. it was a global variable in the\n     * project the sprite was originally exported from), merge the variables. This entails\n     * fixing the variable references in this sprite to reference the id of the pre-existing global variable.\n     *\n     * If this target has a block that references an existing global variable and that\n     * variable does exist in the target itself (e.g. it's a local variable in the sprite being uploaded),\n     * then the local variable is renamed to distinguish itself from the pre-existing variable.\n     * All blocks that reference the local variable will be updated to use the new name.\n     */\n    // TODO (#1360) This function is too long, add some helpers for the different chunks and cases...\n  }, {\n    key: \"fixUpVariableReferences\",\n    value: function fixUpVariableReferences() {\n      var _this5 = this;\n      if (!this.runtime) return; // There's no runtime context to conflict with\n      if (this.isStage) return; // Stage can't have variable conflicts with itself (and also can't be uploaded)\n      var stage = this.runtime.getTargetForStage();\n      if (!stage || !stage.variables) return;\n      var renameConflictingLocalVar = function renameConflictingLocalVar(id, name, type) {\n        var conflict = stage.lookupVariableByNameAndType(name, type);\n        if (conflict) {\n          var newName = StringUtil.unusedName(\"\".concat(_this5.getName(), \": \").concat(name), _this5.getAllVariableNamesInScopeByType(type));\n          _this5.renameVariable(id, newName);\n          return newName;\n        }\n        return null;\n      };\n      var allReferences = this.blocks.getAllVariableAndListReferences();\n      var unreferencedLocalVarIds = [];\n      if (Object.keys(this.variables).length > 0) {\n        for (var localVarId in this.variables) {\n          if (!this.variables.hasOwnProperty(localVarId)) continue;\n          if (!allReferences[localVarId]) unreferencedLocalVarIds.push(localVarId);\n        }\n      }\n      var conflictIdsToReplace = Object.create(null);\n      var conflictNamesToReplace = Object.create(null); // Cache the list of all variable names by type so that we don't need to\n      // re-calculate this in every iteration of the following loop.\n      var varNamesByType = {};\n      var allVarNames = function allVarNames(type) {\n        var namesOfType = varNamesByType[type];\n        if (namesOfType) return namesOfType;\n        varNamesByType[type] = _this5.runtime.getAllVarNamesOfType(type);\n        return varNamesByType[type];\n      };\n      for (var varId in allReferences) {\n        // We don't care about which var ref we get, they should all have the same var info\n        var varRef = allReferences[varId][0];\n        var varName = varRef.referencingField.value;\n        var varType = varRef.type;\n        if (this.lookupVariableById(varId)) {\n          // Found a variable with the id in either the target or the stage,\n          // figure out which one.\n          if (this.variables.hasOwnProperty(varId)) {\n            (function () {\n              // If the target has the variable, then check whether the stage\n              // has one with the same name and type. If it does, then rename\n              // this target specific variable so that there is a distinction.\n              var newVarName = renameConflictingLocalVar(varId, varName, varType);\n              if (newVarName) {\n                // We are not calling this.blocks.updateBlocksAfterVarRename\n                // here because it will search through all the blocks. We already\n                // have access to all the references for this var id.\n                allReferences[varId].map(function (ref) {\n                  ref.referencingField.value = newVarName;\n                  return ref;\n                });\n              }\n            })();\n          }\n        } else {\n          // We didn't find the referenced variable id anywhere,\n          // Treat it as a reference to a global variable (from the original\n          // project this sprite was exported from).\n          // Check for whether a global variable of the same name and type exists,\n          // and if so, track it to merge with the existing global in a second pass of the blocks.\n          var existingVar = stage.lookupVariableByNameAndType(varName, varType);\n          if (existingVar) {\n            if (!conflictIdsToReplace[varId]) {\n              conflictIdsToReplace[varId] = existingVar.id;\n            }\n          } else {\n            // A global variable with the same name did not already exist,\n            // create a new one such that it does not conflict with any\n            // names of local variables of the same type.\n            var allNames = allVarNames(varType);\n            var freshName = StringUtil.unusedName(varName, allNames);\n            stage.createVariable(varId, freshName, varType);\n            if (!conflictNamesToReplace[varId]) {\n              conflictNamesToReplace[varId] = freshName;\n            }\n          }\n        }\n      } // Rename any local variables that were missed above because they aren't\n      // referenced by any blocks\n      for (var id in unreferencedLocalVarIds) {\n        var _varId2 = unreferencedLocalVarIds[id];\n        var name = this.variables[_varId2].name;\n        var type = this.variables[_varId2].type;\n        renameConflictingLocalVar(_varId2, name, type);\n      } // Handle global var conflicts with existing global vars (e.g. a sprite is uploaded, and has\n      // blocks referencing some variable that the sprite does not own, and this\n      // variable conflicts with a global var)\n      // In this case, we want to merge the new variable referenes with the\n      // existing global variable\n      for (var conflictId in conflictIdsToReplace) {\n        var existingId = conflictIdsToReplace[conflictId];\n        var referencesToUpdate = allReferences[conflictId];\n        this.mergeVariables(conflictId, existingId, referencesToUpdate);\n      } // Handle global var conflicts existing local vars (e.g a sprite is uploaded,\n      // and has blocks referencing some variable that the sprite does not own, and this\n      // variable conflcits with another sprite's local var).\n      // In this case, we want to go through the variable references and update\n      // the name of the variable in that reference.\n      var _loop = function _loop(_conflictId) {\n        var newName = conflictNamesToReplace[_conflictId];\n        var referencesToUpdate = allReferences[_conflictId];\n        referencesToUpdate.map(function (ref) {\n          ref.referencingField.value = newName;\n          return ref;\n        });\n      };\n      for (var _conflictId in conflictNamesToReplace) {\n        _loop(_conflictId);\n      }\n    }\n  }]);\n  return Target;\n}(EventEmitter);\nmodule.exports = Target;\n })