/* 442 */\n (function(module, exports) {\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nvar VariableUtil = function () {\n  function VariableUtil() {\n    _classCallCheck(this, VariableUtil);\n  }\n  _createClass(VariableUtil, null, [{\n    key: \"_mergeVarRefObjects\",\n    value: function _mergeVarRefObjects(accum, obj2) {\n      for (var id in obj2) {\n        if (accum[id]) {\n          accum[id] = accum[id].concat(obj2[id]);\n        } else {\n          accum[id] = obj2[id];\n        }\n      }\n      return accum;\n    }\n    /**\n     * Get all variable/list references in the given list of targets\n     * in the project.\n     * @param {Array.<Target>} targets The list of targets to get the variable\n     * and list references from.\n     * @param {boolean} shouldIncludeBroadcast Whether to include broadcast message fields.\n     * @return {object} An object with variable ids as the keys and a list of block fields referencing\n     * the variable.\n     */\n  }, {\n    key: \"getAllVarRefsForTargets\",\n    value: function getAllVarRefsForTargets(targets, shouldIncludeBroadcast) {\n      return targets.map(function (t) {\n        return t.blocks.getAllVariableAndListReferences(null, shouldIncludeBroadcast);\n      }).reduce(VariableUtil._mergeVarRefObjects, {});\n    }\n    /**\n     * Give all variable references provided a new id and possibly new name.\n     * @param {Array<object>} referencesToUpdate Context of the change, the object containing variable\n     * references to update.\n     * @param {string} newId ID of the variable that the old references should be replaced with\n     * @param {?string} optNewName New variable name to merge with. The old\n     * variable name in the references being updated should be replaced with this new name.\n     * If this parameter is not provided or is '', no name change occurs.\n     */\n  }, {\n    key: \"updateVariableIdentifiers\",\n    value: function updateVariableIdentifiers(referencesToUpdate, newId, optNewName) {\n      referencesToUpdate.map(function (ref) {\n        ref.referencingField.id = newId;\n        if (optNewName) {\n          ref.referencingField.value = optNewName;\n        }\n        return ref;\n      });\n    }\n  }]);\n  return VariableUtil;\n}();\nmodule.exports = VariableUtil;\n })