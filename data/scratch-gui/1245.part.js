/* 1245 */\n (function(module, exports, __webpack_require__) {\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nvar twgl = __webpack_require__(103);\nvar Skin = __webpack_require__(187);\nvar BitmapSkin = function (_Skin) {\n  _inherits(BitmapSkin, _Skin);\n  var _super = _createSuper(BitmapSkin);\n  /**\n   * Create a new Bitmap Skin.\n   * @extends Skin\n   * @param {!int} id - The ID for this Skin.\n   * @param {!RenderWebGL} renderer - The renderer which will use this skin.\n   */\n  function BitmapSkin(id, renderer) {\n    var _this;\n    _classCallCheck(this, BitmapSkin);\n    _this = _super.call(this, id);\n    /** @type {!int} */\n    _this._costumeResolution = 1;\n    /** @type {!RenderWebGL} */\n    _this._renderer = renderer;\n    /** @type {Array<int>} */\n    _this._textureSize = [0, 0];\n    return _this;\n  }\n  /**\n   * Dispose of this object. Do not use it after calling this method.\n   */\n  _createClass(BitmapSkin, [{\n    key: \"dispose\",\n    value: function dispose() {\n      if (this._texture) {\n        this._renderer.gl.deleteTexture(this._texture);\n        this._texture = null;\n      }\n      _get(_getPrototypeOf(BitmapSkin.prototype), \"dispose\", this).call(this);\n    }\n    /**\n     * @return {Array<number>} the \"native\" size, in texels, of this skin.\n     */\n  }, {\n    key: \"getTexture\",\n    /**\n     * @param {Array<number>} scale - The scaling factors to be used.\n     * @return {WebGLTexture} The GL texture representation of this skin when drawing at the given scale.\n     */\n    // eslint-disable-next-line no-unused-vars\n    value: function getTexture(scale) {\n      return this._texture || _get(_getPrototypeOf(BitmapSkin.prototype), \"getTexture\", this).call(this);\n    }\n    /**\n     * Set the contents of this skin to a snapshot of the provided bitmap data.\n     * @param {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} bitmapData - new contents for this skin.\n     * @param {int} [costumeResolution=1] - The resolution to use for this bitmap.\n     * @param {Array<number>} [rotationCenter] - Optional rotation center for the bitmap. If not supplied, it will be\n     * calculated from the bounding box\n     * @fires Skin.event:WasAltered\n     */\n  }, {\n    key: \"setBitmap\",\n    value: function setBitmap(bitmapData, costumeResolution, rotationCenter) {\n      if (!bitmapData.width || !bitmapData.height) {\n        _get(_getPrototypeOf(BitmapSkin.prototype), \"setEmptyImageData\", this).call(this);\n        return;\n      }\n      var gl = this._renderer.gl; // Preferably bitmapData is ImageData. ImageData speeds up updating\n      // Silhouette and is better handled by more browsers in regards to\n      // memory.\n      var textureData = bitmapData;\n      if (bitmapData instanceof HTMLCanvasElement) {\n        // Given a HTMLCanvasElement get the image data to pass to webgl and\n        // Silhouette.\n        var context = bitmapData.getContext('2d',{willReadFrequently:true});\n        textureData = context.getImageData(0, 0, bitmapData.width, bitmapData.height);\n      }\n      if (this._texture === null) {\n        var textureOptions = {\n          auto: false,\n          wrap: gl.CLAMP_TO_EDGE\n        };\n        this._texture = twgl.createTexture(gl, textureOptions);\n      }\n      this._setTexture(textureData); // Do these last in case any of the above throws an exception\n      this._costumeResolution = costumeResolution || 2;\n      this._textureSize = BitmapSkin._getBitmapSize(bitmapData);\n      if (typeof rotationCenter === 'undefined') rotationCenter = this.calculateRotationCenter();\n      this._rotationCenter[0] = rotationCenter[0];\n      this._rotationCenter[1] = rotationCenter[1];\n      this.emit(Skin.Events.WasAltered);\n    }\n    /**\n     * @param {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} bitmapData - bitmap data to inspect.\n     * @returns {Array<int>} the width and height of the bitmap data, in pixels.\n     * @private\n     */\n  }, {\n    key: \"size\",\n    get: function get() {\n      return [this._textureSize[0] / this._costumeResolution, this._textureSize[1] / this._costumeResolution];\n    }\n  }], [{\n    key: \"_getBitmapSize\",\n    value: function _getBitmapSize(bitmapData) {\n      if (bitmapData instanceof HTMLImageElement) {\n        return [bitmapData.naturalWidth || bitmapData.width, bitmapData.naturalHeight || bitmapData.height];\n      }\n      if (bitmapData instanceof HTMLVideoElement) {\n        return [bitmapData.videoWidth || bitmapData.width, bitmapData.videoHeight || bitmapData.height];\n      } // ImageData or HTMLCanvasElement\n      return [bitmapData.width, bitmapData.height];\n    }\n  }]);\n  return BitmapSkin;\n}(Skin);\nmodule.exports = BitmapSkin;\n })