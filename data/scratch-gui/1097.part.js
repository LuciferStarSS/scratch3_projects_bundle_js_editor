/* 1097 */\n (function(module, exports, __webpack_require__) {\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nvar JSONRPC = __webpack_require__(443);\nvar BT = function (_JSONRPC) {\n  _inherits(BT, _JSONRPC);\n  var _super = _createSuper(BT);\n  /**\n   * A BT peripheral socket object.  It handles connecting, over web sockets, to\n   * BT peripherals, and reading and writing data to them.\n   * @param {Runtime} runtime - the Runtime for sending/receiving GUI update events.\n   * @param {string} extensionId - the id of the extension using this socket.\n   * @param {object} peripheralOptions - the list of options for peripheral discovery.\n   * @param {object} connectCallback - a callback for connection.\n   * @param {object} resetCallback - a callback for resetting extension state.\n   * @param {object} messageCallback - a callback for message sending.\n   */\n  function BT(runtime, extensionId, peripheralOptions, connectCallback) {\n    var _this;\n    var resetCallback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    var messageCallback = arguments.length > 5 ? arguments[5] : undefined;\n    _classCallCheck(this, BT);\n    _this = _super.call(this);\n    _this._socket = runtime.getScratchLinkSocket('BT');\n    _this._socket.setOnOpen(_this.requestPeripheral.bind(_assertThisInitialized(_this)));\n    _this._socket.setOnError(_this._handleRequestError.bind(_assertThisInitialized(_this)));\n    _this._socket.setOnClose(_this.handleDisconnectError.bind(_assertThisInitialized(_this)));\n    _this._socket.setHandleMessage(_this._handleMessage.bind(_assertThisInitialized(_this)));\n    _this._sendMessage = _this._socket.sendMessage.bind(_this._socket);\n    _this._availablePeripherals = {};\n    _this._connectCallback = connectCallback;\n    _this._connected = false;\n    _this._characteristicDidChangeCallback = null;\n    _this._resetCallback = resetCallback;\n    _this._discoverTimeoutID = null;\n    _this._extensionId = extensionId;\n    _this._peripheralOptions = peripheralOptions;\n    _this._messageCallback = messageCallback;\n    _this._runtime = runtime;\n    _this._socket.open();\n    return _this;\n  }\n  /**\n   * Request connection to the peripheral.\n   * If the web socket is not yet open, request when the socket promise resolves.\n   */\n  _createClass(BT, [{\n    key: \"requestPeripheral\",\n    value: function requestPeripheral() {\n      var _this2 = this;\n      this._availablePeripherals = {};\n      if (this._discoverTimeoutID) {\n        window.clearTimeout(this._discoverTimeoutID);\n      }\n      this._discoverTimeoutID = window.setTimeout(this._handleDiscoverTimeout.bind(this), 15000);\n      this.sendRemoteRequest('discover', this._peripheralOptions).catch(function (e) {\n        return _this2._handleRequestError(e);\n      });\n    }\n    /**\n     * Try connecting to the input peripheral id, and then call the connect\n     * callback if connection is successful.\n     * @param {number} id - the id of the peripheral to connect to\n     * @param {string} pin - an optional pin for pairing\n     */\n  }, {\n    key: \"connectPeripheral\",\n    value: function connectPeripheral(id) {\n      var _this3 = this;\n      var pin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var params = {\n        peripheralId: id\n      };\n      if (pin) {\n        params.pin = pin;\n      }\n      this.sendRemoteRequest('connect', params).then(function () {\n        _this3._connected = true;\n        _this3._runtime.emit(_this3._runtime.constructor.PERIPHERAL_CONNECTED);\n        _this3._connectCallback();\n      }).catch(function (e) {\n        _this3._handleRequestError(e);\n      });\n    }\n    /**\n     * Close the websocket.\n     */\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      if (this._connected) {\n        this._connected = false;\n      }\n      if (this._socket.isOpen()) {\n        this._socket.close();\n      }\n      if (this._discoverTimeoutID) {\n        window.clearTimeout(this._discoverTimeoutID);\n      } // Sets connection status icon to orange\n      this._runtime.emit(this._runtime.constructor.PERIPHERAL_DISCONNECTED);\n    }\n    /**\n     * @return {bool} whether the peripheral is connected.\n     */\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      return this._connected;\n    }\n  }, {\n    key: \"sendMessage\",\n    value: function sendMessage(options) {\n      var _this4 = this;\n      return this.sendRemoteRequest('send', options).catch(function (e) {\n        _this4.handleDisconnectError(e);\n      });\n    }\n    /**\n     * Handle a received call from the socket.\n     * @param {string} method - a received method label.\n     * @param {object} params - a received list of parameters.\n     * @return {object} - optional return value.\n     */\n  }, {\n    key: \"didReceiveCall\",\n    value: function didReceiveCall(method, params) {\n      // TODO: Add peripheral 'undiscover' handling\n      switch (method) {\n        case 'didDiscoverPeripheral':\n          this._availablePeripherals[params.peripheralId] = params;\n          this._runtime.emit(this._runtime.constructor.PERIPHERAL_LIST_UPDATE, this._availablePeripherals);\n          if (this._discoverTimeoutID) {\n            window.clearTimeout(this._discoverTimeoutID);\n          }\n          break;\n        case 'userDidPickPeripheral':\n          this._availablePeripherals[params.peripheralId] = params;\n          this._runtime.emit(this._runtime.constructor.USER_PICKED_PERIPHERAL, this._availablePeripherals);\n          if (this._discoverTimeoutID) {\n            window.clearTimeout(this._discoverTimeoutID);\n          }\n          break;\n        case 'userDidNotPickPeripheral':\n          this._runtime.emit(this._runtime.constructor.PERIPHERAL_SCAN_TIMEOUT);\n          if (this._discoverTimeoutID) {\n            window.clearTimeout(this._discoverTimeoutID);\n          }\n          break;\n        case 'didReceiveMessage':\n          this._messageCallback(params); // TODO: refine?\n          break;\n        default:\n          return 'nah';\n      }\n    }\n    /**\n     * Handle an error resulting from losing connection to a peripheral.\n     *\n     * This could be due to:\n     * - battery depletion\n     * - going out of bluetooth range\n     * - being powered down\n     *\n     * Disconnect the socket, and if the extension using this socket has a\n     * reset callback, call it. Finally, emit an error to the runtime.\n     */\n  }, {\n    key: \"handleDisconnectError\",\n    value: function handleDisconnectError()\n    /* e */\n    {\n      // log.error(`BT error: ${JSON.stringify(e)}`);\n      if (!this._connected) return;\n      this.disconnect();\n      if (this._resetCallback) {\n        this._resetCallback();\n      }\n      this._runtime.emit(this._runtime.constructor.PERIPHERAL_CONNECTION_LOST_ERROR, {\n        message: \"Scratch lost connection to\",\n        extensionId: this._extensionId\n      });\n    }\n  }, {\n    key: \"_handleRequestError\",\n    value: function _handleRequestError()\n    /* e */\n    {\n      // log.error(`BT error: ${JSON.stringify(e)}`);\n      this._runtime.emit(this._runtime.constructor.PERIPHERAL_REQUEST_ERROR, {\n        message: \"Scratch lost connection to\",\n        extensionId: this._extensionId\n      });\n    }\n  }, {\n    key: \"_handleDiscoverTimeout\",\n    value: function _handleDiscoverTimeout() {\n      if (this._discoverTimeoutID) {\n        window.clearTimeout(this._discoverTimeoutID);\n      }\n      this._runtime.emit(this._runtime.constructor.PERIPHERAL_SCAN_TIMEOUT);\n    }\n  }]);\n  return BT;\n}(JSONRPC);\nmodule.exports = BT;\n })