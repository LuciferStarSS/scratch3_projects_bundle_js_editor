/* 1047 */\n (function(module, exports, __webpack_require__) {\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nvar ArgumentType = __webpack_require__(63);\nvar BlockType = __webpack_require__(45);\nvar log = __webpack_require__(39);\nvar cast = __webpack_require__(48);\nvar formatMessage = __webpack_require__(71);\nvar BLE = __webpack_require__(221);\nvar Base64Util = __webpack_require__(182);\n/**\n * Icon png to be displayed at the left edge of each extension block, encoded as a data URI.\n * @type {string}\n */\n// eslint-disable-next-line max-len\nvar blockIconURI = 'data:image/png;base64,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';\n/**\n * Enum for micro:bit BLE command protocol.\n * https://github.com/LLK/scratch-microbit-firmware/blob/master/protocol.md\n * @readonly\n * @enum {number}\n */\nvar BLECommand = {\n  CMD_PIN_CONFIG: 0x80,\n  CMD_DISPLAY_TEXT: 0x81,\n  CMD_DISPLAY_LED: 0x82\n};\n/**\n * A time interval to wait (in milliseconds) before reporting to the BLE socket\n * that data has stopped coming from the peripheral.\n */\nvar BLETimeout = 4500;\n/**\n * A time interval to wait (in milliseconds) while a block that sends a BLE message is running.\n * @type {number}\n */\nvar BLESendInterval = 100;\n/**\n * A string to report to the BLE socket when the micro:bit has stopped receiving data.\n * @type {string}\n */\nvar BLEDataStoppedError = 'micro:bit extension stopped receiving data';\n/**\n * Enum for micro:bit protocol.\n * https://github.com/LLK/scratch-microbit-firmware/blob/master/protocol.md\n * @readonly\n * @enum {string}\n */\nvar BLEUUID = {\n  service: 0xf005,\n  rxChar: '5261da01-fa7e-42ab-850b-7c80220097cc',\n  txChar: '5261da02-fa7e-42ab-850b-7c80220097cc'\n};\n/**\n * Manage communication with a MicroBit peripheral over a Scrath Link client socket.\n */\nvar MicroBit = function () {\n  /**\n   * Construct a MicroBit communication object.\n   * @param {Runtime} runtime - the Scratch 3.0 runtime\n   * @param {string} extensionId - the id of the extension\n   */\n  function MicroBit(runtime, extensionId) {\n    _classCallCheck(this, MicroBit);\n    /**\n     * The Scratch 3.0 runtime used to trigger the green flag button.\n     * @type {Runtime}\n     * @private\n     */\n    this._runtime = runtime;\n    /**\n     * The BluetoothLowEnergy connection socket for reading/writing peripheral data.\n     * @type {BLE}\n     * @private\n     */\n    this._ble = null;\n    this._runtime.registerPeripheralExtension(extensionId, this);\n    /**\n     * The id of the extension this peripheral belongs to.\n     */\n    this._extensionId = extensionId;\n    /**\n     * The most recently received value for each sensor.\n     * @type {Object.<string, number>}\n     * @private\n     */\n    this._sensors = {\n      tiltX: 0,\n      tiltY: 0,\n      buttonA: 0,\n      buttonB: 0,\n      touchPins: [0, 0, 0],\n      gestureState: 0,\n      ledMatrixState: new Uint8Array(5)\n    };\n    /**\n     * The most recently received value for each gesture.\n     * @type {Object.<string, Object>}\n     * @private\n     */\n    this._gestures = {\n      moving: false,\n      move: {\n        active: false,\n        timeout: false\n      },\n      shake: {\n        active: false,\n        timeout: false\n      },\n      jump: {\n        active: false,\n        timeout: false\n      }\n    };\n    /**\n     * Interval ID for data reading timeout.\n     * @type {number}\n     * @private\n     */\n    this._timeoutID = null;\n    /**\n     * A flag that is true while we are busy sending data to the BLE socket.\n     * @type {boolean}\n     * @private\n     */\n    this._busy = false;\n    /**\n     * ID for a timeout which is used to clear the busy flag if it has been\n     * true for a long time.\n     */\n    this._busyTimeoutID = null;\n    this.reset = this.reset.bind(this);\n    this._onConnect = this._onConnect.bind(this);\n    this._onMessage = this._onMessage.bind(this);\n  }\n  /**\n   * @param {string} text - the text to display.\n   * @return {Promise} - a Promise that resolves when writing to peripheral.\n   */\n  _createClass(MicroBit, [{\n    key: \"displayText\",\n    value: function displayText(text) {\n      var output = new Uint8Array(text.length);\n      for (var i = 0; i < text.length; i++) {\n        output[i] = text.charCodeAt(i);\n      }\n      return this.send(BLECommand.CMD_DISPLAY_TEXT, output);\n    }\n    /**\n     * @param {Uint8Array} matrix - the matrix to display.\n     * @return {Promise} - a Promise that resolves when writing to peripheral.\n     */\n  }, {\n    key: \"displayMatrix\",\n    value: function displayMatrix(matrix) {\n      return this.send(BLECommand.CMD_DISPLAY_LED, matrix);\n    }\n    /**\n     * @return {number} - the latest value received for the tilt sensor's tilt about the X axis.\n     */\n  }, {\n    key: \"scan\",\n    /**\n     * Called by the runtime when user wants to scan for a peripheral.\n     */\n    value: function scan() {\n      if (this._ble) {\n        this._ble.disconnect();\n      }\n      this._ble = new BLE(this._runtime, this._extensionId, {\n        filters: [{\n          services: [BLEUUID.service]\n        }]\n      }, this._onConnect, this.reset);\n    }\n    /**\n     * Called by the runtime when user wants to connect to a certain peripheral.\n     * @param {number} id - the id of the peripheral to connect to.\n     */\n  }, {\n    key: \"connect\",\n    value: function connect(id) {\n      if (this._ble) {\n        this._ble.connectPeripheral(id);\n      }\n    }\n    /**\n     * Disconnect from the micro:bit.\n     */\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      if (this._ble) {\n        this._ble.disconnect();\n      }\n      this.reset();\n    }\n    /**\n     * Reset all the state and timeout/interval ids.\n     */\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      if (this._timeoutID) {\n        window.clearTimeout(this._timeoutID);\n        this._timeoutID = null;\n      }\n    }\n    /**\n     * Return true if connected to the micro:bit.\n     * @return {boolean} - whether the micro:bit is connected.\n     */\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      var connected = false;\n      if (this._ble) {\n        connected = this._ble.isConnected();\n      }\n      return connected;\n    }\n    /**\n     * Send a message to the peripheral BLE socket.\n     * @param {number} command - the BLE command hex.\n     * @param {Uint8Array} message - the message to write\n     */\n  }, {\n    key: \"send\",\n    value: function send(command, message) {\n      var _this = this;\n      if (!this.isConnected()) return;\n      if (this._busy) return; // Set a busy flag so that while we are sending a message and waiting for\n      // the response, additional messages are ignored.\n      this._busy = true; // Set a timeout after which to reset the busy flag. This is used in case\n      // a BLE message was sent for which we never received a response, because\n      // e.g. the peripheral was turned off after the message was sent. We reset\n      // the busy flag after a while so that it is possible to try again later.\n      this._busyTimeoutID = window.setTimeout(function () {\n        _this._busy = false;\n      }, 5000);\n      var output = new Uint8Array(message.length + 1);\n      output[0] = command; // attach command to beginning of message\n      for (var i = 0; i < message.length; i++) {\n        output[i + 1] = message[i];\n      }\n      var data = Base64Util.uint8ArrayToBase64(output);\n      this._ble.write(BLEUUID.service, BLEUUID.txChar, data, 'base64', true).then(function () {\n        _this._busy = false;\n        window.clearTimeout(_this._busyTimeoutID);\n      });\n    }\n    /**\n     * Starts reading data from peripheral after BLE has connected to it.\n     * @private\n     */\n  }, {\n    key: \"_onConnect\",\n    value: function _onConnect() {\n      var _this2 = this;\n      this._ble.read(BLEUUID.service, BLEUUID.rxChar, true, this._onMessage);\n      this._timeoutID = window.setTimeout(function () {\n        return _this2._ble.handleDisconnectError(BLEDataStoppedError);\n      }, BLETimeout);\n    }\n    /**\n     * Process the sensor data from the incoming BLE characteristic.\n     * @param {object} base64 - the incoming BLE data.\n     * @private\n     */\n  }, {\n    key: \"_onMessage\",\n    value: function _onMessage(base64) {\n      var _this3 = this;\n      // parse data\n      var data = Base64Util.base64ToUint8Array(base64);\n      this._sensors.tiltX = data[1] | data[0] << 8;\n      if (this._sensors.tiltX > 1 << 15) this._sensors.tiltX -= 1 << 16;\n      this._sensors.tiltY = data[3] | data[2] << 8;\n      if (this._sensors.tiltY > 1 << 15) this._sensors.tiltY -= 1 << 16;\n      this._sensors.buttonA = data[4];\n      this._sensors.buttonB = data[5];\n      this._sensors.touchPins[0] = data[6];\n      this._sensors.touchPins[1] = data[7];\n      this._sensors.touchPins[2] = data[8];\n      this._sensors.gestureState = data[9]; // cancel disconnect timeout and start a new one\n      window.clearTimeout(this._timeoutID);\n      this._timeoutID = window.setTimeout(function () {\n        return _this3._ble.handleDisconnectError(BLEDataStoppedError);\n      }, BLETimeout);\n    }\n    /**\n     * @param {number} pin - the pin to check touch state.\n     * @return {number} - the latest value received for the touch pin states.\n     * @private\n     */\n  }, {\n    key: \"_checkPinState\",\n    value: function _checkPinState(pin) {\n      return this._sensors.touchPins[pin];\n    }\n  }, {\n    key: \"tiltX\",\n    get: function get() {\n      return this._sensors.tiltX;\n    }\n    /**\n     * @return {number} - the latest value received for the tilt sensor's tilt about the Y axis.\n     */\n  }, {\n    key: \"tiltY\",\n    get: function get() {\n      return this._sensors.tiltY;\n    }\n    /**\n     * @return {boolean} - the latest value received for the A button.\n     */\n  }, {\n    key: \"buttonA\",\n    get: function get() {\n      return this._sensors.buttonA;\n    }\n    /**\n     * @return {boolean} - the latest value received for the B button.\n     */\n  }, {\n    key: \"buttonB\",\n    get: function get() {\n      return this._sensors.buttonB;\n    }\n    /**\n     * @return {number} - the latest value received for the motion gesture states.\n     */\n  }, {\n    key: \"gestureState\",\n    get: function get() {\n      return this._sensors.gestureState;\n    }\n    /**\n     * @return {Uint8Array} - the current state of the 5x5 LED matrix.\n     */\n  }, {\n    key: \"ledMatrixState\",\n    get: function get() {\n      return this._sensors.ledMatrixState;\n    }\n  }]);\n  return MicroBit;\n}();\n/**\n * Enum for tilt sensor direction.\n * @readonly\n * @enum {string}\n */\nvar MicroBitTiltDirection = {\n  FRONT: 'front',\n  BACK: 'back',\n  LEFT: 'left',\n  RIGHT: 'right',\n  ANY: 'any'\n};\n/**\n * Enum for micro:bit gestures.\n * @readonly\n * @enum {string}\n */\nvar MicroBitGestures = {\n  MOVED: 'moved',\n  SHAKEN: 'shaken',\n  JUMPED: 'jumped'\n};\n/**\n * Enum for micro:bit buttons.\n * @readonly\n * @enum {string}\n */\nvar MicroBitButtons = {\n  A: 'A',\n  B: 'B',\n  ANY: 'any'\n};\n/**\n * Enum for micro:bit pin states.\n * @readonly\n * @enum {string}\n */\nvar MicroBitPinState = {\n  ON: 'on',\n  OFF: 'off'\n};\n/**\n * Scratch 3.0 blocks to interact with a MicroBit peripheral.\n */\nvar Scratch3MicroBitBlocks = function () {\n  _createClass(Scratch3MicroBitBlocks, [{\n    key: \"BUTTONS_MENU\",\n    /**\n     * @return {array} - text and values for each buttons menu element\n     */\n    get: function get() {\n      return [{\n        text: 'A',\n        value: MicroBitButtons.A\n      }, {\n        text: 'B',\n        value: MicroBitButtons.B\n      }, {\n        text: formatMessage({\n          id: 'microbit.buttonsMenu.any',\n          default: 'any',\n          description: 'label for \"any\" element in button picker for micro:bit extension'\n        }),\n        value: MicroBitButtons.ANY\n      }];\n    }\n    /**\n     * @return {array} - text and values for each gestures menu element\n     */\n  }, {\n    key: \"GESTURES_MENU\",\n    get: function get() {\n      return [{\n        text: formatMessage({\n          id: 'microbit.gesturesMenu.moved',\n          default: 'moved',\n          description: 'label for moved gesture in gesture picker for micro:bit extension'\n        }),\n        value: MicroBitGestures.MOVED\n      }, {\n        text: formatMessage({\n          id: 'microbit.gesturesMenu.shaken',\n          default: 'shaken',\n          description: 'label for shaken gesture in gesture picker for micro:bit extension'\n        }),\n        value: MicroBitGestures.SHAKEN\n      }, {\n        text: formatMessage({\n          id: 'microbit.gesturesMenu.jumped',\n          default: 'jumped',\n          description: 'label for jumped gesture in gesture picker for micro:bit extension'\n        }),\n        value: MicroBitGestures.JUMPED\n      }];\n    }\n    /**\n     * @return {array} - text and values for each pin state menu element\n     */\n  }, {\n    key: \"PIN_STATE_MENU\",\n    get: function get() {\n      return [{\n        text: formatMessage({\n          id: 'microbit.pinStateMenu.on',\n          default: 'on',\n          description: 'label for on element in pin state picker for micro:bit extension'\n        }),\n        value: MicroBitPinState.ON\n      }, {\n        text: formatMessage({\n          id: 'microbit.pinStateMenu.off',\n          default: 'off',\n          description: 'label for off element in pin state picker for micro:bit extension'\n        }),\n        value: MicroBitPinState.OFF\n      }];\n    }\n    /**\n     * @return {array} - text and values for each tilt direction menu element\n     */\n  }, {\n    key: \"TILT_DIRECTION_MENU\",\n    get: function get() {\n      return [{\n        text: formatMessage({\n          id: 'microbit.tiltDirectionMenu.front',\n          default: 'front',\n          description: 'label for front element in tilt direction picker for micro:bit extension'\n        }),\n        value: MicroBitTiltDirection.FRONT\n      }, {\n        text: formatMessage({\n          id: 'microbit.tiltDirectionMenu.back',\n          default: 'back',\n          description: 'label for back element in tilt direction picker for micro:bit extension'\n        }),\n        value: MicroBitTiltDirection.BACK\n      }, {\n        text: formatMessage({\n          id: 'microbit.tiltDirectionMenu.left',\n          default: 'left',\n          description: 'label for left element in tilt direction picker for micro:bit extension'\n        }),\n        value: MicroBitTiltDirection.LEFT\n      }, {\n        text: formatMessage({\n          id: 'microbit.tiltDirectionMenu.right',\n          default: 'right',\n          description: 'label for right element in tilt direction picker for micro:bit extension'\n        }),\n        value: MicroBitTiltDirection.RIGHT\n      }];\n    }\n    /**\n     * @return {array} - text and values for each tilt direction (plus \"any\") menu element\n     */\n  }, {\n    key: \"TILT_DIRECTION_ANY_MENU\",\n    get: function get() {\n      return [].concat(_toConsumableArray(this.TILT_DIRECTION_MENU), [{\n        text: formatMessage({\n          id: 'microbit.tiltDirectionMenu.any',\n          default: 'any',\n          description: 'label for any direction element in tilt direction picker for micro:bit extension'\n        }),\n        value: MicroBitTiltDirection.ANY\n      }]);\n    }\n    /**\n     * Construct a set of MicroBit blocks.\n     * @param {Runtime} runtime - the Scratch 3.0 runtime.\n     */\n  }], [{\n    key: \"EXTENSION_NAME\",\n    /**\n     * @return {string} - the name of this extension.\n     */\n    get: function get() {\n      return 'micro:bit';\n    }\n    /**\n     * @return {string} - the ID of this extension.\n     */\n  }, {\n    key: \"EXTENSION_ID\",\n    get: function get() {\n      return 'microbit';\n    }\n    /**\n     * @return {number} - the tilt sensor counts as \"tilted\" if its tilt angle meets or exceeds this threshold.\n     */\n  }, {\n    key: \"TILT_THRESHOLD\",\n    get: function get() {\n      return 15;\n    }\n  }]);\n  function Scratch3MicroBitBlocks(runtime) {\n    _classCallCheck(this, Scratch3MicroBitBlocks);\n    /**\n     * The Scratch 3.0 runtime.\n     * @type {Runtime}\n     */\n    this.runtime = runtime; // Create a new MicroBit peripheral instance\n    this._peripheral = new MicroBit(this.runtime, Scratch3MicroBitBlocks.EXTENSION_ID);\n  }\n  /**\n   * @returns {object} metadata for this extension and its blocks.\n   */\n  _createClass(Scratch3MicroBitBlocks, [{\n    key: \"getInfo\",\n    value: function getInfo() {\n      return {\n        id: Scratch3MicroBitBlocks.EXTENSION_ID,\n        name: Scratch3MicroBitBlocks.EXTENSION_NAME,\n        blockIconURI: blockIconURI,\n        showStatusButton: true,\n        blocks: [{\n          opcode: 'whenButtonPressed',\n          text: formatMessage({\n            id: 'microbit.whenButtonPressed',\n            default: 'when [BTN] button pressed',\n            description: 'when the selected button on the micro:bit is pressed'\n          }),\n          blockType: BlockType.HAT,\n          arguments: {\n            BTN: {\n              type: ArgumentType.STRING,\n              menu: 'buttons',\n              defaultValue: MicroBitButtons.A\n            }\n          }\n        }, {\n          opcode: 'isButtonPressed',\n          text: formatMessage({\n            id: 'microbit.isButtonPressed',\n            default: '[BTN] button pressed?',\n            description: 'is the selected button on the micro:bit pressed?'\n          }),\n          blockType: BlockType.BOOLEAN,\n          arguments: {\n            BTN: {\n              type: ArgumentType.STRING,\n              menu: 'buttons',\n              defaultValue: MicroBitButtons.A\n            }\n          }\n        }, '---', {\n          opcode: 'whenGesture',\n          text: formatMessage({\n            id: 'microbit.whenGesture',\n            default: 'when [GESTURE]',\n            description: 'when the selected gesture is detected by the micro:bit'\n          }),\n          blockType: BlockType.HAT,\n          arguments: {\n            GESTURE: {\n              type: ArgumentType.STRING,\n              menu: 'gestures',\n              defaultValue: MicroBitGestures.MOVED\n            }\n          }\n        }, '---', {\n          opcode: 'displaySymbol',\n          text: formatMessage({\n            id: 'microbit.displaySymbol',\n            default: 'display [MATRIX]',\n            description: 'display a pattern on the micro:bit display'\n          }),\n          blockType: BlockType.COMMAND,\n          arguments: {\n            MATRIX: {\n              type: ArgumentType.MATRIX,\n              defaultValue: '0101010101100010101000100'\n            }\n          }\n        }, {\n          opcode: 'displayText',\n          text: formatMessage({\n            id: 'microbit.displayText',\n            default: 'display text [TEXT]',\n            description: 'display text on the micro:bit display'\n          }),\n          blockType: BlockType.COMMAND,\n          arguments: {\n            TEXT: {\n              type: ArgumentType.STRING,\n              defaultValue: formatMessage({\n                id: 'microbit.defaultTextToDisplay',\n                default: 'Hello!',\n                description: \"default text to display.\\n                                IMPORTANT - the micro:bit only supports letters a-z, A-Z.\\n                                Please substitute a default word in your language\\n                                that can be written with those characters,\\n                                substitute non-accented characters or leave it as \\\"Hello!\\\".\\n                                Check the micro:bit site documentation for details\"\n              })\n            }\n          }\n        }, {\n          opcode: 'displayClear',\n          text: formatMessage({\n            id: 'microbit.clearDisplay',\n            default: 'clear display',\n            description: 'display nothing on the micro:bit display'\n          }),\n          blockType: BlockType.COMMAND\n        }, '---', {\n          opcode: 'whenTilted',\n          text: formatMessage({\n            id: 'microbit.whenTilted',\n            default: 'when tilted [DIRECTION]',\n            description: 'when the micro:bit is tilted in a direction'\n          }),\n          blockType: BlockType.HAT,\n          arguments: {\n            DIRECTION: {\n              type: ArgumentType.STRING,\n              menu: 'tiltDirectionAny',\n              defaultValue: MicroBitTiltDirection.ANY\n            }\n          }\n        }, {\n          opcode: 'isTilted',\n          text: formatMessage({\n            id: 'microbit.isTilted',\n            default: 'tilted [DIRECTION]?',\n            description: 'is the micro:bit is tilted in a direction?'\n          }),\n          blockType: BlockType.BOOLEAN,\n          arguments: {\n            DIRECTION: {\n              type: ArgumentType.STRING,\n              menu: 'tiltDirectionAny',\n              defaultValue: MicroBitTiltDirection.ANY\n            }\n          }\n        }, {\n          opcode: 'getTiltAngle',\n          text: formatMessage({\n            id: 'microbit.tiltAngle',\n            default: 'tilt angle [DIRECTION]',\n            description: 'how much the micro:bit is tilted in a direction'\n          }),\n          blockType: BlockType.REPORTER,\n          arguments: {\n            DIRECTION: {\n              type: ArgumentType.STRING,\n              menu: 'tiltDirection',\n              defaultValue: MicroBitTiltDirection.FRONT\n            }\n          }\n        }, '---', {\n          opcode: 'whenPinConnected',\n          text: formatMessage({\n            id: 'microbit.whenPinConnected',\n            default: 'when pin [PIN] connected',\n            description: 'when the pin detects a connection to Earth/Ground'\n          }),\n          blockType: BlockType.HAT,\n          arguments: {\n            PIN: {\n              type: ArgumentType.STRING,\n              menu: 'touchPins',\n              defaultValue: '0'\n            }\n          }\n        }],\n        menus: {\n          buttons: {\n            acceptReporters: true,\n            items: this.BUTTONS_MENU\n          },\n          gestures: {\n            acceptReporters: true,\n            items: this.GESTURES_MENU\n          },\n          pinState: {\n            acceptReporters: true,\n            items: this.PIN_STATE_MENU\n          },\n          tiltDirection: {\n            acceptReporters: true,\n            items: this.TILT_DIRECTION_MENU\n          },\n          tiltDirectionAny: {\n            acceptReporters: true,\n            items: this.TILT_DIRECTION_ANY_MENU\n          },\n          touchPins: {\n            acceptReporters: true,\n            items: ['0', '1', '2']\n          }\n        }\n      };\n    }\n    /**\n     * Test whether the A or B button is pressed\n     * @param {object} args - the block's arguments.\n     * @return {boolean} - true if the button is pressed.\n     */\n  }, {\n    key: \"whenButtonPressed\",\n    value: function whenButtonPressed(args) {\n      if (args.BTN === 'any') {\n        return this._peripheral.buttonA | this._peripheral.buttonB;\n      } else if (args.BTN === 'A') {\n        return this._peripheral.buttonA;\n      } else if (args.BTN === 'B') {\n        return this._peripheral.buttonB;\n      }\n      return false;\n    }\n    /**\n     * Test whether the A or B button is pressed\n     * @param {object} args - the block's arguments.\n     * @return {boolean} - true if the button is pressed.\n     */\n  }, {\n    key: \"isButtonPressed\",\n    value: function isButtonPressed(args) {\n      if (args.BTN === 'any') {\n        return (this._peripheral.buttonA | this._peripheral.buttonB) !== 0;\n      } else if (args.BTN === 'A') {\n        return this._peripheral.buttonA !== 0;\n      } else if (args.BTN === 'B') {\n        return this._peripheral.buttonB !== 0;\n      }\n      return false;\n    }\n    /**\n     * Test whether the micro:bit is moving\n     * @param {object} args - the block's arguments.\n     * @return {boolean} - true if the micro:bit is moving.\n     */\n  }, {\n    key: \"whenGesture\",\n    value: function whenGesture(args) {\n      var gesture = cast.toString(args.GESTURE);\n      if (gesture === 'moved') {\n        return this._peripheral.gestureState >> 2 & 1;\n      } else if (gesture === 'shaken') {\n        return this._peripheral.gestureState & 1;\n      } else if (gesture === 'jumped') {\n        return this._peripheral.gestureState >> 1 & 1;\n      }\n      return false;\n    }\n    /**\n     * Display a predefined symbol on the 5x5 LED matrix.\n     * @param {object} args - the block's arguments.\n     * @return {Promise} - a Promise that resolves after a tick.\n     */\n  }, {\n    key: \"displaySymbol\",\n    value: function displaySymbol(args) {\n      var symbol = cast.toString(args.MATRIX).replace(/\\s/g, '');\n      var reducer = function reducer(accumulator, c, index) {\n        var value = c === '0' ? accumulator : accumulator + Math.pow(2, index);\n        return value;\n      };\n      var hex = symbol.split('').reduce(reducer, 0);\n      if (hex !== null) {\n        this._peripheral.ledMatrixState[0] = hex & 0x1F;\n        this._peripheral.ledMatrixState[1] = hex >> 5 & 0x1F;\n        this._peripheral.ledMatrixState[2] = hex >> 10 & 0x1F;\n        this._peripheral.ledMatrixState[3] = hex >> 15 & 0x1F;\n        this._peripheral.ledMatrixState[4] = hex >> 20 & 0x1F;\n        this._peripheral.displayMatrix(this._peripheral.ledMatrixState);\n      }\n      return new Promise(function (resolve) {\n        setTimeout(function () {\n          resolve();\n        }, BLESendInterval);\n      });\n    }\n    /**\n     * Display text on the 5x5 LED matrix.\n     * @param {object} args - the block's arguments.\n     * @return {Promise} - a Promise that resolves after the text is done printing.\n     * Note the limit is 19 characters\n     * The print time is calculated by multiplying the number of horizontal pixels\n     * by the default scroll delay of 120ms.\n     * The number of horizontal pixels = 6px for each character in the string,\n     * 1px before the string, and 5px after the string.\n     */\n  }, {\n    key: \"displayText\",\n    value: function displayText(args) {\n      var text = String(args.TEXT).substring(0, 19);\n      if (text.length > 0) this._peripheral.displayText(text);\n      var yieldDelay = 120 * (6 * text.length + 6);\n      return new Promise(function (resolve) {\n        setTimeout(function () {\n          resolve();\n        }, yieldDelay);\n      });\n    }\n    /**\n     * Turn all 5x5 matrix LEDs off.\n     * @return {Promise} - a Promise that resolves after a tick.\n     */\n  }, {\n    key: \"displayClear\",\n    value: function displayClear() {\n      for (var i = 0; i < 5; i++) {\n        this._peripheral.ledMatrixState[i] = 0;\n      }\n      this._peripheral.displayMatrix(this._peripheral.ledMatrixState);\n      return new Promise(function (resolve) {\n        setTimeout(function () {\n          resolve();\n        }, BLESendInterval);\n      });\n    }\n    /**\n     * Test whether the tilt sensor is currently tilted.\n     * @param {object} args - the block's arguments.\n     * @property {TiltDirection} DIRECTION - the tilt direction to test (front, back, left, right, or any).\n     * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.\n     */\n  }, {\n    key: \"whenTilted\",\n    value: function whenTilted(args) {\n      return this._isTilted(args.DIRECTION);\n    }\n    /**\n     * Test whether the tilt sensor is currently tilted.\n     * @param {object} args - the block's arguments.\n     * @property {TiltDirection} DIRECTION - the tilt direction to test (front, back, left, right, or any).\n     * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.\n     */\n  }, {\n    key: \"isTilted\",\n    value: function isTilted(args) {\n      return this._isTilted(args.DIRECTION);\n    }\n    /**\n     * @param {object} args - the block's arguments.\n     * @property {TiltDirection} DIRECTION - the direction (front, back, left, right) to check.\n     * @return {number} - the tilt sensor's angle in the specified direction.\n     * Note that getTiltAngle(front) = -getTiltAngle(back) and getTiltAngle(left) = -getTiltAngle(right).\n     */\n  }, {\n    key: \"getTiltAngle\",\n    value: function getTiltAngle(args) {\n      return this._getTiltAngle(args.DIRECTION);\n    }\n    /**\n     * Test whether the tilt sensor is currently tilted.\n     * @param {TiltDirection} direction - the tilt direction to test (front, back, left, right, or any).\n     * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.\n     * @private\n     */\n  }, {\n    key: \"_isTilted\",\n    value: function _isTilted(direction) {\n      switch (direction) {\n        case MicroBitTiltDirection.ANY:\n          return Math.abs(this._peripheral.tiltX / 10) >= Scratch3MicroBitBlocks.TILT_THRESHOLD || Math.abs(this._peripheral.tiltY / 10) >= Scratch3MicroBitBlocks.TILT_THRESHOLD;\n        default:\n          return this._getTiltAngle(direction) >= Scratch3MicroBitBlocks.TILT_THRESHOLD;\n      }\n    }\n    /**\n     * @param {TiltDirection} direction - the direction (front, back, left, right) to check.\n     * @return {number} - the tilt sensor's angle in the specified direction.\n     * Note that getTiltAngle(front) = -getTiltAngle(back) and getTiltAngle(left) = -getTiltAngle(right).\n     * @private\n     */\n  }, {\n    key: \"_getTiltAngle\",\n    value: function _getTiltAngle(direction) {\n      switch (direction) {\n        case MicroBitTiltDirection.FRONT:\n          return Math.round(this._peripheral.tiltY / -10);\n        case MicroBitTiltDirection.BACK:\n          return Math.round(this._peripheral.tiltY / 10);\n        case MicroBitTiltDirection.LEFT:\n          return Math.round(this._peripheral.tiltX / -10);\n        case MicroBitTiltDirection.RIGHT:\n          return Math.round(this._peripheral.tiltX / 10);\n        default:\n          log.warn(\"Unknown tilt direction in _getTiltAngle: \".concat(direction));\n      }\n    }\n    /**\n     * @param {object} args - the block's arguments.\n     * @return {boolean} - the touch pin state.\n     * @private\n     */\n  }, {\n    key: \"whenPinConnected\",\n    value: function whenPinConnected(args) {\n      var pin = parseInt(args.PIN, 10);\n      if (isNaN(pin)) return;\n      if (pin < 0 || pin > 2) return false;\n      return this._peripheral._checkPinState(pin);\n    }\n  }]);\n  return Scratch3MicroBitBlocks;\n}();\nmodule.exports = Scratch3MicroBitBlocks;\n })