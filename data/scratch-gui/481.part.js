/* 481 */\n (function(module, exports, __webpack_require__) {\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n/**\n * @fileoverview\n * Partial implementation of an SB2 JSON importer.\n * Parses provided JSON and then generates all needed\n * scratch-vm runtime structures.\n */\nvar Blocks = __webpack_require__(135);\nvar RenderedTarget = __webpack_require__(219);\nvar Sprite = __webpack_require__(479);\nvar Color = __webpack_require__(180);\nvar log = __webpack_require__(39);\nvar uid = __webpack_require__(94);\nvar StringUtil = __webpack_require__(102);\nvar MathUtil = __webpack_require__(62);\nvar specMap = __webpack_require__(1187);\nvar Comment = __webpack_require__(297);\nvar Variable = __webpack_require__(114);\nvar MonitorRecord = __webpack_require__(295);\nvar StageLayering = __webpack_require__(115);\nvar _require = __webpack_require__(225),\n    loadCostume = _require.loadCostume;\nvar _require2 = __webpack_require__(226),\n    loadSound = _require2.loadSound;\nvar _require3 = __webpack_require__(480),\n    deserializeCostume = _require3.deserializeCostume,\n    deserializeSound = _require3.deserializeSound; // Constants used during deserialization of an SB2 file\nvar CORE_EXTENSIONS = ['argument', 'control', 'data', 'event', 'looks', 'math', 'motion', 'operator', 'procedures', 'sensing', 'sound']; // Adjust script coordinates to account for\n// larger block size in scratch-blocks.\n// @todo: Determine more precisely the right formulas here.\nvar WORKSPACE_X_SCALE = 1.5;\nvar WORKSPACE_Y_SCALE = 2.2;\n/**\n * Convert a Scratch 2.0 procedure string (e.g., \"my_procedure %s %b %n\")\n * into an argument map. This allows us to provide the expected inputs\n * to a mutated procedure call.\n * @param {string} procCode Scratch 2.0 procedure string.\n * @return {object} Argument map compatible with those in sb2specmap.\n */\nvar parseProcedureArgMap = function parseProcedureArgMap(procCode) {\n  var argMap = [{} // First item in list is op string.\n  ];\n  var INPUT_PREFIX = 'input';\n  var inputCount = 0; // Split by %n, %b, %s.\n  var parts = procCode.split(/(?=[^\\\\]%[nbs])/);\n  for (var i = 0; i < parts.length; i++) {\n    var part = parts[i].trim();\n    if (part.substring(0, 1) === '%') {\n      var argType = part.substring(1, 2);\n      var arg = {\n        type: 'input',\n        inputName: INPUT_PREFIX + inputCount++\n      };\n      if (argType === 'n') {\n        arg.inputOp = 'math_number';\n      } else if (argType === 's') {\n        arg.inputOp = 'text';\n      } else if (argType === 'b') {\n        arg.inputOp = 'boolean';\n      }\n      argMap.push(arg);\n    }\n  }\n  return argMap;\n};\n/**\n * Generate a list of \"argument IDs\" for procdefs and caller mutations.\n * IDs just end up being `input0`, `input1`, ... which is good enough.\n * @param {string} procCode Scratch 2.0 procedure string.\n * @return {Array.<string>} Array of argument id strings.\n */\nvar parseProcedureArgIds = function parseProcedureArgIds(procCode) {\n  return parseProcedureArgMap(procCode).map(function (arg) {\n    return arg.inputName;\n  }).filter(function (name) {\n    return name;\n  }); // Filter out unnamed inputs which are labels\n};\n/**\n * Flatten a block tree into a block list.\n * Children are temporarily stored on the `block.children` property.\n * @param {Array.<object>} blocks list generated by `parseBlockList`.\n * @return {Array.<object>} Flattened list to be passed to `blocks.createBlock`.\n */\nvar flatten = function flatten(blocks) {\n  var finalBlocks = [];\n  for (var i = 0; i < blocks.length; i++) {\n    var block = blocks[i];\n    finalBlocks.push(block);\n    if (block.children) {\n      finalBlocks = finalBlocks.concat(flatten(block.children));\n    }\n    delete block.children;\n  }\n  return finalBlocks;\n};\n/**\n * Parse any list of blocks from SB2 JSON into a list of VM-format blocks.\n * Could be used to parse a top-level script,\n * a list of blocks in a branch (e.g., in forever),\n * or a list of blocks in an argument (e.g., move [pick random...]).\n * @param {Array.<object>} blockList SB2 JSON-format block list.\n * @param {Function} addBroadcastMsg function to update broadcast message name map\n * @param {Function} getVariableId function to retreive a variable's ID based on name\n * @param {ImportedExtensionsInfo} extensions - (in/out) parsed extension information will be stored here.\n * @param {ParseState} parseState - info on the state of parsing beyond the current block.\n * @param {object<int, Comment>} comments - Comments from sb2 project that need to be attached to blocks.\n * They are indexed in this object by the sb2 flattened block list index indicating\n * which block they should attach to.\n * @param {int} commentIndex The current index of the top block in this list if it were in a flattened\n * list of all blocks for the target\n * @return {Array<Array.<object>|int>} Tuple where first item is the Scratch VM-format block list, and\n * second item is the updated comment index\n */\nvar parseBlockList = function parseBlockList(blockList, addBroadcastMsg, getVariableId, extensions, parseState, comments, commentIndex) {\n  var resultingList = [];\n  var previousBlock = null; // For setting next.\n  for (var i = 0; i < blockList.length; i++) {\n    var block = blockList[i]; // eslint-disable-next-line no-use-before-define\n    var parsedBlockAndComments = parseBlock(block, addBroadcastMsg, getVariableId, extensions, parseState, comments, commentIndex);\n    var parsedBlock = parsedBlockAndComments[0]; // Update commentIndex\n    commentIndex = parsedBlockAndComments[1];\n    if (!parsedBlock) continue;\n    if (previousBlock) {\n      parsedBlock.parent = previousBlock.id;\n      previousBlock.next = parsedBlock.id;\n    }\n    previousBlock = parsedBlock;\n    resultingList.push(parsedBlock);\n  }\n  return [resultingList, commentIndex];\n};\n/**\n * Parse a Scratch object's scripts into VM blocks.\n * This should only handle top-level scripts that include X, Y coordinates.\n * @param {!object} scripts Scripts object from SB2 JSON.\n * @param {!Blocks} blocks Blocks object to load parsed blocks into.\n * @param {Function} addBroadcastMsg function to update broadcast message name map\n * @param {Function} getVariableId function to retreive a variable's ID based on name\n * @param {ImportedExtensionsInfo} extensions - (in/out) parsed extension information will be stored here.\n * @param {object} comments Comments that need to be attached to the blocks that need to be parsed\n */\nvar parseScripts = function parseScripts(scripts, blocks, addBroadcastMsg, getVariableId, extensions, comments) {\n  // Keep track of the index of the current script being\n  // parsed in order to attach block comments correctly\n  var scriptIndexForComment = 0;\n  for (var i = 0; i < scripts.length; i++) {\n    var script = scripts[i];\n    var scriptX = script[0];\n    var scriptY = script[1];\n    var blockList = script[2];\n    var parseState = {};\n    var _parseBlockList = parseBlockList(blockList, addBroadcastMsg, getVariableId, extensions, parseState, comments, scriptIndexForComment),\n        _parseBlockList2 = _slicedToArray(_parseBlockList, 2),\n        parsedBlockList = _parseBlockList2[0],\n        newCommentIndex = _parseBlockList2[1];\n    scriptIndexForComment = newCommentIndex;\n    if (parsedBlockList[0]) {\n      parsedBlockList[0].x = scriptX * WORKSPACE_X_SCALE;\n      parsedBlockList[0].y = scriptY * WORKSPACE_Y_SCALE;\n      parsedBlockList[0].topLevel = true;\n      parsedBlockList[0].parent = null;\n    } // Flatten children and create add the blocks.\n    var convertedBlocks = flatten(parsedBlockList);\n    for (var j = 0; j < convertedBlocks.length; j++) {\n      blocks.createBlock(convertedBlocks[j]);\n    }\n  }\n};\n/**\n * Create a callback for assigning fixed IDs to imported variables\n * Generator stores the global variable mapping in a closure\n * @param {!string} targetId the id of the target to scope the variable to\n * @return {string} variable ID\n */\nvar generateVariableIdGetter = function () {\n  var globalVariableNameMap = {};\n  var namer = function namer(targetId, name, type) {\n    return \"\".concat(targetId, \"-\").concat(StringUtil.replaceUnsafeChars(name), \"-\").concat(type);\n  };\n  return function (targetId, topLevel) {\n    // Reset the global variable map if topLevel\n    if (topLevel) globalVariableNameMap = {};\n    return function (name, type) {\n      if (topLevel) {\n        // Store the name/id pair in the globalVariableNameMap\n        globalVariableNameMap[\"\".concat(name, \"-\").concat(type)] = namer(targetId, name, type);\n        return globalVariableNameMap[\"\".concat(name, \"-\").concat(type)];\n      } // Not top-level, so first check the global name map\n      if (globalVariableNameMap[\"\".concat(name, \"-\").concat(type)]) return globalVariableNameMap[\"\".concat(name, \"-\").concat(type)];\n      return namer(targetId, name, type);\n    };\n  };\n}();\nvar globalBroadcastMsgStateGenerator = function () {\n  var broadcastMsgNameMap = {};\n  var allBroadcastFields = [];\n  var emptyStringName = uid();\n  return function (topLevel) {\n    if (topLevel) broadcastMsgNameMap = {};\n    return {\n      broadcastMsgMapUpdater: function broadcastMsgMapUpdater(name, field) {\n        name = name.toLowerCase();\n        if (name === '') {\n          name = emptyStringName;\n        }\n        broadcastMsgNameMap[name] = \"broadcastMsgId-\".concat(StringUtil.replaceUnsafeChars(name));\n        allBroadcastFields.push(field);\n        return broadcastMsgNameMap[name];\n      },\n      globalBroadcastMsgs: broadcastMsgNameMap,\n      allBroadcastFields: allBroadcastFields,\n      emptyMsgName: emptyStringName\n    };\n  };\n}();\n/**\n * Parse a single monitor object and create all its in-memory VM objects.\n *\n * It is important that monitors are parsed last,\n * - after all sprite targets have finished parsing, and\n * - after the rest of the stage has finished parsing.\n *\n * It is specifically important that all the scripts in the project\n * have been parsed and all the relevant targets exist, have uids,\n * and have their variables initialized.\n * Calling this function before these things are true, will result in\n * undefined behavior.\n * @param {!object} object - From-JSON \"Monitor object\"\n * @param {!Runtime} runtime - (in/out) Runtime object to load monitor info into.\n * @param {!Array.<Target>} targets - Targets have already been parsed.\n * @param {ImportedExtensionsInfo} extensions - (in/out) parsed extension information will be stored here.\n */\nvar parseMonitorObject = function parseMonitorObject(object, runtime, targets, extensions) {\n  // If we can't find the block in the spec map, ignore it.\n  // This happens for things like Lego Wedo 1.0 monitors.\n  var mapped = specMap[object.cmd];\n  if (!mapped) {\n    log.warn(\"Could not find monitor block with opcode: \".concat(object.cmd));\n    return;\n  } // In scratch 2.0, there are two monitors that now correspond to extension\n  // blocks (tempo and video motion/direction). In the case of the\n  // video motion/direction block, this reporter is not monitorable in Scratch 3.0.\n  // In the case of the tempo block, we should import it and load the music extension\n  // only when the monitor is actually visible.\n  var opcode = specMap[object.cmd].opcode;\n  var extIndex = opcode.indexOf('_');\n  var extID = opcode.substring(0, extIndex);\n  if (extID === 'videoSensing') {\n    return;\n  } else if (CORE_EXTENSIONS.indexOf(extID) === -1 && extID !== '' && !extensions.extensionIDs.has(extID) && !object.visible) {\n    // Don't import this monitor if it refers to a non-core extension that\n    // doesn't exist anywhere else in the project and it isn't visible.\n    // This should only apply to the tempo block at this point since\n    // there are no other sb2 blocks that are now extension monitors.\n    return;\n  }\n  var target = null; // List blocks don't come in with their target name set.\n  // Find the target by searching for a target with matching variable name/type.\n  if (!object.hasOwnProperty('target')) {\n    var _loop = function _loop(i) {\n      var currTarget = targets[i];\n      var listVariables = Object.keys(currTarget.variables).filter(function (key) {\n        var variable = currTarget.variables[key];\n        return variable.type === Variable.LIST_TYPE && variable.name === object.listName;\n      });\n      if (listVariables.length > 0) {\n        target = currTarget; // Keep this target for later use\n        object.target = currTarget.getName(); // Set target name to normalize with other monitors\n      }\n    };\n    for (var i = 0; i < targets.length; i++) {\n      _loop(i);\n    }\n  } // Get the target for this monitor, if not gotten above.\n  target = target || targets.filter(function (t) {\n    return t.getName() === object.target;\n  })[0];\n  if (!target) throw new Error('Cannot create monitor for target that cannot be found by name'); // Create var id getter to make block naming/parsing easier, variables already created.\n  var getVariableId = generateVariableIdGetter(target.id, false); // eslint-disable-next-line no-use-before-define\n  var _parseBlock = parseBlock([object.cmd, object.param], // Scratch 2 monitor blocks only have one param.\n  null, // `addBroadcastMsg`, not needed for monitor blocks.\n  getVariableId, extensions, {}, null, // `comments`, not needed for monitor blocks\n  null // `commentIndex`, not needed for monitor blocks\n  ),\n      _parseBlock2 = _slicedToArray(_parseBlock, 2),\n      block = _parseBlock2[0],\n      _ = _parseBlock2[1]; // Monitor blocks have special IDs to match the toolbox obtained from the getId\n  // function in the runtime.monitorBlocksInfo. Variable monitors, however,\n  // get their IDs from the variable id they reference.\n  if (object.cmd === 'getVar:') {\n    block.id = getVariableId(object.param, Variable.SCALAR_TYPE);\n  } else if (object.cmd === 'contentsOfList:') {\n    block.id = getVariableId(object.param, Variable.LIST_TYPE);\n  } else if (runtime.monitorBlockInfo.hasOwnProperty(block.opcode)) {\n    block.id = runtime.monitorBlockInfo[block.opcode].getId(target.id, block.fields);\n  } else {\n    // If the opcode can't be found in the runtime monitorBlockInfo,\n    // then default to using the block opcode as the id instead.\n    // This is for extension monitors, and assumes that extension monitors\n    // cannot be sprite specific.\n    block.id = block.opcode;\n  } // Block needs a targetId if it is targetting something other than the stage\n  block.targetId = target.isStage ? null : target.id; // Property required for running monitored blocks.\n  block.isMonitored = object.visible;\n  var existingMonitorBlock = runtime.monitorBlocks._blocks[block.id];\n  if (existingMonitorBlock) {\n    // A monitor block already exists if the toolbox has been loaded and\n    // the monitor block is not target specific (because the block gets recycled).\n    // Update the existing block with the relevant monitor information.\n    existingMonitorBlock.isMonitored = object.visible;\n    existingMonitorBlock.targetId = block.targetId;\n  } else {\n    // Blocks can be created with children, flatten and add to monitorBlocks.\n    var newBlocks = flatten([block]);\n    for (var _i2 = 0; _i2 < newBlocks.length; _i2++) {\n      runtime.monitorBlocks.createBlock(newBlocks[_i2]);\n    }\n  } // Convert numbered mode into strings for better understandability.\n  switch (object.mode) {\n    case 1:\n      object.mode = 'default';\n      break;\n    case 2:\n      object.mode = 'large';\n      break;\n    case 3:\n      object.mode = 'slider';\n      break;\n  } // Create a monitor record for the runtime's monitorState\n  runtime.requestAddMonitor(MonitorRecord({\n    id: block.id,\n    targetId: block.targetId,\n    spriteName: block.targetId ? object.target : null,\n    opcode: block.opcode,\n    params: runtime.monitorBlocks._getBlockParams(block),\n    value: '',\n    mode: object.mode,\n    sliderMin: object.sliderMin,\n    sliderMax: object.sliderMax,\n    isDiscrete: object.isDiscrete,\n    x: object.x,\n    y: object.y,\n    width: object.width,\n    height: object.height,\n    visible: object.visible\n  }));\n};\n/**\n * Parse the assets of a single \"Scratch object\" and load them. This\n * preprocesses objects to support loading the data for those assets over a\n * network while the objects are further processed into Blocks, Sprites, and a\n * list of needed Extensions.\n * @param {!object} object - From-JSON \"Scratch object:\" sprite, stage, watcher.\n * @param {!Runtime} runtime - Runtime object to load all structures into.\n * @param {boolean} topLevel - Whether this is the top-level object (stage).\n * @param {?object} zip - Optional zipped assets for local file import\n * @return {?{costumePromises:Array.<Promise>,soundPromises:Array.<Promise>,soundBank:SoundBank,children:object}}\n *   Object of arrays of promises and child objects for asset objects used in\n *   Sprites. As well as a SoundBank for the sound assets. null for unsupported\n *   objects.\n */\nvar parseScratchAssets = function parseScratchAssets(object, runtime, topLevel, zip) {\n  if (!object.hasOwnProperty('objName')) {\n    // Skip parsing monitors. Or any other objects missing objName.\n    return null;\n  }\n  var assets = {\n    costumePromises: [],\n    soundPromises: [],\n    soundBank: runtime.audioEngine && runtime.audioEngine.createBank(),\n    children: []\n  }; // Costumes from JSON.\n  var costumePromises = assets.costumePromises;\n  if (object.hasOwnProperty('costumes')) {\n    var _loop2 = function _loop2(i) {\n      var costumeSource = object.costumes[i];\n      var bitmapResolution = costumeSource.bitmapResolution || 1;\n      var costume = {\n        name: costumeSource.costumeName,\n        bitmapResolution: bitmapResolution,\n        rotationCenterX: topLevel ? 240 * bitmapResolution : costumeSource.rotationCenterX,\n        rotationCenterY: topLevel ? 180 * bitmapResolution : costumeSource.rotationCenterY,\n        // TODO we eventually want this next property to be called\n        // md5ext to reflect what it actually contains, however this\n        // will be a very extensive change across many repositories\n        // and should be done carefully and altogether\n        md5: costumeSource.baseLayerMD5,\n        skinId: null\n      };\n      var md5ext = costumeSource.baseLayerMD5;\n      var idParts = StringUtil.splitFirst(md5ext, '.');\n      var md5 = idParts[0];\n      var ext = void 0;\n      if (idParts.length === 2 && idParts[1]) {\n        ext = idParts[1];\n      } else {\n        // Default to 'png' if baseLayerMD5 is not formatted correctly\n        ext = 'png'; // Fix costume md5 for later\n        costume.md5 = \"\".concat(costume.md5, \".\").concat(ext);\n      }\n      costume.dataFormat = ext;\n      costume.assetId = md5;\n      if (costumeSource.textLayerMD5) {\n        costume.textLayerMD5 = StringUtil.splitFirst(costumeSource.textLayerMD5, '.')[0];\n      } // If there is no internet connection, or if the asset is not in storage\n      // for some reason, and we are doing a local .sb2 import, (e.g. zip is provided)\n      // the file name of the costume should be the baseLayerID followed by the file ext\n      var assetFileName = \"\".concat(costumeSource.baseLayerID, \".\").concat(ext);\n      var textLayerFileName = costumeSource.textLayerID ? \"\".concat(costumeSource.textLayerID, \".png\") : null;\n      costumePromises.push(deserializeCostume(costume, runtime, zip, assetFileName, textLayerFileName).then(function () {\n        return loadCostume(costume.md5, costume, runtime, 2\n        /* optVersion */\n        );\n      }));\n    };\n    for (var i = 0; i < object.costumes.length; i++) {\n      _loop2(i);\n    }\n  } // Sounds from JSON\n  var soundBank = assets.soundBank,\n      soundPromises = assets.soundPromises;\n  if (object.hasOwnProperty('sounds')) {\n    var _loop3 = function _loop3(s) {\n      var soundSource = object.sounds[s];\n      var sound = {\n        name: soundSource.soundName,\n        format: soundSource.format,\n        rate: soundSource.rate,\n        sampleCount: soundSource.sampleCount,\n        // TODO we eventually want this next property to be called\n        // md5ext to reflect what it actually contains, however this\n        // will be a very extensive change across many repositories\n        // and should be done carefully and altogether\n        // (for example, the audio engine currently relies on this\n        // property to be named 'md5')\n        md5: soundSource.md5,\n        data: null\n      };\n      var md5ext = soundSource.md5;\n      var idParts = StringUtil.splitFirst(md5ext, '.');\n      var md5 = idParts[0];\n      var ext = idParts[1].toLowerCase();\n      sound.dataFormat = ext;\n      sound.assetId = md5; // If there is no internet connection, or if the asset is not in storage\n      // for some reason, and we are doing a local .sb2 import, (e.g. zip is provided)\n      // the file name of the sound should be the soundID (provided from the project.json)\n      // followed by the file ext\n      var assetFileName = \"\".concat(soundSource.soundID, \".\").concat(ext);\n      soundPromises.push(deserializeSound(sound, runtime, zip, assetFileName).then(function () {\n        return loadSound(sound, runtime, soundBank);\n      }));\n    };\n    for (var s = 0; s < object.sounds.length; s++) {\n      _loop3(s);\n    }\n  } // The stage will have child objects; recursively process them.\n  var childrenAssets = assets.children;\n  if (object.children) {\n    for (var m = 0; m < object.children.length; m++) {\n      childrenAssets.push(parseScratchAssets(object.children[m], runtime, false, zip));\n    }\n  }\n  return assets;\n};\n/**\n * Parse a single \"Scratch object\" and create all its in-memory VM objects.\n * TODO: parse the \"info\" section, especially \"savedExtensions\"\n * @param {!object} object - From-JSON \"Scratch object:\" sprite, stage, watcher.\n * @param {!Runtime} runtime - Runtime object to load all structures into.\n * @param {ImportedExtensionsInfo} extensions - (in/out) parsed extension information will be stored here.\n * @param {boolean} topLevel - Whether this is the top-level object (stage).\n * @param {?object} zip - Optional zipped assets for local file import\n * @param {object} assets - Promises for assets of this scratch object grouped\n *   into costumes and sounds\n * @return {!Promise.<Array.<Target>>} Promise for the loaded targets when ready, or null for unsupported objects.\n */\nvar parseScratchObject = function parseScratchObject(object, runtime, extensions, topLevel, zip, assets) {\n  if (!object.hasOwnProperty('objName')) {\n    if (object.hasOwnProperty('listName')) {\n      // Shim these objects so they can be processed as monitors\n      object.cmd = 'contentsOfList:';\n      object.param = object.listName;\n      object.mode = 'list';\n    } // Defer parsing monitors until targets are all parsed\n    object.deferredMonitor = true;\n    return Promise.resolve(object);\n  } // Blocks container for this object.\n  var blocks = new Blocks(runtime); // @todo: For now, load all Scratch objects (stage/sprites) as a Sprite.\n  var sprite = new Sprite(blocks, runtime); // Sprite/stage name from JSON.\n  if (object.hasOwnProperty('objName')) {\n    if (topLevel && object.objName !== 'Stage') {\n      var _iterator = _createForOfIteratorHelper(object.children),\n          _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var child = _step.value;\n          if (!child.hasOwnProperty('objName') && child.target === object.objName) {\n            child.target = 'Stage';\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      object.objName = 'Stage';\n    }\n    sprite.name = object.objName;\n  } // Costumes from JSON.\n  var costumePromises = assets.costumePromises; // Sounds from JSON\n  var soundBank = assets.soundBank,\n      soundPromises = assets.soundPromises; // Create the first clone, and load its run-state from JSON.\n  var target = sprite.createClone(topLevel ? StageLayering.BACKGROUND_LAYER : StageLayering.SPRITE_LAYER);\n  var getVariableId = generateVariableIdGetter(target.id, topLevel);\n  var globalBroadcastMsgObj = globalBroadcastMsgStateGenerator(topLevel);\n  var addBroadcastMsg = globalBroadcastMsgObj.broadcastMsgMapUpdater; // Load target properties from JSON.\n  if (object.hasOwnProperty('variables')) {\n    for (var j = 0; j < object.variables.length; j++) {\n      var variable = object.variables[j]; // A variable is a cloud variable if:\n      // - the project says it's a cloud variable, and\n      // - it's a stage variable, and\n      // - the runtime can support another cloud variable\n      var isCloud = variable.isPersistent && topLevel && runtime.canAddCloudVariable();\n      var newVariable = new Variable(getVariableId(variable.name, Variable.SCALAR_TYPE), variable.name, Variable.SCALAR_TYPE, isCloud);\n      if (isCloud) runtime.addCloudVariable();\n      newVariable.value = variable.value;\n      target.variables[newVariable.id] = newVariable;\n    }\n  } // If included, parse any and all comments on the object (this includes top-level\n  // workspace comments as well as comments attached to specific blocks)\n  var blockComments = {};\n  if (object.hasOwnProperty('scriptComments')) {\n    var comments = object.scriptComments.map(function (commentDesc) {\n      var _commentDesc = _slicedToArray(commentDesc, 7),\n          commentX = _commentDesc[0],\n          commentY = _commentDesc[1],\n          commentWidth = _commentDesc[2],\n          commentHeight = _commentDesc[3],\n          commentFullSize = _commentDesc[4],\n          flattenedBlockIndex = _commentDesc[5],\n          commentText = _commentDesc[6];\n      var isBlockComment = commentDesc[5] >= 0;\n      var newComment = new Comment(null, // generate a new id for this comment\n      commentText, // text content of sb2 comment\n      // Only serialize x & y position of comment if it's a workspace comment\n      // If it's a block comment, we'll let scratch-blocks handle positioning\n      isBlockComment ? null : commentX * WORKSPACE_X_SCALE, isBlockComment ? null : commentY * WORKSPACE_Y_SCALE, commentWidth * WORKSPACE_X_SCALE, commentHeight * WORKSPACE_Y_SCALE, !commentFullSize);\n      if (isBlockComment) {\n        // commentDesc[5] refers to the index of the block that this\n        // comment is attached to --  in a flattened version of the\n        // scripts array.\n        // If commentDesc[5] is -1, this is a workspace comment (we don't need to do anything\n        // extra at this point), otherwise temporarily save the flattened script array\n        // index as the blockId property of the new comment. We will\n        // change this to refer to the actual block id of the corresponding\n        // block when that block gets created\n        newComment.blockId = flattenedBlockIndex; // Add this comment to the block comments object with its script index\n        // as the key\n        if (blockComments.hasOwnProperty(flattenedBlockIndex)) {\n          blockComments[flattenedBlockIndex].push(newComment);\n        } else {\n          blockComments[flattenedBlockIndex] = [newComment];\n        }\n      }\n      return newComment;\n    }); // Add all the comments that were just created to the target.comments,\n    // referenced by id\n    comments.forEach(function (comment) {\n      target.comments[comment.id] = comment;\n    });\n  } // If included, parse any and all scripts/blocks on the object.\n  if (object.hasOwnProperty('scripts')) {\n    parseScripts(object.scripts, blocks, addBroadcastMsg, getVariableId, extensions, blockComments);\n  } // If there are any comments referring to a numerical block ID, make them\n  // workspace comments. These are comments that were originally created as\n  // block comments, detached from the block, and then had the associated\n  // block deleted.\n  // These comments should be imported as workspace comments\n  // by making their blockIDs (which currently refer to non-existing blocks)\n  // null (See #1452).\n  for (var commentIndex in blockComments) {\n    var currBlockComments = blockComments[commentIndex];\n    currBlockComments.forEach(function (c) {\n      if (typeof c.blockId === 'number') {\n        c.blockId = null;\n      }\n    });\n  } // Update stage specific blocks (e.g. sprite clicked <=> stage clicked)\n  blocks.updateTargetSpecificBlocks(topLevel); // topLevel = isStage\n  if (object.hasOwnProperty('lists')) {\n    for (var k = 0; k < object.lists.length; k++) {\n      var list = object.lists[k];\n      var _newVariable = new Variable(getVariableId(list.listName, Variable.LIST_TYPE), list.listName, Variable.LIST_TYPE, false);\n      _newVariable.value = list.contents;\n      target.variables[_newVariable.id] = _newVariable;\n    }\n  }\n  if (object.hasOwnProperty('scratchX')) {\n    target.x = object.scratchX;\n  }\n  if (object.hasOwnProperty('scratchY')) {\n    target.y = object.scratchY;\n  }\n  if (object.hasOwnProperty('direction')) {\n    target.direction = object.direction;\n  }\n  if (object.hasOwnProperty('isDraggable')) {\n    target.draggable = object.isDraggable;\n  }\n  if (object.hasOwnProperty('scale')) {\n    // SB2 stores as 1.0 = 100%; we use % in the VM.\n    target.size = object.scale * 100;\n  }\n  if (object.hasOwnProperty('visible')) {\n    target.visible = object.visible;\n  }\n  if (object.hasOwnProperty('currentCostumeIndex')) {\n    // Current costume index can sometimes be a floating\n    // point number, use Math.floor to come up with an appropriate index\n    // and clamp it to the actual number of costumes the object has for good measure.\n    target.currentCostume = MathUtil.clamp(Math.floor(object.currentCostumeIndex), 0, object.costumes.length - 1);\n  }\n  if (object.hasOwnProperty('rotationStyle')) {\n    if (object.rotationStyle === 'none') {\n      target.rotationStyle = RenderedTarget.ROTATION_STYLE_NONE;\n    } else if (object.rotationStyle === 'leftRight') {\n      target.rotationStyle = RenderedTarget.ROTATION_STYLE_LEFT_RIGHT;\n    } else if (object.rotationStyle === 'normal') {\n      target.rotationStyle = RenderedTarget.ROTATION_STYLE_ALL_AROUND;\n    }\n  }\n  if (object.hasOwnProperty('tempoBPM')) {\n    target.tempo = object.tempoBPM;\n  }\n  if (object.hasOwnProperty('videoAlpha')) {\n    // SB2 stores alpha as opacity, where 1.0 is opaque.\n    // We convert to a percentage, and invert it so 100% is full transparency.\n    target.videoTransparency = 100 - 100 * object.videoAlpha;\n  }\n  if (object.hasOwnProperty('info')) {\n    if (object.info.hasOwnProperty('videoOn')) {\n      if (object.info.videoOn) {\n        target.videoState = RenderedTarget.VIDEO_STATE.ON;\n      } else {\n        target.videoState = RenderedTarget.VIDEO_STATE.OFF;\n      }\n    }\n  }\n  if (object.hasOwnProperty('indexInLibrary')) {\n    // Temporarily store the 'indexInLibrary' property from the sb2 file\n    // so that we can correctly order sprites in the target pane.\n    // This will be deleted after we are done parsing and ordering the targets list.\n    target.targetPaneOrder = object.indexInLibrary;\n  }\n  target.isStage = topLevel;\n  Promise.all(costumePromises).then(function (costumes) {\n    sprite.costumes = costumes;\n  });\n  Promise.all(soundPromises).then(function (sounds) {\n    sprite.sounds = sounds; // Make sure if soundBank is undefined, sprite.soundBank is then null.\n    sprite.soundBank = soundBank || null;\n  }); // The stage will have child objects; recursively process them.\n  var childrenPromises = [];\n  if (object.children) {\n    for (var m = 0; m < object.children.length; m++) {\n      childrenPromises.push(parseScratchObject(object.children[m], runtime, extensions, false, zip, assets.children[m]));\n    }\n  }\n  return Promise.all(costumePromises.concat(soundPromises)).then(function () {\n    return Promise.all(childrenPromises).then(function (children) {\n      // Need create broadcast msgs as variables after\n      // all other targets have finished processing.\n      if (target.isStage) {\n        var allBroadcastMsgs = globalBroadcastMsgObj.globalBroadcastMsgs;\n        var allBroadcastMsgFields = globalBroadcastMsgObj.allBroadcastFields;\n        var oldEmptyMsgName = globalBroadcastMsgObj.emptyMsgName;\n        if (allBroadcastMsgs[oldEmptyMsgName]) {\n          // Find a fresh 'messageN'\n          var currIndex = 1;\n          while (allBroadcastMsgs[\"message\".concat(currIndex)]) {\n            currIndex += 1;\n          }\n          var newEmptyMsgName = \"message\".concat(currIndex); // Add the new empty message name to the broadcast message\n          // name map, and assign it the old id.\n          // Then, delete the old entry in map.\n          allBroadcastMsgs[newEmptyMsgName] = allBroadcastMsgs[oldEmptyMsgName];\n          delete allBroadcastMsgs[oldEmptyMsgName]; // Now update all the broadcast message fields with\n          // the new empty message name.\n          for (var i = 0; i < allBroadcastMsgFields.length; i++) {\n            if (allBroadcastMsgFields[i].value === '') {\n              allBroadcastMsgFields[i].value = newEmptyMsgName;\n            }\n          }\n        } // Traverse the broadcast message name map and create\n        // broadcast messages as variables on the stage (which is this\n        // target).\n        for (var msgName in allBroadcastMsgs) {\n          var msgId = allBroadcastMsgs[msgName];\n          var newMsg = new Variable(msgId, msgName, Variable.BROADCAST_MESSAGE_TYPE, false);\n          target.variables[newMsg.id] = newMsg;\n        }\n      }\n      var targets = [target];\n      var deferredMonitors = [];\n      for (var n = 0; n < children.length; n++) {\n        if (children[n]) {\n          if (children[n].deferredMonitor) {\n            deferredMonitors.push(children[n]);\n          } else {\n            targets = targets.concat(children[n]);\n          }\n        }\n      } // It is important that monitors are parsed last\n      // - after all sprite targets have finished parsing\n      // - and this is the last thing that happens in the stage parsing\n      // It is specifically important that all the scripts in the project\n      // have been parsed and all the relevant targets exist, have uids,\n      // and have their variables initialized.\n      for (var _n2 = 0; _n2 < deferredMonitors.length; _n2++) {\n        parseMonitorObject(deferredMonitors[_n2], runtime, targets, extensions);\n      }\n      return targets;\n    });\n  });\n};\nvar reorderParsedTargets = function reorderParsedTargets(targets) {\n  // Reorder parsed targets based on the temporary targetPaneOrder property\n  // and then delete it.\n  var reordered = targets.map(function (t, index) {\n    t.layerOrder = index;\n    return t;\n  }).sort(function (a, b) {\n    return a.targetPaneOrder - b.targetPaneOrder;\n  }); // Delete the temporary target pane ordering since we shouldn't need it anymore.\n  reordered.forEach(function (t) {\n    delete t.targetPaneOrder;\n  });\n  return reordered;\n};\n/**\n * Top-level handler. Parse provided JSON,\n * and process the top-level object (the stage object).\n * @param {!object} json SB2-format JSON to load.\n * @param {!Runtime} runtime Runtime object to load all structures into.\n * @param {boolean=} optForceSprite If set, treat as sprite (Sprite2).\n * @param {?object} zip Optional zipped assets for local file import\n * @return {Promise.<ImportedProject>} Promise that resolves to the loaded targets when ready.\n */\nvar sb2import = function sb2import(json, runtime, optForceSprite, zip) {\n  var extensions = {\n    extensionIDs: new Set(),\n    extensionURLs: new Map()\n  };\n  return Promise.resolve(parseScratchAssets(json, runtime, !optForceSprite, zip)) // Force this promise to wait for the next loop in the js tick. Let\n  // storage have some time to send off asset requests.\n  .then(function (assets) {\n    return Promise.resolve(assets);\n  }).then(function (assets) {\n    return parseScratchObject(json, runtime, extensions, !optForceSprite, zip, assets);\n  }).then(reorderParsedTargets).then(function (targets) {\n    return {\n      targets: targets,\n      extensions: extensions\n    };\n  });\n};\n/**\n * Given the sb2 block, inspect the specmap for a translation method or object.\n * @param {!object} block a sb2 formatted block\n * @return {object} specmap block to parse this opcode\n */\nvar specMapBlock = function specMapBlock(block) {\n  var opcode = block[0];\n  var mapped = opcode && specMap[opcode];\n  if (!mapped) {\n    log.warn(\"Couldn't find SB2 block: \".concat(opcode));\n    return null;\n  }\n  if (typeof mapped === 'function') {\n    return mapped(block);\n  }\n  return mapped;\n};\n/**\n * Parse a single SB2 JSON-formatted block and its children.\n * @param {!object} sb2block SB2 JSON-formatted block.\n * @param {Function} addBroadcastMsg function to update broadcast message name map\n * @param {Function} getVariableId function to retrieve a variable's ID based on name\n * @param {ImportedExtensionsInfo} extensions - (in/out) parsed extension information will be stored here.\n * @param {ParseState} parseState - info on the state of parsing beyond the current block.\n * @param {object<int, Comment>} comments - Comments from sb2 project that need to be attached to blocks.\n * They are indexed in this object by the sb2 flattened block list index indicating\n * which block they should attach to.\n * @param {int} commentIndex The comment index for the block to be parsed if it were in a flattened\n * list of all blocks for the target\n * @return {Array.<object|int>} Tuple where first item is the Scratch VM-format block (or null if unsupported object),\n * and second item is the updated comment index (after this block and its children are parsed)\n */\nvar parseBlock = function parseBlock(sb2block, addBroadcastMsg, getVariableId, extensions, parseState, comments, commentIndex) {\n  var commentsForParsedBlock = comments && typeof commentIndex === 'number' && !isNaN(commentIndex) ? comments[commentIndex] : null;\n  var blockMetadata = specMapBlock(sb2block);\n  if (!blockMetadata) {\n    // No block opcode found, exclude this block, increment the commentIndex,\n    // make all block comments into workspace comments and send them to zero/zero\n    // to prevent serialization issues.\n    if (commentsForParsedBlock) {\n      commentsForParsedBlock.forEach(function (comment) {\n        comment.blockId = null;\n        comment.x = comment.y = 0;\n      });\n    }\n    return [null, commentIndex + 1];\n  }\n  var oldOpcode = sb2block[0]; // If the block is from an extension, record it.\n  var index = blockMetadata.opcode.indexOf('_');\n  var prefix = blockMetadata.opcode.substring(0, index);\n  if (CORE_EXTENSIONS.indexOf(prefix) === -1) {\n    if (prefix !== '') extensions.extensionIDs.add(prefix);\n  } // Block skeleton.\n  var activeBlock = {\n    id: uid(),\n    // Generate a new block unique ID.\n    opcode: blockMetadata.opcode,\n    // Converted, e.g. \"motion_movesteps\".\n    inputs: {},\n    // Inputs to this block and the blocks they point to.\n    fields: {},\n    // Fields on this block and their values.\n    next: null,\n    // Next block.\n    shadow: false,\n    // No shadow blocks in an SB2 by default.\n    children: [] // Store any generated children, flattened in `flatten`.\n  }; // Attach any comments to this block..\n  if (commentsForParsedBlock) {\n    // Attach only the last comment to the block, make all others workspace comments\n    activeBlock.comment = commentsForParsedBlock[commentsForParsedBlock.length - 1].id;\n    commentsForParsedBlock.forEach(function (comment) {\n      if (comment.id === activeBlock.comment) {\n        comment.blockId = activeBlock.id;\n      } else {\n        // All other comments don't get a block ID and are sent back to zero.\n        // This is important, because if they have `null` x/y, serialization breaks.\n        comment.blockId = null;\n        comment.x = comment.y = 0;\n      }\n    });\n  }\n  commentIndex++;\n  var parentExpectedArg = parseState.expectedArg; // For a procedure call, generate argument map from proc string.\n  if (oldOpcode === 'call') {\n    blockMetadata.argMap = parseProcedureArgMap(sb2block[1]);\n  } // Look at the expected arguments in `blockMetadata.argMap.`\n  // The basic problem here is to turn positional SB2 arguments into\n  // non-positional named Scratch VM arguments.\n  for (var i = 0; i < blockMetadata.argMap.length; i++) {\n    var expectedArg = blockMetadata.argMap[i];\n    var providedArg = sb2block[i + 1]; // (i = 0 is opcode)\n    // Whether the input is obscuring a shadow.\n    var shadowObscured = false; // Positional argument is an input.\n    if (expectedArg.type === 'input') {\n      // Create a new block and input metadata.\n      var inputUid = uid();\n      activeBlock.inputs[expectedArg.inputName] = {\n        name: expectedArg.inputName,\n        block: null,\n        shadow: null\n      };\n      if (_typeof(providedArg) === 'object' && providedArg) {\n        // Block or block list occupies the input.\n        var innerBlocks = void 0;\n        parseState.expectedArg = expectedArg;\n        if (_typeof(providedArg[0]) === 'object' && providedArg[0]) {\n          // Block list occupies the input.\n          var _parseBlockList3 = parseBlockList(providedArg, addBroadcastMsg, getVariableId, extensions, parseState, comments, commentIndex);\n          var _parseBlockList4 = _slicedToArray(_parseBlockList3, 2);\n          innerBlocks = _parseBlockList4[0];\n          commentIndex = _parseBlockList4[1];\n        } else {\n          // Single block occupies the input.\n          var parsedBlockDesc = parseBlock(providedArg, addBroadcastMsg, getVariableId, extensions, parseState, comments, commentIndex);\n          innerBlocks = parsedBlockDesc[0] ? [parsedBlockDesc[0]] : []; // Update commentIndex\n          commentIndex = parsedBlockDesc[1];\n        }\n        parseState.expectedArg = parentExpectedArg; // Check if innerBlocks is not an empty list.\n        // An empty list indicates that all the inner blocks from the sb2 have\n        // unknown opcodes and have been skipped.\n        if (innerBlocks.length > 0) {\n          var previousBlock = null;\n          for (var j = 0; j < innerBlocks.length; j++) {\n            if (j === 0) {\n              innerBlocks[j].parent = activeBlock.id;\n            } else {\n              innerBlocks[j].parent = previousBlock;\n            }\n            previousBlock = innerBlocks[j].id;\n          }\n          activeBlock.inputs[expectedArg.inputName].block = innerBlocks[0].id;\n          activeBlock.children = activeBlock.children.concat(innerBlocks);\n        } // Obscures any shadow.\n        shadowObscured = true;\n      } // Generate a shadow block to occupy the input.\n      if (!expectedArg.inputOp) {\n        // Undefined inputOp. inputOp should always be defined for inputs.\n        log.warn(\"Unknown input operation for input \".concat(expectedArg.inputName, \" of opcode \").concat(activeBlock.opcode, \".\"));\n        continue;\n      }\n      if (expectedArg.inputOp === 'boolean' || expectedArg.inputOp === 'substack') {\n        // No editable shadow input; e.g., for a boolean.\n        continue;\n      } // Each shadow has a field generated for it automatically.\n      // Value to be filled in the field.\n      var fieldValue = providedArg; // Shadows' field names match the input name, except for these:\n      var fieldName = expectedArg.inputName;\n      if (expectedArg.inputOp === 'math_number' || expectedArg.inputOp === 'math_whole_number' || expectedArg.inputOp === 'math_positive_number' || expectedArg.inputOp === 'math_integer' || expectedArg.inputOp === 'math_angle') {\n        fieldName = 'NUM'; // Fields are given Scratch 2.0 default values if obscured.\n        if (shadowObscured) {\n          fieldValue = 10;\n        }\n      } else if (expectedArg.inputOp === 'text') {\n        fieldName = 'TEXT';\n        if (shadowObscured) {\n          fieldValue = '';\n        }\n      } else if (expectedArg.inputOp === 'colour_picker') {\n        // Convert SB2 color to hex.\n        fieldValue = Color.decimalToHex(providedArg);\n        fieldName = 'COLOUR';\n        if (shadowObscured) {\n          fieldValue = '#990000';\n        }\n      } else if (expectedArg.inputOp === 'event_broadcast_menu') {\n        fieldName = 'BROADCAST_OPTION';\n        if (shadowObscured) {\n          fieldValue = '';\n        }\n      } else if (expectedArg.inputOp === 'sensing_of_object_menu') {\n        if (shadowObscured) {\n          fieldValue = '_stage_';\n        } else if (fieldValue === 'Stage') {\n          fieldValue = '_stage_';\n        }\n      } else if (expectedArg.inputOp === 'note') {\n        if (shadowObscured) {\n          fieldValue = 60;\n        }\n      } else if (expectedArg.inputOp === 'music.menu.DRUM') {\n        if (shadowObscured) {\n          fieldValue = 1;\n        }\n      } else if (expectedArg.inputOp === 'music.menu.INSTRUMENT') {\n        if (shadowObscured) {\n          fieldValue = 1;\n        }\n      } else if (expectedArg.inputOp === 'videoSensing.menu.ATTRIBUTE') {\n        if (shadowObscured) {\n          fieldValue = 'motion';\n        }\n      } else if (expectedArg.inputOp === 'videoSensing.menu.SUBJECT') {\n        if (shadowObscured) {\n          fieldValue = 'this sprite';\n        }\n      } else if (expectedArg.inputOp === 'videoSensing.menu.VIDEO_STATE') {\n        if (shadowObscured) {\n          fieldValue = 'on';\n        }\n      } else if (shadowObscured) {\n        // Filled drop-down menu.\n        fieldValue = '';\n      }\n      var fields = {};\n      fields[fieldName] = {\n        name: fieldName,\n        value: fieldValue\n      }; // event_broadcast_menus have some extra properties to add to the\n      // field and a different value than the rest\n      if (expectedArg.inputOp === 'event_broadcast_menu') {\n        // Need to update the broadcast message name map with\n        // the value of this field.\n        // Also need to provide the fields[fieldName] object,\n        // so that we can later update its value property, e.g.\n        // if sb2 message name is empty string, we will later\n        // replace this field's value with messageN\n        // once we can traverse through all the existing message names\n        // and come up with a fresh messageN.\n        var broadcastId = addBroadcastMsg(fieldValue, fields[fieldName]);\n        fields[fieldName].id = broadcastId;\n        fields[fieldName].variableType = expectedArg.variableType;\n      }\n      activeBlock.children.push({\n        id: inputUid,\n        opcode: expectedArg.inputOp,\n        inputs: {},\n        fields: fields,\n        next: null,\n        topLevel: false,\n        parent: activeBlock.id,\n        shadow: true\n      });\n      activeBlock.inputs[expectedArg.inputName].shadow = inputUid; // If no block occupying the input, alias to the shadow.\n      if (!activeBlock.inputs[expectedArg.inputName].block) {\n        activeBlock.inputs[expectedArg.inputName].block = inputUid;\n      }\n    } else if (expectedArg.type === 'field') {\n      // Add as a field on this block.\n      activeBlock.fields[expectedArg.fieldName] = {\n        name: expectedArg.fieldName,\n        value: providedArg\n      };\n      if (expectedArg.fieldName === 'CURRENTMENU') {\n        // In 3.0, the field value of the `sensing_current` block\n        // is in all caps.\n        activeBlock.fields[expectedArg.fieldName].value = providedArg.toUpperCase();\n        if (providedArg === 'day of week') {\n          activeBlock.fields[expectedArg.fieldName].value = 'DAYOFWEEK';\n        }\n      }\n      if (expectedArg.fieldName === 'VARIABLE') {\n        // Add `id` property to variable fields\n        activeBlock.fields[expectedArg.fieldName].id = getVariableId(providedArg, Variable.SCALAR_TYPE);\n      } else if (expectedArg.fieldName === 'LIST') {\n        // Add `id` property to variable fields\n        activeBlock.fields[expectedArg.fieldName].id = getVariableId(providedArg, Variable.LIST_TYPE);\n      } else if (expectedArg.fieldName === 'BROADCAST_OPTION') {\n        // Add the name in this field to the broadcast msg name map.\n        // Also need to provide the fields[fieldName] object,\n        // so that we can later update its value property, e.g.\n        // if sb2 message name is empty string, we will later\n        // replace this field's value with messageN\n        // once we can traverse through all the existing message names\n        // and come up with a fresh messageN.\n        var _broadcastId = addBroadcastMsg(providedArg, activeBlock.fields[expectedArg.fieldName]);\n        activeBlock.fields[expectedArg.fieldName].id = _broadcastId;\n      }\n      var varType = expectedArg.variableType;\n      if (typeof varType === 'string') {\n        activeBlock.fields[expectedArg.fieldName].variableType = varType;\n      }\n    }\n  } // Updates for blocks that have new menus (e.g. in Looks)\n  switch (oldOpcode) {\n    case 'comeToFront':\n      activeBlock.fields.FRONT_BACK = {\n        name: 'FRONT_BACK',\n        value: 'front'\n      };\n      break;\n    case 'goBackByLayers:':\n      activeBlock.fields.FORWARD_BACKWARD = {\n        name: 'FORWARD_BACKWARD',\n        value: 'backward'\n      };\n      break;\n    case 'backgroundIndex':\n      activeBlock.fields.NUMBER_NAME = {\n        name: 'NUMBER_NAME',\n        value: 'number'\n      };\n      break;\n    case 'sceneName':\n      activeBlock.fields.NUMBER_NAME = {\n        name: 'NUMBER_NAME',\n        value: 'name'\n      };\n      break;\n    case 'costumeIndex':\n      activeBlock.fields.NUMBER_NAME = {\n        name: 'NUMBER_NAME',\n        value: 'number'\n      };\n      break;\n    case 'costumeName':\n      activeBlock.fields.NUMBER_NAME = {\n        name: 'NUMBER_NAME',\n        value: 'name'\n      };\n      break;\n  } // Special cases to generate mutations.\n  if (oldOpcode === 'stopScripts') {\n    // Mutation for stop block: if the argument is 'other scripts',\n    // the block needs a next connection.\n    if (sb2block[1] === 'other scripts in sprite' || sb2block[1] === 'other scripts in stage') {\n      activeBlock.mutation = {\n        tagName: 'mutation',\n        hasnext: 'true',\n        children: []\n      };\n    }\n  } else if (oldOpcode === 'procDef') {\n    // Mutation for procedure definition:\n    // store all 2.0 proc data.\n    var procData = sb2block.slice(1); // Create a new block and input metadata.\n    var _inputUid = uid();\n    var inputName = 'custom_block';\n    activeBlock.inputs[inputName] = {\n      name: inputName,\n      block: _inputUid,\n      shadow: _inputUid\n    };\n    activeBlock.children = [{\n      id: _inputUid,\n      opcode: 'procedures_prototype',\n      inputs: {},\n      fields: {},\n      next: null,\n      shadow: true,\n      children: [],\n      mutation: {\n        tagName: 'mutation',\n        proccode: procData[0],\n        // e.g., \"abc %n %b %s\"\n        argumentnames: JSON.stringify(procData[1]),\n        // e.g. ['arg1', 'arg2']\n        argumentids: JSON.stringify(parseProcedureArgIds(procData[0])),\n        argumentdefaults: JSON.stringify(procData[2]),\n        // e.g., [1, 'abc']\n        warp: procData[3],\n        // Warp mode, e.g., true/false.\n        children: []\n      }\n    }];\n  } else if (oldOpcode === 'call') {\n    // Mutation for procedure call:\n    // string for proc code (e.g., \"abc %n %b %s\").\n    activeBlock.mutation = {\n      tagName: 'mutation',\n      children: [],\n      proccode: sb2block[1],\n      argumentids: JSON.stringify(parseProcedureArgIds(sb2block[1]))\n    };\n  } else if (oldOpcode === 'getParam') {\n    var returnCode = sb2block[2]; // Ensure the returnCode is \"b\" if used in a boolean input.\n    if (parentExpectedArg && parentExpectedArg.inputOp === 'boolean' && returnCode !== 'b') {\n      returnCode = 'b';\n    } // Assign correct opcode based on the block shape.\n    switch (returnCode) {\n      case 'r':\n        activeBlock.opcode = 'argument_reporter_string_number';\n        break;\n      case 'b':\n        activeBlock.opcode = 'argument_reporter_boolean';\n        break;\n    }\n  }\n  return [activeBlock, commentIndex];\n};\nmodule.exports = {\n  deserialize: sb2import\n};\n })