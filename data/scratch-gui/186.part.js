/* 186 */\n (function(module, exports, __webpack_require__) {\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n/**\n * @fileoverview\n * An SB3 serializer and deserializer. Parses provided\n * JSON and then generates all needed scratch-vm runtime structures.\n */\nvar vmPackage = __webpack_require__(1186);\nvar Blocks = __webpack_require__(135);\nvar Sprite = __webpack_require__(479);\nvar Variable = __webpack_require__(114);\nvar Comment = __webpack_require__(297);\nvar MonitorRecord = __webpack_require__(295);\nvar StageLayering = __webpack_require__(115);\nvar log = __webpack_require__(39);\nvar uid = __webpack_require__(94);\nvar MathUtil = __webpack_require__(62);\nvar StringUtil = __webpack_require__(102);\nvar VariableUtil = __webpack_require__(442);\nvar _require = __webpack_require__(225),\n    loadCostume = _require.loadCostume;\nvar _require2 = __webpack_require__(226),\n    loadSound = _require2.loadSound;\nvar _require3 = __webpack_require__(480),\n    deserializeCostume = _require3.deserializeCostume,\n    deserializeSound = _require3.deserializeSound;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\n * @typedef {object} ImportedProject\n * @property {Array.<Target>} targets - the imported Scratch 3.0 target objects.\n * @property {ImportedExtensionsInfo} extensionsInfo - the ID of each extension actually used by this project.\n */\n/**\n * @typedef {object} ImportedExtensionsInfo\n * @property {Set.<string>} extensionIDs - the ID of each extension actually in use by blocks in this project.\n * @property {Map.<string, string>} extensionURLs - map of ID => URL from project metadata. May not match extensionIDs.\n */\n// Constants used during serialization and deserialization\nvar INPUT_SAME_BLOCK_SHADOW = 1; // unobscured shadow\nvar INPUT_BLOCK_NO_SHADOW = 2; // no shadow\nvar INPUT_DIFF_BLOCK_SHADOW = 3; // obscured shadow\n// There shouldn't be a case where block is null, but shadow is present...\n// Constants used during deserialization of an SB3 file\nvar CORE_EXTENSIONS = ['argument', 'colour', 'control', 'data', 'event', 'looks', 'math', 'motion', 'operator', 'procedures', 'sensing', 'sound']; // Constants referring to 'primitive' blocks that are usually shadows,\n// or in the case of variables and lists, appear quite often in projects\n// math_number\nvar MATH_NUM_PRIMITIVE = 4; // there's no reason these constants can't collide\n// math_positive_number\nvar POSITIVE_NUM_PRIMITIVE = 5; // with the above, but removing duplication for clarity\n// math_whole_number\nvar WHOLE_NUM_PRIMITIVE = 6; // math_integer\nvar INTEGER_NUM_PRIMITIVE = 7; // math_angle\nvar ANGLE_NUM_PRIMITIVE = 8; // colour_picker\nvar COLOR_PICKER_PRIMITIVE = 9; // text\nvar TEXT_PRIMITIVE = 10; // event_broadcast_menu\nvar BROADCAST_PRIMITIVE = 11; // data_variable\nvar VAR_PRIMITIVE = 12; // data_listcontents\nvar LIST_PRIMITIVE = 13; // Map block opcodes to the above primitives and the name of the field we can use\n// to find the value of the field\nvar primitiveOpcodeInfoMap = {\n  math_number: [MATH_NUM_PRIMITIVE, 'NUM'],\n  math_positive_number: [POSITIVE_NUM_PRIMITIVE, 'NUM'],\n  math_whole_number: [WHOLE_NUM_PRIMITIVE, 'NUM'],\n  math_integer: [INTEGER_NUM_PRIMITIVE, 'NUM'],\n  math_angle: [ANGLE_NUM_PRIMITIVE, 'NUM'],\n  colour_picker: [COLOR_PICKER_PRIMITIVE, 'COLOUR'],\n  text: [TEXT_PRIMITIVE, 'TEXT'],\n  event_broadcast_menu: [BROADCAST_PRIMITIVE, 'BROADCAST_OPTION'],\n  data_variable: [VAR_PRIMITIVE, 'VARIABLE'],\n  data_listcontents: [LIST_PRIMITIVE, 'LIST']\n};\n/**\n * Serializes primitives described above into a more compact format\n * @param {object} block the block to serialize\n * @return {array} An array representing the information in the block,\n * or null if the given block is not one of the primitives described above.\n */\nvar serializePrimitiveBlock = function serializePrimitiveBlock(block) {\n  // Returns an array represeting a primitive block or null if not one of\n  // the primitive types above\n  if (hasOwnProperty.call(primitiveOpcodeInfoMap, block.opcode)) {\n    var primitiveInfo = primitiveOpcodeInfoMap[block.opcode];\n    var primitiveConstant = primitiveInfo[0];\n    var fieldName = primitiveInfo[1];\n    var field = block.fields[fieldName];\n    var primitiveDesc = [primitiveConstant, field.value];\n    if (block.opcode === 'event_broadcast_menu') {\n      primitiveDesc.push(field.id);\n    } else if (block.opcode === 'data_variable' || block.opcode === 'data_listcontents') {\n      primitiveDesc.push(field.id);\n      if (block.topLevel) {\n        primitiveDesc.push(block.x ? Math.round(block.x) : 0);\n        primitiveDesc.push(block.y ? Math.round(block.y) : 0);\n      }\n    }\n    return primitiveDesc;\n  }\n  return null;\n};\n/**\n * Serializes the inputs field of a block in a compact form using\n * constants described above to represent the relationship between the\n * inputs of this block (e.g. if there is an unobscured shadow, an obscured shadow\n * -- a block plugged into a droppable input -- or, if there is just a block).\n * Based on this relationship, serializes the ids of the block and shadow (if present)\n *\n * @param {object} inputs The inputs to serialize\n * @return {object} An object representing the serialized inputs\n */\nvar serializeInputs = function serializeInputs(inputs) {\n  var obj = Object.create(null);\n  for (var inputName in inputs) {\n    if (!hasOwnProperty.call(inputs, inputName)) continue; // if block and shadow refer to the same block, only serialize one\n    if (inputs[inputName].block === inputs[inputName].shadow) {\n      // has block and shadow, and they are the same\n      obj[inputName] = [INPUT_SAME_BLOCK_SHADOW, inputs[inputName].block];\n    } else if (inputs[inputName].shadow === null) {\n      // does not have shadow\n      obj[inputName] = [INPUT_BLOCK_NO_SHADOW, inputs[inputName].block];\n    } else {\n      // block and shadow are both present and are different\n      obj[inputName] = [INPUT_DIFF_BLOCK_SHADOW, inputs[inputName].block, inputs[inputName].shadow];\n    }\n  }\n  return obj;\n};\n/**\n * Serialize the fields of a block in a more compact form.\n * @param {object} fields The fields object to serialize\n * @return {object} An object representing the serialized fields\n */\nvar serializeFields = function serializeFields(fields) {\n  var obj = Object.create(null);\n  for (var fieldName in fields) {\n    if (!hasOwnProperty.call(fields, fieldName)) continue;\n    obj[fieldName] = [fields[fieldName].value];\n    if (fields[fieldName].hasOwnProperty('id')) {\n      obj[fieldName].push(fields[fieldName].id);\n    }\n  }\n  return obj;\n};\n/**\n * Serialize the given block in the SB3 format with some compression of inputs,\n * fields, and primitives.\n * @param {object} block The block to serialize\n * @return {object | array} A serialized representation of the block. This is an\n * array if the block is one of the primitive types described above or an object,\n * if not.\n */\nvar serializeBlock = function serializeBlock(block) {\n  var serializedPrimitive = serializePrimitiveBlock(block);\n  if (serializedPrimitive) return serializedPrimitive; // If serializedPrimitive is null, proceed with serializing a non-primitive block\n  var obj = Object.create(null);\n  obj.opcode = block.opcode; // NOTE: this is extremely important to serialize even if null;\n  // not serializing `next: null` results in strange behavior with block\n  // execution\n  obj.next = block.next;\n  obj.parent = block.parent;\n  obj.inputs = serializeInputs(block.inputs);\n  obj.fields = serializeFields(block.fields);\n  obj.shadow = block.shadow;\n  if (block.topLevel) {\n    obj.topLevel = true;\n    obj.x = block.x ? Math.round(block.x) : 0;\n    obj.y = block.y ? Math.round(block.y) : 0;\n  } else {\n    obj.topLevel = false;\n  }\n  if (block.mutation) {\n    obj.mutation = block.mutation;\n  }\n  if (block.comment) {\n    obj.comment = block.comment;\n  }\n  return obj;\n};\n/**\n * Compresses the serialized inputs replacing block/shadow ids that refer to\n * one of the primitives with the primitive itself. E.g.\n *\n * blocks: {\n *      aUidForMyBlock: {\n *          inputs: {\n *               MYINPUT: [1, 'aUidForAnUnobscuredShadowPrimitive']\n *          }\n *      },\n *      aUidForAnUnobscuredShadowPrimitive: [4, 10]\n *      // the above is a primitive representing a 'math_number' with value 10\n * }\n *\n * becomes:\n *\n * blocks: {\n *      aUidForMyBlock: {\n *          inputs: {\n *               MYINPUT: [1, [4, 10]]\n *          }\n *      }\n * }\n * Note: this function modifies the given blocks object in place\n * @param {object} block The block with inputs to compress\n * @param {objec} blocks The object containing all the blocks currently getting serialized\n * @return {object} The serialized block with compressed inputs\n */\nvar compressInputTree = function compressInputTree(block, blocks) {\n  // This is the second pass on the block\n  // so the inputs field should be an object of key - array pairs\n  var serializedInputs = block.inputs;\n  for (var inputName in serializedInputs) {\n    // don't need to check for hasOwnProperty because of how we constructed\n    // inputs\n    var currInput = serializedInputs[inputName]; // traverse currInput skipping the first element, which describes whether the block\n    // and shadow are the same\n    for (var i = 1; i < currInput.length; i++) {\n      if (!currInput[i]) continue; // need this check b/c block/shadow can be null\n      var blockOrShadowID = currInput[i]; // replace element of currInput directly\n      // (modifying input block directly)\n      var blockOrShadow = blocks[blockOrShadowID];\n      if (Array.isArray(blockOrShadow)) {\n        currInput[i] = blockOrShadow; // Modifying blocks in place!\n        delete blocks[blockOrShadowID];\n      }\n    }\n  }\n  return block;\n};\n/**\n * Get sanitized non-core extension ID for a given sb3 opcode.\n * Note that this should never return a URL. If in the future the SB3 loader supports loading extensions by URL, this\n * ID should be used to (for example) look up the extension's full URL from a table in the SB3's JSON.\n * @param {!string} opcode The opcode to examine for extension.\n * @return {?string} The extension ID, if it exists and is not a core extension.\n */\nvar getExtensionIdForOpcode = function getExtensionIdForOpcode(opcode) {\n  // Allowed ID characters are those matching the regular expression [\\w-]: A-Z, a-z, 0-9, and hyphen (\"-\").\n  var index = opcode.indexOf('_');\n  var forbiddenSymbols = /[^\\w-]/g;\n  var prefix = opcode.substring(0, index).replace(forbiddenSymbols, '-');\n  if (CORE_EXTENSIONS.indexOf(prefix) === -1) {\n    if (prefix !== '') return prefix;\n  }\n};\n/**\n * Serialize the given blocks object (representing all the blocks for the target\n * currently being serialized.)\n * @param {object} blocks The blocks to be serialized\n * @return {Array} An array of the serialized blocks with compressed inputs and\n * compressed primitives and the list of all extension IDs present\n * in the serialized blocks.\n */\nvar serializeBlocks = function serializeBlocks(blocks) {\n  var obj = Object.create(null);\n  var extensionIDs = new Set();\n  for (var blockID in blocks) {\n    if (!blocks.hasOwnProperty(blockID)) continue;\n    obj[blockID] = serializeBlock(blocks[blockID], blocks);\n    var extensionID = getExtensionIdForOpcode(blocks[blockID].opcode);\n    if (extensionID) {\n      extensionIDs.add(extensionID);\n    }\n  } // once we have completed a first pass, do a second pass on block inputs\n  for (var _blockID in obj) {\n    // don't need to do the hasOwnProperty check here since we\n    // created an object that doesn't get extra properties/functions\n    var serializedBlock = obj[_blockID]; // caution, this function deletes parts of this object in place as\n    // it's traversing it\n    obj[_blockID] = compressInputTree(serializedBlock, obj); // second pass on connecting primitives to serialized inputs directly\n  } // Do one last pass and remove any top level shadows (these are caused by\n  // a bug: LLK/scratch-vm#1011, and this pass should be removed once that is\n  // completely fixed)\n  for (var _blockID2 in obj) {\n    var _serializedBlock = obj[_blockID2]; // If the current block is serialized as a primitive (e.g. it's an array\n    // instead of an object), AND it is not one of the top level primitives\n    // e.g. variable getter or list getter, then it should be deleted as it's\n    // a shadow block, and there are no blocks that reference it, otherwise\n    // they would have been compressed in the last pass)\n    if (Array.isArray(_serializedBlock) && [VAR_PRIMITIVE, LIST_PRIMITIVE].indexOf(_serializedBlock[0]) < 0) {\n      log.warn(\"Found an unexpected top level primitive with block ID: \".concat(_blockID2, \"; deleting it from serialized blocks.\"));\n      delete obj[_blockID2];\n    }\n  }\n  return [obj, Array.from(extensionIDs)];\n};\n/**\n * Serialize the given costume.\n * @param {object} costume The costume to be serialized.\n * @return {object} A serialized representation of the costume.\n */\nvar serializeCostume = function serializeCostume(costume) {\n  var obj = Object.create(null);\n  obj.assetId = costume.assetId;\n  obj.name = costume.name;\n  obj.bitmapResolution = costume.bitmapResolution; // serialize this property with the name 'md5ext' because that's\n  // what it's actually referring to. TODO runtime objects need to be\n  // updated to actually refer to this as 'md5ext' instead of 'md5'\n  // but that change should be made carefully since it is very\n  // pervasive\n  obj.md5ext = costume.md5;\n  obj.dataFormat = costume.dataFormat.toLowerCase();\n  obj.rotationCenterX = costume.rotationCenterX;\n  obj.rotationCenterY = costume.rotationCenterY;\n  return obj;\n};\n/**\n * Serialize the given sound.\n * @param {object} sound The sound to be serialized.\n * @return {object} A serialized representation of the sound.\n */\nvar serializeSound = function serializeSound(sound) {\n  var obj = Object.create(null);\n  obj.assetId = sound.assetId;\n  obj.name = sound.name;\n  obj.dataFormat = sound.dataFormat.toLowerCase();\n  obj.format = sound.format;\n  obj.rate = sound.rate;\n  obj.sampleCount = sound.sampleCount; // serialize this property with the name 'md5ext' because that's\n  // what it's actually referring to. TODO runtime objects need to be\n  // updated to actually refer to this as 'md5ext' instead of 'md5'\n  // but that change should be made carefully since it is very\n  // pervasive\n  obj.md5ext = sound.md5;\n  return obj;\n};\n/**\n * Serialize the given variables object.\n * @param {object} variables The variables to be serialized.\n * @return {object} A serialized representation of the variables. They get\n * separated by type to compress the representation of each given variable and\n * reduce duplicate information.\n */\nvar serializeVariables = function serializeVariables(variables) {\n  var obj = Object.create(null); // separate out variables into types at the top level so we don't have\n  // keep track of a type for each\n  obj.variables = Object.create(null);\n  obj.lists = Object.create(null);\n  obj.broadcasts = Object.create(null);\n  for (var varId in variables) {\n    var v = variables[varId];\n    if (v.type === Variable.BROADCAST_MESSAGE_TYPE) {\n      obj.broadcasts[varId] = v.value; // name and value is the same for broadcast msgs\n      continue;\n    }\n    if (v.type === Variable.LIST_TYPE) {\n      obj.lists[varId] = [v.name, v.value];\n      continue;\n    } // otherwise should be a scalar type\n    obj.variables[varId] = [v.name, v.value]; // only scalar vars have the potential to be cloud vars\n    if (v.isCloud) obj.variables[varId].push(true);\n  }\n  return obj;\n};\nvar serializeComments = function serializeComments(comments) {\n  var obj = Object.create(null);\n  for (var commentId in comments) {\n    if (!comments.hasOwnProperty(commentId)) continue;\n    var comment = comments[commentId];\n    var serializedComment = Object.create(null);\n    serializedComment.blockId = comment.blockId;\n    serializedComment.x = comment.x;\n    serializedComment.y = comment.y;\n    serializedComment.width = comment.width;\n    serializedComment.height = comment.height;\n    serializedComment.minimized = comment.minimized;\n    serializedComment.text = comment.text;\n    obj[commentId] = serializedComment;\n  }\n  return obj;\n};\n/**\n * Serialize the given target. Only serialize properties that are necessary\n * for saving and loading this target.\n * @param {object} target The target to be serialized.\n * @param {Set} extensions A set of extensions to add extension IDs to\n * @return {object} A serialized representation of the given target.\n */\nvar serializeTarget = function serializeTarget(target, extensions) {\n  var obj = Object.create(null);\n  var targetExtensions = [];\n  obj.isStage = target.isStage;\n  obj.name = obj.isStage ? 'Stage' : target.name;\n  var vars = serializeVariables(target.variables);\n  obj.variables = vars.variables;\n  obj.lists = vars.lists;\n  obj.broadcasts = vars.broadcasts;\n  var _serializeBlocks = serializeBlocks(target.blocks);\n  var _serializeBlocks2 = _slicedToArray(_serializeBlocks, 2);\n  obj.blocks = _serializeBlocks2[0];\n  targetExtensions = _serializeBlocks2[1];\n  obj.comments = serializeComments(target.comments); // TODO remove this check/patch when (#1901) is fixed\n  if (target.currentCostume < 0 || target.currentCostume >= target.costumes.length) {\n    log.warn(\"currentCostume property for target \".concat(target.name, \" is out of range\"));\n    target.currentCostume = MathUtil.clamp(target.currentCostume, 0, target.costumes.length - 1);\n  }\n  obj.currentCostume = target.currentCostume;\n  obj.costumes = target.costumes.map(serializeCostume);\n  obj.sounds = target.sounds.map(serializeSound);\n  if (target.hasOwnProperty('volume')) obj.volume = target.volume;\n  if (target.hasOwnProperty('layerOrder')) obj.layerOrder = target.layerOrder;\n  if (obj.isStage) {\n    // Only the stage should have these properties\n    if (target.hasOwnProperty('tempo')) obj.tempo = target.tempo;\n    if (target.hasOwnProperty('videoTransparency')) obj.videoTransparency = target.videoTransparency;\n    if (target.hasOwnProperty('videoState')) obj.videoState = target.videoState;\n    if (target.hasOwnProperty('textToSpeechLanguage')) obj.textToSpeechLanguage = target.textToSpeechLanguage;\n  } else {\n    // The stage does not need the following properties, but sprites should\n    obj.visible = target.visible;\n    obj.x = target.x;\n    obj.y = target.y;\n    obj.size = target.size;\n    obj.direction = target.direction;\n    obj.draggable = target.draggable;\n    obj.rotationStyle = target.rotationStyle;\n  } // Add found extensions to the extensions object\n  targetExtensions.forEach(function (extensionId) {\n    extensions.add(extensionId);\n  });\n  return obj;\n};\nvar getSimplifiedLayerOrdering = function getSimplifiedLayerOrdering(targets) {\n  var layerOrders = targets.map(function (t) {\n    return t.getLayerOrder();\n  });\n  return MathUtil.reducedSortOrdering(layerOrders);\n};\nvar serializeMonitors = function serializeMonitors(monitors) {\n  return monitors.valueSeq().map(function (monitorData) {\n    var serializedMonitor = {\n      id: monitorData.id,\n      mode: monitorData.mode,\n      opcode: monitorData.opcode,\n      params: monitorData.params,\n      spriteName: monitorData.spriteName,\n      value: monitorData.value,\n      width: monitorData.width,\n      height: monitorData.height,\n      x: monitorData.x,\n      y: monitorData.y,\n      visible: monitorData.visible\n    };\n    if (monitorData.mode !== 'list') {\n      serializedMonitor.sliderMin = monitorData.sliderMin;\n      serializedMonitor.sliderMax = monitorData.sliderMax;\n      serializedMonitor.isDiscrete = monitorData.isDiscrete;\n    }\n    return serializedMonitor;\n  });\n};\n/**\n * Serializes the specified VM runtime.\n * @param {!Runtime} runtime VM runtime instance to be serialized.\n * @param {string=} targetId Optional target id if serializing only a single target\n * @return {object} Serialized runtime instance.\n */\nvar serialize = function serialize(runtime, targetId) {\n  // Fetch targets\n  var obj = Object.create(null); // Create extension set to hold extension ids found while serializing targets\n  var extensions = new Set();\n  var originalTargetsToSerialize = targetId ? [runtime.getTargetById(targetId)] : runtime.targets.filter(function (target) {\n    return target.isOriginal;\n  });\n  var layerOrdering = getSimplifiedLayerOrdering(originalTargetsToSerialize);\n  var flattenedOriginalTargets = originalTargetsToSerialize.map(function (t) {\n    return t.toJSON();\n  }); // If the renderer is attached, and we're serializing a whole project (not a sprite)\n  // add a temporary layerOrder property to each target.\n  if (runtime.renderer && !targetId) {\n    flattenedOriginalTargets.forEach(function (t, index) {\n      t.layerOrder = layerOrdering[index];\n    });\n  }\n  var serializedTargets = flattenedOriginalTargets.map(function (t) {\n    return serializeTarget(t, extensions);\n  });\n  if (targetId) {\n    return serializedTargets[0];\n  }\n  obj.targets = serializedTargets;\n  obj.monitors = serializeMonitors(runtime.getMonitorState()); // Assemble extension list\n  obj.extensions = Array.from(extensions); // Assemble metadata\n  var meta = Object.create(null);\n  meta.semver = '3.0.0';\n  meta.vm = vmPackage.version; // Attach full user agent string to metadata if available\n  meta.agent = 'none';\n  if (typeof navigator !== 'undefined') meta.agent = navigator.userAgent; // Assemble payload and return\n  obj.meta = meta;\n  return obj;\n};\n/**\n * Deserialize a block input descriptors. This is either a\n * block id or a serialized primitive, e.g. an array\n * (see serializePrimitiveBlock function).\n * @param {string | array} inputDescOrId The block input descriptor to be serialized.\n * @param {string} parentId The id of the parent block for this input block.\n * @param {boolean} isShadow Whether or not this input block is a shadow.\n * @param {object} blocks The entire blocks object currently in the process of getting serialized.\n * @return {object} The deserialized input descriptor.\n */\nvar deserializeInputDesc = function deserializeInputDesc(inputDescOrId, parentId, isShadow, blocks) {\n  if (!Array.isArray(inputDescOrId)) return inputDescOrId;\n  var primitiveObj = Object.create(null);\n  var newId = uid();\n  primitiveObj.id = newId;\n  primitiveObj.next = null;\n  primitiveObj.parent = parentId;\n  primitiveObj.shadow = isShadow;\n  primitiveObj.inputs = Object.create(null); // need a reference to parent id\n  switch (inputDescOrId[0]) {\n    case MATH_NUM_PRIMITIVE:\n      {\n        primitiveObj.opcode = 'math_number';\n        primitiveObj.fields = {\n          NUM: {\n            name: 'NUM',\n            value: inputDescOrId[1]\n          }\n        };\n        primitiveObj.topLevel = false;\n        break;\n      }\n    case POSITIVE_NUM_PRIMITIVE:\n      {\n        primitiveObj.opcode = 'math_positive_number';\n        primitiveObj.fields = {\n          NUM: {\n            name: 'NUM',\n            value: inputDescOrId[1]\n          }\n        };\n        primitiveObj.topLevel = false;\n        break;\n      }\n    case WHOLE_NUM_PRIMITIVE:\n      {\n        primitiveObj.opcode = 'math_whole_number';\n        primitiveObj.fields = {\n          NUM: {\n            name: 'NUM',\n            value: inputDescOrId[1]\n          }\n        };\n        primitiveObj.topLevel = false;\n        break;\n      }\n    case INTEGER_NUM_PRIMITIVE:\n      {\n        primitiveObj.opcode = 'math_integer';\n        primitiveObj.fields = {\n          NUM: {\n            name: 'NUM',\n            value: inputDescOrId[1]\n          }\n        };\n        primitiveObj.topLevel = false;\n        break;\n      }\n    case ANGLE_NUM_PRIMITIVE:\n      {\n        primitiveObj.opcode = 'math_angle';\n        primitiveObj.fields = {\n          NUM: {\n            name: 'NUM',\n            value: inputDescOrId[1]\n          }\n        };\n        primitiveObj.topLevel = false;\n        break;\n      }\n    case COLOR_PICKER_PRIMITIVE:\n      {\n        primitiveObj.opcode = 'colour_picker';\n        primitiveObj.fields = {\n          COLOUR: {\n            name: 'COLOUR',\n            value: inputDescOrId[1]\n          }\n        };\n        primitiveObj.topLevel = false;\n        break;\n      }\n    case TEXT_PRIMITIVE:\n      {\n        primitiveObj.opcode = 'text';\n        primitiveObj.fields = {\n          TEXT: {\n            name: 'TEXT',\n            value: inputDescOrId[1]\n          }\n        };\n        primitiveObj.topLevel = false;\n        break;\n      }\n    case BROADCAST_PRIMITIVE:\n      {\n        primitiveObj.opcode = 'event_broadcast_menu';\n        primitiveObj.fields = {\n          BROADCAST_OPTION: {\n            name: 'BROADCAST_OPTION',\n            value: inputDescOrId[1],\n            id: inputDescOrId[2],\n            variableType: Variable.BROADCAST_MESSAGE_TYPE\n          }\n        };\n        primitiveObj.topLevel = false;\n        break;\n      }\n    case VAR_PRIMITIVE:\n      {\n        primitiveObj.opcode = 'data_variable';\n        primitiveObj.fields = {\n          VARIABLE: {\n            name: 'VARIABLE',\n            value: inputDescOrId[1],\n            id: inputDescOrId[2],\n            variableType: Variable.SCALAR_TYPE\n          }\n        };\n        if (inputDescOrId.length > 3) {\n          primitiveObj.topLevel = true;\n          primitiveObj.x = inputDescOrId[3];\n          primitiveObj.y = inputDescOrId[4];\n        }\n        break;\n      }\n    case LIST_PRIMITIVE:\n      {\n        primitiveObj.opcode = 'data_listcontents';\n        primitiveObj.fields = {\n          LIST: {\n            name: 'LIST',\n            value: inputDescOrId[1],\n            id: inputDescOrId[2],\n            variableType: Variable.LIST_TYPE\n          }\n        };\n        if (inputDescOrId.length > 3) {\n          primitiveObj.topLevel = true;\n          primitiveObj.x = inputDescOrId[3];\n          primitiveObj.y = inputDescOrId[4];\n        }\n        break;\n      }\n    default:\n      {\n        log.error(\"Found unknown primitive type during deserialization: \".concat(JSON.stringify(inputDescOrId)));\n        return null;\n      }\n  }\n  blocks[newId] = primitiveObj;\n  return newId;\n};\n/**\n * Deserialize the given block inputs.\n * @param {object} inputs The inputs to deserialize.\n * @param {string} parentId The block id of the parent block\n * @param {object} blocks The object representing the entire set of blocks currently\n * in the process of getting deserialized.\n * @return {object} The deserialized and uncompressed inputs.\n */\nvar deserializeInputs = function deserializeInputs(inputs, parentId, blocks) {\n  // Explicitly not using Object.create(null) here\n  // because we call prototype functions later in the vm\n  var obj = {};\n  for (var inputName in inputs) {\n    if (!hasOwnProperty.call(inputs, inputName)) continue;\n    var inputDescArr = inputs[inputName]; // If this block has already been deserialized (it's not an array) skip it\n    if (!Array.isArray(inputDescArr)) continue;\n    var block = null;\n    var shadow = null;\n    var blockShadowInfo = inputDescArr[0];\n    if (blockShadowInfo === INPUT_SAME_BLOCK_SHADOW) {\n      // block and shadow are the same id, and only one is provided\n      block = shadow = deserializeInputDesc(inputDescArr[1], parentId, true, blocks);\n    } else if (blockShadowInfo === INPUT_BLOCK_NO_SHADOW) {\n      block = deserializeInputDesc(inputDescArr[1], parentId, false, blocks);\n    } else {\n      // assume INPUT_DIFF_BLOCK_SHADOW\n      block = deserializeInputDesc(inputDescArr[1], parentId, false, blocks);\n      shadow = deserializeInputDesc(inputDescArr[2], parentId, true, blocks);\n    }\n    obj[inputName] = {\n      name: inputName,\n      block: block,\n      shadow: shadow\n    };\n  }\n  return obj;\n};\n/**\n * Deserialize the given block fields.\n * @param {object} fields The fields to be deserialized\n * @return {object} The deserialized and uncompressed block fields.\n */\nvar deserializeFields = function deserializeFields(fields) {\n  // Explicitly not using Object.create(null) here\n  // because we call prototype functions later in the vm\n  var obj = {};\n  for (var fieldName in fields) {\n    if (!hasOwnProperty.call(fields, fieldName)) continue;\n    var fieldDescArr = fields[fieldName]; // If this block has already been deserialized (it's not an array) skip it\n    if (!Array.isArray(fieldDescArr)) continue;\n    obj[fieldName] = {\n      name: fieldName,\n      value: fieldDescArr[0]\n    };\n    if (fieldDescArr.length > 1) {\n      obj[fieldName].id = fieldDescArr[1];\n    }\n    if (fieldName === 'BROADCAST_OPTION') {\n      obj[fieldName].variableType = Variable.BROADCAST_MESSAGE_TYPE;\n    } else if (fieldName === 'VARIABLE') {\n      obj[fieldName].variableType = Variable.SCALAR_TYPE;\n    } else if (fieldName === 'LIST') {\n      obj[fieldName].variableType = Variable.LIST_TYPE;\n    }\n  }\n  return obj;\n};\n/**\n * Covnert serialized INPUT and FIELD primitives back to hydrated block templates.\n * Should be able to deserialize a format that has already been deserialized.  The only\n * \"east\" path to adding new targets/code requires going through deserialize, so it should\n * work with pre-parsed deserialized blocks.\n *\n * @param {object} blocks Serialized SB3 \"blocks\" property of a target. Will be mutated.\n * @return {object} input is modified and returned\n */\nvar deserializeBlocks = function deserializeBlocks(blocks) {\n  for (var blockId in blocks) {\n    if (!Object.prototype.hasOwnProperty.call(blocks, blockId)) {\n      continue;\n    }\n    var block = blocks[blockId];\n    if (Array.isArray(block)) {\n      // this is one of the primitives\n      // delete the old entry in object.blocks and replace it w/the\n      // deserialized object\n      delete blocks[blockId];\n      deserializeInputDesc(block, null, false, blocks);\n      continue;\n    }\n    block.id = blockId; // add id back to block since it wasn't serialized\n    block.inputs = deserializeInputs(block.inputs, blockId, blocks);\n    block.fields = deserializeFields(block.fields);\n  }\n  return blocks;\n};\n/**\n * Parse the assets of a single \"Scratch object\" and load them. This\n * preprocesses objects to support loading the data for those assets over a\n * network while the objects are further processed into Blocks, Sprites, and a\n * list of needed Extensions.\n * @param {!object} object From-JSON \"Scratch object:\" sprite, stage, watcher.\n * @param {!Runtime} runtime Runtime object to load all structures into.\n * @param {JSZip} zip Sb3 file describing this project (to load assets from)\n * @return {?{costumePromises:Array.<Promise>,soundPromises:Array.<Promise>,soundBank:SoundBank}}\n * Object of arrays of promises for asset objects used in Sprites. As well as a\n * SoundBank for the sound assets. null for unsupported objects.\n */\nvar parseScratchAssets = function parseScratchAssets(object, runtime, zip) {\n  if (!object.hasOwnProperty('name')) {\n    // Watcher/monitor - skip this object until those are implemented in VM.\n    // @todo\n    return Promise.resolve(null);\n  }\n  var assets = {\n    costumePromises: null,\n    soundPromises: null,\n    soundBank: runtime.audioEngine && runtime.audioEngine.createBank()\n  }; // Costumes from JSON.\n  assets.costumePromises = (object.costumes || []).map(function (costumeSource) {\n    // @todo: Make sure all the relevant metadata is being pulled out.\n    var costume = {\n      // costumeSource only has an asset if an image is being uploaded as\n      // a sprite\n      asset: costumeSource.asset,\n      assetId: costumeSource.assetId,\n      skinId: null,\n      name: costumeSource.name,\n      bitmapResolution: costumeSource.bitmapResolution,\n      rotationCenterX: costumeSource.rotationCenterX,\n      rotationCenterY: costumeSource.rotationCenterY\n    };\n    var dataFormat = costumeSource.dataFormat || costumeSource.assetType && costumeSource.assetType.runtimeFormat || // older format\n    'png'; // if all else fails, guess that it might be a PNG\n    var costumeMd5Ext = costumeSource.hasOwnProperty('md5ext') ? costumeSource.md5ext : \"\".concat(costumeSource.assetId, \".\").concat(dataFormat);\n    costume.md5 = costumeMd5Ext;\n    costume.dataFormat = dataFormat; // deserializeCostume should be called on the costume object we're\n    // creating above instead of the source costume object, because this way\n    // we're always loading the 'sb3' representation of the costume\n    // any translation that needs to happen will happen in the process\n    // of building up the costume object into an sb3 format\n    return deserializeCostume(costume, runtime, zip).then(function () {\n      return loadCostume(costumeMd5Ext, costume, runtime);\n    }); // Only attempt to load the costume after the deserialization\n    // process has been completed\n  }); // Sounds from JSON\n  assets.soundPromises = (object.sounds || []).map(function (soundSource) {\n    var sound = {\n      assetId: soundSource.assetId,\n      format: soundSource.format,\n      rate: soundSource.rate,\n      sampleCount: soundSource.sampleCount,\n      name: soundSource.name,\n      // TODO we eventually want this property to be called md5ext,\n      // but there are many things relying on this particular name at the\n      // moment, so this translation is very important\n      md5: soundSource.md5ext,\n      dataFormat: soundSource.dataFormat,\n      data: null\n    }; // deserializeSound should be called on the sound object we're\n    // creating above instead of the source sound object, because this way\n    // we're always loading the 'sb3' representation of the costume\n    // any translation that needs to happen will happen in the process\n    // of building up the costume object into an sb3 format\n    return deserializeSound(sound, runtime, zip).then(function () {\n      return loadSound(sound, runtime, assets.soundBank);\n    }); // Only attempt to load the sound after the deserialization\n    // process has been completed.\n  });\n  return assets;\n};\n/**\n * Parse a single \"Scratch object\" and create all its in-memory VM objects.\n * @param {!object} object From-JSON \"Scratch object:\" sprite, stage, watcher.\n * @param {!Runtime} runtime Runtime object to load all structures into.\n * @param {ImportedExtensionsInfo} extensions - (in/out) parsed extension information will be stored here.\n * @param {JSZip} zip Sb3 file describing this project (to load assets from)\n * @param {object} assets - Promises for assets of this scratch object grouped\n *   into costumes and sounds\n * @return {!Promise.<Target>} Promise for the target created (stage or sprite), or null for unsupported objects.\n */\nvar parseScratchObject = function parseScratchObject(object, runtime, extensions, zip, assets) {\n  if (!object.hasOwnProperty('name')) {\n    // Watcher/monitor - skip this object until those are implemented in VM.\n    // @todo\n    return Promise.resolve(null);\n  } // Blocks container for this object.\n  var blocks = new Blocks(runtime); // @todo: For now, load all Scratch objects (stage/sprites) as a Sprite.\n  var sprite = new Sprite(blocks, runtime); // Sprite/stage name from JSON.\n  if (object.hasOwnProperty('name')) {\n    sprite.name = object.name;\n  }\n  if (object.hasOwnProperty('blocks')) {\n    deserializeBlocks(object.blocks); // Take a second pass to create objects and add extensions\n    for (var blockId in object.blocks) {\n      if (!object.blocks.hasOwnProperty(blockId)) continue;\n      var blockJSON = object.blocks[blockId];\n      blocks.createBlock(blockJSON); // If the block is from an extension, record it.\n      var extensionID = getExtensionIdForOpcode(blockJSON.opcode);\n      if (extensionID) {\n        extensions.extensionIDs.add(extensionID);\n      }\n    }\n  } // Costumes from JSON.\n  var costumePromises = assets.costumePromises; // Sounds from JSON\n  var soundBank = assets.soundBank,\n      soundPromises = assets.soundPromises; // Create the first clone, and load its run-state from JSON.\n  var target = sprite.createClone(object.isStage ? StageLayering.BACKGROUND_LAYER : StageLayering.SPRITE_LAYER); // Load target properties from JSON.\n  if (object.hasOwnProperty('tempo')) {\n    target.tempo = object.tempo;\n  }\n  if (object.hasOwnProperty('volume')) {\n    target.volume = object.volume;\n  }\n  if (object.hasOwnProperty('videoTransparency')) {\n    target.videoTransparency = object.videoTransparency;\n  }\n  if (object.hasOwnProperty('videoState')) {\n    target.videoState = object.videoState;\n  }\n  if (object.hasOwnProperty('textToSpeechLanguage')) {\n    target.textToSpeechLanguage = object.textToSpeechLanguage;\n  }\n  if (object.hasOwnProperty('variables')) {\n    for (var varId in object.variables) {\n      var variable = object.variables[varId]; // A variable is a cloud variable if:\n      // - the project says it's a cloud variable, and\n      // - it's a stage variable, and\n      // - the runtime can support another cloud variable\n      var isCloud = variable.length === 3 && variable[2] && object.isStage && runtime.canAddCloudVariable();\n      var newVariable = new Variable(varId, // var id is the index of the variable desc array in the variables obj\n      variable[0], // name of the variable\n      Variable.SCALAR_TYPE, // type of the variable\n      isCloud);\n      if (isCloud) runtime.addCloudVariable();\n      newVariable.value = variable[1];\n      target.variables[newVariable.id] = newVariable;\n    }\n  }\n  if (object.hasOwnProperty('lists')) {\n    for (var listId in object.lists) {\n      var list = object.lists[listId];\n      var newList = new Variable(listId, list[0], Variable.LIST_TYPE, false);\n      newList.value = list[1];\n      target.variables[newList.id] = newList;\n    }\n  }\n  if (object.hasOwnProperty('broadcasts')) {\n    for (var broadcastId in object.broadcasts) {\n      var broadcast = object.broadcasts[broadcastId];\n      var newBroadcast = new Variable(broadcastId, broadcast, Variable.BROADCAST_MESSAGE_TYPE, false); // no need to explicitly set the value, variable constructor\n      // sets the value to the same as the name for broadcast msgs\n      target.variables[newBroadcast.id] = newBroadcast;\n    }\n  }\n  if (object.hasOwnProperty('comments')) {\n    for (var commentId in object.comments) {\n      var comment = object.comments[commentId];\n      var newComment = new Comment(commentId, comment.text, comment.x, comment.y, comment.width, comment.height, comment.minimized);\n      if (comment.blockId) {\n        newComment.blockId = comment.blockId;\n      }\n      target.comments[newComment.id] = newComment;\n    }\n  }\n  if (object.hasOwnProperty('x')) {\n    target.x = object.x;\n  }\n  if (object.hasOwnProperty('y')) {\n    target.y = object.y;\n  }\n  if (object.hasOwnProperty('direction')) {\n    target.direction = object.direction;\n  }\n  if (object.hasOwnProperty('size')) {\n    target.size = object.size;\n  }\n  if (object.hasOwnProperty('visible')) {\n    target.visible = object.visible;\n  }\n  if (object.hasOwnProperty('currentCostume')) {\n    target.currentCostume = MathUtil.clamp(object.currentCostume, 0, object.costumes.length - 1);\n  }\n  if (object.hasOwnProperty('rotationStyle')) {\n    target.rotationStyle = object.rotationStyle;\n  }\n  if (object.hasOwnProperty('isStage')) {\n    target.isStage = object.isStage;\n  }\n  if (object.hasOwnProperty('targetPaneOrder')) {\n    // Temporarily store the 'targetPaneOrder' property\n    // so that we can correctly order sprites in the target pane.\n    // This will be deleted after we are done parsing and ordering the targets list.\n    target.targetPaneOrder = object.targetPaneOrder;\n  }\n  if (object.hasOwnProperty('draggable')) {\n    target.draggable = object.draggable;\n  }\n  Promise.all(costumePromises).then(function (costumes) {\n    sprite.costumes = costumes;\n  });\n  Promise.all(soundPromises).then(function (sounds) {\n    sprite.sounds = sounds; // Make sure if soundBank is undefined, sprite.soundBank is then null.\n    sprite.soundBank = soundBank || null;\n  });\n  return Promise.all(costumePromises.concat(soundPromises)).then(function () {\n    return target;\n  });\n};\nvar deserializeMonitor = function deserializeMonitor(monitorData, runtime, targets, extensions) {\n  // If the serialized monitor has spriteName defined, look up the sprite\n  // by name in the given list of targets and update the monitor's targetId\n  // to match the sprite's id.\n  if (monitorData.spriteName) {\n    var filteredTargets = targets.filter(function (t) {\n      return t.sprite.name === monitorData.spriteName;\n    });\n    if (filteredTargets && filteredTargets.length > 0) {\n      monitorData.targetId = filteredTargets[0].id;\n    } else {\n      log.warn(\"Tried to deserialize sprite specific monitor \".concat(monitorData.opcode, \" but could not find sprite \").concat(monitorData.spriteName, \".\"));\n    }\n  } // Get information about this monitor, if it exists, given the monitor's opcode.\n  // This will be undefined for extension blocks\n  var monitorBlockInfo = runtime.monitorBlockInfo[monitorData.opcode]; // Due to a bug (see https://github.com/LLK/scratch-vm/pull/2322), renamed list monitors may have been serialized\n  // with an outdated/incorrect LIST parameter. Fix it up to use the current name of the actual corresponding list.\n  if (monitorData.opcode === 'data_listcontents') {\n    var listTarget = monitorData.targetId ? targets.find(function (t) {\n      return t.id === monitorData.targetId;\n    }) : targets.find(function (t) {\n      return t.isStage;\n    });\n    if (listTarget && Object.prototype.hasOwnProperty.call(listTarget.variables, monitorData.id)) {\n      monitorData.params.LIST = listTarget.variables[monitorData.id].name;\n    }\n  } // Convert the serialized monitorData params into the block fields structure\n  var fields = {};\n  for (var paramKey in monitorData.params) {\n    var field = {\n      name: paramKey,\n      value: monitorData.params[paramKey]\n    };\n    fields[paramKey] = field;\n  } // Variables, lists, and non-sprite-specific monitors, including any extension\n  // monitors should already have the correct monitor ID serialized in the monitorData,\n  // find the correct id for all other monitors.\n  if (monitorData.opcode !== 'data_variable' && monitorData.opcode !== 'data_listcontents' && monitorBlockInfo && monitorBlockInfo.isSpriteSpecific) {\n    monitorData.id = monitorBlockInfo.getId(monitorData.targetId, fields);\n  } else {\n    // Replace unsafe characters in monitor ID, if there are any.\n    // These would have come from projects that were originally 2.0 projects\n    // that had unsafe characters in the variable name (and then the name was\n    // used as part of the variable ID when importing the project).\n    monitorData.id = StringUtil.replaceUnsafeChars(monitorData.id);\n  } // If the runtime already has a monitor block for this monitor's id,\n  // update the existing block with the relevant monitor information.\n  var existingMonitorBlock = runtime.monitorBlocks._blocks[monitorData.id];\n  if (existingMonitorBlock) {\n    // A monitor block already exists if the toolbox has been loaded and\n    // the monitor block is not target specific (because the block gets recycled).\n    existingMonitorBlock.isMonitored = monitorData.visible;\n    existingMonitorBlock.targetId = monitorData.targetId;\n  } else {\n    // If a monitor block doesn't already exist for this monitor,\n    // construct a monitor block to add to the monitor blocks container\n    var monitorBlock = {\n      id: monitorData.id,\n      opcode: monitorData.opcode,\n      inputs: {},\n      // Assuming that monitor blocks don't have droppable fields\n      fields: fields,\n      topLevel: true,\n      next: null,\n      parent: null,\n      shadow: false,\n      x: 0,\n      y: 0,\n      isMonitored: monitorData.visible,\n      targetId: monitorData.targetId\n    }; // Variables and lists have additional properties\n    // stored in their fields, update this info in the\n    // monitor block fields\n    if (monitorData.opcode === 'data_variable') {\n      var _field = monitorBlock.fields.VARIABLE;\n      _field.id = monitorData.id;\n      _field.variableType = Variable.SCALAR_TYPE;\n    } else if (monitorData.opcode === 'data_listcontents') {\n      var _field2 = monitorBlock.fields.LIST;\n      _field2.id = monitorData.id;\n      _field2.variableType = Variable.LIST_TYPE;\n    }\n    runtime.monitorBlocks.createBlock(monitorBlock); // If the block is from an extension, record it.\n    var extensionID = getExtensionIdForOpcode(monitorBlock.opcode);\n    if (extensionID) {\n      extensions.extensionIDs.add(extensionID);\n    }\n  }\n  runtime.requestAddMonitor(MonitorRecord(monitorData));\n}; // Replace variable IDs throughout the project with\n// xml-safe versions.\n// This is to fix up projects imported from 2.0 where xml-unsafe names\n// were getting added to the variable ids.\nvar replaceUnsafeCharsInVariableIds = function replaceUnsafeCharsInVariableIds(targets) {\n  var allVarRefs = VariableUtil.getAllVarRefsForTargets(targets, true); // Re-id the variables in the actual targets\n  targets.forEach(function (t) {\n    Object.keys(t.variables).forEach(function (id) {\n      var newId = StringUtil.replaceUnsafeChars(id);\n      if (newId === id) return;\n      t.variables[id].id = newId;\n      t.variables[newId] = t.variables[id];\n      delete t.variables[id];\n    });\n  }); // Replace the IDs in the blocks refrencing variables or lists\n  for (var id in allVarRefs) {\n    var newId = StringUtil.replaceUnsafeChars(id);\n    if (id === newId) continue; // ID was already safe, skip\n    // We're calling this on the stage target because we need a\n    // target to call on but this shouldn't matter because we're passing\n    // in all the varRefs we want to operate on\n    VariableUtil.updateVariableIdentifiers(allVarRefs[id], newId);\n  }\n  return targets;\n};\n/**\n * Deserialize the specified representation of a VM runtime and loads it into the provided runtime instance.\n * @param  {object} json - JSON representation of a VM runtime.\n * @param  {Runtime} runtime - Runtime instance\n * @param {JSZip} zip - Sb3 file describing this project (to load assets from)\n * @param {boolean} isSingleSprite - If true treat as single sprite, else treat as whole project\n * @returns {Promise.<ImportedProject>} Promise that resolves to the list of targets after the project is deserialized\n */\nvar deserialize = function deserialize(json, runtime, zip, isSingleSprite) {\n  var extensions = {\n    extensionIDs: new Set(),\n    extensionURLs: new Map()\n  }; // First keep track of the current target order in the json,\n  // then sort by the layer order property before parsing the targets\n  // so that their corresponding render drawables can be created in\n  // their layer order (e.g. back to front)\n  var targetObjects = ((isSingleSprite ? [json] : json.targets) || []).map(function (t, i) {\n    return Object.assign(t, {\n      targetPaneOrder: i\n    });\n  }).sort(function (a, b) {\n    return a.layerOrder - b.layerOrder;\n  });\n  var monitorObjects = json.monitors || [];\n  return Promise.resolve(targetObjects.map(function (target) {\n    return parseScratchAssets(target, runtime, zip);\n  })) // Force this promise to wait for the next loop in the js tick. Let\n  // storage have some time to send off asset requests.\n  .then(function (assets) {\n    return Promise.resolve(assets);\n  }).then(function (assets) {\n    return Promise.all(targetObjects.map(function (target, index) {\n      return parseScratchObject(target, runtime, extensions, zip, assets[index]);\n    }));\n  }).then(function (targets) {\n    return targets // Re-sort targets back into original sprite-pane ordering\n    .map(function (t, i) {\n      // Add layer order property to deserialized targets.\n      // This property is used to initialize executable targets in\n      // the correct order and is deleted in VM's installTargets function\n      t.layerOrder = i;\n      return t;\n    }).sort(function (a, b) {\n      return a.targetPaneOrder - b.targetPaneOrder;\n    }).map(function (t) {\n      // Delete the temporary properties used for\n      // sprite pane ordering and stage layer ordering\n      delete t.targetPaneOrder;\n      return t;\n    });\n  }).then(function (targets) {\n    return replaceUnsafeCharsInVariableIds(targets);\n  }).then(function (targets) {\n    monitorObjects.map(function (monitorDesc) {\n      return deserializeMonitor(monitorDesc, runtime, targets, extensions);\n    });\n    return targets;\n  }).then(function (targets) {\n    return {\n      targets: targets,\n      extensions: extensions\n    };\n  });\n};\nmodule.exports = {\n  serialize: serialize,\n  deserialize: deserialize,\n  deserializeBlocks: deserializeBlocks,\n  serializeBlocks: serializeBlocks,\n  getExtensionIdForOpcode: getExtensionIdForOpcode\n};\n })