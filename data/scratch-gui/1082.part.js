/* 1082 */\n (function(module, exports, __webpack_require__) {\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nvar MathUtil = __webpack_require__(62);\nvar Mouse = function () {\n  function Mouse(runtime) {\n    _classCallCheck(this, Mouse);\n    this._x = 0;\n    this._y = 0;\n    this._isDown = false;\n    /**\n     * Reference to the owning Runtime.\n     * Can be used, for example, to activate hats.\n     * @type{!Runtime}\n     */\n    this.runtime = runtime;\n  }\n  /**\n   * Activate \"event_whenthisspriteclicked\" hats.\n   * @param  {Target} target to trigger hats on.\n   * @private\n   */\n  _createClass(Mouse, [{\n    key: \"_activateClickHats\",\n    value: function _activateClickHats(target) {\n      // Activate both \"this sprite clicked\" and \"stage clicked\"\n      // They were separated into two opcodes for labeling,\n      // but should act the same way.\n      // Intentionally not checking isStage to make it work when sharing blocks.\n      // @todo the blocks should be converted from one to another when shared\n      this.runtime.startHats('event_whenthisspriteclicked', null, target);\n      this.runtime.startHats('event_whenstageclicked', null, target);\n    }\n    /**\n     * Find a target by XY location\n     * @param  {number} x X position to be sent to the renderer.\n     * @param  {number} y Y position to be sent to the renderer.\n     * @return {Target} the target at that location\n     * @private\n     */\n  }, {\n    key: \"_pickTarget\",\n    value: function _pickTarget(x, y) {\n      if (this.runtime.renderer) {\n        var drawableID = this.runtime.renderer.pick(x, y);\n        for (var i = 0; i < this.runtime.targets.length; i++) {\n          var target = this.runtime.targets[i];\n          if (target.hasOwnProperty('drawableID') && target.drawableID === drawableID) {\n            return target;\n          }\n        }\n      } // Return the stage if no target was found\n      return this.runtime.getTargetForStage();\n    }\n    /**\n     * Mouse DOM event handler.\n     * @param  {object} data Data from DOM event.\n     */\n  }, {\n    key: \"postData\",\n    value: function postData(data) {\n      if (data.x) {\n        this._clientX = data.x;\n        this._scratchX = Math.round(MathUtil.clamp(480 * (data.x / data.canvasWidth - 0.5), -240, 240));\n      }\n      if (data.y) {\n        this._clientY = data.y;\n        this._scratchY = Math.round(MathUtil.clamp(-360 * (data.y / data.canvasHeight - 0.5), -180, 180));\n      }\n      if (typeof data.isDown !== 'undefined') {\n        var previousDownState = this._isDown;\n        this._isDown = data.isDown; // Do not trigger if down state has not changed\n        if (previousDownState === this._isDown) return; // Never trigger click hats at the end of a drag\n        if (data.wasDragged) return; // Do not activate click hats for clicks outside canvas bounds\n        if (!(data.x > 0 && data.x < data.canvasWidth && data.y > 0 && data.y < data.canvasHeight)) return;\n        var target = this._pickTarget(data.x, data.y);\n        var isNewMouseDown = !previousDownState && this._isDown;\n        var isNewMouseUp = previousDownState && !this._isDown; // Draggable targets start click hats on mouse up.\n        // Non-draggable targets start click hats on mouse down.\n        if (target.draggable && isNewMouseUp) {\n          this._activateClickHats(target);\n        } else if (!target.draggable && isNewMouseDown) {\n          this._activateClickHats(target);\n        }\n      }\n    }\n    /**\n     * Get the X position of the mouse in client coordinates.\n     * @return {number} Non-clamped X position of the mouse cursor.\n     */\n  }, {\n    key: \"getClientX\",\n    value: function getClientX() {\n      return this._clientX;\n    }\n    /**\n     * Get the Y position of the mouse in client coordinates.\n     * @return {number} Non-clamped Y position of the mouse cursor.\n     */\n  }, {\n    key: \"getClientY\",\n    value: function getClientY() {\n      return this._clientY;\n    }\n    /**\n     * Get the X position of the mouse in scratch coordinates.\n     * @return {number} Clamped and integer rounded X position of the mouse cursor.\n     */\n  }, {\n    key: \"getScratchX\",\n    value: function getScratchX() {\n      return this._scratchX;\n    }\n    /**\n     * Get the Y position of the mouse in scratch coordinates.\n     * @return {number} Clamped and integer rounded Y position of the mouse cursor.\n     */\n  }, {\n    key: \"getScratchY\",\n    value: function getScratchY() {\n      return this._scratchY;\n    }\n    /**\n     * Get the down state of the mouse.\n     * @return {boolean} Is the mouse down?\n     */\n  }, {\n    key: \"getIsDown\",\n    value: function getIsDown() {\n      return this._isDown;\n    }\n  }]);\n  return Mouse;\n}();\nmodule.exports = Mouse;\n })