/* 451 */\n (function(module, exports, __webpack_require__) {\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\nvar BlockUtility = __webpack_require__(1076);\nvar BlocksExecuteCache = __webpack_require__(440);\nvar log = __webpack_require__(39);\nvar Thread = __webpack_require__(224);\nvar _require = __webpack_require__(181),\n    Map = _require.Map;\nvar cast = __webpack_require__(48);\n/**\n * Single BlockUtility instance reused by execute for every pritimive ran.\n * @const\n */\nvar blockUtility = new BlockUtility();\n/**\n * Profiler frame name for block functions.\n * @const {string}\n */\nvar blockFunctionProfilerFrame = 'blockFunction';\n/**\n * Profiler frame ID for 'blockFunction'.\n * @type {number}\n */\nvar blockFunctionProfilerId = -1;\n/**\n * Utility function to determine if a value is a Promise.\n * @param {*} value Value to check for a Promise.\n * @return {boolean} True if the value appears to be a Promise.\n */\nvar isPromise = function isPromise(value) {\n  return value !== null && _typeof(value) === 'object' && typeof value.then === 'function';\n};\n/**\n * Handle any reported value from the primitive, either directly returned\n * or after a promise resolves.\n * @param {*} resolvedValue Value eventually returned from the primitive.\n * @param {!Sequencer} sequencer Sequencer stepping the thread for the ran\n * primitive.\n * @param {!Thread} thread Thread containing the primitive.\n * @param {!string} currentBlockId Id of the block in its thread for value from\n * the primitive.\n * @param {!string} opcode opcode used to identify a block function primitive.\n * @param {!boolean} isHat Is the current block a hat?\n */\n// @todo move this to callback attached to the thread when we have performance\n// metrics (dd)\nvar handleReport = function handleReport(resolvedValue, sequencer, thread, blockCached, lastOperation) {\n  var currentBlockId = blockCached.id;\n  var opcode = blockCached.opcode;\n  var isHat = blockCached._isHat;\n  thread.pushReportedValue(resolvedValue);\n  if (isHat) {\n    // Hat predicate was evaluated.\n    if (sequencer.runtime.getIsEdgeActivatedHat(opcode)) {\n      // If this is an edge-activated hat, only proceed if the value is\n      // true and used to be false, or the stack was activated explicitly\n      // via stack click\n      if (!thread.stackClick) {\n        var hasOldEdgeValue = thread.target.hasEdgeActivatedValue(currentBlockId);\n        var oldEdgeValue = thread.target.updateEdgeActivatedValue(currentBlockId, resolvedValue);\n        var edgeWasActivated = hasOldEdgeValue ? !oldEdgeValue && resolvedValue : resolvedValue;\n        if (!edgeWasActivated) {\n          sequencer.retireThread(thread);\n        }\n      }\n    } else if (!resolvedValue) {\n      // Not an edge-activated hat: retire the thread\n      // if predicate was false.\n      sequencer.retireThread(thread);\n    }\n  } else {\n    // In a non-hat, report the value visually if necessary if\n    // at the top of the thread stack.\n    if (lastOperation && typeof resolvedValue !== 'undefined' && thread.atStackTop()) {\n      if (thread.stackClick) {\n        sequencer.runtime.visualReport(currentBlockId, resolvedValue);\n      }\n      if (thread.updateMonitor) {\n        var targetId = sequencer.runtime.monitorBlocks.getBlock(currentBlockId).targetId;\n        if (targetId && !sequencer.runtime.getTargetById(targetId)) {\n          // Target no longer exists\n          return;\n        }\n        sequencer.runtime.requestUpdateMonitor(Map({\n          id: currentBlockId,\n          spriteName: targetId ? sequencer.runtime.getTargetById(targetId).getName() : null,\n          value: resolvedValue\n        }));\n      }\n    } // Finished any yields.\n    thread.status = Thread.STATUS_RUNNING;\n  }\n};\nvar handlePromise = function handlePromise(primitiveReportedValue, sequencer, thread, blockCached, lastOperation) {\n  if (thread.status === Thread.STATUS_RUNNING) {\n    // Primitive returned a promise; automatically yield thread.\n    thread.status = Thread.STATUS_PROMISE_WAIT;\n  } // Promise handlers\n  primitiveReportedValue.then(function (resolvedValue) {\n    handleReport(resolvedValue, sequencer, thread, blockCached, lastOperation); // If it's a command block or a top level reporter in a stackClick.\n    if (lastOperation) {\n      var stackFrame;\n      var nextBlockId;\n      do {\n        // In the case that the promise is the last block in the current thread stack\n        // We need to pop out repeatedly until we find the next block.\n        var popped = thread.popStack();\n        if (popped === null) {\n          return;\n        }\n        nextBlockId = thread.target.blocks.getNextBlock(popped);\n        if (nextBlockId !== null) {\n          // A next block exists so break out this loop\n          break;\n        } // Investigate the next block and if not in a loop,\n        // then repeat and pop the next item off the stack frame\n        stackFrame = thread.peekStackFrame();\n      } while (stackFrame !== null && !stackFrame.isLoop);\n      thread.pushStack(nextBlockId);\n    }\n  }, function (rejectionReason) {\n    // Promise rejected: the primitive had some error.\n    // Log it and proceed.\n    log.warn('Primitive rejected promise: ', rejectionReason);\n    thread.status = Thread.STATUS_RUNNING;\n    thread.popStack();\n  });\n};\n/**\n * A execute.js internal representation of a block to reduce the time spent in\n * execute as the same blocks are called the most.\n *\n * With the help of the Blocks class create a mutable copy of block\n * information. The members of BlockCached derived values of block information\n * that does not need to be reevaluated until a change in Blocks. Since Blocks\n * handles where the cache instance is stored, it drops all cache versions of a\n * block when any change happens to it. This way we can quickly execute blocks\n * and keep perform the right action according to the current block information\n * in the editor.\n *\n * @param {Blocks} blockContainer the related Blocks instance\n * @param {object} cached default set of cached values\n */\nvar BlockCached = function BlockCached(blockContainer, cached) {\n  _classCallCheck(this, BlockCached);\n  /**\n   * Block id in its parent set of blocks.\n   * @type {string}\n   */\n  this.id = cached.id;\n  /**\n   * Block operation code for this block.\n   * @type {string}\n   */\n  this.opcode = cached.opcode;\n  /**\n   * Original block object containing argument values for static fields.\n   * @type {object}\n   */\n  this.fields = cached.fields;\n  /**\n   * Original block object containing argument values for executable inputs.\n   * @type {object}\n   */\n  this.inputs = cached.inputs;\n  /**\n   * Procedure mutation.\n   * @type {?object}\n   */\n  this.mutation = cached.mutation;\n  /**\n   * The profiler the block is configured with.\n   * @type {?Profiler}\n   */\n  this._profiler = null;\n  /**\n   * Profiler information frame.\n   * @type {?ProfilerFrame}\n   */\n  this._profilerFrame = null;\n  /**\n   * Is the opcode a hat (event responder) block.\n   * @type {boolean}\n   */\n  this._isHat = false;\n  /**\n   * The block opcode's implementation function.\n   * @type {?function}\n   */\n  this._blockFunction = null;\n  /**\n   * Is the block function defined for this opcode?\n   * @type {boolean}\n   */\n  this._definedBlockFunction = false;\n  /**\n   * Is this block a block with no function but a static value to return.\n   * @type {boolean}\n   */\n  this._isShadowBlock = false;\n  /**\n   * The static value of this block if it is a shadow block.\n   * @type {?any}\n   */\n  this._shadowValue = null;\n  /**\n   * A copy of the block's fields that may be modified.\n   * @type {object}\n   */\n  this._fields = Object.assign({}, this.fields);\n  /**\n   * A copy of the block's inputs that may be modified.\n   * @type {object}\n   */\n  this._inputs = Object.assign({}, this.inputs);\n  /**\n   * An arguments object for block implementations. All executions of this\n   * specific block will use this objecct.\n   * @type {object}\n   */\n  this._argValues = {\n    mutation: this.mutation\n  };\n  /**\n   * The inputs key the parent refers to this BlockCached by.\n   * @type {string}\n   */\n  this._parentKey = null;\n  /**\n   * The target object where the parent wants the resulting value stored\n   * with _parentKey as the key.\n   * @type {object}\n   */\n  this._parentValues = null;\n  /**\n   * A sequence of non-shadow operations that can must be performed. This\n   * list recreates the order this block and its children are executed.\n   * Since the order is always the same we can safely store that order\n   * and iterate over the operations instead of dynamically walking the\n   * tree every time.\n   * @type {Array<BlockCached>}\n   */\n  this._ops = [];\n  var runtime = blockUtility.sequencer.runtime;\n  var opcode = this.opcode,\n      fields = this.fields,\n      inputs = this.inputs; // Assign opcode isHat and blockFunction data to avoid dynamic lookups.\n  this._isHat = runtime.getIsHat(opcode);\n  this._blockFunction = runtime.getOpcodeFunction(opcode);\n  this._definedBlockFunction = typeof this._blockFunction !== 'undefined'; // Store the current shadow value if there is a shadow value.\n  var fieldKeys = Object.keys(fields);\n  this._isShadowBlock = !this._definedBlockFunction && fieldKeys.length === 1 && Object.keys(inputs).length === 0;\n  this._shadowValue = this._isShadowBlock && fields[fieldKeys[0]].value; // Store the static fields onto _argValues.\n  for (var fieldName in fields) {\n    if (fieldName === 'VARIABLE' || fieldName === 'LIST' || fieldName === 'BROADCAST_OPTION') {\n      this._argValues[fieldName] = {\n        id: fields[fieldName].id,\n        name: fields[fieldName].value\n      };\n    } else {\n      this._argValues[fieldName] = fields[fieldName].value;\n    }\n  } // Remove custom_block. It is not part of block execution.\n  delete this._inputs.custom_block;\n  if ('BROADCAST_INPUT' in this._inputs) {\n    // BROADCAST_INPUT is called BROADCAST_OPTION in the args and is an\n    // object with an unchanging shape.\n    this._argValues.BROADCAST_OPTION = {\n      id: null,\n      name: null\n    }; // We can go ahead and compute BROADCAST_INPUT if it is a shadow\n    // value.\n    var broadcastInput = this._inputs.BROADCAST_INPUT;\n    if (broadcastInput.block === broadcastInput.shadow) {\n      // Shadow dropdown menu is being used.\n      // Get the appropriate information out of it.\n      var shadow = blockContainer.getBlock(broadcastInput.shadow);\n      var broadcastField = shadow.fields.BROADCAST_OPTION;\n      this._argValues.BROADCAST_OPTION.id = broadcastField.id;\n      this._argValues.BROADCAST_OPTION.name = broadcastField.value; // Evaluating BROADCAST_INPUT here we do not need to do so\n      // later.\n      delete this._inputs.BROADCAST_INPUT;\n    }\n  } // Cache all input children blocks in the operation lists. The\n  // operations can later be run in the order they appear in correctly\n  // executing the operations quickly in a flat loop instead of needing to\n  // recursivly iterate them.\n  for (var inputName in this._inputs) {\n    var input = this._inputs[inputName];\n    if (input.block) {\n      var _this$_ops;\n      var inputCached = BlocksExecuteCache.getCached(blockContainer, input.block, BlockCached);\n      if (inputCached._isHat) {\n        continue;\n      }\n      (_this$_ops = this._ops).push.apply(_this$_ops, _toConsumableArray(inputCached._ops));\n      inputCached._parentKey = inputName;\n      inputCached._parentValues = this._argValues; // Shadow values are static and do not change, go ahead and\n      // store their value on args.\n      if (inputCached._isShadowBlock) {\n        this._argValues[inputName] = inputCached._shadowValue;\n      }\n    }\n  } // The final operation is this block itself. At the top most block is a\n  // command block or a block that is being run as a monitor.\n  if (this._definedBlockFunction) {\n    this._ops.push(this);\n  }\n};\n/**\n * Initialize a BlockCached instance so its command/hat\n * block and reporters can be profiled during execution.\n * @param {Profiler} profiler - The profiler that is currently enabled.\n * @param {BlockCached} blockCached - The blockCached instance to profile.\n */\nvar _prepareBlockProfiling = function _prepareBlockProfiling(profiler, blockCached) {\n  blockCached._profiler = profiler;\n  if (blockFunctionProfilerId === -1) {\n    blockFunctionProfilerId = profiler.idByName(blockFunctionProfilerFrame);\n  }\n  var ops = blockCached._ops;\n  for (var i = 0; i < ops.length; i++) {\n    ops[i]._profilerFrame = profiler.frame(blockFunctionProfilerId, ops[i].opcode);\n  }\n};\n/**\n * Execute a block.\n * @param {!Sequencer} sequencer Which sequencer is executing.\n * @param {!Thread} thread Thread which to read and execute.\n */\nvar execute = function execute(sequencer, thread) {\n  var runtime = sequencer.runtime; // store sequencer and thread so block functions can access them through\n  // convenience methods.\n  blockUtility.sequencer = sequencer;\n  blockUtility.thread = thread; // Current block to execute is the one on the top of the stack.\n  var currentBlockId = thread.peekStack();\n  var currentStackFrame = thread.peekStackFrame();\n  var blockContainer = thread.blockContainer;\n  var blockCached = BlocksExecuteCache.getCached(blockContainer, currentBlockId, BlockCached);\n  if (blockCached === null) {\n    blockContainer = runtime.flyoutBlocks;\n    blockCached = BlocksExecuteCache.getCached(blockContainer, currentBlockId, BlockCached); // Stop if block or target no longer exists.\n    if (blockCached === null) {\n      // No block found: stop the thread; script no longer exists.\n      sequencer.retireThread(thread);\n      return;\n    }\n  }\n  var ops = blockCached._ops;\n  var length = ops.length;\n  var i = 0;\n  if (currentStackFrame.reported !== null) {\n    var reported = currentStackFrame.reported; // Reinstate all the previous values.\n    var _loop = function _loop() {\n      var _reported$i = reported[i],\n          oldOpCached = _reported$i.opCached,\n          inputValue = _reported$i.inputValue;\n      var opCached = ops.find(function (op) {\n        return op.id === oldOpCached;\n      });\n      if (opCached) {\n        var _inputName = opCached._parentKey;\n        var _argValues = opCached._parentValues;\n        if (_inputName === 'BROADCAST_INPUT') {\n          // Something is plugged into the broadcast input.\n          // Cast it to a string. We don't need an id here.\n          _argValues.BROADCAST_OPTION.id = null;\n          _argValues.BROADCAST_OPTION.name = cast.toString(inputValue);\n        } else {\n          _argValues[_inputName] = inputValue;\n        }\n      }\n    };\n    for (; i < reported.length; i++) {\n      _loop();\n    } // Find the last reported block that is still in the set of operations.\n    // This way if the last operation was removed, we'll find the next\n    // candidate. If an earlier block that was performed was removed then\n    // we'll find the index where the last operation is now.\n    if (reported.length > 0) {\n      var lastExisting = reported.reverse().find(function (report) {\n        return ops.find(function (op) {\n          return op.id === report.opCached;\n        });\n      });\n      if (lastExisting) {\n        i = ops.findIndex(function (opCached) {\n          return opCached.id === lastExisting.opCached;\n        }) + 1;\n      } else {\n        i = 0;\n      }\n    } // The reporting block must exist and must be the next one in the sequence of operations.\n    if (thread.justReported !== null && ops[i] && ops[i].id === currentStackFrame.reporting) {\n      var opCached = ops[i];\n      var inputValue = thread.justReported;\n      thread.justReported = null;\n      var inputName = opCached._parentKey;\n      var argValues = opCached._parentValues;\n      if (inputName === 'BROADCAST_INPUT') {\n        // Something is plugged into the broadcast input.\n        // Cast it to a string. We don't need an id here.\n        argValues.BROADCAST_OPTION.id = null;\n        argValues.BROADCAST_OPTION.name = cast.toString(inputValue);\n      } else {\n        argValues[inputName] = inputValue;\n      }\n      i += 1;\n    }\n    currentStackFrame.reporting = null;\n    currentStackFrame.reported = null;\n  }\n  var start = i;\n  for (; i < length; i++) {\n    var lastOperation = i === length - 1;\n    var _opCached = ops[i];\n    var blockFunction = _opCached._blockFunction; // Update values for arguments (inputs).\n    var _argValues2 = _opCached._argValues; // Fields are set during opCached initialization.\n    // Blocks should glow when a script is starting,\n    // not after it has finished (see #1404).\n    // Only blocks in blockContainers that don't forceNoGlow\n    // should request a glow.\n    if (!blockContainer.forceNoGlow) {\n      thread.requestScriptGlowInFrame = true;\n    } // Inputs are set during previous steps in the loop.\n    var primitiveReportedValue = blockFunction(_argValues2, blockUtility); // If it's a promise, wait until promise resolves.\n    if (isPromise(primitiveReportedValue)) {\n      handlePromise(primitiveReportedValue, sequencer, thread, _opCached, lastOperation); // Store the already reported values. They will be thawed into the\n      // future versions of the same operations by block id. The reporting\n      // operation if it is promise waiting will set its parent value at\n      // that time.\n      thread.justReported = null;\n      currentStackFrame.reporting = ops[i].id;\n      currentStackFrame.reported = ops.slice(0, i).map(function (reportedCached) {\n        var inputName = reportedCached._parentKey;\n        var reportedValues = reportedCached._parentValues;\n        if (inputName === 'BROADCAST_INPUT') {\n          return {\n            opCached: reportedCached.id,\n            inputValue: reportedValues[inputName].BROADCAST_OPTION.name\n          };\n        }\n        return {\n          opCached: reportedCached.id,\n          inputValue: reportedValues[inputName]\n        };\n      }); // We are waiting for a promise. Stop running this set of operations\n      // and continue them later after thawing the reported values.\n      break;\n    } else if (thread.status === Thread.STATUS_RUNNING) {\n      if (lastOperation) {\n        handleReport(primitiveReportedValue, sequencer, thread, _opCached, lastOperation);\n      } else {\n        // By definition a block that is not last in the list has a\n        // parent.\n        var _inputName2 = _opCached._parentKey;\n        var parentValues = _opCached._parentValues;\n        if (_inputName2 === 'BROADCAST_INPUT') {\n          // Something is plugged into the broadcast input.\n          // Cast it to a string. We don't need an id here.\n          parentValues.BROADCAST_OPTION.id = null;\n          parentValues.BROADCAST_OPTION.name = cast.toString(primitiveReportedValue);\n        } else {\n          parentValues[_inputName2] = primitiveReportedValue;\n        }\n      }\n    }\n  }\n  if (runtime.profiler !== null) {\n    if (blockCached._profiler !== runtime.profiler) {\n      _prepareBlockProfiling(runtime.profiler, blockCached);\n    } // Determine the index that is after the last executed block. `i` is\n    // currently the block that was just executed. `i + 1` will be the block\n    // after that. `length` with the min call makes sure we don't try to\n    // reference an operation outside of the set of operations.\n    var end = Math.min(i + 1, length);\n    for (var p = start; p < end; p++) {\n      ops[p]._profilerFrame.count += 1;\n    }\n  }\n};\nmodule.exports = execute;\n })