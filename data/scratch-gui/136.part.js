/* 136 */\n (function(module, exports, __webpack_require__) {\n(function(global) {function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n/**\n * @fileoverview\n * A utility for accurately measuring time.\n * To use:\n * ---\n * var timer = new Timer();\n * timer.start();\n * ... pass some time ...\n * var timeDifference = timer.timeElapsed();\n * ---\n * Or, you can use the `time` and `relativeTime`\n * to do some measurement yourself.\n */\nvar Timer = function () {\n  function Timer() {\n    var nowObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Timer.nowObj;\n    _classCallCheck(this, Timer);\n    /**\n     * Used to store the start time of a timer action.\n     * Updated when calling `timer.start`.\n     */\n    this.startTime = 0;\n    /**\n     * Used to pass custom logic for determining the value for \"now\",\n     * which is sometimes useful for compatibility with Scratch 2\n     */\n    this.nowObj = nowObj;\n  }\n  /**\n   * Disable use of self.performance for now as it results in lower performance\n   * However, instancing it like below (caching the self.performance to a local variable) negates most of the issues.\n   * @type {boolean}\n   */\n  _createClass(Timer, [{\n    key: \"time\",\n    /**\n     * Return the currently known absolute time, in ms precision.\n     * @returns {number} ms elapsed since 1 January 1970 00:00:00 UTC.\n     */\n    value: function time() {\n      return this.nowObj.now();\n    }\n    /**\n     * Returns a time accurate relative to other times produced by this function.\n     * If possible, will use sub-millisecond precision.\n     * If not, will use millisecond precision.\n     * Not guaranteed to produce the same absolute values per-system.\n     * @returns {number} ms-scale accurate time relative to other relative times.\n     */\n  }, {\n    key: \"relativeTime\",\n    value: function relativeTime() {\n      return this.nowObj.now();\n    }\n    /**\n     * Start a timer for measuring elapsed time,\n     * at the most accurate precision possible.\n     */\n  }, {\n    key: \"start\",\n    value: function start() {\n      this.startTime = this.nowObj.now();\n    }\n  }, {\n    key: \"timeElapsed\",\n    value: function timeElapsed() {\n      return this.nowObj.now() - this.startTime;\n    }\n    /**\n     * Call a handler function after a specified amount of time has elapsed.\n     * @param {function} handler - function to call after the timeout\n     * @param {number} timeout - number of milliseconds to delay before calling the handler\n     * @returns {number} - the ID of the new timeout\n     */\n  }, {\n    key: \"setTimeout\",\n    value: function setTimeout(handler, timeout) {\n      return global.setTimeout(handler, timeout);\n    }\n    /**\n     * Clear a timeout from the pending timeout pool.\n     * @param {number} timeoutId - the ID returned by `setTimeout()`\n     * @memberof Timer\n     */\n  }, {\n    key: \"clearTimeout\",\n    value: function clearTimeout(timeoutId) {\n      global.clearTimeout(timeoutId);\n    }\n  }], [{\n    key: \"USE_PERFORMANCE\",\n    get: function get() {\n      return false;\n    }\n    /**\n     * Legacy object to allow for us to call now to get the old style date time (for backwards compatibility)\n     * @deprecated This is only called via the nowObj.now() if no other means is possible...\n     */\n  }, {\n    key: \"legacyDateCode\",\n    get: function get() {\n      return {\n        now: function now() {\n          return new Date().getTime();\n        }\n      };\n    }\n    /**\n     * Use this object to route all time functions through single access points.\n     */\n  }, {\n    key: \"nowObj\",\n    get: function get() {\n      if (Timer.USE_PERFORMANCE && typeof self !== 'undefined' && self.performance && 'now' in self.performance) {\n        return self.performance;\n      } else if (Date.now) {\n        return Date;\n      }\n      return Timer.legacyDateCode;\n    }\n  }]);\n  return Timer;\n}();\nmodule.exports = Timer;\n}.call(this, __webpack_require__(44)))\n })