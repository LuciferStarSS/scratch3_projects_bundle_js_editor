/* 193 */\n (function(module, __webpack_exports__, __webpack_require__) {\n\"use strict\";\n// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"default\", function() { return /* reexport */ containers_paint_editor; });\n__webpack_require__.d(__webpack_exports__, \"ScratchPaintReducer\", function() { return /* reexport */ scratch_paint_reducer; });\n// EXTERNAL MODULE: ./node_modules/@scratch/paper/dist/paper-full.js\nvar paper_full = __webpack_require__(3);\nvar paper_full_default = __webpack_require__.n(paper_full);\n// EXTERNAL MODULE: ./node_modules/prop-types/index.js\nvar prop_types = __webpack_require__(0);\nvar prop_types_default = __webpack_require__.n(prop_types);\n// EXTERNAL MODULE: ./node_modules/minilog/lib/web/index.js\nvar web = __webpack_require__(79);\nvar web_default = __webpack_require__.n(web);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/log/log.js\nweb_default.a.enable();\n/* harmony default export */ var log = (web_default()('scratch-paint'));\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(1);\nvar react_default = __webpack_require__.n(react);\n// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 14 modules\nvar es = __webpack_require__(6);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/node_modules/classnames/index.js\nvar classnames = __webpack_require__(16);\nvar classnames_default = __webpack_require__.n(classnames);\n// EXTERNAL MODULE: ./node_modules/react-intl/lib/index.es.js + 1 modules\nvar index_es = __webpack_require__(2);\n// EXTERNAL MODULE: ./node_modules/lodash.bindall/index.js\nvar lodash_bindall = __webpack_require__(5);\nvar lodash_bindall_default = __webpack_require__.n(lodash_bindall);\n// EXTERNAL MODULE: ./node_modules/keymirror/index.js\nvar keymirror = __webpack_require__(40);\nvar keymirror_default = __webpack_require__.n(keymirror);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/lib/format.js\nvar Formats = keymirror_default()({\n  BITMAP: null,\n  VECTOR: null,\n  // Format changes which should not trigger conversions, for instance undo\n  BITMAP_SKIP_CONVERT: null,\n  VECTOR_SKIP_CONVERT: null\n});\nvar isVector = function isVector(format) {\n  return format === Formats.VECTOR || format === Formats.VECTOR_SKIP_CONVERT;\n};\nvar format_isBitmap = function isBitmap(format) {\n  return format === Formats.BITMAP || format === Formats.BITMAP_SKIP_CONVERT;\n};\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/lib/modes.js\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nvar vectorModesObj = {\n  BRUSH: null,\n  ERASER: null,\n  LINE: null,\n  FILL: null,\n  SELECT: null,\n  RESHAPE: null,\n  OVAL: null,\n  RECT: null,\n  ROUNDED_RECT: null,\n  TEXT: null\n};\nvar bitmapModesObj = {\n  BIT_BRUSH: null,\n  BIT_LINE: null,\n  BIT_OVAL: null,\n  BIT_RECT: null,\n  BIT_TEXT: null,\n  BIT_FILL: null,\n  BIT_ERASER: null,\n  BIT_SELECT: null\n};\nvar VectorModes = keymirror_default()(vectorModesObj);\nvar BitmapModes = keymirror_default()(bitmapModesObj);\nvar Modes = keymirror_default()(_objectSpread(_objectSpread({}, vectorModesObj), bitmapModesObj));\nvar GradientToolsModes = keymirror_default()({\n  FILL: null,\n  SELECT: null,\n  RESHAPE: null,\n  OVAL: null,\n  RECT: null,\n  LINE: null,\n  BIT_OVAL: null,\n  BIT_RECT: null,\n  BIT_SELECT: null,\n  BIT_FILL: null\n});\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/helper/item.js\nvar getRootItem = function getRootItem(item) {\n  if (item.parent.className === 'Layer') {\n    return item;\n  }\n  return getRootItem(item.parent);\n};\nvar isBoundsItem = function isBoundsItem(item) {\n  if (item.className === 'PointText' || item.className === 'Shape' || item.className === 'PlacedSymbol' || item.className === 'Raster') {\n    return true;\n  }\n  return false;\n};\nvar isPathItem = function isPathItem(item) {\n  return item.className === 'Path';\n};\nvar isCompoundPathItem = function isCompoundPathItem(item) {\n  return item.className === 'CompoundPath';\n};\nvar isGroupItem = function isGroupItem(item) {\n  return item && item.className && item.className === 'Group';\n};\nvar isPointTextItem = function isPointTextItem(item) {\n  return item.className === 'PointText';\n};\nvar isPGTextItem = function isPGTextItem(item) {\n  return getRootItem(item).data.isPGTextItem;\n};\nvar setPivot = function setPivot(item, point) {\n  if (isBoundsItem(item)) {\n    item.pivot = item.globalToLocal(point);\n  } else {\n    item.pivot = point;\n  }\n};\nvar item_getPositionInView = function getPositionInView(item) {\n  var itemPos = new paper_full_default.a.Point();\n  itemPos.x = item.position.x - paper_full_default.a.view.bounds.x;\n  itemPos.y = item.position.y - paper_full_default.a.view.bounds.y;\n  return itemPos;\n};\nvar item_setPositionInView = function setPositionInView(item, pos) {\n  item.position.x = paper_full_default.a.view.bounds.x + pos.x;\n  item.position.y = paper_full_default.a.view.bounds.y + pos.y;\n};\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/helper/group.js\n\nvar group_isGroup = function isGroup(item) {\n  return isGroupItem(item);\n};\n/**\n * Groups the given items. Other things are then deselected and the new group is selected.\n * @param {!Array<paper.Item>} items Root level items to group\n * @param {!function} clearSelectedItems Function to clear Redux state's selected items\n * @param {!function} setSelectedItems Function to set Redux state with new list of selected items\n * @param {!function} onUpdateImage Function to let listeners know that SVG has changed.\n * @return {paper.Group} the group if one is created, otherwise false.\n */\nvar group_groupItems = function groupItems(items, clearSelectedItems, setSelectedItems, onUpdateImage) {\n  if (items.length > 0) {\n    var group = new paper_full_default.a.Group(items);\n    selection_clearSelection(clearSelectedItems);\n    selection_setItemSelection(group, true);\n    for (var i = 0; i < group.children.length; i++) {\n      group.children[i].selected = true;\n    }\n    setSelectedItems();\n    onUpdateImage();\n    return group;\n  }\n  return false;\n};\n/**\n * Groups the selected items. Other things are then deselected and the new group is selected.\n * @param {!function} clearSelectedItems Function to clear Redux state's selected items\n * @param {!function} setSelectedItems Function to set Redux state with new list of selected items\n * @param {!function} onUpdateImage Function to let listeners know that SVG has changed.\n * @return {paper.Group} the group if one is created, otherwise false.\n */\nvar group_groupSelection = function groupSelection(clearSelectedItems, setSelectedItems, onUpdateImage) {\n  var items = selection_getSelectedRootItems();\n  return group_groupItems(items, clearSelectedItems, setSelectedItems, onUpdateImage);\n};\nvar group_ungroupLoop = function _ungroupLoop(group, recursive, setSelectedItems) {\n  // Can't ungroup items that are not groups\n  if (!group || !group.children || !group_isGroup(group)) return;\n  group.applyMatrix = true; // iterate over group children recursively\n  for (var i = 0; i < group.children.length; i++) {\n    var groupChild = group.children[i];\n    if (groupChild instanceof paper_full_default.a.Group && groupChild.hasChildren()) {\n      // recursion (groups can contain groups, ie. from SVG import)\n      if (recursive) {\n        _ungroupLoop(groupChild, recursive, setSelectedItems);\n        continue;\n      }\n      if (groupChild.children.length === 1) {\n        groupChild = groupChild.reduce();\n      }\n    }\n    groupChild.applyMatrix = true; // move items from the group to the activeLayer (ungrouping)\n    groupChild.insertBelow(group);\n    if (setSelectedItems) {\n      groupChild.selected = true;\n    }\n    i--;\n  }\n};\n/**\n * Ungroups the given items. The new group is selected only if setSelectedItems is passed in.\n * onUpdateImage is called to notify listeners of a change on the SVG only if onUpdateImage is passed in.\n * The reason these arguments are optional on ungroupItems is because ungroupItems is used for parts of\n * SVG import, which shouldn't change the selection or undo state.\n *\n * @param {!Array<paper.Item>} items Items to ungroup if they are groups\n * @param {?function} setSelectedItems Function to set Redux state with new list of selected items\n * @param {?function} onUpdateImage Function to let listeners know that SVG has changed.\n */\nvar ungroupItems = function ungroupItems(items, setSelectedItems, onUpdateImage) {\n  if (items.length === 0) {\n    return;\n  }\n  var emptyGroups = [];\n  for (var i = 0; i < items.length; i++) {\n    var item = items[i];\n    if (group_isGroup(item) && !item.data.isPGTextItem) {\n      group_ungroupLoop(item, false\n      /* recursive */\n      , setSelectedItems);\n      if (!item.hasChildren()) {\n        emptyGroups.push(item);\n      }\n    } else if (setSelectedItems) {\n      item.selected = true;\n    }\n  }\n  if (setSelectedItems) {\n    setSelectedItems();\n  } // remove all empty groups after ungrouping\n  for (var j = 0; j < emptyGroups.length; j++) {\n    emptyGroups[j].remove();\n  } // @todo: enable/disable grouping icons\n  if (onUpdateImage) {\n    onUpdateImage();\n  }\n};\n/**\n * Ungroups the selected items. Other items are deselected and the ungrouped items are selected.\n *\n * @param {!function} clearSelectedItems Function to clear Redux state's selected items\n * @param {!function} setSelectedItems Function to set Redux state with new list of selected items\n * @param {!function} onUpdateImage Function to let listeners know that SVG has changed.\n */\nvar group_ungroupSelection = function ungroupSelection(clearSelectedItems, setSelectedItems, onUpdateImage) {\n  var items = selection_getSelectedRootItems();\n  selection_clearSelection(clearSelectedItems);\n  ungroupItems(items, setSelectedItems, onUpdateImage);\n};\nvar getItemsGroup = function getItemsGroup(item) {\n  var itemParent = item.parent;\n  if (group_isGroup(itemParent)) {\n    return itemParent;\n  }\n  return null;\n};\nvar group_isGroupChild = function isGroupChild(item) {\n  var rootItem = getRootItem(item);\n  return group_isGroup(rootItem);\n};\nvar group_shouldShowGroup = function shouldShowGroup() {\n  var items = selection_getSelectedRootItems();\n  return items.length > 1;\n};\nvar group_shouldShowUngroup = function shouldShowUngroup() {\n  var items = selection_getSelectedRootItems();\n  for (var i = 0; i < items.length; i++) {\n    var item = items[i];\n    if (group_isGroup(item) && !item.data.isPGTextItem && item.children && item.children.length > 0) {\n      return true;\n    }\n  }\n  return false;\n};\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/helper/compound-path.js\nvar isCompoundPath = function isCompoundPath(item) {\n  return item && item.className === 'CompoundPath';\n};\nvar isCompoundPathChild = function isCompoundPathChild(item) {\n  if (item.parent) {\n    return item.parent.className === 'CompoundPath';\n  }\n  return false;\n};\nvar getItemsCompoundPath = function getItemsCompoundPath(item) {\n  var itemParent = item.parent;\n  if (isCompoundPath(itemParent)) {\n    return itemParent;\n  }\n  return null;\n};\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/helper/math.js\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n/** The ratio of the curve length to use for the handle length to convert squares into approximately circles. */\nvar HANDLE_RATIO = 0.3902628565;\nvar checkPointsClose = function checkPointsClose(startPos, eventPoint, threshold) {\n  var xOff = Math.abs(startPos.x - eventPoint.x);\n  var yOff = Math.abs(startPos.y - eventPoint.y);\n  if (xOff < threshold && yOff < threshold) {\n    return true;\n  }\n  return false;\n};\nvar getRandomInt = function getRandomInt(min, max) {\n  return Math.floor(Math.random() * (max - min)) + min;\n};\nvar getRandomBoolean = function getRandomBoolean() {\n  return getRandomInt(0, 2) === 1;\n}; // Thanks Mikko Mononen! https://github.com/memononen/stylii\nvar math_snapDeltaToAngle = function snapDeltaToAngle(delta, snapAngle) {\n  var angle = Math.atan2(delta.y, delta.x);\n  angle = Math.round(angle / snapAngle) * snapAngle;\n  var dirx = Math.cos(angle);\n  var diry = Math.sin(angle);\n  var d = dirx * delta.x + diry * delta.y;\n  return new paper_full_default.a.Point(dirx * d, diry * d);\n};\nvar math_getDepth = function _getDepth(item) {\n  var temp = item;\n  var depth = 0;\n  while (!(temp instanceof paper_full_default.a.Layer)) {\n    depth++;\n    if (temp.parent === null) {\n      // This item isn't attached to a layer, so it's not on the canvas and can't be compared.\n      return null;\n    }\n    temp = temp.parent;\n  }\n  return depth;\n};\nvar math_sortItemsByZIndex = function sortItemsByZIndex(a, b) {\n  if (a === null || b === null) {\n    return null;\n  } // Get to the same depth in the project tree\n  var tempA = a;\n  var tempB = b;\n  var aDepth = math_getDepth(a);\n  var bDepth = math_getDepth(b);\n  while (bDepth > aDepth) {\n    tempB = tempB.parent;\n    bDepth--;\n  }\n  while (aDepth > bDepth) {\n    tempA = tempA.parent;\n    aDepth--;\n  } // Step up until they share parents. When they share parents, compare indices.\n  while (tempA && tempB) {\n    if (tempB === tempA) {\n      return 0;\n    } else if (tempB.parent === tempA.parent) {\n      if (tempB.parent instanceof paper_full_default.a.CompoundPath) {\n        // Neither is on top of the other in a compound path. Return in order of decreasing size.\n        return Math.abs(tempB.area) - Math.abs(tempA.area);\n      }\n      return parseFloat(tempA.index) - parseFloat(tempB.index);\n    }\n    tempB = tempB.parent;\n    tempA = tempA.parent;\n  } // No shared hierarchy\n  return null;\n}; // Expand the size of the path by amount all around\nvar math_expandBy = function expandBy(path, amount) {\n  var center = path.position;\n  var pathArea = path.area;\n  var _iterator = _createForOfIteratorHelper(path.segments),\n      _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var seg = _step.value;\n      var delta = seg.point.subtract(center).normalize().multiply(amount);\n      seg.point = seg.point.add(delta); // If that made the path area smaller, go the other way.\n      if (path.area < pathArea) seg.point = seg.point.subtract(delta.multiply(2));\n      pathArea = path.area;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}; // Do for all nested items in groups\nvar math_doRecursively = function _doRecursively(item, func) {\n  if (item instanceof paper_full_default.a.Group) {\n    var _iterator2 = _createForOfIteratorHelper(item.children),\n        _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var child = _step2.value;\n        _doRecursively(child, func);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  } else {\n    func(item);\n  }\n}; // Make item clockwise. Drill down into groups.\nvar math_ensureClockwise = function ensureClockwise(root) {\n  math_doRecursively(root, function (item) {\n    if (item instanceof paper_full_default.a.PathItem) {\n      item.clockwise = true;\n    }\n  });\n}; // Scale item and its strokes by factor\nvar math_scaleWithStrokes = function scaleWithStrokes(root, factor, pivot) {\n  math_doRecursively(root, function (item) {\n    if (item instanceof paper_full_default.a.PointText) {\n      // Text outline size is controlled by text transform matrix, thus it's already scaled.\n      return;\n    }\n    if (item.strokeWidth) {\n      item.strokeWidth = item.strokeWidth * factor;\n    }\n  });\n  root.scale(factor, pivot);\n};\n/**\n * Get the size and position of a square, as in if the user were holding the shift key down while drawing the shape,\n * from the point where the drag started and the point where the mouse is currently positioned. (Note: This also works\n * for shapes like circles (\"square ovals\"), which fill the same dimensions.)\n * @param {!paper.Point} startPos The point where the user started dragging\n * @param {!paper.Point} eventPoint The point where the user has currently dragged to\n * @return {object} Information about the size and position of how the square should be drawn\n */\nvar math_getSquareDimensions = function getSquareDimensions(startPos, eventPoint) {\n  // These variables are used for determining the relative quadrant that the shape will appear in.\n  // So if you drag up and right, it'll show up above and to the right of where you started dragging, etc.\n  var offsetX = eventPoint.x - startPos.x;\n  var offsetY = eventPoint.y - startPos.y; // If the offset variables are zero, the shape ends up having zero width or height, which is bad.\n  // Deal with this by forcing them to be non-zero (we arbitrarily choose 1; any non-zero value would work).\n  offsetX = offsetX ? offsetX : 1;\n  offsetY = offsetY ? offsetY : 1; // The length of the shape is the greater of the X and Y offsets.\n  var offsetDistance = eventPoint.subtract(startPos).abs();\n  var length = Math.max(offsetDistance.x, offsetDistance.y);\n  var size = new paper_full_default.a.Point(length * offsetX / Math.abs(offsetX), length * offsetY / Math.abs(offsetY));\n  var position = startPos.add(size.multiply(0.5));\n  return {\n    size: size,\n    position: position\n  };\n};\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/helper/selection.js\nfunction selection_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = selection_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction selection_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return selection_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return selection_arrayLikeToArray(o, minLen); }\nfunction selection_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction selection_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\nfunction selection_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { selection_ownKeys(Object(source), true).forEach(function (key) { selection_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { selection_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\nfunction selection_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Wrapper for paper.project.getItems that excludes our helper items\n * @param {?object} options See paper.js docs for paper.Item.getItems\n * @return {Array<paper.Item>} items that match options\n */\nvar selection_getItems = function getItems(options) {\n  var newMatcher = function newMatcher(item) {\n    return !(item instanceof paper_full_default.a.Layer) && item.layer.data && item.layer.data.isPaintingLayer && !item.locked && !item.isClipMask() && !(item.data && item.data.isHelperItem) && (!options.match || options.match(item));\n  };\n  var newOptions = selection_objectSpread(selection_objectSpread({}, options), {}, {\n    match: newMatcher\n  });\n  return paper_full_default.a.project.getItems(newOptions);\n};\n/**\n * @param {boolean} includeGuides True if guide layer items like the bounding box should\n *     be included in the returned items.\n * @return {Array<paper.item>} all top-level (direct descendants of a paper.Layer) items\n */\nvar selection_getAllRootItems = function getAllRootItems(includeGuides) {\n  includeGuides = includeGuides || false;\n  var allItems = [];\n  var _iterator = selection_createForOfIteratorHelper(paper_full_default.a.project.layers),\n      _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var layer = _step.value;\n      var _iterator2 = selection_createForOfIteratorHelper(layer.children),\n          _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var child = _step2.value;\n          // don't give guides back\n          if (!includeGuides && child.guide) {\n            continue;\n          }\n          allItems.push(child);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return allItems;\n};\n/**\n * @return {Array<paper.item>} all top-level (direct descendants of a paper.Layer) items\n *     that aren't guide items or helper items.\n */\nvar getAllSelectableRootItems = function getAllSelectableRootItems() {\n  var allItems = selection_getAllRootItems();\n  var selectables = [];\n  for (var i = 0; i < allItems.length; i++) {\n    if (allItems[i].data && !allItems[i].data.isHelperItem) {\n      selectables.push(allItems[i]);\n    }\n  }\n  return selectables;\n};\nvar selectItemSegments = function selectItemSegments(item, state) {\n  if (item.children) {\n    for (var i = 0; i < item.children.length; i++) {\n      var child = item.children[i];\n      if (child.children && child.children.length > 0) {\n        selectItemSegments(child, state);\n      } else {\n        child.fullySelected = state;\n      }\n    }\n  } else {\n    for (var _i = 0; _i < item.segments.length; _i++) {\n      item.segments[_i].selected = state;\n    }\n  }\n};\nvar selection_setGroupSelection = function _setGroupSelection(root, selected, fullySelected) {\n  root.fullySelected = fullySelected;\n  root.selected = selected; // select children of compound-path or group\n  if (isCompoundPath(root) || group_isGroup(root)) {\n    var children = root.children;\n    if (children) {\n      var _iterator3 = selection_createForOfIteratorHelper(children),\n          _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var child = _step3.value;\n          if (group_isGroup(child)) {\n            _setGroupSelection(child, selected, fullySelected);\n          } else {\n            child.fullySelected = fullySelected;\n            child.selected = selected;\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n  }\n};\nvar selection_setItemSelection = function setItemSelection(item, state, fullySelected) {\n  var parentGroup = getItemsGroup(item);\n  var itemsCompoundPath = getItemsCompoundPath(item); // if selection is in a group, select group\n  if (parentGroup) {\n    // do it recursive\n    setItemSelection(parentGroup, state, fullySelected);\n  } else if (itemsCompoundPath) {\n    selection_setGroupSelection(itemsCompoundPath, state, fullySelected);\n  } else {\n    if (item.data && item.data.noSelect) {\n      return;\n    }\n    selection_setGroupSelection(item, state, fullySelected);\n  }\n};\n/** @return {boolean} true if anything was selected */\nvar selectAllItems = function selectAllItems() {\n  var items = getAllSelectableRootItems();\n  if (items.length === 0) return false;\n  for (var i = 0; i < items.length; i++) {\n    selection_setItemSelection(items[i], true);\n  }\n  return true;\n};\n/** @return {boolean} true if anything was selected */\nvar selectAllSegments = function selectAllSegments() {\n  var items = getAllSelectableRootItems();\n  if (items.length === 0) return false;\n  for (var i = 0; i < items.length; i++) {\n    selectItemSegments(items[i], true);\n  }\n  return true;\n};\n/** @param {!function} dispatchClearSelect Function to update the Redux select state */\nvar selection_clearSelection = function clearSelection(dispatchClearSelect) {\n  paper_full_default.a.project.deselectAll();\n  dispatchClearSelect();\n};\n/**\n * This gets all selected non-grouped items and groups\n * (alternative to paper.project.selectedItems, which includes\n * group children in addition to the group)\n * @return {Array<paper.Item>} in increasing Z order.\n */\nvar selection_getSelectedRootItems = function getSelectedRootItems() {\n  var allItems = getAllSelectableRootItems();\n  var items = [];\n  var _iterator4 = selection_createForOfIteratorHelper(allItems),\n      _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var item = _step4.value;\n      if (item.selected) {\n        items.push(item);\n      } else if (item instanceof paper_full_default.a.CompoundPath) {\n        // Consider a compound path selected if any of its paths are selected\n        var _iterator5 = selection_createForOfIteratorHelper(item.children),\n            _step5;\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var child = _step5.value;\n            if (child.selected) {\n              items.push(item);\n              break;\n            }\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n      }\n    } // sort items by index (0 at bottom)\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n  items.sort(function (a, b) {\n    return parseFloat(a.index) - parseFloat(b.index);\n  });\n  return items;\n};\n/**\n * This gets all selected items that are as deeply nested as possible. Does not\n * return the parent groups.\n * @return {Array<paper.Item>} in increasing Z order.\n */\nvar selection_getSelectedLeafItems = function getSelectedLeafItems() {\n  var allItems = paper_full_default.a.project.selectedItems;\n  var items = [];\n  for (var i = 0; i < allItems.length; i++) {\n    var item = allItems[i];\n    if (!(item instanceof paper_full_default.a.Layer) && !group_isGroup(item) && item.data && !item.data.isSelectionBound) {\n      items.push(item);\n    }\n  }\n  items.sort(math_sortItemsByZIndex);\n  return items;\n};\n/**\n * This gets all selected path segments.\n * @return {Array<paper.Segment>} selected segments\n */\nvar getSelectedSegments = function getSelectedSegments() {\n  var selected = selection_getSelectedLeafItems();\n  var segments = [];\n  var _iterator6 = selection_createForOfIteratorHelper(selected),\n      _step6;\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var item = _step6.value;\n      if (!item.segments) {\n        continue;\n      }\n      var _iterator7 = selection_createForOfIteratorHelper(item.segments),\n          _step7;\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var seg = _step7.value;\n          if (seg.selected) {\n            segments.push(seg);\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n  return segments;\n};\nvar _deleteItemSelection = function _deleteItemSelection(items, onUpdateImage) {\n  // @todo: Update toolbar state on change\n  if (items.length === 0) {\n    return false;\n  }\n  for (var i = 0; i < items.length; i++) {\n    items[i].remove();\n  }\n  onUpdateImage();\n  return true;\n}; // Return true if anything was removed\nvar _removeSelectedSegments = function _removeSelectedSegments(items, onUpdateImage) {\n  var segmentsToRemove = [];\n  for (var i = 0; i < items.length; i++) {\n    if (!items[i].segments) continue;\n    var segments = items[i].segments;\n    for (var j = 0; j < segments.length; j++) {\n      var seg = segments[j];\n      if (seg.selected) {\n        segmentsToRemove.push(seg);\n      }\n    }\n  }\n  var removedSegments = false;\n  for (var _i2 = 0; _i2 < segmentsToRemove.length; _i2++) {\n    var _seg = segmentsToRemove[_i2];\n    _seg.remove();\n    removedSegments = true;\n  }\n  if (removedSegments) {\n    onUpdateImage();\n  }\n  return removedSegments;\n}; // Return whether anything was deleted\nvar selection_deleteSelection = function deleteSelection(mode, onUpdateImage) {\n  if (mode === Modes.RESHAPE) {\n    var _selectedItems = selection_getSelectedLeafItems(); // If there are points selected remove them. If not delete the item selected.\n    if (_removeSelectedSegments(_selectedItems, onUpdateImage)) {\n      return true;\n    }\n    return _deleteItemSelection(_selectedItems, onUpdateImage);\n  }\n  var selectedItems = selection_getSelectedRootItems();\n  return _deleteItemSelection(selectedItems, onUpdateImage);\n};\nvar cloneSelection = function cloneSelection(recursive, onUpdateImage) {\n  var selectedItems = recursive ? selection_getSelectedLeafItems() : selection_getSelectedRootItems();\n  for (var i = 0; i < selectedItems.length; i++) {\n    var item = selectedItems[i];\n    item.clone();\n    item.selected = false;\n  }\n  onUpdateImage();\n};\nvar selection_checkBoundsItem = function _checkBoundsItem(selectionRect, item, event) {\n  var itemBounds = new paper_full_default.a.Path([item.localToGlobal(item.internalBounds.topLeft), item.localToGlobal(item.internalBounds.topRight), item.localToGlobal(item.internalBounds.bottomRight), item.localToGlobal(item.internalBounds.bottomLeft)]);\n  itemBounds.closed = true;\n  itemBounds.guide = true;\n  for (var i = 0; i < itemBounds.segments.length; i++) {\n    var seg = itemBounds.segments[i];\n    if (selectionRect.contains(seg.point) || i === 0 && selectionRect.getIntersections(itemBounds).length > 0) {\n      if (event.modifiers.shift && item.selected) {\n        selection_setItemSelection(item, false);\n      } else {\n        selection_setItemSelection(item, true);\n      }\n      itemBounds.remove();\n      return true;\n    }\n  }\n  itemBounds.remove();\n};\nvar selection_handleRectangularSelectionItems = function _handleRectangularSelectionItems(item, event, rect, mode, root) {\n  if (isPathItem(item)) {\n    var segmentMode = false; // first round checks for segments inside the selectionRect\n    for (var j = 0; j < item.segments.length; j++) {\n      var seg = item.segments[j];\n      if (rect.contains(seg.point)) {\n        if (mode === Modes.RESHAPE) {\n          if (event.modifiers.shift && seg.selected) {\n            seg.selected = false;\n          } else {\n            seg.selected = true;\n          }\n          segmentMode = true;\n        } else {\n          if (event.modifiers.shift && item.selected) {\n            selection_setItemSelection(root, false);\n          } else {\n            selection_setItemSelection(root, true, true\n            /* fullySelected */\n            );\n          }\n          return false;\n        }\n      }\n    } // second round checks for path intersections\n    var intersections = item.getIntersections(rect);\n    if (intersections.length > 0 && !segmentMode) {\n      // if in reshape mode, select the curves that intersect\n      // with the selectionRect\n      if (mode === Modes.RESHAPE) {\n        for (var k = 0; k < intersections.length; k++) {\n          var curve = intersections[k].curve; // intersections contains every curve twice because\n          // the selectionRect intersects a circle always at\n          // two points. so we skip every other curve\n          if (k % 2 === 1) {\n            continue;\n          }\n          if (event.modifiers.shift) {\n            curve.selected = !curve.selected;\n          } else {\n            curve.selected = true;\n          }\n        }\n      } else {\n        if (event.modifiers.shift && item.selected) {\n          selection_setItemSelection(item, false);\n        } else {\n          selection_setItemSelection(item, true);\n        }\n        return false;\n      }\n    } // @todo: Update toolbar state on change\n  } else if (isBoundsItem(item)) {\n    if (selection_checkBoundsItem(rect, item, event)) {\n      return false;\n    }\n  }\n  return true;\n}; // if the rectangular selection found a group, drill into it recursively\nvar selection_rectangularSelectionGroupLoop = function _rectangularSelectionGroupLoop(group, rect, root, event, mode) {\n  for (var i = 0; i < group.children.length; i++) {\n    var child = group.children[i];\n    if (group_isGroup(child) || isCompoundPathItem(child)) {\n      _rectangularSelectionGroupLoop(child, rect, root, event, mode);\n    } else {\n      selection_handleRectangularSelectionItems(child, event, rect, mode, root);\n    }\n  }\n  return true;\n};\n/**\n * Called after drawing a selection rectangle in a select mode. In reshape mode, this\n * selects all control points and curves within the rectangle. In select mode, this\n * selects all items and groups that intersect the rectangle\n * @param {!MouseEvent} event The mouse event to draw the rectangle\n * @param {!paper.Rect} rect The selection rectangle\n * @param {Modes} mode The mode of the paint editor when drawing the rectangle\n */\nvar selection_processRectangularSelection = function processRectangularSelection(event, rect, mode) {\n  var allItems = getAllSelectableRootItems();\n  for (var i = 0; i < allItems.length; i++) {\n    var item = allItems[i];\n    if (mode === Modes.RESHAPE && isPGTextItem(getRootItem(item))) {\n      continue;\n    }\n    if (group_isGroup(item) || isCompoundPathItem(item)) {\n      // check for item segment points inside\n      selection_rectangularSelectionGroupLoop(item, rect, item, event, mode);\n    } else {\n      selection_handleRectangularSelectionItems(item, event, rect, mode, item);\n    }\n  }\n};\n/**\n * When switching to the select tool while having a child object of a\n * compound path selected, deselect the child and select the compound path\n * instead. (otherwise the compound path breaks because of scale-grouping)\n */\nvar selection_selectRootItem = function selectRootItem() {\n  var items = selection_getSelectedLeafItems();\n  var _iterator8 = selection_createForOfIteratorHelper(items),\n      _step8;\n  try {\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var item = _step8.value;\n      if (isCompoundPathChild(item)) {\n        var cp = getItemsCompoundPath(item);\n        selection_setItemSelection(cp, true, true\n        /* fullySelected */\n        );\n      }\n      var rootItem = getRootItem(item);\n      if (item !== rootItem) {\n        selection_setItemSelection(rootItem, true, true\n        /* fullySelected */\n        );\n      }\n    }\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n};\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/helper/guides.js\nfunction guides_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = guides_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction guides_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return guides_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return guides_arrayLikeToArray(o, minLen); }\nfunction guides_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar GUIDE_BLUE = '#009dec';\nvar GUIDE_GREY = '#aaaaaa';\nvar guides_setDefaultGuideStyle = function setDefaultGuideStyle(item) {\n  item.strokeWidth = 1 / paper_full_default.a.view.zoom;\n  item.opacity = 1;\n  item.blendMode = 'normal';\n  item.guide = true;\n};\nvar guides_hoverItem = function hoverItem(item) {\n  var segments = item.segments;\n  var clone = new paper_full_default.a.Path(segments);\n  guides_setDefaultGuideStyle(clone);\n  if (item.closed) {\n    clone.closed = true;\n  }\n  clone.parent = getGuideLayer();\n  clone.position = item.position;\n  clone.strokeColor = GUIDE_BLUE;\n  clone.fillColor = null;\n  clone.data.isHelperItem = true;\n  clone.data.origItem = item;\n  clone.bringToFront();\n  return clone;\n};\nvar guides_hoverBounds = function hoverBounds(item, expandBy) {\n  var bounds = item.internalBounds;\n  if (expandBy) {\n    bounds = bounds.expand(expandBy);\n  }\n  var rect = new paper_full_default.a.Path.Rectangle(bounds);\n  rect.matrix = item.matrix;\n  guides_setDefaultGuideStyle(rect);\n  rect.parent = getGuideLayer();\n  rect.strokeColor = GUIDE_BLUE;\n  rect.fillColor = null;\n  rect.data.isHelperItem = true;\n  rect.data.origItem = item;\n  rect.bringToFront();\n  return rect;\n};\nvar guides_rectSelect = function rectSelect(event, color) {\n  var half = new paper_full_default.a.Point(0.5 / paper_full_default.a.view.zoom, 0.5 / paper_full_default.a.view.zoom);\n  var start = event.downPoint.add(half);\n  var end = event.point.add(half);\n  var rect = new paper_full_default.a.Path.Rectangle(start, end);\n  var zoom = 1.0 / paper_full_default.a.view.zoom;\n  guides_setDefaultGuideStyle(rect);\n  if (!color) color = GUIDE_GREY;\n  rect.parent = getGuideLayer();\n  rect.strokeColor = color;\n  rect.data.isRectSelect = true;\n  rect.data.isHelperItem = true;\n  rect.dashArray = [3.0 * zoom, 3.0 * zoom];\n  return rect;\n};\nvar getGuideColor = function getGuideColor() {\n  return GUIDE_BLUE;\n};\nvar guides_removePaperItemsByDataTags = function _removePaperItemsByDataTags(tags) {\n  var allItems = selection_getAllRootItems(true);\n  var _iterator = guides_createForOfIteratorHelper(allItems),\n      _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var item = _step.value;\n      var _iterator2 = guides_createForOfIteratorHelper(tags),\n          _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var tag = _step2.value;\n          if (item.data && item.data[tag]) {\n            item.remove();\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n};\nvar guides_removePaperItemsByTags = function _removePaperItemsByTags(tags) {\n  var allItems = selection_getAllRootItems(true);\n  var _iterator3 = guides_createForOfIteratorHelper(allItems),\n      _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var item = _step3.value;\n      var _iterator4 = guides_createForOfIteratorHelper(tags),\n          _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var tag = _step4.value;\n          if (item[tag]) {\n            item.remove();\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n};\nvar guides_removeBoundsPath = function removeBoundsPath() {\n  guides_removePaperItemsByDataTags(['isSelectionBound', 'isRotHandle', 'isScaleHandle']);\n};\nvar guides_removeBoundsHandles = function removeBoundsHandles() {\n  guides_removePaperItemsByDataTags(['isRotHandle', 'isScaleHandle']);\n};\nvar removeAllGuides = function removeAllGuides() {\n  guides_removePaperItemsByTags(['guide']);\n};\nvar removeHitPoint = function removeHitPoint() {\n  guides_removePaperItemsByDataTags(['isHitPoint']);\n};\nvar guides_drawHitPoint = function drawHitPoint(point) {\n  removeHitPoint();\n  if (point) {\n    var hitPoint = paper_full_default.a.Path.Circle(point, 4 / paper_full_default.a.view.zoom\n    /* radius */\n    );\n    hitPoint.strokeWidth = 1 / paper_full_default.a.view.zoom;\n    hitPoint.strokeColor = GUIDE_BLUE;\n    hitPoint.fillColor = new paper_full_default.a.Color(1, 1, 1, 0.5);\n    hitPoint.parent = getGuideLayer();\n    hitPoint.data.isHitPoint = true;\n    hitPoint.data.isHelperItem = true;\n  }\n};\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/helper/bitmap.js\nfunction bitmap_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = bitmap_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction bitmap_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return bitmap_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return bitmap_arrayLikeToArray(o, minLen); }\nfunction bitmap_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar forEachLinePoint = function forEachLinePoint(point1, point2, callback) {\n  // Bresenham line algorithm\n  var x1 = ~~point1.x;\n  var x2 = ~~point2.x;\n  var y1 = ~~point1.y;\n  var y2 = ~~point2.y;\n  var dx = Math.abs(x2 - x1);\n  var dy = Math.abs(y2 - y1);\n  var sx = x1 < x2 ? 1 : -1;\n  var sy = y1 < y2 ? 1 : -1;\n  var err = dx - dy;\n  callback(x1, y1);\n  while (x1 !== x2 || y1 !== y2) {\n    var e2 = err * 2;\n    if (e2 > -dy) {\n      err -= dy;\n      x1 += sx;\n    }\n    if (e2 < dx) {\n      err += dx;\n      y1 += sy;\n    }\n    callback(x1, y1);\n  }\n};\n/**\n * @param {!number} a Coefficient in ax^2 + bx + c = 0\n * @param {!number} b Coefficient in ax^2 + bx + c = 0\n * @param {!number} c Coefficient in ax^2 + bx + c = 0\n * @return {Array<number>} Array of 2 solutions, with the larger solution first\n */\nvar solveQuadratic_ = function solveQuadratic_(a, b, c) {\n  var soln1 = (-b + Math.sqrt(b * b - 4 * a * c)) / 2 / a;\n  var soln2 = (-b - Math.sqrt(b * b - 4 * a * c)) / 2 / a;\n  return soln1 > soln2 ? [soln1, soln2] : [soln2, soln1];\n};\n/**\n * @param {!object} options drawing options\n * @param {!number} options.centerX center of ellipse, x\n * @param {!number} options.centerY center of ellipse, y\n * @param {!number} options.radiusX major radius of ellipse\n * @param {!number} options.radiusY minor radius of ellipse\n * @param {!number} options.shearSlope slope of the sheared x axis\n * @param {?boolean} options.isFilled true if isFilled\n * @param {?function} options.drawFn The function called on each point in the outline, used only\n *     if isFilled is false.\n * @param {!CanvasRenderingContext2D} context for drawing\n * @return {boolean} true if anything was drawn, false if not\n */\nvar drawShearedEllipse_ = function drawShearedEllipse_(options, context) {\n  var centerX = ~~options.centerX;\n  var centerY = ~~options.centerY;\n  var radiusX = ~~Math.abs(options.radiusX) - .5;\n  var radiusY = ~~Math.abs(options.radiusY) - .5;\n  var shearSlope = options.shearSlope;\n  var isFilled = options.isFilled;\n  var drawFn = options.drawFn;\n  if (shearSlope === Infinity || radiusX < 1 || radiusY < 1) {\n    return false;\n  } // A, B, and C represent Ax^2 + Bxy + Cy^2 = 1 coefficients in a skewed ellipse formula\n  var A = 1 / radiusX / radiusX + shearSlope * shearSlope / radiusY / radiusY;\n  var B = -2 * shearSlope / radiusY / radiusY;\n  var C = 1 / radiusY / radiusY; // Line with slope1 intersects the ellipse where its derivative is 1\n  var slope1 = (-2 * A - B) / (2 * C + B); // Line with slope2 intersects the ellipse where its derivative is -1\n  var slope2 = (-(2 * A) + B) / (-(2 * C) + B);\n  var verticalStepsFirst = slope1 > slope2;\n  /**\n   * Vertical stepping portion of ellipse drawing algorithm\n   * @param {!number} startY y to start drawing from\n   * @param {!function} conditionFn function which should become true when we should stop stepping\n   * @return {object} last point drawn to the canvas, or null if no points drawn\n   */\n  var drawEllipseStepVertical_ = function drawEllipseStepVertical_(startY, conditionFn) {\n    // Points on the ellipse\n    var y = startY;\n    var x = solveQuadratic_(A, B * y, C * y * y - 1); // last pixel position at which a draw was performed\n    var pY;\n    var pX1;\n    var pX2;\n    while (conditionFn(x[0], y)) {\n      pY = Math.floor(y);\n      pX1 = Math.floor(x[0]);\n      pX2 = Math.floor(x[1]);\n      if (isFilled) {\n        context.fillRect(centerX - pX1 - 1, centerY + pY, pX1 - pX2 + 1, 1);\n        context.fillRect(centerX + pX2, centerY - pY - 1, pX1 - pX2 + 1, 1);\n      } else {\n        drawFn(centerX - pX1 - 1, centerY + pY);\n        drawFn(centerX + pX1, centerY - pY - 1);\n      }\n      y--;\n      x = solveQuadratic_(A, B * y, C * y * y - 1);\n    }\n    return pX1 || pY ? {\n      x: pX1,\n      y: pY\n    } : null;\n  };\n  /**\n   * Horizontal stepping portion of ellipse drawing algorithm\n   * @param {!number} startX x to start drawing from\n   * @param {!function} conditionFn function which should become false when we should stop stepping\n   * @return {object} last point drawn to the canvas, or null if no points drawn\n   */\n  var drawEllipseStepHorizontal_ = function drawEllipseStepHorizontal_(startX, conditionFn) {\n    // Points on the ellipse\n    var x = startX;\n    var y = solveQuadratic_(C, B * x, A * x * x - 1); // last pixel position at which a draw was performed\n    var pX;\n    var pY1;\n    var pY2;\n    while (conditionFn(x, y[0])) {\n      pX = Math.floor(x);\n      pY1 = Math.floor(y[0]);\n      pY2 = Math.floor(y[1]);\n      if (isFilled) {\n        context.fillRect(centerX - pX - 1, centerY + pY2, 1, pY1 - pY2 + 1);\n        context.fillRect(centerX + pX, centerY - pY1 - 1, 1, pY1 - pY2 + 1);\n      } else {\n        drawFn(centerX - pX - 1, centerY + pY1);\n        drawFn(centerX + pX, centerY - pY1 - 1);\n      }\n      x++;\n      y = solveQuadratic_(C, B * x, A * x * x - 1);\n    }\n    return pX || pY1 ? {\n      x: pX,\n      y: pY1\n    } : null;\n  }; // Last point drawn\n  var lastPoint;\n  if (verticalStepsFirst) {\n    var forwardLeaning = false;\n    if (slope1 > 0) forwardLeaning = true; // step vertically\n    lastPoint = drawEllipseStepVertical_(forwardLeaning ? -radiusY : radiusY, function (x, y) {\n      if (x === 0 && y > 0) return true;\n      if (x === 0 && y < 0) return false;\n      return y / x > slope1;\n    }); // step horizontally while slope is flat\n    lastPoint = drawEllipseStepHorizontal_(lastPoint ? -lastPoint.x + .5 : .5, function (x, y) {\n      return y / x > slope2;\n    }) || {\n      x: -lastPoint.x - .5,\n      y: -lastPoint.y - .5\n    }; // step vertically until back to start\n    drawEllipseStepVertical_(lastPoint.y - .5, function (x, y) {\n      if (forwardLeaning) return y > -radiusY;\n      return y > radiusY;\n    });\n  } else {\n    // step horizontally forward\n    lastPoint = drawEllipseStepHorizontal_(.5, function (x, y) {\n      return y / x > slope2;\n    }); // step vertically while slope is steep\n    lastPoint = drawEllipseStepVertical_(lastPoint ? lastPoint.y - .5 : radiusY, function (x, y) {\n      if (x === 0 && y > 0) return true;\n      if (x === 0 && y < 0) return false;\n      return y / x > slope1;\n    }) || lastPoint; // step horizontally until back to start\n    drawEllipseStepHorizontal_(-lastPoint.x + .5, function (x) {\n      return x < 0;\n    });\n  }\n  return true;\n};\n/**\n * @param {!number} size The diameter of the brush\n * @param {!string} color The css color of the brush\n * @param {?boolean} isEraser True if we want the brush mark for the eraser\n * @return {HTMLCanvasElement} a canvas with the brush mark printed on it\n */\nvar bitmap_getBrushMark = function getBrushMark(size, color, isEraser) {\n  size = ~~size;\n  var canvas = document.createElement('canvas');\n  var roundedUpRadius = Math.ceil(size / 2);\n  canvas.width = roundedUpRadius * 2;\n  canvas.height = roundedUpRadius * 2;\n  var context = canvas.getContext('2d',{willReadFrequently:true});\n  context.imageSmoothingEnabled = false;\n  context.fillStyle = isEraser ? 'white' : color; // Small squares for pixel artists\n  if (size <= 5) {\n    var offset = 0;\n    if (size % 2) offset = 1;\n    if (isEraser) {\n      context.fillStyle = getGuideColor();\n      context.fillRect(offset, offset, size, size);\n      context.fillStyle = 'white';\n      context.fillRect(offset + 1, offset + 1, size - 2, size - 2);\n    } else {\n      context.fillRect(offset, offset, size, size);\n    }\n  } else {\n    drawShearedEllipse_({\n      centerX: size / 2,\n      centerY: size / 2,\n      radiusX: size / 2,\n      radiusY: size / 2,\n      shearSlope: 0,\n      isFilled: true\n    }, context);\n    if (isEraser) {\n      // Add outline\n      context.fillStyle = getGuideColor();\n      drawShearedEllipse_({\n        centerX: size / 2,\n        centerY: size / 2,\n        radiusX: size / 2,\n        radiusY: size / 2,\n        shearSlope: 0,\n        isFilled: false,\n        drawFn: function drawFn(x, y) {\n          return context.fillRect(x, y, 1, 1);\n        }\n      }, context);\n    }\n  }\n  return canvas;\n};\n/**\n * Draw an ellipse, given the original axis-aligned radii and\n * an affine transformation. Returns false if the ellipse could\n * not be drawn; for instance, the matrix is non-invertible.\n *\n * @param {!options} options Parameters for the ellipse\n * @param {!paper.Point} options.position Center of ellipse\n * @param {!number} options.radiusX x-aligned radius of ellipse\n * @param {!number} options.radiusY y-aligned radius of ellipse\n * @param {!paper.Matrix} options.matrix affine transformation matrix\n * @param {?boolean} options.isFilled true if isFilled\n * @param {?number} options.thickness Thickness of outline, used only if isFilled is false.\n * @param {!CanvasRenderingContext2D} context for drawing\n * @return {boolean} true if anything was drawn, false if not\n */\nvar bitmap_drawEllipse = function drawEllipse(options, context) {\n  var positionX = options.position.x;\n  var positionY = options.position.y;\n  var radiusX = options.radiusX;\n  var radiusY = options.radiusY;\n  var matrix = options.matrix;\n  var isFilled = options.isFilled;\n  var thickness = options.thickness;\n  var drawFn = null;\n  if (!matrix.isInvertible()) return false;\n  var inverse = matrix.clone().invert();\n  var isGradient = context.fillStyle instanceof CanvasGradient; // If drawing a gradient, we need to draw the shape onto a temporary canvas, then draw the gradient atop that canvas\n  // only where the shape appears. drawShearedEllipse draws some pixels twice, which would be a problem if the\n  // gradient fades to transparent as those pixels would end up looking more opaque. Instead, mask in the gradient.\n  // https://github.com/LLK/scratch-paint/issues/1152\n  // Outlines are drawn as a series of brush mark images and as such can't be drawn as gradients in the first place.\n  var origContext;\n  var tmpCanvas;\n  var _context$canvas = context.canvas,\n      canvasWidth = _context$canvas.width,\n      canvasHeight = _context$canvas.height;\n  if (isGradient) {\n    tmpCanvas = layer_createCanvas(canvasWidth, canvasHeight);\n    origContext = context;\n    context = tmpCanvas.getContext('2d',{willReadFrequently:true});\n  }\n  if (!isFilled) {\n    var brushMark = bitmap_getBrushMark(thickness, isGradient ? 'black' : context.fillStyle);\n    var roundedUpRadius = Math.ceil(thickness / 2);\n    drawFn = function drawFn(x, y) {\n      context.drawImage(brushMark, ~~x - roundedUpRadius, ~~y - roundedUpRadius);\n    };\n  } // Calculate the ellipse formula\n  // A, B, and C represent Ax^2 + Bxy + Cy^2 = 1 coefficients in a transformed ellipse formula\n  var A = inverse.a * inverse.a / radiusX / radiusX + inverse.b * inverse.b / radiusY / radiusY;\n  var B = 2 * inverse.a * inverse.c / radiusX / radiusX + 2 * inverse.b * inverse.d / radiusY / radiusY;\n  var C = inverse.c * inverse.c / radiusX / radiusX + inverse.d * inverse.d / radiusY / radiusY; // Convert to a sheared ellipse formula. All ellipses are equivalent to some sheared axis-aligned ellipse.\n  // radiusA, radiusB, and slope are parameters of a skewed ellipse with the above formula\n  var radiusB = 1 / Math.sqrt(C);\n  var radiusA = Math.sqrt(-4 * C / (B * B - 4 * A * C));\n  var slope = B / 2 / C;\n  var wasDrawn = drawShearedEllipse_({\n    centerX: positionX,\n    centerY: positionY,\n    radiusX: radiusA,\n    radiusY: radiusB,\n    shearSlope: slope,\n    isFilled: isFilled,\n    drawFn: drawFn\n  }, context); // Mask in the gradient only where the shape was drawn, and draw it. Then draw the gradientified shape onto the\n  // original canvas normally.\n  if (isGradient && wasDrawn) {\n    context.globalCompositeOperation = 'source-in';\n    context.fillStyle = origContext.fillStyle;\n    context.fillRect(0, 0, canvasWidth, canvasHeight);\n    origContext.drawImage(tmpCanvas, 0, 0);\n  }\n  return wasDrawn;\n};\nvar rowBlank_ = function rowBlank_(imageData, width, y) {\n  for (var x = 0; x < width; ++x) {\n    if (imageData.data[(y * width << 2) + (x << 2) + 3] !== 0) return false;\n  }\n  return true;\n};\nvar columnBlank_ = function columnBlank_(imageData, width, x, top, bottom) {\n  for (var y = top; y < bottom; ++y) {\n    if (imageData.data[(y * width << 2) + (x << 2) + 3] !== 0) return false;\n  }\n  return true;\n};\n/**\n * Get bounds around the contents of a raster, trimming transparent pixels from edges.\n * Adapted from Tim Down's https://gist.github.com/timdown/021d9c8f2aabc7092df564996f5afbbf\n * @param {paper.Raster} raster The raster to get the bounds around\n * @param {paper.Rectangle} [rect] Optionally, an alternative bounding rectangle to limit the check to.\n * @returns {paper.Rectangle} The bounds around the opaque area of the passed raster\n * (or opaque within the passed rectangle)\n */\nvar bitmap_getHitBounds = function getHitBounds(raster, rect) {\n  var bounds = rect || raster.bounds;\n  var width = bounds.width;\n  var imageData = raster.getImageData(bounds);\n  var top = 0;\n  var bottom = imageData.height;\n  var left = 0;\n  var right = imageData.width;\n  while (top < bottom && rowBlank_(imageData, width, top)) {\n    ++top;\n  }\n  while (bottom - 1 > top && rowBlank_(imageData, width, bottom - 1)) {\n    --bottom;\n  }\n  while (left < right && columnBlank_(imageData, width, left, top, bottom)) {\n    ++left;\n  }\n  while (right - 1 > left && columnBlank_(imageData, width, right - 1, top, bottom)) {\n    --right;\n  } // Center an empty bitmap\n  if (top === bottom) {\n    top = bottom = imageData.height / 2;\n  }\n  if (left === right) {\n    left = right = imageData.width / 2;\n  }\n  return new paper_full_default.a.Rectangle(left + bounds.left, top + bounds.top, right - left, bottom - top);\n};\nvar trim_ = function trim_(raster) {\n  var hitBounds = bitmap_getHitBounds(raster);\n  if (hitBounds.width && hitBounds.height) {\n    return raster.getSubRaster(bitmap_getHitBounds(raster));\n  }\n  return null;\n};\n/**\n * @param {boolean} shouldInsert True if the trimmed raster should be added to the active layer.\n * @returns {paper.Raster} raster layer with whitespace trimmed from ends, or null if there is\n * nothing on the raster layer.\n */\nvar bitmap_getTrimmedRaster = function getTrimmedRaster(shouldInsert) {\n  var trimmedRaster = trim_(getRaster());\n  if (!trimmedRaster) return null;\n  if (shouldInsert) {\n    paper_full_default.a.project.activeLayer.addChild(trimmedRaster);\n  } else {\n    trimmedRaster.remove();\n  }\n  return trimmedRaster;\n};\nvar bitmap_convertToBitmap = function convertToBitmap(clearSelectedItems, onUpdateImage, optFontInlineFn) {\n  // @todo if the active layer contains only rasters, drawing them directly to the raster layer\n  // would be more efficient.\n  selection_clearSelection(clearSelectedItems); // Export svg\n  var guideLayers = hideGuideLayers(true\n  /* includeRaster */\n  );\n  var bounds = paper_full_default.a.project.activeLayer.drawnBounds;\n  var svg = paper_full_default.a.project.exportSVG({\n    bounds: 'content',\n    matrix: new paper_full_default.a.Matrix().translate(-bounds.x, -bounds.y)\n  });\n  layer_showGuideLayers(guideLayers); // Get rid of anti-aliasing\n  // @todo get crisp text https://github.com/LLK/scratch-paint/issues/508\n  svg.setAttribute('shape-rendering', 'crispEdges');\n  var svgString = new XMLSerializer().serializeToString(svg);\n  if (optFontInlineFn) {\n    svgString = optFontInlineFn(svgString);\n  } else {\n    log.error('Fonts may be converted to bitmap incorrectly if fontInlineFn prop is not set on PaintEditor.');\n  } // Put anti-aliased SVG into image, and dump image back into canvas\n  var img = new Image();\n  img.onload = function () {\n    if (img.width && img.height) {\n      getRaster().drawImage(img, new paper_full_default.a.Point(Math.floor(bounds.topLeft.x), Math.floor(bounds.topLeft.y)));\n    }\n    for (var i = paper_full_default.a.project.activeLayer.children.length - 1; i >= 0; i--) {\n      var item = paper_full_default.a.project.activeLayer.children[i];\n      if (item.clipMask === false) {\n        item.remove();\n      } else {\n        // Resize mask for bitmap bounds\n        item.size.height = ART_BOARD_HEIGHT;\n        item.size.width = ART_BOARD_WIDTH;\n        item.setPosition(CENTER);\n      }\n    }\n    onUpdateImage(false\n    /* skipSnapshot */\n    , Formats.BITMAP\n    /* formatOverride */\n    );\n  };\n  img.onerror = function () {\n    // Fallback if browser does not support SVG data URIs in images.\n    // The problem with rasterize is that it will anti-alias.\n    var raster = paper_full_default.a.project.activeLayer.rasterize(72, false\n    /* insert */\n    );\n    raster.onLoad = function () {\n      if (raster.canvas.width && raster.canvas.height) {\n        getRaster().drawImage(raster.canvas, raster.bounds.topLeft);\n      }\n      paper_full_default.a.project.activeLayer.removeChildren();\n      onUpdateImage(false\n      /* skipSnapshot */\n      , Formats.BITMAP\n      /* formatOverride */\n      );\n    };\n  }; // Hash tags will break image loading without being encoded first\n  img.src = \"data:image/svg+xml;utf8,\".concat(encodeURIComponent(svgString));\n};\nvar bitmap_convertToVector = function convertToVector(clearSelectedItems, onUpdateImage) {\n  selection_clearSelection(clearSelectedItems);\n  var _iterator = bitmap_createForOfIteratorHelper(paper_full_default.a.project.activeLayer.children),\n      _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var item = _step.value;\n      if (item.clipMask === true) {\n        // Resize mask for vector bounds\n        item.size.height = MAX_WORKSPACE_BOUNDS.height;\n        item.size.width = MAX_WORKSPACE_BOUNDS.width;\n        item.setPosition(CENTER);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  bitmap_getTrimmedRaster(true\n  /* shouldInsert */\n  );\n  layer_clearRaster();\n  onUpdateImage(false\n  /* skipSnapshot */\n  , Formats.VECTOR\n  /* formatOverride */\n  );\n};\nvar getColor_ = function getColor_(x, y, context) {\n  return context.getImageData(x, y, 1, 1).data;\n};\nvar matchesColor_ = function matchesColor_(x, y, imageData, oldColor) {\n  var index = (y * imageData.width + x) * 4;\n  return imageData.data[index + 0] === oldColor[0] && imageData.data[index + 1] === oldColor[1] && imageData.data[index + 2] === oldColor[2] && imageData.data[index + 3] === oldColor[3];\n};\nvar colorPixel_ = function colorPixel_(x, y, imageData, newColor) {\n  var index = (y * imageData.width + x) * 4;\n  imageData.data[index + 0] = newColor[0];\n  imageData.data[index + 1] = newColor[1];\n  imageData.data[index + 2] = newColor[2];\n  imageData.data[index + 3] = newColor[3];\n};\n/**\n * Flood fill beginning at the given point.\n * Based on http://www.williammalone.com/articles/html5-canvas-javascript-paint-bucket-tool/\n *\n * @param {!int} x The x coordinate on the context at which to begin\n * @param {!int} y The y coordinate on the context at which to begin\n * @param {!ImageData} sourceImageData The image data to sample from. This is edited by the function.\n * @param {!ImageData} destImageData The image data to edit. May match sourceImageData. Should match\n *     size of sourceImageData.\n * @param {!Array<number>} newColor The color to replace with. A length 4 array [r, g, b, a].\n * @param {!Array<number>} oldColor The color to replace. A length 4 array [r, g, b, a].\n *     This must be different from newColor.\n * @param {!Array<Array<int>>} stack The stack of pixels we need to look at\n */\nvar floodFillInternal_ = function floodFillInternal_(x, y, sourceImageData, destImageData, newColor, oldColor, stack) {\n  while (y > 0 && matchesColor_(x, y - 1, sourceImageData, oldColor)) {\n    y--;\n  }\n  var lastLeftMatchedColor = false;\n  var lastRightMatchedColor = false;\n  for (; y < sourceImageData.height; y++) {\n    if (!matchesColor_(x, y, sourceImageData, oldColor)) break;\n    colorPixel_(x, y, sourceImageData, newColor);\n    colorPixel_(x, y, destImageData, newColor);\n    if (x > 0) {\n      if (matchesColor_(x - 1, y, sourceImageData, oldColor)) {\n        if (!lastLeftMatchedColor) {\n          stack.push([x - 1, y]);\n          lastLeftMatchedColor = true;\n        }\n      } else {\n        lastLeftMatchedColor = false;\n      }\n    }\n    if (x < sourceImageData.width - 1) {\n      if (matchesColor_(x + 1, y, sourceImageData, oldColor)) {\n        if (!lastRightMatchedColor) {\n          stack.push([x + 1, y]);\n          lastRightMatchedColor = true;\n        }\n      } else {\n        lastRightMatchedColor = false;\n      }\n    }\n  }\n};\n/**\n * Given a fill style string, get the color\n * @param {string} fillStyleString the fill style\n * @return {Array<int>} Color, a length 4 array\n */\nvar fillStyleToColor_ = function fillStyleToColor_(fillStyleString) {\n  var tmpCanvas = document.createElement('canvas');\n  tmpCanvas.width = 1;\n  tmpCanvas.height = 1;\n  var context = tmpCanvas.getContext('2d',{willReadFrequently:true});\n  context.fillStyle = fillStyleString;\n  context.fillRect(0, 0, 1, 1);\n  return context.getImageData(0, 0, 1, 1).data;\n};\n/**\n * Flood fill beginning at the given point\n * @param {!number} x The x coordinate on the context at which to begin\n * @param {!number} y The y coordinate on the context at which to begin\n * @param {!string} color A color string, which would go into context.fillStyle\n * @param {!HTMLCanvas2DContext} sourceContext The context from which to sample to determine where to flood fill\n * @param {!HTMLCanvas2DContext} destContext The context to which to draw. May match sourceContext. Should match\n *     the size of sourceContext.\n * @return {boolean} True if image changed, false otherwise\n */\nvar floodFill = function floodFill(x, y, color, sourceContext, destContext) {\n  x = ~~x;\n  y = ~~y;\n  var newColor = fillStyleToColor_(color);\n  var oldColor = getColor_(x, y, sourceContext);\n  var sourceImageData = sourceContext.getImageData(0, 0, sourceContext.canvas.width, sourceContext.canvas.height);\n  var destImageData = sourceImageData;\n  if (destContext !== sourceContext) {\n    destImageData = new ImageData(sourceContext.canvas.width, sourceContext.canvas.height);\n  }\n  if (oldColor[0] === newColor[0] && oldColor[1] === newColor[1] && oldColor[2] === newColor[2] && oldColor[3] === newColor[3]) {\n    // no-op\n    return false;\n  }\n  var stack = [[x, y]];\n  while (stack.length) {\n    var pop = stack.pop();\n    floodFillInternal_(pop[0], pop[1], sourceImageData, destImageData, newColor, oldColor, stack);\n  }\n  destContext.putImageData(destImageData, 0, 0);\n  return true;\n};\n/**\n * Replace all instances of the color at the given point\n * @param {!number} x The x coordinate on the context of the start color\n * @param {!number} y The y coordinate on the context of the start color\n * @param {!string} color A color string, which would go into context.fillStyle\n * @param {!HTMLCanvas2DContext} sourceContext The context from which to sample to determine where to flood fill\n * @param {!HTMLCanvas2DContext} destContext The context to which to draw. May match sourceContext. Should match\n * @return {boolean} True if image changed, false otherwise\n */\nvar floodFillAll = function floodFillAll(x, y, color, sourceContext, destContext) {\n  x = ~~x;\n  y = ~~y;\n  var newColor = fillStyleToColor_(color);\n  var oldColor = getColor_(x, y, sourceContext);\n  var sourceImageData = sourceContext.getImageData(0, 0, sourceContext.canvas.width, sourceContext.canvas.height);\n  var destImageData = sourceImageData;\n  if (destContext !== sourceContext) {\n    destImageData = new ImageData(sourceContext.canvas.width, sourceContext.canvas.height);\n  }\n  if (oldColor[0] === newColor[0] && oldColor[1] === newColor[1] && oldColor[2] === newColor[2] && oldColor[3] === newColor[3]) {\n    // no-op\n    return false;\n  }\n  for (var i = 0; i < sourceImageData.width; i++) {\n    for (var j = 0; j < sourceImageData.height; j++) {\n      if (matchesColor_(i, j, sourceImageData, oldColor)) {\n        colorPixel_(i, j, destImageData, newColor);\n      }\n    }\n  }\n  destContext.putImageData(destImageData, 0, 0);\n  return true;\n};\n/**\n * @param {!paper.Shape.Rectangle} rect The rectangle to draw to the canvas\n * @param {!HTMLCanvas2DContext} context The context in which to draw\n */\nvar bitmap_fillRect = function fillRect(rect, context) {\n  // No rotation component to matrix\n  if (rect.matrix.b === 0 && rect.matrix.c === 0) {\n    var width = rect.size.width * rect.matrix.a;\n    var height = rect.size.height * rect.matrix.d;\n    context.fillRect(Math.round(rect.matrix.tx - width / 2), Math.round(rect.matrix.ty - height / 2), Math.round(width), Math.round(height));\n    return;\n  }\n  var startPoint = rect.matrix.transform(new paper_full_default.a.Point(-rect.size.width / 2, -rect.size.height / 2));\n  var widthPoint = rect.matrix.transform(new paper_full_default.a.Point(rect.size.width / 2, -rect.size.height / 2));\n  var heightPoint = rect.matrix.transform(new paper_full_default.a.Point(-rect.size.width / 2, rect.size.height / 2));\n  var endPoint = rect.matrix.transform(new paper_full_default.a.Point(rect.size.width / 2, rect.size.height / 2));\n  var center = rect.matrix.transform(new paper_full_default.a.Point());\n  var points = [startPoint, widthPoint, heightPoint, endPoint].sort(function (a, b) {\n    return a.x - b.x;\n  });\n  var solveY = function solveY(point1, point2, x) {\n    if (point2.x === point1.x) return center.x > point1.x ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\n    return (point2.y - point1.y) / (point2.x - point1.x) * (x - point1.x) + point1.y;\n  };\n  for (var x = Math.round(points[0].x); x < Math.round(points[3].x); x++) {\n    var ys = [solveY(startPoint, widthPoint, x + .5), solveY(startPoint, heightPoint, x + .5), solveY(endPoint, widthPoint, x + .5), solveY(endPoint, heightPoint, x + .5)].sort(function (a, b) {\n      return a - b;\n    });\n    context.fillRect(x, Math.round(ys[1]), 1, Math.max(1, Math.round(ys[2]) - Math.round(ys[1])));\n  }\n};\n/**\n * @param {!paper.Shape.Rectangle} rect The rectangle to draw to the canvas\n * @param {!number} thickness The thickness of the outline\n * @param {!HTMLCanvas2DContext} context The context in which to draw\n */\nvar bitmap_outlineRect = function outlineRect(rect, thickness, context) {\n  var brushMark = bitmap_getBrushMark(thickness, context.fillStyle);\n  var roundedUpRadius = Math.ceil(thickness / 2);\n  var drawFn = function drawFn(x, y) {\n    context.drawImage(brushMark, ~~x - roundedUpRadius, ~~y - roundedUpRadius);\n  };\n  var isGradient = context.fillStyle instanceof CanvasGradient; // If drawing a gradient, we need to draw the shape onto a temporary canvas, then draw the gradient atop that canvas\n  // only where the shape appears. Outlines are drawn as a series of brush mark images and as such can't be drawn as\n  // gradients.\n  var origContext;\n  var tmpCanvas;\n  var _context$canvas2 = context.canvas,\n      canvasWidth = _context$canvas2.width,\n      canvasHeight = _context$canvas2.height;\n  if (isGradient) {\n    tmpCanvas = layer_createCanvas(canvasWidth, canvasHeight);\n    origContext = context;\n    context = tmpCanvas.getContext('2d',{willReadFrequently:true});\n  }\n  var startPoint = rect.matrix.transform(new paper_full_default.a.Point(-rect.size.width / 2, -rect.size.height / 2));\n  var widthPoint = rect.matrix.transform(new paper_full_default.a.Point(rect.size.width / 2, -rect.size.height / 2));\n  var heightPoint = rect.matrix.transform(new paper_full_default.a.Point(-rect.size.width / 2, rect.size.height / 2));\n  var endPoint = rect.matrix.transform(new paper_full_default.a.Point(rect.size.width / 2, rect.size.height / 2));\n  forEachLinePoint(startPoint, widthPoint, drawFn);\n  forEachLinePoint(startPoint, heightPoint, drawFn);\n  forEachLinePoint(endPoint, widthPoint, drawFn);\n  forEachLinePoint(endPoint, heightPoint, drawFn); // Mask in the gradient only where the shape was drawn, and draw it. Then draw the gradientified shape onto the\n  // original canvas normally.\n  if (isGradient) {\n    context.globalCompositeOperation = 'source-in';\n    context.fillStyle = origContext.fillStyle;\n    context.fillRect(0, 0, canvasWidth, canvasHeight);\n    origContext.drawImage(tmpCanvas, 0, 0);\n  }\n};\nvar bitmap_flipBitmapHorizontal = function flipBitmapHorizontal(canvas) {\n  var tmpCanvas = layer_createCanvas(canvas.width, canvas.height);\n  var context = tmpCanvas.getContext('2d',{willReadFrequently:true});\n  context.save();\n  context.scale(-1, 1);\n  context.drawImage(canvas, 0, 0, -tmpCanvas.width, tmpCanvas.height);\n  context.restore();\n  return tmpCanvas;\n};\nvar bitmap_flipBitmapVertical = function flipBitmapVertical(canvas) {\n  var tmpCanvas = layer_createCanvas(canvas.width, canvas.height);\n  var context = tmpCanvas.getContext('2d',{willReadFrequently:true});\n  context.save();\n  context.scale(1, -1);\n  context.drawImage(canvas, 0, 0, tmpCanvas.width, -tmpCanvas.height);\n  context.restore();\n  return tmpCanvas;\n};\nvar bitmap_scaleBitmap = function scaleBitmap(canvas, scale) {\n  var tmpCanvas = layer_createCanvas(Math.round(canvas.width * Math.abs(scale.x)), canvas.height);\n  if (scale.x < 0) {\n    canvas = bitmap_flipBitmapHorizontal(canvas);\n  }\n  tmpCanvas.getContext('2d',{willReadFrequently:true}).drawImage(canvas, 0, 0, tmpCanvas.width, tmpCanvas.height);\n  canvas = tmpCanvas;\n  tmpCanvas = layer_createCanvas(canvas.width, Math.round(canvas.height * Math.abs(scale.y)));\n  if (scale.y < 0) {\n    canvas = bitmap_flipBitmapVertical(canvas);\n  }\n  tmpCanvas.getContext('2d',{willReadFrequently:true}).drawImage(canvas, 0, 0, tmpCanvas.width, tmpCanvas.height);\n  return tmpCanvas;\n};\n/**\n * Given a raster, take the scale on the transform and apply it to the raster's canvas, then remove\n * the scale from the item's transform matrix. Do this only if scale.x or scale.y is less than 1.\n * @param {paper.Raster} item raster to change\n */\nvar bitmap_maybeApplyScaleToCanvas_ = function maybeApplyScaleToCanvas_(item) {\n  // context.drawImage will anti-alias the image if both width and height are reduced.\n  // However, it will preserve pixel colors if only one or the other is reduced, and\n  // imageSmoothingEnabled is set to false. Therefore, we can avoid aliasing by scaling\n  // down images in a 2 step process.\n  var decomposed = item.matrix.decompose(); // Decomposition order: translate, rotate, scale, skew\n  if (Math.abs(decomposed.scaling.x) < 1 && Math.abs(decomposed.scaling.y) < 1 && decomposed.scaling.x !== 0 && decomposed.scaling.y !== 0) {\n    item.canvas = bitmap_scaleBitmap(item.canvas, decomposed.scaling);\n    if (item.data && item.data.expanded) {\n      item.data.expanded.canvas = bitmap_scaleBitmap(item.data.expanded.canvas, decomposed.scaling);\n    } // Remove the scale from the item's matrix\n    item.matrix.append(new paper_full_default.a.Matrix().scale(new paper_full_default.a.Point(1 / decomposed.scaling.x, 1 / decomposed.scaling.y)));\n  }\n};\n/**\n * Given a raster, apply its transformation matrix to its canvas. Call maybeApplyScaleToCanvas_ first\n * to avoid introducing anti-aliasing to scaled-down rasters.\n * @param {paper.Raster} item raster to resolve transform of\n * @param {paper.Raster} destination raster to draw selection to\n */\nvar bitmap_commitArbitraryTransformation_ = function commitArbitraryTransformation_(item, destination) {\n  // Create a canvas to perform masking\n  var tmpCanvas = layer_createCanvas();\n  var context = tmpCanvas.getContext('2d',{willReadFrequently:true}); // Draw mask\n  var rect = new paper_full_default.a.Shape.Rectangle(new paper_full_default.a.Point(), item.size);\n  rect.matrix = item.matrix;\n  bitmap_fillRect(rect, context);\n  rect.remove();\n  context.globalCompositeOperation = 'source-in'; // Draw image onto mask\n  var m = item.matrix;\n  context.transform(m.a, m.b, m.c, m.d, m.tx, m.ty);\n  var canvas = item.canvas;\n  if (item.data && item.data.expanded) {\n    canvas = item.data.expanded.canvas;\n  }\n  context.transform(1, 0, 0, 1, -canvas.width / 2, -canvas.height / 2);\n  context.drawImage(canvas, 0, 0); // Draw temp canvas onto raster layer\n  destination.drawImage(tmpCanvas, new paper_full_default.a.Point());\n};\n/**\n * Given a raster item, take its transform matrix and apply it to its canvas. Try to avoid\n * introducing anti-aliasing.\n * @param {paper.Raster} selection raster to resolve transform of\n * @param {paper.Raster} bitmap raster to draw selection to\n */\nvar commitSelectionToBitmap = function commitSelectionToBitmap(selection, bitmap) {\n  if (!selection.matrix.isInvertible()) {\n    return;\n  }\n  bitmap_maybeApplyScaleToCanvas_(selection);\n  bitmap_commitArbitraryTransformation_(selection, bitmap);\n};\n/**\n * Converts a Paper.js color style (an item's fillColor or strokeColor) into a canvas-applicable color style.\n * Note that a \"color style\" as applied to an item is different from a plain paper.Color or paper.Gradient.\n * For instance, a gradient \"color style\" has origin and destination points whereas an unattached paper.Gradient\n * does not.\n * @param {paper.Color} color The color to convert to a canvas color/gradient\n * @param {CanvasRenderingContext2D} context The rendering context on which the style will be used\n * @returns {string|CanvasGradient} The canvas fill/stroke style.\n */\nvar _paperColorToCanvasStyle = function _paperColorToCanvasStyle(color, context) {\n  if (!color) return null;\n  if (color.type === 'gradient') {\n    var canvasGradient;\n    var origin = color.origin,\n        destination = color.destination;\n    if (color.gradient.radial) {\n      // Adapted from:\n      // https://github.com/paperjs/paper.js/blob/b081fd72c72cd61331313c3961edb48f3dfaffbd/src/style/Color.js#L926-L935\n      var highlight = color.highlight;\n      var start = highlight || origin;\n      var radius = destination.getDistance(origin);\n      if (highlight) {\n        var vector = highlight.subtract(origin);\n        if (vector.getLength() > radius) {\n          // Paper ¯\\_(ツ)_/¯\n          highlight = origin.add(vector.normalize(radius - 0.1));\n        }\n      }\n      canvasGradient = context.createRadialGradient(start.x, start.y, 0, origin.x, origin.y, radius);\n    } else {\n      canvasGradient = context.createLinearGradient(origin.x, origin.y, destination.x, destination.y);\n    }\n    var stops = color.gradient.stops; // Adapted from:\n    // https://github.com/paperjs/paper.js/blob/b081fd72c72cd61331313c3961edb48f3dfaffbd/src/style/Color.js#L940-L950\n    for (var i = 0, len = stops.length; i < len; i++) {\n      var stop = stops[i];\n      var offset = stop.offset;\n      canvasGradient.addColorStop(offset || i / (len - 1), stop.color.toCSS());\n    }\n    return canvasGradient;\n  }\n  return color.toCSS();\n};\n/**\n * @param {paper.Shape.Ellipse} oval Vector oval to convert\n * @param {paper.Raster} bitmap raster to draw selection\n * @return {bool} true if the oval was drawn\n */\nvar bitmap_commitOvalToBitmap = function commitOvalToBitmap(oval, bitmap) {\n  var radiusX = Math.abs(oval.size.width / 2);\n  var radiusY = Math.abs(oval.size.height / 2);\n  var context = bitmap.getContext('2d',{willReadFrequently:true});\n  var filled = oval.strokeWidth === 0;\n  var canvasColor = _paperColorToCanvasStyle(filled ? oval.fillColor : oval.strokeColor, context); // If the color is null (e.g. fully transparent/\"no fill\"), don't bother drawing anything\n  if (!canvasColor) return;\n  context.fillStyle = canvasColor;\n  var drew = bitmap_drawEllipse({\n    position: oval.position,\n    radiusX: radiusX,\n    radiusY: radiusY,\n    matrix: oval.matrix,\n    isFilled: filled,\n    thickness: oval.strokeWidth / paper_full_default.a.view.zoom\n  }, context);\n  return drew;\n};\n/**\n * @param {paper.Rectangle} rect Vector rectangle to convert\n * @param {paper.Raster} bitmap raster to draw selection to\n */\nvar bitmap_commitRectToBitmap = function commitRectToBitmap(rect, bitmap) {\n  var tmpCanvas = layer_createCanvas();\n  var context = tmpCanvas.getContext('2d',{willReadFrequently:true});\n  var filled = rect.strokeWidth === 0;\n  var canvasColor = _paperColorToCanvasStyle(filled ? rect.fillColor : rect.strokeColor, context); // If the color is null (e.g. fully transparent/\"no fill\"), don't bother drawing anything\n  if (!canvasColor) return;\n  context.fillStyle = canvasColor;\n  if (filled) {\n    bitmap_fillRect(rect, context);\n  } else {\n    bitmap_outlineRect(rect, rect.strokeWidth / paper_full_default.a.view.zoom, context);\n  }\n  bitmap.drawImage(tmpCanvas, new paper_full_default.a.Point());\n};\nvar bitmap_selectAllBitmap = function selectAllBitmap(clearSelectedItems) {\n  selection_clearSelection(clearSelectedItems); // Copy trimmed raster to active layer. If the raster layer was empty, nothing is selected.\n  var trimmedRaster = bitmap_getTrimmedRaster(true\n  /* shouldInsert */\n  );\n  if (trimmedRaster) {\n    trimmedRaster.selected = true;\n  } // Clear raster layer\n  layer_clearRaster();\n};\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/helper/view.js\nfunction view_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = view_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction view_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return view_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return view_arrayLikeToArray(o, minLen); }\nfunction view_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n // Vectors are imported and exported at SVG_ART_BOARD size.\n// Once they are imported however, both SVGs and bitmaps are on\n// canvases of ART_BOARD size.\n// (This is for backwards compatibility, to handle both assets\n// designed for 480 x 360, and bitmap resolution 2 bitmaps)\nvar SVG_ART_BOARD_WIDTH = 480;\nvar SVG_ART_BOARD_HEIGHT = 360;\nvar ART_BOARD_WIDTH = SVG_ART_BOARD_WIDTH * 2;\nvar ART_BOARD_HEIGHT = SVG_ART_BOARD_HEIGHT * 2;\nvar CENTER = new paper_full_default.a.Point(ART_BOARD_WIDTH / 2, ART_BOARD_HEIGHT / 2);\nvar PADDING_PERCENT = 25; // Padding as a percent of the max of width/height of the sprite\nvar BUFFER = 50; // Number of pixels of allowance around objects at the edges of the workspace\nvar MIN_RATIO = .125; // Zoom in to at least 1/8 of the screen. This way you don't end up incredibly\n//                         zoomed in for tiny costumes.\nvar OUTERMOST_ZOOM_LEVEL = 0.333;\nvar ART_BOARD_BOUNDS = new paper_full_default.a.Rectangle(0, 0, ART_BOARD_WIDTH, ART_BOARD_HEIGHT);\nvar MAX_WORKSPACE_BOUNDS = new paper_full_default.a.Rectangle(-ART_BOARD_WIDTH / 4, -ART_BOARD_HEIGHT / 4, ART_BOARD_WIDTH * 1.5, ART_BOARD_HEIGHT * 1.5);\nvar _workspaceBounds = ART_BOARD_BOUNDS;\nvar getWorkspaceBounds = function getWorkspaceBounds() {\n  return _workspaceBounds;\n};\n/**\n* The workspace bounds define the areas that the scroll bars can access.\n* They include at minimum the artboard, and extend to a bit beyond the\n* farthest item off tne edge in any given direction (so items can't be\n* \"lost\" off the edge)\n*\n* @param {boolean} clipEmpty Clip empty space from bounds, even if it\n* means discontinuously jumping the viewport. This should probably be\n* false unless the viewport is going to move discontinuously anyway\n* (such as in a zoom button click)\n*/\nvar view_setWorkspaceBounds = function setWorkspaceBounds(clipEmpty) {\n  var items = selection_getAllRootItems(); // Include the artboard and what's visible in the viewport\n  var bounds = ART_BOARD_BOUNDS;\n  if (!clipEmpty) {\n    bounds = bounds.unite(paper_full_default.a.view.bounds);\n  } // Include everything the user has drawn and a buffer around it\n  var _iterator = view_createForOfIteratorHelper(items),\n      _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var item = _step.value;\n      bounds = bounds.unite(item.bounds.expand(BUFFER));\n    } // Limit to max workspace bounds\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  bounds = bounds.intersect(MAX_WORKSPACE_BOUNDS.expand(BUFFER));\n  var top = bounds.top;\n  var left = bounds.left;\n  var bottom = bounds.bottom;\n  var right = bounds.right; // Center in view if viewport is larger than workspace\n  var hDiff = 0;\n  var vDiff = 0;\n  if (bounds.width < paper_full_default.a.view.bounds.width) {\n    hDiff = (paper_full_default.a.view.bounds.width - bounds.width) / 2;\n    left -= hDiff;\n    right += hDiff;\n  }\n  if (bounds.height < paper_full_default.a.view.bounds.height) {\n    vDiff = (paper_full_default.a.view.bounds.height - bounds.height) / 2;\n    top -= vDiff;\n    bottom += vDiff;\n  }\n  _workspaceBounds = new paper_full_default.a.Rectangle(left, top, right - left, bottom - top);\n};\nvar view_clampViewBounds = function clampViewBounds() {\n  var _paper$project$view$b = paper_full_default.a.project.view.bounds,\n      left = _paper$project$view$b.left,\n      right = _paper$project$view$b.right,\n      top = _paper$project$view$b.top,\n      bottom = _paper$project$view$b.bottom;\n  if (left < _workspaceBounds.left) {\n    paper_full_default.a.project.view.scrollBy(new paper_full_default.a.Point(_workspaceBounds.left - left, 0));\n  }\n  if (top < _workspaceBounds.top) {\n    paper_full_default.a.project.view.scrollBy(new paper_full_default.a.Point(0, _workspaceBounds.top - top));\n  }\n  if (bottom > _workspaceBounds.bottom) {\n    paper_full_default.a.project.view.scrollBy(new paper_full_default.a.Point(0, _workspaceBounds.bottom - bottom));\n  }\n  if (right > _workspaceBounds.right) {\n    paper_full_default.a.project.view.scrollBy(new paper_full_default.a.Point(_workspaceBounds.right - right, 0));\n  }\n  view_setWorkspaceBounds();\n};\nvar view_resizeCrosshair = function resizeCrosshair() {\n  if (getDragCrosshairLayer() && getDragCrosshairLayer().dragCrosshair) {\n    getDragCrosshairLayer().dragCrosshair.scale(CROSSHAIR_SIZE / getDragCrosshairLayer().dragCrosshair.bounds.width / paper_full_default.a.view.zoom);\n  }\n  if (getBackgroundGuideLayer() && getBackgroundGuideLayer().dragCrosshair) {\n    getBackgroundGuideLayer().dragCrosshair.scale(CROSSHAIR_SIZE / getBackgroundGuideLayer().dragCrosshair.bounds.width / paper_full_default.a.view.zoom);\n  }\n}; // Zoom keeping a project-space point fixed.\n// This article was helpful http://matthiasberth.com/tech/stable-zoom-and-pan-in-paperjs\nvar view_zoomOnFixedPoint = function zoomOnFixedPoint(deltaZoom, fixedPoint) {\n  var view = paper_full_default.a.view;\n  var preZoomCenter = view.center;\n  var newZoom = Math.max(OUTERMOST_ZOOM_LEVEL, view.zoom + deltaZoom);\n  var scaling = view.zoom / newZoom;\n  var preZoomOffset = fixedPoint.subtract(preZoomCenter);\n  var postZoomOffset = fixedPoint.subtract(preZoomOffset.multiply(scaling)).subtract(preZoomCenter);\n  view.zoom = newZoom;\n  view.translate(postZoomOffset.multiply(-1));\n  view_setWorkspaceBounds(true\n  /* clipEmpty */\n  );\n  view_clampViewBounds();\n  view_resizeCrosshair();\n}; // Zoom keeping the selection center (if any) fixed.\nvar view_zoomOnSelection = function zoomOnSelection(deltaZoom) {\n  var fixedPoint;\n  var items = selection_getSelectedRootItems();\n  if (items.length > 0) {\n    var rect = null;\n    var _iterator2 = view_createForOfIteratorHelper(items),\n        _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var item = _step2.value;\n        if (rect) {\n          rect = rect.unite(item.bounds);\n        } else {\n          rect = item.bounds;\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    fixedPoint = rect.center;\n  } else {\n    fixedPoint = paper_full_default.a.project.view.center;\n  }\n  view_zoomOnFixedPoint(deltaZoom, fixedPoint);\n};\nvar view_resetZoom = function resetZoom() {\n  paper_full_default.a.project.view.zoom = .5;\n  view_setWorkspaceBounds(true\n  /* clipEmpty */\n  );\n  view_resizeCrosshair();\n  view_clampViewBounds();\n};\nvar view_pan = function pan(dx, dy) {\n  paper_full_default.a.project.view.scrollBy(new paper_full_default.a.Point(dx, dy));\n  view_clampViewBounds();\n};\n/**\n * Mouse actions are clamped to action bounds\n * @param {boolean} isBitmap True if the editor is in bitmap mode, false if it is in vector mode\n * @returns {paper.Rectangle} the bounds within which mouse events should work in the paint editor\n */\nvar view_getActionBounds = function getActionBounds(isBitmap) {\n  if (isBitmap) {\n    return ART_BOARD_BOUNDS;\n  }\n  return paper_full_default.a.view.bounds.unite(ART_BOARD_BOUNDS).intersect(MAX_WORKSPACE_BOUNDS);\n};\nvar view_zoomToFit = function zoomToFit(isBitmap) {\n  view_resetZoom();\n  var bounds;\n  if (isBitmap) {\n    bounds = bitmap_getHitBounds(getRaster()).expand(BUFFER);\n  } else {\n    var items = selection_getAllRootItems();\n    var _iterator3 = view_createForOfIteratorHelper(items),\n        _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var item = _step3.value;\n        if (bounds) {\n          bounds = bounds.unite(item.bounds);\n        } else {\n          bounds = item.bounds;\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n  }\n  if (bounds && bounds.width && bounds.height) {\n    var canvas = paper_full_default.a.view.element; // Ratio of (sprite length plus padding on all sides) to viewport length.\n    var ratio = paper_full_default.a.view.zoom * Math.max(bounds.width * (1 + 2 * PADDING_PERCENT / 100) / canvas.clientWidth, bounds.height * (1 + 2 * PADDING_PERCENT / 100) / canvas.clientHeight); // Clamp ratio\n    ratio = Math.max(Math.min(1, ratio), MIN_RATIO);\n    if (ratio < 1) {\n      paper_full_default.a.view.center = bounds.center;\n      paper_full_default.a.view.zoom = paper_full_default.a.view.zoom / ratio;\n      view_resizeCrosshair();\n      view_clampViewBounds();\n    }\n  } else {\n    log.warn('No bounds!');\n  }\n};\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/helper/layer.js\nfunction layer_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = layer_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction layer_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return layer_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return layer_arrayLikeToArray(o, minLen); }\nfunction layer_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar CHECKERBOARD_SIZE = 8;\nvar CROSSHAIR_SIZE = 16;\nvar CROSSHAIR_FULL_OPACITY = 0.75;\nvar layer_getLayer = function _getLayer(layerString) {\n  var _iterator = layer_createForOfIteratorHelper(paper_full_default.a.project.layers),\n      _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var layer = _step.value;\n      if (layer.data && layer.data[layerString]) {\n        return layer;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n};\nvar _getPaintingLayer = function _getPaintingLayer() {\n  return layer_getLayer('isPaintingLayer');\n};\n/**\n * Creates a canvas with width and height matching the art board size.\n * @param {?number} width Width of the canvas. Defaults to ART_BOARD_WIDTH.\n * @param {?number} height Height of the canvas. Defaults to ART_BOARD_HEIGHT.\n * @return {HTMLCanvasElement} the canvas\n */\nvar layer_createCanvas = function createCanvas(width, height) {\n  var canvas = document.createElement('canvas');\n  canvas.width = width ? width : ART_BOARD_WIDTH;\n  canvas.height = height ? height : ART_BOARD_HEIGHT;\n  canvas.getContext('2d',{willReadFrequently:true}).imageSmoothingEnabled = false;\n  return canvas;\n};\nvar layer_clearRaster = function clearRaster() {\n  var layer = layer_getLayer('isRasterLayer');\n  layer.removeChildren(); // Generate blank raster\n  var raster = new paper_full_default.a.Raster(layer_createCanvas());\n  raster.canvas.getContext('2d',{willReadFrequently:true}).imageSmoothingEnabled = false;\n  raster.parent = layer;\n  raster.guide = true;\n  raster.locked = true;\n  raster.position = CENTER;\n};\nvar getRaster = function getRaster() {\n  var layer = layer_getLayer('isRasterLayer'); // Generate blank raster\n  if (layer.children.length === 0) {\n    layer_clearRaster();\n  }\n  return layer_getLayer('isRasterLayer').children[0];\n};\nvar getDragCrosshairLayer = function getDragCrosshairLayer() {\n  return layer_getLayer('isDragCrosshairLayer');\n};\nvar getBackgroundGuideLayer = function getBackgroundGuideLayer() {\n  return layer_getLayer('isBackgroundGuideLayer');\n};\nvar layer_convertLayer = function _convertLayer(layer, format) {\n  layer.bitmapBackground.visible = format_isBitmap(format);\n  layer.vectorBackground.visible = isVector(format);\n};\nvar convertBackgroundGuideLayer = function convertBackgroundGuideLayer(format) {\n  layer_convertLayer(getBackgroundGuideLayer(), format);\n};\nvar layer_makeGuideLayer = function _makeGuideLayer() {\n  var guideLayer = new paper_full_default.a.Layer();\n  guideLayer.data.isGuideLayer = true;\n  return guideLayer;\n};\nvar getGuideLayer = function getGuideLayer() {\n  var layer = layer_getLayer('isGuideLayer');\n  if (!layer) {\n    layer = layer_makeGuideLayer();\n    _getPaintingLayer().activate();\n  }\n  return layer;\n};\nvar layer_setGuideItem = function setGuideItem(item) {\n  item.locked = true;\n  item.guide = true;\n  if (isGroupItem(item)) {\n    for (var i = 0; i < item.children.length; i++) {\n      setGuideItem(item.children[i]);\n    }\n  }\n};\n/**\n * Removes the guide layers, e.g. for purposes of exporting the image. Must call showGuideLayers to re-add them.\n * @param {boolean} includeRaster true if the raster layer should also be hidden\n * @return {object} an object of the removed layers, which should be passed to showGuideLayers to re-add them.\n */\nvar hideGuideLayers = function hideGuideLayers(includeRaster) {\n  var backgroundGuideLayer = getBackgroundGuideLayer();\n  var dragCrosshairLayer = getDragCrosshairLayer();\n  var outlineLayer = layer_getLayer('isOutlineLayer');\n  var guideLayer = getGuideLayer();\n  dragCrosshairLayer.remove();\n  outlineLayer.remove();\n  guideLayer.remove();\n  backgroundGuideLayer.remove();\n  var rasterLayer;\n  if (includeRaster) {\n    rasterLayer = layer_getLayer('isRasterLayer');\n    rasterLayer.remove();\n  }\n  return {\n    dragCrosshairLayer: dragCrosshairLayer,\n    outlineLayer: outlineLayer,\n    guideLayer: guideLayer,\n    backgroundGuideLayer: backgroundGuideLayer,\n    rasterLayer: rasterLayer\n  };\n};\n/**\n * Add back the guide layers removed by calling hideGuideLayers. This must be done before any editing operations are\n * taken in the paint editor.\n * @param {!object} guideLayers object of the removed layers, which was returned by hideGuideLayers\n */\nvar layer_showGuideLayers = function showGuideLayers(guideLayers) {\n  var backgroundGuideLayer = guideLayers.backgroundGuideLayer;\n  var dragCrosshairLayer = guideLayers.dragCrosshairLayer;\n  var outlineLayer = guideLayers.outlineLayer;\n  var guideLayer = guideLayers.guideLayer;\n  var rasterLayer = guideLayers.rasterLayer;\n  if (rasterLayer && !rasterLayer.index) {\n    paper_full_default.a.project.addLayer(rasterLayer);\n    rasterLayer.sendToBack();\n  }\n  if (!backgroundGuideLayer.index) {\n    paper_full_default.a.project.addLayer(backgroundGuideLayer);\n    backgroundGuideLayer.sendToBack();\n  }\n  if (!dragCrosshairLayer.index) {\n    paper_full_default.a.project.addLayer(dragCrosshairLayer);\n    dragCrosshairLayer.bringToFront();\n  }\n  if (!outlineLayer.index) {\n    paper_full_default.a.project.addLayer(outlineLayer);\n    outlineLayer.bringToFront();\n  }\n  if (!guideLayer.index) {\n    paper_full_default.a.project.addLayer(guideLayer);\n    guideLayer.bringToFront();\n  }\n  if (paper_full_default.a.project.activeLayer !== _getPaintingLayer()) {\n    log.error(\"Wrong active layer\");\n    log.error(paper_full_default.a.project.activeLayer.data);\n  }\n};\nvar layer_makePaintingLayer = function _makePaintingLayer() {\n  var paintingLayer = new paper_full_default.a.Layer();\n  paintingLayer.data.isPaintingLayer = true;\n  return paintingLayer;\n};\nvar layer_makeRasterLayer = function _makeRasterLayer() {\n  var rasterLayer = new paper_full_default.a.Layer();\n  rasterLayer.data.isRasterLayer = true;\n  layer_clearRaster();\n  return rasterLayer;\n};\nvar layer_makeBackgroundPaper = function _makeBackgroundPaper(width, height, color, opacity) {\n  // creates a checkerboard path of width * height squares in color on white\n  var x = 0;\n  var y = 0;\n  var pathPoints = [];\n  while (x < width) {\n    pathPoints.push(new paper_full_default.a.Point(x, y));\n    x++;\n    pathPoints.push(new paper_full_default.a.Point(x, y));\n    y = y === 0 ? height : 0;\n  }\n  y = height - 1;\n  x = width;\n  while (y > 0) {\n    pathPoints.push(new paper_full_default.a.Point(x, y));\n    x = x === 0 ? width : 0;\n    pathPoints.push(new paper_full_default.a.Point(x, y));\n    y--;\n  }\n  var vRect = new paper_full_default.a.Shape.Rectangle(new paper_full_default.a.Point(0, 0), new paper_full_default.a.Point(ART_BOARD_WIDTH / CHECKERBOARD_SIZE, ART_BOARD_HEIGHT / CHECKERBOARD_SIZE));\n  vRect.fillColor = '#fff';\n  vRect.guide = true;\n  vRect.locked = true;\n  vRect.position = CENTER;\n  var vPath = new paper_full_default.a.Path(pathPoints);\n  vPath.fillRule = 'evenodd';\n  vPath.fillColor = color;\n  vPath.opacity = opacity;\n  vPath.guide = true;\n  vPath.locked = true;\n  vPath.position = CENTER;\n  var mask = new paper_full_default.a.Shape.Rectangle(MAX_WORKSPACE_BOUNDS);\n  mask.position = CENTER;\n  mask.guide = true;\n  mask.locked = true;\n  mask.scale(1 / CHECKERBOARD_SIZE);\n  var vGroup = new paper_full_default.a.Group([vRect, vPath, mask]);\n  mask.clipMask = true;\n  return vGroup;\n}; // Helper function for drawing a crosshair\nvar layer_makeCrosshair = function _makeCrosshair(opacity, parent) {\n  var crosshair = new paper_full_default.a.Group();\n  var vLine2 = new paper_full_default.a.Path.Line(new paper_full_default.a.Point(0, -7), new paper_full_default.a.Point(0, 7));\n  vLine2.strokeWidth = 6;\n  vLine2.strokeColor = 'white';\n  vLine2.strokeCap = 'round';\n  crosshair.addChild(vLine2);\n  var hLine2 = new paper_full_default.a.Path.Line(new paper_full_default.a.Point(-7, 0), new paper_full_default.a.Point(7, 0));\n  hLine2.strokeWidth = 6;\n  hLine2.strokeColor = 'white';\n  hLine2.strokeCap = 'round';\n  crosshair.addChild(hLine2);\n  var circle2 = new paper_full_default.a.Shape.Circle(new paper_full_default.a.Point(0, 0), 5.5);\n  circle2.strokeWidth = 6;\n  circle2.strokeColor = 'white';\n  crosshair.addChild(circle2);\n  var vLine = new paper_full_default.a.Path.Line(new paper_full_default.a.Point(0, -7), new paper_full_default.a.Point(0, 7));\n  vLine.strokeWidth = 2;\n  vLine.strokeColor = 'black';\n  vLine.strokeCap = 'round';\n  crosshair.addChild(vLine);\n  var hLine = new paper_full_default.a.Path.Line(new paper_full_default.a.Point(-7, 0), new paper_full_default.a.Point(7, 0));\n  hLine.strokeWidth = 2;\n  hLine.strokeColor = 'black';\n  hLine.strokeCap = 'round';\n  crosshair.addChild(hLine);\n  var circle = new paper_full_default.a.Shape.Circle(new paper_full_default.a.Point(0, 0), 5.5);\n  circle.strokeWidth = 2;\n  circle.strokeColor = 'black';\n  crosshair.addChild(circle);\n  layer_setGuideItem(crosshair);\n  crosshair.position = CENTER;\n  crosshair.opacity = opacity;\n  crosshair.parent = parent;\n  crosshair.applyMatrix = false;\n  parent.dragCrosshair = crosshair;\n  crosshair.scale(CROSSHAIR_SIZE / crosshair.bounds.width / paper_full_default.a.view.zoom);\n};\nvar layer_makeDragCrosshairLayer = function _makeDragCrosshairLayer() {\n  var dragCrosshairLayer = new paper_full_default.a.Layer();\n  layer_makeCrosshair(CROSSHAIR_FULL_OPACITY, dragCrosshairLayer);\n  dragCrosshairLayer.data.isDragCrosshairLayer = true;\n  dragCrosshairLayer.visible = false;\n  return dragCrosshairLayer;\n};\nvar layer_makeOutlineLayer = function _makeOutlineLayer() {\n  var outlineLayer = new paper_full_default.a.Layer();\n  var whiteRect = new paper_full_default.a.Shape.Rectangle(ART_BOARD_BOUNDS.expand(1));\n  whiteRect.strokeWidth = 2;\n  whiteRect.strokeColor = 'white';\n  layer_setGuideItem(whiteRect);\n  var blueRect = new paper_full_default.a.Shape.Rectangle(ART_BOARD_BOUNDS.expand(5));\n  blueRect.strokeWidth = 2;\n  blueRect.strokeColor = '#4280D7';\n  blueRect.opacity = 0.25;\n  layer_setGuideItem(blueRect);\n  outlineLayer.data.isOutlineLayer = true;\n  return outlineLayer;\n};\nvar layer_makeBackgroundGuideLayer = function _makeBackgroundGuideLayer(format) {\n  var guideLayer = new paper_full_default.a.Layer();\n  guideLayer.locked = true;\n  var vWorkspaceBounds = new paper_full_default.a.Shape.Rectangle(MAX_WORKSPACE_BOUNDS);\n  vWorkspaceBounds.fillColor = '#ECF1F9';\n  vWorkspaceBounds.position = CENTER; // Add 1 to the height because it's an odd number otherwise, and we want it to be even\n  // so the corner of the checkerboard to line up with the center crosshair\n  var vBackground = layer_makeBackgroundPaper(MAX_WORKSPACE_BOUNDS.width / CHECKERBOARD_SIZE, MAX_WORKSPACE_BOUNDS.height / CHECKERBOARD_SIZE + 1, '#D9E3F2', 0.55);\n  vBackground.position = CENTER;\n  vBackground.scaling = new paper_full_default.a.Point(CHECKERBOARD_SIZE, CHECKERBOARD_SIZE);\n  var vectorBackground = new paper_full_default.a.Group();\n  vectorBackground.addChild(vWorkspaceBounds);\n  vectorBackground.addChild(vBackground);\n  layer_setGuideItem(vectorBackground);\n  guideLayer.vectorBackground = vectorBackground;\n  var bitmapBackground = layer_makeBackgroundPaper(ART_BOARD_WIDTH / CHECKERBOARD_SIZE, ART_BOARD_HEIGHT / CHECKERBOARD_SIZE, '#D9E3F2', 0.55);\n  bitmapBackground.position = CENTER;\n  bitmapBackground.scaling = new paper_full_default.a.Point(CHECKERBOARD_SIZE, CHECKERBOARD_SIZE);\n  bitmapBackground.guide = true;\n  bitmapBackground.locked = true;\n  guideLayer.bitmapBackground = bitmapBackground;\n  layer_convertLayer(guideLayer, format);\n  layer_makeCrosshair(0.16, guideLayer);\n  guideLayer.data.isBackgroundGuideLayer = true;\n  return guideLayer;\n};\nvar setupLayers = function setupLayers(format) {\n  var backgroundGuideLayer = layer_makeBackgroundGuideLayer(format);\n  layer_makeRasterLayer();\n  var paintLayer = layer_makePaintingLayer();\n  var dragCrosshairLayer = layer_makeDragCrosshairLayer();\n  var outlineLayer = layer_makeOutlineLayer();\n  var guideLayer = layer_makeGuideLayer();\n  backgroundGuideLayer.sendToBack();\n  dragCrosshairLayer.bringToFront();\n  outlineLayer.bringToFront();\n  guideLayer.bringToFront();\n  paintLayer.activate();\n};\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/helper/undo.js\nfunction undo_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = undo_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction undo_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return undo_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return undo_arrayLikeToArray(o, minLen); }\nfunction undo_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n// undo functionality\n// modifed from https://github.com/memononen/stylii\n\n/**\n * Take an undo snapshot\n * @param {function} dispatchPerformSnapshot Callback to dispatch a state update\n * @param {Formats} format Either Formats.BITMAP or Formats.VECTOR\n */\nvar undo_performSnapshot = function performSnapshot(dispatchPerformSnapshot, format) {\n  if (!format) {\n    log.error('Format must be specified.');\n  }\n  var guideLayers = hideGuideLayers();\n  dispatchPerformSnapshot({\n    json: paper_full_default.a.project.exportJSON({\n      asString: false\n    }),\n    paintEditorFormat: format\n  });\n  layer_showGuideLayers(guideLayers);\n};\nvar undo_restore = function _restore(entry, setSelectedItems, onUpdateImage, isBitmapMode) {\n  for (var i = paper_full_default.a.project.layers.length - 1; i >= 0; i--) {\n    var layer = paper_full_default.a.project.layers[i];\n    if (!layer.data.isBackgroundGuideLayer && !layer.data.isDragCrosshairLayer && !layer.data.isOutlineLayer) {\n      layer.removeChildren();\n      layer.remove();\n    }\n  }\n  paper_full_default.a.project.importJSON(entry.json);\n  setSelectedItems(); // Ensure that all rasters are loaded before updating storage with new image data.\n  var rastersThatNeedToLoad = [];\n  var onLoad = function onLoad() {\n    if (!getRaster().loaded) return;\n    var _iterator = undo_createForOfIteratorHelper(rastersThatNeedToLoad),\n        _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var raster = _step.value;\n        if (!raster.loaded) return;\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    onUpdateImage(true\n    /* skipSnapshot */\n    );\n  }; // Bitmap mode should have at most 1 selected item\n  if (isBitmapMode) {\n    var selectedItems = selection_getSelectedLeafItems();\n    if (selectedItems.length === 1 && selectedItems[0] instanceof paper_full_default.a.Raster) {\n      rastersThatNeedToLoad.push(selectedItems[0]);\n      if (selectedItems[0].data && selectedItems[0].data.expanded instanceof paper_full_default.a.Raster) {\n        rastersThatNeedToLoad.push(selectedItems[0].data.expanded);\n      }\n    }\n  }\n  getRaster().onLoad = onLoad;\n  for (var _i = 0, _rastersThatNeedToLoa = rastersThatNeedToLoad; _i < _rastersThatNeedToLoa.length; _i++) {\n    var raster = _rastersThatNeedToLoa[_i];\n    raster.onLoad = onLoad;\n    if (raster.loaded) raster.onLoad();\n  }\n};\nvar undo_performUndo = function performUndo(undoState, dispatchPerformUndo, setSelectedItems, onUpdateImage) {\n  if (undoState.pointer > 0) {\n    var state = undoState.stack[undoState.pointer - 1];\n    undo_restore(state, setSelectedItems, onUpdateImage, format_isBitmap(state.paintEditorFormat));\n    var format = isVector(state.paintEditorFormat) ? Formats.VECTOR_SKIP_CONVERT : format_isBitmap(state.paintEditorFormat) ? Formats.BITMAP_SKIP_CONVERT : null;\n    dispatchPerformUndo(format);\n  }\n};\nvar undo_performRedo = function performRedo(undoState, dispatchPerformRedo, setSelectedItems, onUpdateImage) {\n  if (undoState.pointer >= 0 && undoState.pointer < undoState.stack.length - 1) {\n    var state = undoState.stack[undoState.pointer + 1];\n    undo_restore(state, setSelectedItems, onUpdateImage, format_isBitmap(state.paintEditorFormat));\n    var format = isVector(state.paintEditorFormat) ? Formats.VECTOR_SKIP_CONVERT : format_isBitmap(state.paintEditorFormat) ? Formats.BITMAP_SKIP_CONVERT : null;\n    dispatchPerformRedo(format);\n  }\n};\nvar undo_shouldShowUndo = function shouldShowUndo(undoState) {\n  return undoState.pointer > 0;\n};\nvar undo_shouldShowRedo = function shouldShowRedo(undoState) {\n  return undoState.pointer > -1 && undoState.pointer !== undoState.stack.length - 1;\n};\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/reducers/undo.js\nvar UNDO = 'scratch-paint/undo/UNDO';\nvar REDO = 'scratch-paint/undo/REDO';\nvar SNAPSHOT = 'scratch-paint/undo/SNAPSHOT';\nvar CLEAR = 'scratch-paint/undo/CLEAR';\nvar MAX_STACK_SIZE = 100;\nvar initialState = {\n  stack: [],\n  pointer: -1\n};\nvar undo_reducer = function reducer(state, action) {\n  if (typeof state === 'undefined') state = initialState;\n  switch (action.type) {\n    case UNDO:\n      if (state.pointer <= 0) {\n        log.warn(\"Can't undo, undo stack is empty\");\n        return state;\n      }\n      return {\n        stack: state.stack,\n        pointer: state.pointer - 1\n      };\n    case REDO:\n      if (state.pointer <= -1 || state.pointer === state.stack.length - 1) {\n        log.warn(\"Can't redo, redo stack is empty\");\n        return state;\n      }\n      return {\n        stack: state.stack,\n        pointer: state.pointer + 1\n      };\n    case SNAPSHOT:\n      if (!action.snapshot) {\n        log.warn(\"Couldn't create undo snapshot, no data provided\");\n        return state;\n      } // Overflowed or about to overflow\n      if (state.pointer >= MAX_STACK_SIZE - 1) {\n        return {\n          // Make a stack of size MAX_STACK_SIZE, cutting off the oldest snapshots.\n          stack: state.stack.slice(state.pointer - MAX_STACK_SIZE + 2, state.pointer + 1).concat(action.snapshot),\n          pointer: MAX_STACK_SIZE - 1\n        };\n      }\n      return {\n        // Performing an action clears the redo stack\n        stack: state.stack.slice(0, state.pointer + 1).concat(action.snapshot),\n        pointer: state.pointer + 1\n      };\n    case CLEAR:\n      return initialState;\n    default:\n      return state;\n  }\n}; // Action creators ==================================\nvar undo_undoSnapshot = function undoSnapshot(snapshot) {\n  return {\n    type: SNAPSHOT,\n    snapshot: snapshot\n  };\n};\n/**\n * @param {Format} format Either VECTOR_SKIP_CONVERT or BITMAP_SKIP_CONVERT\n * @return {Action} undo action\n */\nvar undo = function undo(format) {\n  return {\n    type: UNDO,\n    format: format\n  };\n};\n/**\n * @param {Format} format Either VECTOR_SKIP_CONVERT or BITMAP_SKIP_CONVERT\n * @return {Action} undo action\n */\nvar redo = function redo(format) {\n  return {\n    type: REDO,\n    format: format\n  };\n};\nvar clearUndoState = function clearUndoState() {\n  return {\n    type: CLEAR\n  };\n};\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/reducers/selected-items.js\nvar CHANGE_SELECTED_ITEMS = 'scratch-paint/select/CHANGE_SELECTED_ITEMS';\nvar REDRAW_SELECTION_BOX = 'scratch-paint/select/REDRAW_SELECTION_BOX';\nvar selected_items_initialState = [];\nvar selected_items_reducer = function reducer(state, action) {\n  if (typeof state === 'undefined') state = selected_items_initialState;\n  switch (action.type) {\n    case REDRAW_SELECTION_BOX:\n      if (state.length > 0) return state.slice(0); // Sends an update even though the items haven't changed\n      return state;\n    case CHANGE_SELECTED_ITEMS:\n      if (!action.selectedItems || !(action.selectedItems instanceof Array)) {\n        log.warn(\"No selected items or wrong format provided: \".concat(action.selectedItems));\n        return state;\n      }\n      if (action.selectedItems.length > 1 && action.bitmapMode) {\n        log.warn(\"Multiselect should not be possible in bitmap mode: \".concat(action.selectedItems));\n        return state;\n      } // If they are both empty, no change\n      if (action.selectedItems.length === 0 && state.length === 0) {\n        return state;\n      }\n      return action.selectedItems;\n    default:\n      return state;\n  }\n}; // Action creators ==================================\n/**\n * Set the selected item state to the given array of items\n * @param {Array<paper.Item>} selectedItems from paper.project.selectedItems\n * @param {?boolean} bitmapMode True if the items are being selected in bitmap mode\n * @return {object} Redux action to change the selected items.\n */\nvar selected_items_setSelectedItems = function setSelectedItems(selectedItems, bitmapMode) {\n  return {\n    type: CHANGE_SELECTED_ITEMS,\n    selectedItems: selectedItems,\n    bitmapMode: bitmapMode\n  };\n};\nvar selected_items_clearSelectedItems = function clearSelectedItems() {\n  return {\n    type: CHANGE_SELECTED_ITEMS,\n    selectedItems: []\n  };\n};\nvar selected_items_redrawSelectionBox = function redrawSelectionBox() {\n  return {\n    type: REDRAW_SELECTION_BOX\n  };\n};\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/reducers/hover.js\nvar CHANGE_HOVERED = 'scratch-paint/hover/CHANGE_HOVERED';\nvar hover_initialState = null;\nvar hover_reducer = function reducer(state, action) {\n  if (typeof state === 'undefined') state = hover_initialState;\n  switch (action.type) {\n    case CHANGE_HOVERED:\n      if (typeof action.hoveredItemId === 'undefined') {\n        log.warn(\"Hovered item should not be set to undefined. Use null.\");\n        return state;\n      } else if (typeof action.hoveredItemId === 'undefined' || isNaN(action.hoveredItemId)) {\n        log.warn(\"Hovered item should be an item ID number. Got: \".concat(action.hoveredItemId));\n        return state;\n      }\n      return action.hoveredItemId;\n    default:\n      return state;\n  }\n}; // Action creators ==================================\n/**\n * Set the hovered item state to the given item ID\n * @param {number} hoveredItemId The paper.Item ID of the hover indicator item.\n * @return {object} Redux action to change the hovered item.\n */\nvar hover_setHoveredItem = function setHoveredItem(hoveredItemId) {\n  return {\n    type: CHANGE_HOVERED,\n    hoveredItemId: hoveredItemId\n  };\n};\nvar hover_clearHoveredItem = function clearHoveredItem() {\n  return {\n    type: CHANGE_HOVERED,\n    hoveredItemId: null\n  };\n};\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/reducers/clipboard.js\nvar SET = 'scratch-paint/clipboard/SET';\nvar INCREMENT_PASTE_OFFSET = 'scratch-paint/clipboard/INCREMENT_PASTE_OFFSET';\nvar CLEAR_PASTE_OFFSET = 'scratch-paint/clipboard/CLEAR_PASTE_OFFSET';\nvar clipboard_initialState = {\n  items: [],\n  pasteOffset: 0\n};\nvar clipboard_reducer = function reducer(state, action) {\n  if (typeof state === 'undefined') state = clipboard_initialState;\n  switch (action.type) {\n    case SET:\n      if (!action.clipboardItems || !(action.clipboardItems instanceof Array) || action.clipboardItems.length === 0) {\n        log.warn(\"Invalid clipboard item format\");\n        return state;\n      }\n      return {\n        items: action.clipboardItems,\n        pasteOffset: 1\n      };\n    case INCREMENT_PASTE_OFFSET:\n      return {\n        items: state.items,\n        pasteOffset: state.pasteOffset + 1\n      };\n    case CLEAR_PASTE_OFFSET:\n      return {\n        items: state.items,\n        pasteOffset: 0\n      };\n    default:\n      return state;\n  }\n}; // Action creators ==================================\nvar clipboard_setClipboardItems = function setClipboardItems(clipboardItems) {\n  return {\n    type: SET,\n    clipboardItems: clipboardItems\n  };\n};\nvar clipboard_incrementPasteOffset = function incrementPasteOffset() {\n  return {\n    type: INCREMENT_PASTE_OFFSET\n  };\n};\nvar clipboard_clearPasteOffset = function clearPasteOffset() {\n  return {\n    type: CLEAR_PASTE_OFFSET\n  };\n};\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/reducers/format.js\nvar CHANGE_FORMAT = 'scratch-paint/formats/CHANGE_FORMAT';\nvar format_initialState = null;\nvar format_reducer = function reducer(state, action) {\n  if (typeof state === 'undefined') state = format_initialState;\n  switch (action.type) {\n    case UNDO:\n    /* falls through */\n    case REDO:\n    /* falls through */\n    case CHANGE_FORMAT:\n      if (!action.format) return state;\n      if (action.format in Formats) {\n        return action.format;\n      }\n      log.warn(\"Format does not exist: \".concat(action.format));\n    /* falls through */\n    default:\n      return state;\n  }\n}; // Action creators ==================================\nvar format_changeFormat = function changeFormat(format) {\n  return {\n    type: CHANGE_FORMAT,\n    format: format\n  };\n};\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/reducers/view-bounds.js\nvar UPDATE_VIEW_BOUNDS = 'scratch-paint/view/UPDATE_VIEW_BOUNDS';\nvar view_bounds_initialState = new paper_full_default.a.Matrix(); // Identity\nvar view_bounds_reducer = function reducer(state, action) {\n  if (typeof state === 'undefined') state = view_bounds_initialState;\n  switch (action.type) {\n    case UPDATE_VIEW_BOUNDS:\n      if (!(action.viewBounds instanceof paper_full_default.a.Matrix)) {\n        log.warn(\"View bounds should be a paper.Matrix.\");\n        return state;\n      }\n      return action.viewBounds;\n    default:\n      return state;\n  }\n}; // Action creators ==================================\n/**\n * Set the view bounds, which defines the zoom and scroll of the paper canvas.\n * @param {paper.Matrix} matrix The matrix applied to the view\n * @return {object} Redux action to set the view bounds\n */\nvar view_bounds_updateViewBounds = function updateViewBounds(matrix) {\n  return {\n    type: UPDATE_VIEW_BOUNDS,\n    viewBounds: matrix.clone()\n  };\n};\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/reducers/zoom-levels.js\nfunction zoom_levels_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nvar SAVE_ZOOM_LEVEL = 'scratch-paint/zoom-levels/SAVE_ZOOM_LEVEL';\nvar SET_ZOOM_LEVEL_ID = 'scratch-paint/zoom-levels/SET_ZOOM_LEVEL_ID';\nvar zoom_levels_initialState = {};\nvar zoom_levels_reducer = function reducer(state, action) {\n  if (typeof state === 'undefined') state = zoom_levels_initialState;\n  switch (action.type) {\n    case SET_ZOOM_LEVEL_ID:\n      if (action.zoomLevelId === 'currentZoomLevelId') {\n        log.warn(\"currentZoomLevelId is an invalid string for zoomLevel\");\n        return state;\n      }\n      return Object.assign({}, state, {\n        currentZoomLevelId: action.zoomLevelId\n      });\n    case SAVE_ZOOM_LEVEL:\n      return Object.assign({}, state, zoom_levels_defineProperty({}, state.currentZoomLevelId, action.zoomLevel));\n    default:\n      return state;\n  }\n}; // Action creators ==================================\nvar zoom_levels_saveZoomLevel = function saveZoomLevel(zoomLevel) {\n  if (!(zoomLevel instanceof paper_full_default.a.Matrix)) {\n    log.warn(\"Not a matrix: \".concat(zoomLevel));\n  }\n  return {\n    type: SAVE_ZOOM_LEVEL,\n    zoomLevel: new paper_full_default.a.Matrix(zoomLevel)\n  };\n};\nvar zoom_levels_setZoomLevelId = function setZoomLevelId(zoomLevelId) {\n  return {\n    type: SET_ZOOM_LEVEL_ID,\n    zoomLevelId: zoomLevelId\n  };\n};\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/containers/paper-canvas.css\nvar paper_canvas = __webpack_require__(601);\nvar paper_canvas_default = __webpack_require__.n(paper_canvas);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/containers/paper-canvas.jsx\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\nfunction paper_canvas_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = paper_canvas_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction paper_canvas_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return paper_canvas_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return paper_canvas_arrayLikeToArray(o, minLen); }\nfunction paper_canvas_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar paper_canvas_PaperCanvas = function (_React$Component) {\n  _inherits(PaperCanvas, _React$Component);\n  var _super = _createSuper(PaperCanvas);\n  function PaperCanvas(props) {\n    var _this;\n    _classCallCheck(this, PaperCanvas);\n    _this = _super.call(this, props);\n    lodash_bindall_default()(_assertThisInitialized(_this), ['clearQueuedImport', 'setCanvas', 'importSvg', 'initializeSvg', 'maybeZoomToFit', 'switchCostume', 'onViewResize', 'recalibrateSize']);\n    return _this;\n  }\n  _createClass(PaperCanvas, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      paper_full_default.a.setup(this.canvas);\n      paper_full_default.a.view.on('resize', this.onViewResize);\n      view_resetZoom();\n      if (this.props.zoomLevelId) {\n        this.props.setZoomLevelId(this.props.zoomLevelId);\n        if (this.props.zoomLevels[this.props.zoomLevelId]) {\n          // This is the matrix that the view should be zoomed to after image import\n          this.shouldZoomToFit = this.props.zoomLevels[this.props.zoomLevelId];\n        } else {\n          // Zoom to fit true means find a comfortable zoom level for viewing the costume\n          this.shouldZoomToFit = true;\n        }\n      } else {\n        this.props.updateViewBounds(paper_full_default.a.view.matrix);\n      }\n      var context = this.canvas.getContext('2d',{willReadFrequently:true});\n      context.webkitImageSmoothingEnabled = false;\n      context.imageSmoothingEnabled = false; // Don't show handles by default\n      paper_full_default.a.settings.handleSize = 0; // Make layers.\n      setupLayers(this.props.format);\n      this.importImage(this.props.imageFormat, this.props.image, this.props.rotationCenterX, this.props.rotationCenterY);\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(newProps) {\n      if (this.props.imageId !== newProps.imageId) {\n        this.switchCostume(newProps.imageFormat, newProps.image, newProps.rotationCenterX, newProps.rotationCenterY, this.props.zoomLevelId, newProps.zoomLevelId);\n      }\n      if (this.props.format !== newProps.format) {\n        this.recalibrateSize();\n        convertBackgroundGuideLayer(newProps.format);\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.clearQueuedImport(); // shouldZoomToFit means the zoom level hasn't been initialized yet\n      if (!this.shouldZoomToFit) {\n        this.props.saveZoomLevel();\n      }\n      paper_full_default.a.remove();\n    }\n  }, {\n    key: \"clearQueuedImport\",\n    value: function clearQueuedImport() {\n      if (this.queuedImport) {\n        window.clearTimeout(this.queuedImport);\n        this.queuedImport = null;\n      }\n      if (this.queuedImageToLoad) {\n        this.queuedImageToLoad.src = '';\n        this.queuedImageToLoad.onload = null;\n        this.queuedImageToLoad = null;\n      }\n    }\n  }, {\n    key: \"switchCostume\",\n    value: function switchCostume(format, image, rotationCenterX, rotationCenterY, oldZoomLevelId, newZoomLevelId) {\n      if (oldZoomLevelId && oldZoomLevelId !== newZoomLevelId) {\n        this.props.saveZoomLevel();\n      }\n      if (newZoomLevelId && oldZoomLevelId !== newZoomLevelId) {\n        if (this.props.zoomLevels[newZoomLevelId]) {\n          this.shouldZoomToFit = this.props.zoomLevels[newZoomLevelId];\n        } else {\n          this.shouldZoomToFit = true;\n        }\n        this.props.setZoomLevelId(newZoomLevelId);\n      }\n      var _iterator = paper_canvas_createForOfIteratorHelper(paper_full_default.a.project.layers),\n          _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var layer = _step.value;\n          if (layer.data.isRasterLayer) {\n            layer_clearRaster();\n          } else if (!layer.data.isBackgroundGuideLayer && !layer.data.isDragCrosshairLayer && !layer.data.isOutlineLayer) {\n            layer.removeChildren();\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      this.props.clearUndo();\n      this.props.clearSelectedItems();\n      this.props.clearHoveredItem();\n      this.props.clearPasteOffset();\n      this.importImage(format, image, rotationCenterX, rotationCenterY);\n    }\n  }, {\n    key: \"importImage\",\n    value: function importImage(format, image, rotationCenterX, rotationCenterY) {\n      var _this2 = this;\n      // Stop any in-progress imports\n      this.clearQueuedImport();\n      if (!image) {\n        this.props.changeFormat(Formats.VECTOR_SKIP_CONVERT);\n        undo_performSnapshot(this.props.undoSnapshot, Formats.VECTOR_SKIP_CONVERT);\n        this.recalibrateSize();\n        return;\n      }\n      if (format === 'jpg' || format === 'png') {\n        // import bitmap\n        this.props.changeFormat(Formats.BITMAP_SKIP_CONVERT);\n        var mask = new paper_full_default.a.Shape.Rectangle(getRaster().getBounds());\n        mask.guide = true;\n        mask.locked = true;\n        mask.setPosition(CENTER);\n        mask.clipMask = true;\n        var imgElement = new Image();\n        this.queuedImageToLoad = imgElement;\n        imgElement.onload = function () {\n          if (!_this2.queuedImageToLoad) return;\n          _this2.queuedImageToLoad = null;\n          if (typeof rotationCenterX === 'undefined') {\n            rotationCenterX = imgElement.width / 2;\n          }\n          if (typeof rotationCenterY === 'undefined') {\n            rotationCenterY = imgElement.height / 2;\n          }\n          getRaster().drawImage(imgElement, ART_BOARD_WIDTH / 2 - rotationCenterX, ART_BOARD_HEIGHT / 2 - rotationCenterY);\n          getRaster().drawImage(imgElement, ART_BOARD_WIDTH / 2 - rotationCenterX, ART_BOARD_HEIGHT / 2 - rotationCenterY);\n          _this2.maybeZoomToFit(true\n          /* isBitmap */\n          );\n          undo_performSnapshot(_this2.props.undoSnapshot, Formats.BITMAP_SKIP_CONVERT);\n          _this2.recalibrateSize();\n        };\n        imgElement.src = image;\n      } else if (format === 'svg') {\n        this.props.changeFormat(Formats.VECTOR_SKIP_CONVERT);\n        this.importSvg(image, rotationCenterX, rotationCenterY);\n      } else {\n        log.error(\"Didn't recognize format: \".concat(format, \". Use 'jpg', 'png' or 'svg'.\"));\n        this.props.changeFormat(Formats.VECTOR_SKIP_CONVERT);\n        undo_performSnapshot(this.props.undoSnapshot, Formats.VECTOR_SKIP_CONVERT);\n        this.recalibrateSize();\n      }\n    }\n  }, {\n    key: \"maybeZoomToFit\",\n    value: function maybeZoomToFit(isBitmapMode) {\n      if (this.shouldZoomToFit instanceof paper_full_default.a.Matrix) {\n        paper_full_default.a.view.matrix = this.shouldZoomToFit;\n        this.props.updateViewBounds(paper_full_default.a.view.matrix);\n        view_resizeCrosshair();\n      } else if (this.shouldZoomToFit === true) {\n        view_zoomToFit(isBitmapMode);\n      }\n      this.shouldZoomToFit = false;\n      view_setWorkspaceBounds();\n      this.props.updateViewBounds(paper_full_default.a.view.matrix);\n    }\n  }, {\n    key: \"importSvg\",\n    value: function importSvg(svg, rotationCenterX, rotationCenterY) {\n      var paperCanvas = this; // Pre-process SVG to prevent parsing errors (discussion from #213)\n      // 1. Remove svg: namespace on elements.\n      svg = svg.split(/<\\s*svg:/).join('<');\n      svg = svg.split(/<\\/\\s*svg:/).join('</'); // 2. Add root svg namespace if it does not exist.\n      var svgAttrs = svg.match(/<svg [^>]*>/);\n      if (svgAttrs && svgAttrs[0].indexOf('xmlns=') === -1) {\n        svg = svg.replace('<svg ', '<svg xmlns=\"http://www.w3.org/2000/svg\" ');\n      } // Get the origin which the viewBox is defined relative to. During import, Paper will translate\n      // the viewBox to start at (0, 0), and we need to translate it back for some costumes to render\n      // correctly.\n      var parser = new DOMParser();\n      var svgDom = parser.parseFromString(svg, 'text/xml');\n      var viewBox = svgDom.documentElement.attributes.viewBox ? svgDom.documentElement.attributes.viewBox.value.match(/\\S+/g) : null;\n      if (viewBox) {\n        for (var i = 0; i < viewBox.length; i++) {\n          viewBox[i] = parseFloat(viewBox[i]);\n        }\n      }\n      paper_full_default.a.project.importSVG(svg, {\n        expandShapes: true,\n        onLoad: function onLoad(item) {\n          if (!item) {\n            log.error('SVG import failed:');\n            log.info(svg);\n            this.props.changeFormat(Formats.VECTOR_SKIP_CONVERT);\n            undo_performSnapshot(paperCanvas.props.undoSnapshot, Formats.VECTOR_SKIP_CONVERT);\n            return;\n          }\n          item.remove(); // Without the callback, rasters' load function has not been called yet, and they are\n          // positioned incorrectly\n          paperCanvas.queuedImport = paperCanvas.recalibrateSize(function () {\n            paperCanvas.props.updateViewBounds(paper_full_default.a.view.matrix);\n            paperCanvas.initializeSvg(item, rotationCenterX, rotationCenterY, viewBox);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"initializeSvg\",\n    value: function initializeSvg(item, rotationCenterX, rotationCenterY, viewBox) {\n      if (this.queuedImport) this.queuedImport = null;\n      var itemWidth = item.bounds.width;\n      var itemHeight = item.bounds.height; // Get reference to viewbox\n      var mask;\n      if (item.clipped) {\n        var _iterator2 = paper_canvas_createForOfIteratorHelper(item.children),\n            _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var child = _step2.value;\n            if (child.isClipMask()) {\n              mask = child;\n              break;\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        mask.clipMask = false;\n      } else {\n        mask = new paper_full_default.a.Shape.Rectangle(item.bounds);\n      }\n      mask.guide = true;\n      mask.locked = true;\n      mask.matrix = new paper_full_default.a.Matrix(); // Identity\n      // Set the artwork to get clipped at the max costume size\n      mask.size.height = MAX_WORKSPACE_BOUNDS.height;\n      mask.size.width = MAX_WORKSPACE_BOUNDS.width;\n      mask.setPosition(CENTER);\n      paper_full_default.a.project.activeLayer.addChild(mask);\n      mask.clipMask = true; // Reduce single item nested in groups\n      if (item instanceof paper_full_default.a.Group && item.children.length === 1) {\n        item = item.reduce();\n      }\n      math_ensureClockwise(item);\n      math_scaleWithStrokes(item, 2, new paper_full_default.a.Point()); // Import at 2x\n      // Apply rotation center\n      if (typeof rotationCenterX !== 'undefined' && typeof rotationCenterY !== 'undefined') {\n        var rotationPoint = new paper_full_default.a.Point(rotationCenterX, rotationCenterY);\n        if (viewBox && viewBox.length >= 2 && !isNaN(viewBox[0]) && !isNaN(viewBox[1])) {\n          rotationPoint = rotationPoint.subtract(viewBox[0], viewBox[1]);\n        }\n        item.translate(CENTER.subtract(rotationPoint.multiply(2)));\n      } else {\n        // Center\n        item.translate(CENTER.subtract(itemWidth, itemHeight));\n      }\n      paper_full_default.a.project.activeLayer.insertChild(0, item);\n      if (group_isGroup(item)) {\n        // Fixes an issue where we may export empty groups\n        var _iterator3 = paper_canvas_createForOfIteratorHelper(item.children),\n            _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var _child = _step3.value;\n            if (group_isGroup(_child) && _child.children.length === 0) {\n              _child.remove();\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n        ungroupItems([item]);\n      }\n      undo_performSnapshot(this.props.undoSnapshot, Formats.VECTOR_SKIP_CONVERT);\n      this.maybeZoomToFit();\n    }\n  }, {\n    key: \"onViewResize\",\n    value: function onViewResize() {\n      view_setWorkspaceBounds(true\n      /* clipEmpty */\n      );\n      view_clampViewBounds(); // Fix incorrect paper canvas scale on browser zoom reset\n      this.recalibrateSize();\n      this.props.updateViewBounds(paper_full_default.a.view.matrix);\n    }\n  }, {\n    key: \"recalibrateSize\",\n    value: function recalibrateSize(callback) {\n      // Sets the size that Paper thinks the canvas is to the size the canvas element actually is.\n      // When these are out of sync, the mouse events in the paint editor don't line up correctly.\n      return window.setTimeout(function () {\n        // If the component unmounts, the canvas will be removed from the page, detaching paper.view.\n        // This could also be called before paper.view exists.\n        // In either case, return early if so without running the callback.\n        if (!paper_full_default.a.view) return; // Prevent blurriness caused if the \"CSS size\" of the element is a float--\n        // setting canvas dimensions to floats floors them, but we need to round instead\n        var elemSize = paper_full_default.a.DomElement.getSize(paper_full_default.a.view.element);\n        elemSize.width = Math.round(elemSize.width);\n        elemSize.height = Math.round(elemSize.height);\n        paper_full_default.a.view.setViewSize(elemSize);\n        if (callback) callback();\n      }, 0);\n    }\n  }, {\n    key: \"setCanvas\",\n    value: function setCanvas(canvas) {\n      this.canvas = canvas;\n      if (this.props.canvasRef) {\n        this.props.canvasRef(canvas);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return react_default.a.createElement(\"canvas\", {\n        className: paper_canvas_default.a.paperCanvas,\n        ref: this.setCanvas,\n        style: {\n          cursor: this.props.cursor\n        },\n        resize: \"true\"\n      });\n    }\n  }]);\n  return PaperCanvas;\n}(react_default.a.Component);\npaper_canvas_PaperCanvas.propTypes = {\n  canvasRef: prop_types_default.a.func,\n  changeFormat: prop_types_default.a.func.isRequired,\n  clearHoveredItem: prop_types_default.a.func.isRequired,\n  clearPasteOffset: prop_types_default.a.func.isRequired,\n  clearSelectedItems: prop_types_default.a.func.isRequired,\n  clearUndo: prop_types_default.a.func.isRequired,\n  cursor: prop_types_default.a.string,\n  format: prop_types_default.a.oneOf(Object.keys(Formats)),\n  image: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.instanceOf(HTMLImageElement)]),\n  imageFormat: prop_types_default.a.string,\n  // The incoming image's data format, used during import. The user could switch this.\n  imageId: prop_types_default.a.string,\n  rotationCenterX: prop_types_default.a.number,\n  rotationCenterY: prop_types_default.a.number,\n  saveZoomLevel: prop_types_default.a.func.isRequired,\n  setZoomLevelId: prop_types_default.a.func.isRequired,\n  undoSnapshot: prop_types_default.a.func.isRequired,\n  updateViewBounds: prop_types_default.a.func.isRequired,\n  zoomLevelId: prop_types_default.a.string,\n  zoomLevels: prop_types_default.a.shape({\n    currentZoomLevelId: prop_types_default.a.string\n  })\n};\nvar paper_canvas_mapStateToProps = function mapStateToProps(state) {\n  return {\n    mode: state.scratchPaint.mode,\n    cursor: state.scratchPaint.cursor,\n    format: state.scratchPaint.format,\n    zoomLevels: state.scratchPaint.zoomLevels\n  };\n};\nvar paper_canvas_mapDispatchToProps = function mapDispatchToProps(dispatch) {\n  return {\n    undoSnapshot: function undoSnapshot(snapshot) {\n      dispatch(undo_undoSnapshot(snapshot));\n    },\n    clearUndo: function clearUndo() {\n      dispatch(clearUndoState());\n    },\n    clearSelectedItems: function clearSelectedItems() {\n      dispatch(selected_items_clearSelectedItems());\n    },\n    clearHoveredItem: function clearHoveredItem() {\n      dispatch(hover_clearHoveredItem());\n    },\n    clearPasteOffset: function clearPasteOffset() {\n      dispatch(clipboard_clearPasteOffset());\n    },\n    changeFormat: function changeFormat(format) {\n      dispatch(format_changeFormat(format));\n    },\n    saveZoomLevel: function saveZoomLevel() {\n      dispatch(zoom_levels_saveZoomLevel(paper_full_default.a.view.matrix));\n    },\n    setZoomLevelId: function setZoomLevelId(zoomLevelId) {\n      dispatch(zoom_levels_setZoomLevelId(zoomLevelId));\n    },\n    updateViewBounds: function updateViewBounds(matrix) {\n      dispatch(view_bounds_updateViewBounds(matrix));\n    }\n  };\n};\n/* harmony default export */ var containers_paper_canvas = (Object(es[\"b\" /* connect */])(paper_canvas_mapStateToProps, paper_canvas_mapDispatchToProps)(paper_canvas_PaperCanvas));\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/scrollable-canvas/scrollable-canvas.css\nvar scrollable_canvas = __webpack_require__(147);\nvar scrollable_canvas_default = __webpack_require__.n(scrollable_canvas);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/components/scrollable-canvas/scrollable-canvas.jsx\n\nvar scrollable_canvas_ScrollableCanvasComponent = function ScrollableCanvasComponent(props) {\n  return react_default.a.createElement(\"div\", {\n    className: props.style\n  }, props.children, react_default.a.createElement(\"div\", {\n    className: scrollable_canvas_default.a.horizontalScrollbarWrapper,\n    style: {\n      pointerEvents: 'none'\n    }\n  }, react_default.a.createElement(\"div\", {\n    className: scrollable_canvas_default.a.horizontalScrollbarHitbox,\n    style: {\n      width: \"\".concat(props.horizontalScrollLengthPercent, \"%\"),\n      left: \"\".concat(props.horizontalScrollStartPercent, \"%\"),\n      pointerEvents: 'auto',\n      display: \"\".concat(props.hideScrollbars || Math.abs(props.horizontalScrollLengthPercent - 100) < 1e-8 ? 'none' : 'block')\n    },\n    onMouseDown: props.onHorizontalScrollbarMouseDown,\n    onTouchStart: props.onHorizontalScrollbarMouseDown\n  }, react_default.a.createElement(\"div\", {\n    className: scrollable_canvas_default.a.horizontalScrollbar\n  }))), react_default.a.createElement(\"div\", {\n    className: scrollable_canvas_default.a.verticalScrollbarWrapper,\n    style: {\n      pointerEvents: 'none'\n    }\n  }, react_default.a.createElement(\"div\", {\n    className: scrollable_canvas_default.a.verticalScrollbarHitbox,\n    style: {\n      height: \"\".concat(props.verticalScrollLengthPercent, \"%\"),\n      top: \"\".concat(props.verticalScrollStartPercent, \"%\"),\n      pointerEvents: 'auto',\n      display: \"\".concat(props.hideScrollbars || Math.abs(props.verticalScrollLengthPercent - 100) < 1e-8 ? 'none' : 'block')\n    },\n    onMouseDown: props.onVerticalScrollbarMouseDown,\n    onTouchStart: props.onVerticalScrollbarMouseDown\n  }, react_default.a.createElement(\"div\", {\n    className: scrollable_canvas_default.a.verticalScrollbar\n  }))));\n};\nscrollable_canvas_ScrollableCanvasComponent.propTypes = {\n  children: prop_types_default.a.node.isRequired,\n  hideScrollbars: prop_types_default.a.bool,\n  horizontalScrollLengthPercent: prop_types_default.a.number,\n  horizontalScrollStartPercent: prop_types_default.a.number,\n  onHorizontalScrollbarMouseDown: prop_types_default.a.func.isRequired,\n  onVerticalScrollbarMouseDown: prop_types_default.a.func.isRequired,\n  style: prop_types_default.a.string,\n  verticalScrollLengthPercent: prop_types_default.a.number,\n  verticalScrollStartPercent: prop_types_default.a.number\n};\n/* harmony default export */ var scrollable_canvas_scrollable_canvas = (scrollable_canvas_ScrollableCanvasComponent);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/lib/touch-utils.js\n/* DO NOT EDIT\n@todo This file is copied from GUI and should be pulled out into a shared library.\nSee https://github.com/LLK/scratch-paint/issues/13 */\nvar getEventXY = function getEventXY(e) {\n  if (e.touches && e.touches[0]) {\n    return {\n      x: e.touches[0].clientX,\n      y: e.touches[0].clientY\n    };\n  } else if (e.changedTouches && e.changedTouches[0]) {\n    return {\n      x: e.changedTouches[0].clientX,\n      y: e.changedTouches[0].clientY\n    };\n  }\n  return {\n    x: e.clientX,\n    y: e.clientY\n  };\n};\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/containers/scrollable-canvas.jsx\nfunction scrollable_canvas_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { scrollable_canvas_typeof = function _typeof(obj) { return typeof obj; }; } else { scrollable_canvas_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return scrollable_canvas_typeof(obj); }\nfunction scrollable_canvas_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction scrollable_canvas_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction scrollable_canvas_createClass(Constructor, protoProps, staticProps) { if (protoProps) scrollable_canvas_defineProperties(Constructor.prototype, protoProps); if (staticProps) scrollable_canvas_defineProperties(Constructor, staticProps); return Constructor; }\nfunction scrollable_canvas_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) scrollable_canvas_setPrototypeOf(subClass, superClass); }\nfunction scrollable_canvas_setPrototypeOf(o, p) { scrollable_canvas_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return scrollable_canvas_setPrototypeOf(o, p); }\nfunction scrollable_canvas_createSuper(Derived) { var hasNativeReflectConstruct = scrollable_canvas_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = scrollable_canvas_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = scrollable_canvas_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return scrollable_canvas_possibleConstructorReturn(this, result); }; }\nfunction scrollable_canvas_possibleConstructorReturn(self, call) { if (call && (scrollable_canvas_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return scrollable_canvas_assertThisInitialized(self); }\nfunction scrollable_canvas_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction scrollable_canvas_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction scrollable_canvas_getPrototypeOf(o) { scrollable_canvas_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return scrollable_canvas_getPrototypeOf(o); }\n\nvar scrollable_canvas_ScrollableCanvas = function (_React$Component) {\n  scrollable_canvas_inherits(ScrollableCanvas, _React$Component);\n  var _super = scrollable_canvas_createSuper(ScrollableCanvas);\n  scrollable_canvas_createClass(ScrollableCanvas, null, [{\n    key: \"ZOOM_INCREMENT\",\n    get: function get() {\n      return 0.5;\n    }\n  }]);\n  function ScrollableCanvas(props) {\n    var _this;\n    scrollable_canvas_classCallCheck(this, ScrollableCanvas);\n    _this = _super.call(this, props);\n    lodash_bindall_default()(scrollable_canvas_assertThisInitialized(_this), ['handleHorizontalScrollbarMouseDown', 'handleHorizontalScrollbarMouseMove', 'handleHorizontalScrollbarMouseUp', 'handleVerticalScrollbarMouseDown', 'handleVerticalScrollbarMouseMove', 'handleVerticalScrollbarMouseUp', 'handleWheel']);\n    return _this;\n  }\n  scrollable_canvas_createClass(ScrollableCanvas, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this.props.canvas) {\n        this.props.canvas.addEventListener('wheel', this.handleWheel,{passive:false});\n      }\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(nextProps) {\n      if (nextProps.canvas) {\n        if (this.props.canvas) {\n          this.props.canvas.removeEventListener('wheel', this.handleWheel);\n        }\n        nextProps.canvas.addEventListener('wheel', this.handleWheel,{passive:false});\n      }\n    }\n  }, {\n    key: \"handleHorizontalScrollbarMouseDown\",\n    value: function handleHorizontalScrollbarMouseDown(event) {\n      this.initialMouseX = getEventXY(event).x;\n      this.initialScreenX = paper_full_default.a.view.matrix.tx;\n      window.addEventListener('mousemove', this.handleHorizontalScrollbarMouseMove);\n      window.addEventListener('touchmove', this.handleHorizontalScrollbarMouseMove, {\n        passive: false\n      });\n      window.addEventListener('mouseup', this.handleHorizontalScrollbarMouseUp);\n      window.addEventListener('touchend', this.handleHorizontalScrollbarMouseUp);\n      event.preventDefault();\n    }\n  }, {\n    key: \"handleHorizontalScrollbarMouseMove\",\n    value: function handleHorizontalScrollbarMouseMove(event) {\n      var dx = this.initialMouseX - getEventXY(event).x;\n      paper_full_default.a.view.matrix.tx = this.initialScreenX + dx * paper_full_default.a.view.zoom * 2;\n      view_clampViewBounds();\n      this.props.updateViewBounds(paper_full_default.a.view.matrix);\n      event.preventDefault();\n    }\n  }, {\n    key: \"handleHorizontalScrollbarMouseUp\",\n    value: function handleHorizontalScrollbarMouseUp() {\n      window.removeEventListener('mousemove', this.handleHorizontalScrollbarMouseMove);\n      window.removeEventListener('touchmove', this.handleHorizontalScrollbarMouseMove, {\n        passive: false\n      });\n      window.removeEventListener('mouseup', this.handleHorizontalScrollbarMouseUp);\n      window.removeEventListener('touchend', this.handleHorizontalScrollbarMouseUp);\n      this.initialMouseX = null;\n      this.initialScreenX = null;\n      event.preventDefault();\n    }\n  }, {\n    key: \"handleVerticalScrollbarMouseDown\",\n    value: function handleVerticalScrollbarMouseDown(event) {\n      this.initialMouseY = getEventXY(event).y;\n      this.initialScreenY = paper_full_default.a.view.matrix.ty;\n      window.addEventListener('mousemove', this.handleVerticalScrollbarMouseMove);\n      window.addEventListener('touchmove', this.handleVerticalScrollbarMouseMove, {\n        passive: false\n      });\n      window.addEventListener('mouseup', this.handleVerticalScrollbarMouseUp);\n      window.addEventListener('touchend', this.handleVerticalScrollbarMouseUp);\n      event.preventDefault();\n    }\n  }, {\n    key: \"handleVerticalScrollbarMouseMove\",\n    value: function handleVerticalScrollbarMouseMove(event) {\n      var dy = this.initialMouseY - getEventXY(event).y;\n      paper_full_default.a.view.matrix.ty = this.initialScreenY + dy * paper_full_default.a.view.zoom * 2;\n      view_clampViewBounds();\n      this.props.updateViewBounds(paper_full_default.a.view.matrix);\n      event.preventDefault();\n    }\n  }, {\n    key: \"handleVerticalScrollbarMouseUp\",\n    value: function handleVerticalScrollbarMouseUp(event) {\n      window.removeEventListener('mousemove', this.handleVerticalScrollbarMouseMove);\n      window.removeEventListener('touchmove', this.handleVerticalScrollbarMouseMove, {\n        passive: false\n      });\n      window.removeEventListener('mouseup', this.handleVerticalScrollbarMouseUp);\n      window.removeEventListener('touchend', this.handleVerticalScrollbarMouseUp);\n      this.initialMouseY = null;\n      this.initialScreenY = null;\n      event.preventDefault();\n    }\n  }, {\n    key: \"handleWheel\",\n    value: function handleWheel(event) {\n      // Multiplier variable, so that non-pixel-deltaModes are supported. Needed for Firefox.\n      // See #529 (or LLK/scratch-blocks#1190).\n      var multiplier = event.deltaMode === 0x1 ? 15 : 1;\n      var deltaX = event.deltaX * multiplier;\n      var deltaY = event.deltaY * multiplier;\n      var canvasRect = this.props.canvas.getBoundingClientRect();\n      var offsetX = event.clientX - canvasRect.left;\n      var offsetY = event.clientY - canvasRect.top;\n      var fixedPoint = paper_full_default.a.view.viewToProject(new paper_full_default.a.Point(offsetX, offsetY));\n      if (event.metaKey || event.ctrlKey) {\n        // Zoom keeping mouse location fixed\n        view_zoomOnFixedPoint(-deltaY / 1000, fixedPoint);\n        this.props.updateViewBounds(paper_full_default.a.view.matrix);\n        this.props.redrawSelectionBox(); // Selection handles need to be resized after zoom\n      } else if (event.shiftKey && event.deltaX === 0) {\n        // Scroll horizontally (based on vertical scroll delta)\n        // This is needed as for some browser/system combinations which do not set deltaX.\n        // See #156.\n        var dx = deltaY / paper_full_default.a.view.zoom;\n        view_pan(dx, 0);\n        this.props.updateViewBounds(paper_full_default.a.view.matrix);\n      } else {\n        var _dx = deltaX / paper_full_default.a.view.zoom;\n        var dy = deltaY / paper_full_default.a.view.zoom;\n        view_pan(_dx, dy);\n        this.props.updateViewBounds(paper_full_default.a.view.matrix);\n        if (paper_full_default.a.tool) {\n          paper_full_default.a.tool.view._handleMouseEvent('mousemove', event, fixedPoint);\n        }\n      }\n      event.preventDefault();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var widthPercent = 0;\n      var heightPercent = 0;\n      var topPercent = 0;\n      var leftPercent = 0;\n      if (paper_full_default.a.project) {\n        var bounds = getWorkspaceBounds();\n        var _paper$view$bounds = paper_full_default.a.view.bounds,\n            x = _paper$view$bounds.x,\n            y = _paper$view$bounds.y,\n            width = _paper$view$bounds.width,\n            height = _paper$view$bounds.height;\n        widthPercent = Math.min(100, 100 * width / bounds.width);\n        heightPercent = Math.min(100, 100 * height / bounds.height);\n        var centerX = (x + width / 2 - bounds.x) / bounds.width;\n        var centerY = (y + height / 2 - bounds.y) / bounds.height;\n        topPercent = Math.max(0, 100 * centerY - heightPercent / 2);\n        leftPercent = Math.max(0, 100 * centerX - widthPercent / 2);\n      }\n      return react_default.a.createElement(scrollable_canvas_scrollable_canvas, {\n        hideScrollbars: this.props.hideScrollbars,\n        horizontalScrollLengthPercent: widthPercent,\n        horizontalScrollStartPercent: leftPercent,\n        style: this.props.style,\n        verticalScrollLengthPercent: heightPercent,\n        verticalScrollStartPercent: topPercent,\n        onHorizontalScrollbarMouseDown: this.handleHorizontalScrollbarMouseDown,\n        onVerticalScrollbarMouseDown: this.handleVerticalScrollbarMouseDown\n      }, this.props.children);\n    }\n  }]);\n  return ScrollableCanvas;\n}(react_default.a.Component);\nscrollable_canvas_ScrollableCanvas.propTypes = {\n  canvas: prop_types_default.a.instanceOf(Element),\n  children: prop_types_default.a.node.isRequired,\n  hideScrollbars: prop_types_default.a.bool,\n  redrawSelectionBox: prop_types_default.a.func.isRequired,\n  style: prop_types_default.a.string,\n  updateViewBounds: prop_types_default.a.func.isRequired\n};\nvar scrollable_canvas_mapStateToProps = function mapStateToProps(state) {\n  return {\n    viewBounds: state.scratchPaint.viewBounds\n  };\n};\nvar scrollable_canvas_mapDispatchToProps = function mapDispatchToProps(dispatch) {\n  return {\n    redrawSelectionBox: function redrawSelectionBox() {\n      dispatch(selected_items_redrawSelectionBox());\n    },\n    updateViewBounds: function updateViewBounds(matrix) {\n      dispatch(view_bounds_updateViewBounds(matrix));\n    }\n  };\n};\n/* harmony default export */ var containers_scrollable_canvas = (Object(es[\"b\" /* connect */])(scrollable_canvas_mapStateToProps, scrollable_canvas_mapDispatchToProps)(scrollable_canvas_ScrollableCanvas));\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/lib/gradient-types.js\nvar GradientTypes = keymirror_default()({\n  SOLID: null,\n  HORIZONTAL: null,\n  VERTICAL: null,\n  RADIAL: null\n});\n/* harmony default export */ var gradient_types = (GradientTypes);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/lib/make-color-style-reducer.js\nfunction make_color_style_reducer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\nfunction make_color_style_reducer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { make_color_style_reducer_ownKeys(Object(source), true).forEach(function (key) { make_color_style_reducer_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { make_color_style_reducer_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\nfunction make_color_style_reducer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n // Matches hex colors\nvar hexRegex = /^#([0-9a-f]{3}){1,2}$/i;\nvar make_color_style_reducer_isValidHexColor = function isValidHexColor(color) {\n  if (!hexRegex.test(color) && color !== null && color !== MIXED) {\n    log.warn(\"Invalid hex color code: \".concat(color));\n    return false;\n  }\n  return true;\n};\nvar make_color_style_reducer_makeColorStyleReducer = function makeColorStyleReducer(_ref) {\n  var changePrimaryColorAction = _ref.changePrimaryColorAction,\n      changeSecondaryColorAction = _ref.changeSecondaryColorAction,\n      changeGradientTypeAction = _ref.changeGradientTypeAction,\n      clearGradientAction = _ref.clearGradientAction,\n      defaultColor = _ref.defaultColor,\n      selectionPrimaryColorKey = _ref.selectionPrimaryColorKey,\n      selectionSecondaryColorKey = _ref.selectionSecondaryColorKey,\n      selectionGradientTypeKey = _ref.selectionGradientTypeKey;\n  return function colorReducer(state, action) {\n    if (typeof state === 'undefined') {\n      state = {\n        primary: defaultColor,\n        secondary: null,\n        gradientType: gradient_types.SOLID\n      };\n    }\n    switch (action.type) {\n      case changePrimaryColorAction:\n        if (!make_color_style_reducer_isValidHexColor(action.color)) return state;\n        return make_color_style_reducer_objectSpread(make_color_style_reducer_objectSpread({}, state), {}, {\n          primary: action.color\n        });\n      case changeSecondaryColorAction:\n        if (!make_color_style_reducer_isValidHexColor(action.color)) return state;\n        return make_color_style_reducer_objectSpread(make_color_style_reducer_objectSpread({}, state), {}, {\n          secondary: action.color\n        });\n      case CHANGE_SELECTED_ITEMS:\n        {\n          // Don't change state if no selection\n          if (!action.selectedItems || !action.selectedItems.length) {\n            return state;\n          }\n          var colors = style_path_getColorsFromSelection(action.selectedItems, action.bitmapMode); // Only set the primary color + gradient type if they exist in what getColorsFromSelection gave us.\n          // E.g. in bitmap mode, getColorsFromSelection will not return stroke color/gradient type. This allows us to\n          // preserve stroke swatch state across bitmap mode-- if getColorsFromSelection set them to null, then selecting\n          // anything in bitmap mode would overwrite the stroke state.\n          var newState = make_color_style_reducer_objectSpread({}, state);\n          if (selectionPrimaryColorKey in colors) {\n            newState.primary = colors[selectionPrimaryColorKey];\n          }\n          if (selectionGradientTypeKey in colors) {\n            newState.gradientType = colors[selectionGradientTypeKey];\n          } // Gradient type may be solid when multiple gradient types are selected.\n          // In this case, changing the first color should not change the second color.\n          if (selectionSecondaryColorKey in colors && (colors[selectionGradientTypeKey] !== gradient_types.SOLID || colors[selectionSecondaryColorKey] === MIXED)) {\n            newState.secondary = colors[selectionSecondaryColorKey];\n          }\n          return newState;\n        }\n      case changeGradientTypeAction:\n        if (action.gradientType in gradient_types) {\n          return make_color_style_reducer_objectSpread(make_color_style_reducer_objectSpread({}, state), {}, {\n            gradientType: action.gradientType\n          });\n        }\n        log.warn(\"Gradient type does not exist: \".concat(action.gradientType));\n        return state;\n      case clearGradientAction:\n        return make_color_style_reducer_objectSpread(make_color_style_reducer_objectSpread({}, state), {}, {\n          secondary: null,\n          gradientType: gradient_types.SOLID\n        });\n      default:\n        return state;\n    }\n  };\n};\n/* harmony default export */ var make_color_style_reducer = (make_color_style_reducer_makeColorStyleReducer);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/reducers/fill-style.js\nvar CHANGE_FILL_COLOR = 'scratch-paint/fill-style/CHANGE_FILL_COLOR';\nvar CHANGE_FILL_COLOR_2 = 'scratch-paint/fill-style/CHANGE_FILL_COLOR_2';\nvar CHANGE_FILL_GRADIENT_TYPE = 'scratch-paint/fill-style/CHANGE_FILL_GRADIENT_TYPE';\nvar CLEAR_FILL_GRADIENT = 'scratch-paint/fill-style/CLEAR_FILL_GRADIENT';\nvar DEFAULT_COLOR = '#9966FF';\nvar fill_style_reducer = make_color_style_reducer({\n  changePrimaryColorAction: CHANGE_FILL_COLOR,\n  changeSecondaryColorAction: CHANGE_FILL_COLOR_2,\n  changeGradientTypeAction: CHANGE_FILL_GRADIENT_TYPE,\n  clearGradientAction: CLEAR_FILL_GRADIENT,\n  defaultColor: DEFAULT_COLOR,\n  selectionPrimaryColorKey: 'fillColor',\n  selectionSecondaryColorKey: 'fillColor2',\n  selectionGradientTypeKey: 'fillGradientType'\n}); // Action creators ==================================\nvar changeFillColor = function changeFillColor(fillColor) {\n  return {\n    type: CHANGE_FILL_COLOR,\n    color: fillColor\n  };\n};\nvar changeFillColor2 = function changeFillColor2(fillColor) {\n  return {\n    type: CHANGE_FILL_COLOR_2,\n    color: fillColor\n  };\n};\nvar changeFillGradientType = function changeFillGradientType(gradientType) {\n  return {\n    type: CHANGE_FILL_GRADIENT_TYPE,\n    gradientType: gradientType\n  };\n};\nvar fill_style_clearFillGradient = function clearFillGradient() {\n  return {\n    type: CLEAR_FILL_GRADIENT\n  };\n};\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/helper/style-path.js\nfunction style_path_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = style_path_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction style_path_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return style_path_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return style_path_arrayLikeToArray(o, minLen); }\nfunction style_path_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar MIXED = 'scratch-paint/style-path/mixed'; // Check if the item color matches the incoming color. If the item color is a gradient, we assume\n// that the incoming color never matches, since we don't support gradients yet.\nvar style_path_colorMatch = function _colorMatch(itemColor, incomingColor) {\n  if (itemColor && itemColor.type === 'gradient') return false; // Either both are null or both are the same color when converted to CSS.\n  return !itemColor && !incomingColor || itemColor && incomingColor && itemColor.toCSS() === new paper_full_default.a.Color(incomingColor).toCSS();\n}; // Selected items and currently active text edit items respond to color changes.\nvar style_path_getColorStateListeners = function _getColorStateListeners(textEditTargetId) {\n  var items = selection_getSelectedLeafItems();\n  if (textEditTargetId) {\n    var matches = selection_getItems({\n      match: function match(item) {\n        return item.id === textEditTargetId;\n      }\n    });\n    if (matches.length) {\n      items.push(matches[0]);\n    }\n  }\n  return items;\n};\n/**\n * Transparent R, G, B values need to match the other color of the gradient\n * in order to form a smooth gradient, otherwise it fades through black. This\n * function gets the transparent color for a given color string.\n * @param {?string} colorToMatch CSS string of other color of gradient, or null for transparent\n * @return {string} CSS string for matching color of transparent\n */\nvar style_path_getColorStringForTransparent = function getColorStringForTransparent(colorToMatch) {\n  var color = new paper_full_default.a.Color(colorToMatch);\n  color.alpha = 0;\n  return color.toCSS();\n};\n/**\n * Generate a color that contrasts well with the passed-in color.\n * @param {string} firstColor The \"primary\" color\n * @return {string} CSS string for generated color\n */\nvar style_path_generateSecondaryColor = function generateSecondaryColor(firstColor) {\n  if (firstColor === MIXED) return null;\n  var color = new paper_full_default.a.Color(firstColor);\n  if (!firstColor || color.alpha === 0) return DEFAULT_COLOR;\n  color.type = 'hsb';\n  var desaturated = color.saturation <= 0.15; // If the color is desaturated or dark enough that a hue shift would be hard to see, do a brightness shift.\n  if (desaturated || color.brightness <= 0.4) {\n    // Choose the shade that contrasts the most with the given color.\n    // Use a brightness of 0.1 instead of 0 because if the brightness is 0, it's black and we lose the hue.\n    color.brightness = color.brightness < 0.55 ? 1 : 0.1;\n  } // If the color was desaturated, don't do a hue shift, as it would be hard to see anyway.\n  if (!desaturated) {\n    color.hue -= 72;\n  } // The returned color will be one of three things:\n  // 1. If the color was bright and saturated (e.g. colorful), it will be that color, hue-shifted.\n  // 2. If the color was dark and saturated, it will be that color, brightened and hue-shifted.\n  // 3. If the color was not saturated, it will be that color, brightened or darkened as needed to contrast most.\n  return color.toCSS(true\n  /* hex */\n  );\n};\n/**\n * Convert params to a paper.Color gradient object\n * @param {?string} color1 CSS string, or null for transparent\n * @param {?string} color2 CSS string, or null for transparent\n * @param {GradientType} gradientType gradient type\n * @param {paper.Rectangle} bounds Bounds of the object\n * @param {?paper.Point} [radialCenter] Where the center of a radial gradient should be, if the gradient is radial.\n * Defaults to center of bounds.\n * @param {number} [minSize] The minimum width/height of the gradient object.\n * @return {paper.Color} Color object with gradient, may be null or color string if the gradient type is solid\n */\nvar style_path_createGradientObject = function createGradientObject(color1, color2, gradientType, bounds, radialCenter, minSize) {\n  if (gradientType === gradient_types.SOLID) return color1;\n  if (color1 === null) {\n    color1 = style_path_getColorStringForTransparent(color2);\n  }\n  if (color2 === null) {\n    color2 = style_path_getColorStringForTransparent(color1);\n  } // Force gradients to have a minimum length. If the gradient start and end points are the same or very close\n  // (e.g. applying a vertical gradient to a perfectly horizontal line or vice versa), the gradient will not appear.\n  if (!minSize) minSize = 1e-2;\n  var start;\n  var end;\n  switch (gradientType) {\n    case gradient_types.HORIZONTAL:\n      {\n        // clone these points so that adding/subtracting doesn't affect actual bounds\n        start = bounds.leftCenter.clone();\n        end = bounds.rightCenter.clone();\n        var gradientSize = Math.abs(end.x - start.x);\n        if (gradientSize < minSize) {\n          var sizeDiff = (minSize - gradientSize) / 2;\n          end.x += sizeDiff;\n          start.x -= sizeDiff;\n        }\n        break;\n      }\n    case gradient_types.VERTICAL:\n      {\n        // clone these points so that adding/subtracting doesn't affect actual bounds\n        start = bounds.topCenter.clone();\n        end = bounds.bottomCenter.clone();\n        var _gradientSize = Math.abs(end.y - start.y);\n        if (_gradientSize < minSize) {\n          var _sizeDiff = (minSize - _gradientSize) / 2;\n          end.y += _sizeDiff;\n          start.y -= _sizeDiff;\n        }\n        break;\n      }\n    case gradient_types.RADIAL:\n      {\n        var halfLongestDimension = Math.max(bounds.width, bounds.height) / 2;\n        start = radialCenter || bounds.center;\n        end = start.add(new paper_full_default.a.Point(Math.max(halfLongestDimension, minSize / 2), 0));\n        break;\n      }\n  }\n  return {\n    gradient: {\n      stops: [color1, color2],\n      radial: gradientType === gradient_types.RADIAL\n    },\n    origin: start,\n    destination: end\n  };\n};\n/**\n * Called when setting an item's color\n * @param {string} colorString color, css format, or null if completely transparent\n * @param {number} colorIndex index of color being changed\n * @param {boolean} isSolidGradient True if is solid gradient. Sometimes the item has a gradient but the color\n *     picker is set to a solid gradient. This happens when a mix of colors and gradient types is selected.\n *     When changing the color in this case, the solid gradient should override the existing gradient on the item.\n * @param {?boolean} applyToStroke True if changing the selection's stroke, false if changing its fill.\n * @param {?string} textEditTargetId paper.Item.id of text editing target, if any\n * @return {boolean} Whether the color application actually changed visibly.\n */\nvar style_path_applyColorToSelection = function applyColorToSelection(colorString, colorIndex, isSolidGradient, applyToStroke, textEditTargetId) {\n  var items = style_path_getColorStateListeners(textEditTargetId);\n  var changed = false;\n  var _iterator = style_path_createForOfIteratorHelper(items),\n      _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var item = _step.value;\n      if (item.parent instanceof paper_full_default.a.CompoundPath) {\n        item = item.parent;\n      }\n      var itemColorProp = applyToStroke ? 'strokeColor' : 'fillColor';\n      var itemColor = item[itemColorProp];\n      if (isSolidGradient || !itemColor || !itemColor.gradient || !itemColor.gradient.stops.length === 2) {\n        // Applying a solid color\n        if (!style_path_colorMatch(itemColor, colorString)) {\n          changed = true;\n          if (isPointTextItem(item) && !colorString) {\n            // Allows transparent text to be hit\n            item[itemColorProp] = 'rgba(0,0,0,0)';\n          } else {\n            item[itemColorProp] = colorString;\n          }\n        }\n      } else if (!style_path_colorMatch(itemColor.gradient.stops[colorIndex].color, colorString)) {\n        // Changing one color of an existing gradient\n        changed = true;\n        var otherIndex = colorIndex === 0 ? 1 : 0;\n        if (colorString === null) {\n          colorString = style_path_getColorStringForTransparent(itemColor.gradient.stops[otherIndex].color.toCSS());\n        }\n        var colors = [0, 0];\n        colors[colorIndex] = colorString; // If the other color is transparent, its RGB values need to be adjusted for the gradient to be smooth\n        if (itemColor.gradient.stops[otherIndex].color.alpha === 0) {\n          colors[otherIndex] = style_path_getColorStringForTransparent(colorString);\n        } else {\n          colors[otherIndex] = itemColor.gradient.stops[otherIndex].color.toCSS();\n        } // There seems to be a bug where setting colors on stops doesn't always update the view, so set gradient.\n        itemColor.gradient = {\n          stops: colors,\n          radial: itemColor.gradient.radial\n        };\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return changed;\n};\n/**\n * Called to swap gradient colors\n * @param {?boolean} applyToStroke True if changing the selection's stroke, false if changing its fill.\n * @param {?string} textEditTargetId paper.Item.id of text editing target, if any\n * @return {boolean} Whether the color application actually changed visibly.\n */\nvar style_path_swapColorsInSelection = function swapColorsInSelection(applyToStroke, textEditTargetId) {\n  var items = style_path_getColorStateListeners(textEditTargetId);\n  var changed = false;\n  var _iterator2 = style_path_createForOfIteratorHelper(items),\n      _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var item = _step2.value;\n      // If an item is a child path, do not swap colors.\n      // At some point, we'll iterate over its parent path, and we don't want to swap colors twice--\n      // that would leave us right where we started.\n      if (isCompoundPathChild(item)) continue;\n      var itemColor = applyToStroke ? item.strokeColor : item.fillColor;\n      if (!itemColor || !itemColor.gradient || !itemColor.gradient.stops.length === 2) {\n        // Only one color; nothing to swap\n        continue;\n      } else if (!itemColor.gradient.stops[0].color.equals(itemColor.gradient.stops[1].color)) {\n        // Changing one color of an existing gradient\n        changed = true;\n        var colors = [itemColor.gradient.stops[1].color.toCSS(), itemColor.gradient.stops[0].color.toCSS()]; // There seems to be a bug where setting colors on stops doesn't always update the view, so set gradient.\n        itemColor.gradient = {\n          stops: colors,\n          radial: itemColor.gradient.radial\n        };\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return changed;\n};\n/**\n * Called when setting gradient type\n * @param {GradientType} gradientType gradient type\n * @param {?boolean} applyToStroke True if changing the selection's stroke, false if changing its fill.\n * @param {?string} textEditTargetId paper.Item.id of text editing target, if any\n * @return {boolean} Whether the color application actually changed visibly.\n */\nvar style_path_applyGradientTypeToSelection = function applyGradientTypeToSelection(gradientType, applyToStroke, textEditTargetId) {\n  var items = style_path_getColorStateListeners(textEditTargetId);\n  var changed = false;\n  var _iterator3 = style_path_createForOfIteratorHelper(items),\n      _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var item = _step3.value;\n      if (item.parent instanceof paper_full_default.a.CompoundPath) {\n        item = item.parent;\n      }\n      var itemColorProp = applyToStroke ? 'strokeColor' : 'fillColor';\n      var itemColor = item[itemColorProp];\n      var hasGradient = itemColor && itemColor.gradient;\n      var itemColor1 = void 0;\n      if (itemColor === null || itemColor.alpha === 0) {\n        // Transparent\n        itemColor1 = null;\n      } else if (!hasGradient) {\n        // Solid color\n        itemColor1 = itemColor.toCSS();\n      } else if (!itemColor.gradient.stops[0] || itemColor.gradient.stops[0].color.alpha === 0) {\n        // Gradient where first color is transparent\n        itemColor1 = null;\n      } else {\n        // Gradient where first color is not transparent\n        itemColor1 = itemColor.gradient.stops[0].color.toCSS();\n      }\n      var itemColor2 = void 0;\n      if (!hasGradient || !itemColor.gradient.stops[1]) {\n        // If item color is solid or a gradient that has no 2nd color, set the 2nd color based on the first color\n        itemColor2 = style_path_generateSecondaryColor(itemColor1);\n      } else if (itemColor.gradient.stops[1].color.alpha === 0) {\n        // Gradient has 2nd color which is transparent\n        itemColor2 = null;\n      } else {\n        // Gradient has 2nd color which is not transparent\n        itemColor2 = itemColor.gradient.stops[1].color.toCSS();\n      }\n      if (gradientType === gradient_types.SOLID) {\n        if (itemColor && itemColor.gradient) {\n          changed = true;\n          item[itemColorProp] = itemColor1;\n        }\n        continue;\n      } // If this is a stroke, we don't display it as having a gradient in the color picker\n      // if there's no stroke width. Then treat it as if it doesn't have a gradient.\n      var hasDisplayGradient = hasGradient;\n      if (applyToStroke) hasDisplayGradient = hasGradient && item.strokeWidth > 0;\n      if (!hasDisplayGradient) {\n        var noColorOriginally = !itemColor || itemColor.gradient && itemColor.gradient.stops && itemColor.gradient.stops[0].color.alpha === 0;\n        var addingStroke = applyToStroke && item.strokeWidth === 0;\n        var hasGradientNow = itemColor1 || itemColor2;\n        if ((noColorOriginally || addingStroke) && hasGradientNow) {\n          if (applyToStroke) {\n            // Make outline visible\n            item.strokeWidth = 1;\n          } // Make the gradient black to white\n          itemColor1 = 'black';\n          itemColor2 = 'white';\n        }\n      }\n      if (itemColor1 === null) {\n        itemColor1 = style_path_getColorStringForTransparent(itemColor2);\n      }\n      if (itemColor2 === null) {\n        itemColor2 = style_path_getColorStringForTransparent(itemColor1);\n      }\n      var gradientTypeDiffers = false; // If the item's gradient type differs from the gradient type we want to apply, then we change it\n      switch (gradientType) {\n        case gradient_types.RADIAL:\n          {\n            var hasRadialGradient = hasDisplayGradient && itemColor.gradient.radial;\n            gradientTypeDiffers = !hasRadialGradient;\n            break;\n          }\n        case gradient_types.HORIZONTAL:\n          {\n            var hasHorizontalGradient = hasDisplayGradient && !itemColor.gradient.radial && Math.abs(itemColor.origin.y - itemColor.destination.y) < 1e-8;\n            gradientTypeDiffers = !hasHorizontalGradient;\n            break;\n          }\n        case gradient_types.VERTICAL:\n          {\n            var hasVerticalGradient = hasDisplayGradient && !itemColor.gradient.radial && Math.abs(itemColor.origin.x - itemColor.destination.x) < 1e-8;\n            gradientTypeDiffers = !hasVerticalGradient;\n            break;\n          }\n      }\n      if (gradientTypeDiffers) {\n        changed = true;\n        item[itemColorProp] = style_path_createGradientObject(itemColor1, itemColor2, gradientType, item.bounds, null, // radialCenter\n        item.strokeWidth);\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  return changed;\n};\n/**\n * Called when setting stroke width\n * @param {number} value New stroke width\n * @param {?string} textEditTargetId paper.Item.id of text editing target, if any\n * @return {boolean} Whether the color application actually changed visibly.\n */\nvar style_path_applyStrokeWidthToSelection = function applyStrokeWidthToSelection(value, textEditTargetId) {\n  var changed = false;\n  var items = style_path_getColorStateListeners(textEditTargetId);\n  var _iterator4 = style_path_createForOfIteratorHelper(items),\n      _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var item = _step4.value;\n      if (item.parent instanceof paper_full_default.a.CompoundPath) {\n        item = item.parent;\n      }\n      if (group_isGroup(item)) {\n        continue;\n      } else if (item.strokeWidth !== value) {\n        item.strokeWidth = value;\n        changed = true;\n      }\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n  return changed;\n};\nvar style_path_colorStateFromGradient = function _colorStateFromGradient(gradient) {\n  var colorState = {}; // Scratch only recognizes 2 color gradients\n  if (gradient.stops.length === 2) {\n    if (gradient.radial) {\n      colorState.gradientType = gradient_types.RADIAL;\n    } else {\n      // Always use horizontal for linear gradients, since horizontal and vertical gradients\n      // are the same with rotation. We don't want to show MIXED just because anything is rotated.\n      colorState.gradientType = gradient_types.HORIZONTAL;\n    }\n    colorState.primary = gradient.stops[0].color.alpha === 0 ? null : gradient.stops[0].color.toCSS();\n    colorState.secondary = gradient.stops[1].color.alpha === 0 ? null : gradient.stops[1].color.toCSS();\n  } else {\n    if (gradient.stops.length < 2) log.warn(\"Gradient has \".concat(gradient.stops.length, \" stop(s)\"));\n    colorState.primary = MIXED;\n    colorState.secondary = MIXED;\n  }\n  return colorState;\n};\n/**\n * Get state of colors and stroke width for selection\n * @param {!Array<paper.Item>} selectedItems Selected paper items\n * @param {?boolean} bitmapMode True if the item is being selected in bitmap mode\n * @return {?object} Object of strokeColor, strokeWidth, fillColor, thickness of the selection.\n *     Gives MIXED when there are mixed values for a color, and null for transparent.\n *     Gives null when there are mixed values for stroke width.\n *     Thickness is line thickness, used in the bitmap editor\n */\nvar style_path_getColorsFromSelection = function getColorsFromSelection(selectedItems, bitmapMode) {\n  // TODO: DRY out this code\n  var selectionFillColorString;\n  var selectionFillColor2String;\n  var selectionStrokeColorString;\n  var selectionStrokeColor2String;\n  var selectionStrokeWidth;\n  var selectionThickness;\n  var selectionFillGradientType;\n  var selectionStrokeGradientType;\n  var firstChild = true;\n  var _iterator5 = style_path_createForOfIteratorHelper(selectedItems),\n      _step5;\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var item = _step5.value;\n      if (item.parent instanceof paper_full_default.a.CompoundPath) {\n        // Compound path children inherit fill and stroke color from their parent.\n        item = item.parent;\n      }\n      var itemFillColorString = void 0;\n      var itemFillColor2String = void 0;\n      var itemStrokeColorString = void 0;\n      var itemStrokeColor2String = void 0;\n      var itemFillGradientType = gradient_types.SOLID;\n      var itemStrokeGradientType = gradient_types.SOLID;\n      if (!group_isGroup(item)) {\n        if (item.fillColor) {\n          // hack bc text items with null fill can't be detected by fill-hitTest anymore\n          if (isPointTextItem(item) && item.fillColor.alpha === 0) {\n            itemFillColorString = null;\n          } else if (item.fillColor.type === 'gradient') {\n            var _colorStateFromGradie = style_path_colorStateFromGradient(item.fillColor.gradient),\n                primary = _colorStateFromGradie.primary,\n                secondary = _colorStateFromGradie.secondary,\n                gradientType = _colorStateFromGradie.gradientType;\n            itemFillColorString = primary;\n            itemFillColor2String = secondary;\n            itemFillGradientType = gradientType;\n          } else {\n            itemFillColorString = item.fillColor.alpha === 0 ? null : item.fillColor.toCSS();\n            itemFillColor2String = null;\n          }\n        }\n        if (item.strokeColor) {\n          if (item.strokeColor.type === 'gradient') {\n            var _colorStateFromGradie2 = style_path_colorStateFromGradient(item.strokeColor.gradient),\n                _primary = _colorStateFromGradie2.primary,\n                _secondary = _colorStateFromGradie2.secondary,\n                _gradientType = _colorStateFromGradie2.gradientType;\n            var strokeColorString = _primary;\n            var strokeColor2String = _secondary;\n            var strokeGradientType = _gradientType; // If the item's stroke width is 0, pretend the stroke color is null\n            if (!item.strokeWidth) {\n              strokeColorString = null; // Hide the second color. This way if you choose a second color, remove\n              // the gradient, and re-add it, your second color selection is preserved.\n              strokeGradientType = gradient_types.SOLID;\n            } // Stroke color is fill color in bitmap\n            if (bitmapMode) {\n              itemFillColorString = strokeColorString;\n              itemFillColor2String = strokeColor2String;\n              itemFillGradientType = strokeGradientType;\n            } else {\n              itemStrokeColorString = strokeColorString;\n              itemStrokeColor2String = strokeColor2String;\n              itemStrokeGradientType = strokeGradientType;\n            }\n          } else {\n            var _strokeColorString = item.strokeColor.alpha === 0 || !item.strokeWidth ? null : item.strokeColor.toCSS(); // Stroke color is fill color in bitmap\n            if (bitmapMode) {\n              itemFillColorString = _strokeColorString;\n            } else {\n              itemStrokeColorString = _strokeColorString;\n            }\n          }\n        } else {\n          itemStrokeColorString = null;\n          itemStrokeColor2String = null;\n        } // check every style against the first of the items\n        if (firstChild) {\n          firstChild = false;\n          selectionFillColorString = itemFillColorString;\n          selectionFillColor2String = itemFillColor2String;\n          selectionStrokeColorString = itemStrokeColorString;\n          selectionStrokeColor2String = itemStrokeColor2String;\n          selectionFillGradientType = itemFillGradientType;\n          selectionStrokeGradientType = itemStrokeGradientType;\n          selectionStrokeWidth = itemStrokeColorString || itemStrokeColor2String ? item.strokeWidth : 0;\n          if (item.strokeWidth && item.data && item.data.zoomLevel) {\n            selectionThickness = item.strokeWidth / item.data.zoomLevel;\n          }\n        }\n        if (itemFillColorString !== selectionFillColorString) {\n          selectionFillColorString = MIXED;\n        }\n        if (itemFillColor2String !== selectionFillColor2String) {\n          selectionFillColor2String = MIXED;\n        }\n        if (itemFillGradientType !== selectionFillGradientType) {\n          selectionFillGradientType = gradient_types.SOLID;\n          selectionFillColorString = MIXED;\n          selectionFillColor2String = MIXED;\n        }\n        if (itemStrokeGradientType !== selectionStrokeGradientType) {\n          selectionStrokeGradientType = gradient_types.SOLID;\n          selectionStrokeColorString = MIXED;\n          selectionStrokeColor2String = MIXED;\n        }\n        if (itemStrokeColorString !== selectionStrokeColorString) {\n          selectionStrokeColorString = MIXED;\n        }\n        if (itemStrokeColor2String !== selectionStrokeColor2String) {\n          selectionStrokeColor2String = MIXED;\n        }\n        var itemStrokeWidth = itemStrokeColorString || itemStrokeColor2String ? item.strokeWidth : 0;\n        if (selectionStrokeWidth !== itemStrokeWidth) {\n          selectionStrokeWidth = null;\n        }\n      }\n    } // Convert selection gradient type from horizontal to vertical if first item is exactly vertical\n    // This is because up to this point, we assume all non-radial gradients are horizontal\n    // Otherwise, if there were a mix of horizontal/vertical gradient types in the selection, they would show as MIXED\n    // whereas we want them to show as horizontal (or vertical if the first item is vertical)\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n  if (selectedItems && selectedItems.length) {\n    var firstItem = selectedItems[0];\n    if (firstItem.parent instanceof paper_full_default.a.CompoundPath) firstItem = firstItem.parent;\n    if (selectionFillGradientType !== gradient_types.SOLID) {\n      // Stroke color is fill color in bitmap if fill color is missing\n      // TODO: this whole \"treat horizontal/vertical gradients specially\" logic is janky; refactor at some point\n      var firstItemColor = bitmapMode && firstItem.strokeColor ? firstItem.strokeColor : firstItem.fillColor;\n      var direction = firstItemColor.destination.subtract(firstItemColor.origin);\n      if (Math.abs(direction.angle) === 90) {\n        selectionFillGradientType = gradient_types.VERTICAL;\n      }\n    }\n    if (selectionStrokeGradientType !== gradient_types.SOLID) {\n      var _direction = firstItem.strokeColor.destination.subtract(firstItem.strokeColor.origin);\n      if (Math.abs(_direction.angle) === 90) {\n        selectionStrokeGradientType = gradient_types.VERTICAL;\n      }\n    }\n  }\n  if (bitmapMode) {\n    return {\n      fillColor: selectionFillColorString ? selectionFillColorString : null,\n      fillColor2: selectionFillColor2String ? selectionFillColor2String : null,\n      fillGradientType: selectionFillGradientType,\n      thickness: selectionThickness\n    };\n  }\n  return {\n    fillColor: selectionFillColorString ? selectionFillColorString : null,\n    fillColor2: selectionFillColor2String ? selectionFillColor2String : null,\n    fillGradientType: selectionFillGradientType,\n    strokeColor: selectionStrokeColorString ? selectionStrokeColorString : null,\n    strokeColor2: selectionStrokeColor2String ? selectionStrokeColor2String : null,\n    strokeGradientType: selectionStrokeGradientType,\n    strokeWidth: selectionStrokeWidth || selectionStrokeWidth === null ? selectionStrokeWidth : 0\n  };\n};\nvar styleBlob = function styleBlob(path, options) {\n  if (options.isEraser) {\n    path.fillColor = 'white';\n  } else if (options.fillColor) {\n    path.fillColor = options.fillColor;\n  } else {\n    // Make sure something visible is drawn\n    path.fillColor = 'black';\n  }\n};\nvar styleCursorPreview = function styleCursorPreview(path, options) {\n  if (options.isEraser) {\n    path.fillColor = 'white';\n    path.strokeColor = 'cornflowerblue';\n    path.strokeWidth = 1;\n  } else if (options.fillColor) {\n    path.fillColor = options.fillColor;\n  } else {\n    // Make sure something visible is drawn\n    path.fillColor = 'black';\n  }\n};\nvar style_path_styleShape = function styleShape(path, options) {\n  for (var _i = 0, _arr = ['fillColor', 'strokeColor']; _i < _arr.length; _i++) {\n    var colorKey = _arr[_i];\n    if (options[colorKey] === null) {\n      path[colorKey] = null;\n    } else if (options[colorKey].gradientType === gradient_types.SOLID) {\n      path[colorKey] = options[colorKey].primary;\n    } else {\n      var _options$colorKey = options[colorKey],\n          primary = _options$colorKey.primary,\n          secondary = _options$colorKey.secondary,\n          gradientType = _options$colorKey.gradientType;\n      path[colorKey] = style_path_createGradientObject(primary, secondary, gradientType, path.bounds, null, // radialCenter\n      options.strokeWidth // minimum gradient size is stroke width\n      );\n    }\n  }\n  if (options.hasOwnProperty('strokeWidth')) path.strokeWidth = options.strokeWidth;\n};\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/reducers/modes.js\nvar CHANGE_MODE = 'scratch-paint/modes/CHANGE_MODE';\nvar modes_initialState = Modes.SELECT;\nvar modes_reducer = function reducer(state, action) {\n  if (typeof state === 'undefined') state = modes_initialState;\n  switch (action.type) {\n    case CHANGE_MODE:\n      if (action.mode in Modes) {\n        return action.mode;\n      }\n      log.warn(\"Mode does not exist: \".concat(action.mode));\n    /* falls through */\n    default:\n      return state;\n  }\n}; // Action creators ==================================\nvar modes_changeMode = function changeMode(mode) {\n  return {\n    type: CHANGE_MODE,\n    mode: mode\n  };\n};\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/button/button.css\nvar button_button = __webpack_require__(276);\nvar button_default = __webpack_require__.n(button_button);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/components/button/button.jsx\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction button_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* DO NOT EDIT\n@todo This file is copied from GUI and should be pulled out into a shared library.\nSee #13 */\n/* ACTUALLY, THIS IS EDITED ;)\nTHIS WAS CHANGED ON 10/25/2017 BY @mewtaylor TO ADD HANDLING FOR DISABLED STATES.*/\n\nvar button_ButtonComponent = function ButtonComponent(_ref) {\n  var _classNames;\n  var className = _ref.className,\n      highlighted = _ref.highlighted,\n      onClick = _ref.onClick,\n      children = _ref.children,\n      props = _objectWithoutProperties(_ref, [\"className\", \"highlighted\", \"onClick\", \"children\"]);\n  var disabled = props.disabled || false;\n  if (disabled === false) {\n    // if not disabled, add `onClick()` to be applied\n    // in props. If disabled, don't add `onClick()`\n    props.onClick = onClick;\n  }\n  return react_default.a.createElement(\"span\", _extends({\n    className: classnames_default()(button_default.a.button, className, (_classNames = {}, button_defineProperty(_classNames, button_default.a.modDisabled, disabled), button_defineProperty(_classNames, button_default.a.highlighted, highlighted), _classNames)),\n    role: \"button\"\n  }, props), children);\n};\nbutton_ButtonComponent.propTypes = {\n  children: prop_types_default.a.node,\n  className: prop_types_default.a.string,\n  disabled: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.bool]),\n  highlighted: prop_types_default.a.bool,\n  onClick: prop_types_default.a.func.isRequired\n};\n/* harmony default export */ var components_button_button = (button_ButtonComponent);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/tool-select-base/tool-select-base.css\nvar tool_select_base = __webpack_require__(277);\nvar tool_select_base_default = __webpack_require__.n(tool_select_base);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/components/tool-select-base/tool-select-base.jsx\nfunction tool_select_base_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar tool_select_base_ToolSelectComponent = function ToolSelectComponent(props) {\n  return react_default.a.createElement(components_button_button, {\n    className: classnames_default()(props.className, tool_select_base_default.a.modToolSelect, tool_select_base_defineProperty({}, tool_select_base_default.a.isSelected, props.isSelected)),\n    disabled: props.disabled,\n    title: props.intl.formatMessage(props.imgDescriptor),\n    onClick: props.onMouseDown\n  }, react_default.a.createElement(\"img\", {\n    alt: props.intl.formatMessage(props.imgDescriptor),\n    className: tool_select_base_default.a.toolSelectIcon,\n    draggable: false,\n    src: props.imgSrc\n  }));\n};\ntool_select_base_ToolSelectComponent.propTypes = {\n  className: prop_types_default.a.string,\n  disabled: prop_types_default.a.bool,\n  imgDescriptor: prop_types_default.a.shape({\n    defaultMessage: prop_types_default.a.string,\n    description: prop_types_default.a.string,\n    id: prop_types_default.a.string\n  }).isRequired,\n  imgSrc: prop_types_default.a.string.isRequired,\n  intl: index_es[\"f\" /* intlShape */].isRequired,\n  isSelected: prop_types_default.a.bool.isRequired,\n  onMouseDown: prop_types_default.a.func.isRequired\n};\n/* harmony default export */ var tool_select_base_tool_select_base = (Object(index_es[\"e\" /* injectIntl */])(tool_select_base_ToolSelectComponent));\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/lib/messages.js\nvar messages_messages = Object(index_es[\"d\" /* defineMessages */])({\n  brush: {\n    \"id\": \"paint.brushMode.brush\",\n    \"defaultMessage\": \"Brush\"\n  },\n  eraser: {\n    \"id\": \"paint.eraserMode.eraser\",\n    \"defaultMessage\": \"Eraser\"\n  },\n  fill: {\n    \"id\": \"paint.fillMode.fill\",\n    \"defaultMessage\": \"Fill\"\n  },\n  line: {\n    \"id\": \"paint.lineMode.line\",\n    \"defaultMessage\": \"Line\"\n  },\n  oval: {\n    \"id\": \"paint.ovalMode.oval\",\n    \"defaultMessage\": \"Circle\"\n  },\n  rect: {\n    \"id\": \"paint.rectMode.rect\",\n    \"defaultMessage\": \"Rectangle\"\n  },\n  reshape: {\n    \"id\": \"paint.reshapeMode.reshape\",\n    \"defaultMessage\": \"Reshape\"\n  },\n  roundedRect: {\n    \"id\": \"paint.roundedRectMode.roundedRect\",\n    \"defaultMessage\": \"Rounded Rectangle\"\n  },\n  select: {\n    \"id\": \"paint.selectMode.select\",\n    \"defaultMessage\": \"Select\"\n  },\n  text: {\n    \"id\": \"paint.textMode.text\",\n    \"defaultMessage\": \"Text\"\n  }\n});\n/* harmony default export */ var lib_messages = (messages_messages);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/bit-brush-mode/brush.svg\nvar brush = __webpack_require__(251);\nvar brush_default = __webpack_require__.n(brush);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/components/bit-brush-mode/bit-brush-mode.jsx\n\nvar bit_brush_mode_BitBrushModeComponent = function BitBrushModeComponent(props) {\n  return react_default.a.createElement(tool_select_base_tool_select_base, {\n    imgDescriptor: lib_messages.brush,\n    imgSrc: brush_default.a,\n    isSelected: props.isSelected,\n    onMouseDown: props.onMouseDown\n  });\n};\nbit_brush_mode_BitBrushModeComponent.propTypes = {\n  isSelected: prop_types_default.a.bool.isRequired,\n  onMouseDown: prop_types_default.a.func.isRequired\n};\n/* harmony default export */ var bit_brush_mode = (bit_brush_mode_BitBrushModeComponent);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/helper/bit-tools/brush-tool.js\nfunction brush_tool_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { brush_tool_typeof = function _typeof(obj) { return typeof obj; }; } else { brush_tool_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return brush_tool_typeof(obj); }\nfunction brush_tool_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction brush_tool_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction brush_tool_createClass(Constructor, protoProps, staticProps) { if (protoProps) brush_tool_defineProperties(Constructor.prototype, protoProps); if (staticProps) brush_tool_defineProperties(Constructor, staticProps); return Constructor; }\nfunction brush_tool_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) brush_tool_setPrototypeOf(subClass, superClass); }\nfunction brush_tool_setPrototypeOf(o, p) { brush_tool_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return brush_tool_setPrototypeOf(o, p); }\nfunction brush_tool_createSuper(Derived) { var hasNativeReflectConstruct = brush_tool_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = brush_tool_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = brush_tool_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return brush_tool_possibleConstructorReturn(this, result); }; }\nfunction brush_tool_possibleConstructorReturn(self, call) { if (call && (brush_tool_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return brush_tool_assertThisInitialized(self); }\nfunction brush_tool_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction brush_tool_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction brush_tool_getPrototypeOf(o) { brush_tool_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return brush_tool_getPrototypeOf(o); }\n\n/**\n * Tool for drawing with the bitmap brush and eraser\n */\nvar brush_tool_BrushTool = function (_paper$Tool) {\n  brush_tool_inherits(BrushTool, _paper$Tool);\n  var _super = brush_tool_createSuper(BrushTool);\n  /**\n   * @param {!function} onUpdateImage A callback to call when the image visibly changes\n   * @param {boolean} isEraser True if brush should erase\n   */\n  function BrushTool(onUpdateImage, isEraser) {\n    var _this;\n    brush_tool_classCallCheck(this, BrushTool);\n    _this = _super.call(this);\n    _this.onUpdateImage = onUpdateImage;\n    _this.isEraser = isEraser; // We have to set these functions instead of just declaring them because\n    // paper.js tools hook up the listeners in the setter functions.\n    _this.onMouseMove = _this.handleMouseMove;\n    _this.onMouseDown = _this.handleMouseDown;\n    _this.onMouseDrag = _this.handleMouseDrag;\n    _this.onMouseUp = _this.handleMouseUp;\n    _this.colorState = null;\n    _this.active = false;\n    _this.lastPoint = null;\n    _this.cursorPreview = null;\n    return _this;\n  }\n  brush_tool_createClass(BrushTool, [{\n    key: \"setColor\",\n    value: function setColor(color) {\n      this.color = color;\n      this.tmpCanvas = bitmap_getBrushMark(this.size, this.color, this.isEraser || !this.color);\n    }\n  }, {\n    key: \"setBrushSize\",\n    value: function setBrushSize(size) {\n      // For performance, make sure this is an integer\n      this.size = Math.max(1, ~~size);\n      this.tmpCanvas = bitmap_getBrushMark(this.size, this.color, this.isEraser || !this.color);\n    } // Draw a brush mark at the given point\n  }, {\n    key: \"draw\",\n    value: function draw(x, y) {\n      var roundedUpRadius = Math.ceil(this.size / 2);\n      var context = getRaster().getContext('2d',{willReadFrequently:true});\n      if (this.isEraser || !this.color) {\n        context.globalCompositeOperation = 'destination-out';\n      }\n      getRaster().drawImage(this.tmpCanvas, new paper_full_default.a.Point(~~x - roundedUpRadius, ~~y - roundedUpRadius));\n      if (this.isEraser || !this.color) {\n        context.globalCompositeOperation = 'source-over';\n      }\n    }\n  }, {\n    key: \"updateCursorIfNeeded\",\n    value: function updateCursorIfNeeded() {\n      if (!this.size) {\n        return;\n      } // The cursor preview was unattached from the view by an outside process,\n      // such as changing costumes or undo.\n      if (this.cursorPreview && !this.cursorPreview.parent) {\n        this.cursorPreview = null;\n      }\n      if (!this.cursorPreview || !(this.lastSize === this.size && this.lastColor === this.color)) {\n        if (this.cursorPreview) {\n          this.cursorPreview.remove();\n        }\n        this.tmpCanvas = bitmap_getBrushMark(this.size, this.color, this.isEraser || !this.color);\n        this.cursorPreview = new paper_full_default.a.Raster(this.tmpCanvas);\n        this.cursorPreview.guide = true;\n        this.cursorPreview.parent = getGuideLayer();\n        this.cursorPreview.data.isHelperItem = true;\n      }\n      this.lastSize = this.size;\n      this.lastColor = this.color;\n    }\n  }, {\n    key: \"handleMouseMove\",\n    value: function handleMouseMove(event) {\n      this.updateCursorIfNeeded();\n      this.cursorPreview.position = new paper_full_default.a.Point(~~event.point.x, ~~event.point.y);\n    }\n  }, {\n    key: \"handleMouseDown\",\n    value: function handleMouseDown(event) {\n      if (event.event.button > 0) return; // only first mouse button\n      this.active = true;\n      if (this.cursorPreview) {\n        this.cursorPreview.remove();\n      }\n      this.draw(event.point.x, event.point.y);\n      this.lastPoint = event.point;\n    }\n  }, {\n    key: \"handleMouseDrag\",\n    value: function handleMouseDrag(event) {\n      if (event.event.button > 0 || !this.active) return; // only first mouse button\n      forEachLinePoint(this.lastPoint, event.point, this.draw.bind(this));\n      this.lastPoint = event.point;\n    }\n  }, {\n    key: \"handleMouseUp\",\n    value: function handleMouseUp(event) {\n      if (event.event.button > 0 || !this.active) return; // only first mouse button\n      forEachLinePoint(this.lastPoint, event.point, this.draw.bind(this));\n      this.onUpdateImage();\n      this.lastPoint = null;\n      this.active = false;\n      this.updateCursorIfNeeded();\n      this.cursorPreview.position = new paper_full_default.a.Point(~~event.point.x, ~~event.point.y);\n    }\n  }, {\n    key: \"deactivateTool\",\n    value: function deactivateTool() {\n      this.active = false;\n      this.tmpCanvas = null;\n      if (this.cursorPreview) {\n        this.cursorPreview.remove();\n        this.cursorPreview = null;\n      }\n    }\n  }]);\n  return BrushTool;\n}(paper_full_default.a.Tool);\n/* harmony default export */ var brush_tool = (brush_tool_BrushTool);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/containers/bit-brush-mode.jsx\nfunction bit_brush_mode_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { bit_brush_mode_typeof = function _typeof(obj) { return typeof obj; }; } else { bit_brush_mode_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return bit_brush_mode_typeof(obj); }\nfunction bit_brush_mode_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction bit_brush_mode_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction bit_brush_mode_createClass(Constructor, protoProps, staticProps) { if (protoProps) bit_brush_mode_defineProperties(Constructor.prototype, protoProps); if (staticProps) bit_brush_mode_defineProperties(Constructor, staticProps); return Constructor; }\nfunction bit_brush_mode_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) bit_brush_mode_setPrototypeOf(subClass, superClass); }\nfunction bit_brush_mode_setPrototypeOf(o, p) { bit_brush_mode_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return bit_brush_mode_setPrototypeOf(o, p); }\nfunction bit_brush_mode_createSuper(Derived) { var hasNativeReflectConstruct = bit_brush_mode_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = bit_brush_mode_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = bit_brush_mode_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return bit_brush_mode_possibleConstructorReturn(this, result); }; }\nfunction bit_brush_mode_possibleConstructorReturn(self, call) { if (call && (bit_brush_mode_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return bit_brush_mode_assertThisInitialized(self); }\nfunction bit_brush_mode_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction bit_brush_mode_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction bit_brush_mode_getPrototypeOf(o) { bit_brush_mode_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return bit_brush_mode_getPrototypeOf(o); }\n\nvar bit_brush_mode_BitBrushMode = function (_React$Component) {\n  bit_brush_mode_inherits(BitBrushMode, _React$Component);\n  var _super = bit_brush_mode_createSuper(BitBrushMode);\n  function BitBrushMode(props) {\n    var _this;\n    bit_brush_mode_classCallCheck(this, BitBrushMode);\n    _this = _super.call(this, props);\n    lodash_bindall_default()(bit_brush_mode_assertThisInitialized(_this), ['activateTool', 'deactivateTool']);\n    return _this;\n  }\n  bit_brush_mode_createClass(BitBrushMode, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this.props.isBitBrushModeActive) {\n        this.activateTool(this.props);\n      }\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(nextProps) {\n      if (this.tool && nextProps.color !== this.props.color) {\n        this.tool.setColor(nextProps.color);\n      }\n      if (this.tool && nextProps.bitBrushSize !== this.props.bitBrushSize) {\n        this.tool.setBrushSize(nextProps.bitBrushSize);\n      }\n      if (nextProps.isBitBrushModeActive && !this.props.isBitBrushModeActive) {\n        this.activateTool();\n      } else if (!nextProps.isBitBrushModeActive && this.props.isBitBrushModeActive) {\n        this.deactivateTool();\n      }\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps) {\n      return nextProps.isBitBrushModeActive !== this.props.isBitBrushModeActive;\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.tool) {\n        this.deactivateTool();\n      }\n    }\n  }, {\n    key: \"activateTool\",\n    value: function activateTool() {\n      selection_clearSelection(this.props.clearSelectedItems);\n      this.props.clearGradient(); // Force the default brush color if fill is MIXED or transparent\n      var color = this.props.color;\n      if (!color || color === MIXED) {\n        this.props.onChangeFillColor(DEFAULT_COLOR);\n        color = DEFAULT_COLOR;\n      }\n      this.tool = new brush_tool(this.props.onUpdateImage);\n      this.tool.setColor(color);\n      this.tool.setBrushSize(this.props.bitBrushSize);\n      this.tool.activate();\n    }\n  }, {\n    key: \"deactivateTool\",\n    value: function deactivateTool() {\n      this.tool.deactivateTool();\n      this.tool.remove();\n      this.tool = null;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return react_default.a.createElement(bit_brush_mode, {\n        isSelected: this.props.isBitBrushModeActive,\n        onMouseDown: this.props.handleMouseDown\n      });\n    }\n  }]);\n  return BitBrushMode;\n}(react_default.a.Component);\nbit_brush_mode_BitBrushMode.propTypes = {\n  bitBrushSize: prop_types_default.a.number.isRequired,\n  clearGradient: prop_types_default.a.func.isRequired,\n  clearSelectedItems: prop_types_default.a.func.isRequired,\n  color: prop_types_default.a.string,\n  handleMouseDown: prop_types_default.a.func.isRequired,\n  isBitBrushModeActive: prop_types_default.a.bool.isRequired,\n  onChangeFillColor: prop_types_default.a.func.isRequired,\n  onUpdateImage: prop_types_default.a.func.isRequired\n};\nvar bit_brush_mode_mapStateToProps = function mapStateToProps(state) {\n  return {\n    bitBrushSize: state.scratchPaint.bitBrushSize,\n    color: state.scratchPaint.color.fillColor.primary,\n    isBitBrushModeActive: state.scratchPaint.mode === Modes.BIT_BRUSH\n  };\n};\nvar bit_brush_mode_mapDispatchToProps = function mapDispatchToProps(dispatch) {\n  return {\n    clearSelectedItems: function clearSelectedItems() {\n      dispatch(selected_items_clearSelectedItems());\n    },\n    clearGradient: function clearGradient() {\n      dispatch(fill_style_clearFillGradient());\n    },\n    handleMouseDown: function handleMouseDown() {\n      dispatch(modes_changeMode(Modes.BIT_BRUSH));\n    },\n    onChangeFillColor: function onChangeFillColor(fillColor) {\n      dispatch(changeFillColor(fillColor));\n    }\n  };\n};\n/* harmony default export */ var containers_bit_brush_mode = (Object(es[\"b\" /* connect */])(bit_brush_mode_mapStateToProps, bit_brush_mode_mapDispatchToProps)(bit_brush_mode_BitBrushMode));\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/bit-line-mode/line.svg\nvar bit_line_mode_line = __webpack_require__(252);\nvar line_default = __webpack_require__.n(bit_line_mode_line);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/components/bit-line-mode/bit-line-mode.jsx\n\nvar bit_line_mode_BitLineComponent = function BitLineComponent(props) {\n  return react_default.a.createElement(tool_select_base_tool_select_base, {\n    imgDescriptor: lib_messages.line,\n    imgSrc: line_default.a,\n    isSelected: props.isSelected,\n    onMouseDown: props.onMouseDown\n  });\n};\nbit_line_mode_BitLineComponent.propTypes = {\n  isSelected: prop_types_default.a.bool.isRequired,\n  onMouseDown: prop_types_default.a.func.isRequired\n};\n/* harmony default export */ var bit_line_mode = (bit_line_mode_BitLineComponent);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/helper/bit-tools/line-tool.js\nfunction line_tool_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { line_tool_typeof = function _typeof(obj) { return typeof obj; }; } else { line_tool_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return line_tool_typeof(obj); }\nfunction line_tool_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction line_tool_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction line_tool_createClass(Constructor, protoProps, staticProps) { if (protoProps) line_tool_defineProperties(Constructor.prototype, protoProps); if (staticProps) line_tool_defineProperties(Constructor, staticProps); return Constructor; }\nfunction line_tool_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) line_tool_setPrototypeOf(subClass, superClass); }\nfunction line_tool_setPrototypeOf(o, p) { line_tool_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return line_tool_setPrototypeOf(o, p); }\nfunction line_tool_createSuper(Derived) { var hasNativeReflectConstruct = line_tool_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = line_tool_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = line_tool_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return line_tool_possibleConstructorReturn(this, result); }; }\nfunction line_tool_possibleConstructorReturn(self, call) { if (call && (line_tool_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return line_tool_assertThisInitialized(self); }\nfunction line_tool_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction line_tool_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction line_tool_getPrototypeOf(o) { line_tool_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return line_tool_getPrototypeOf(o); }\n\n/**\n * Tool for drawing lines with the bitmap brush.\n */\nvar line_tool_LineTool = function (_paper$Tool) {\n  line_tool_inherits(LineTool, _paper$Tool);\n  var _super = line_tool_createSuper(LineTool);\n  /**\n   * @param {!function} onUpdateImage A callback to call when the image visibly changes\n   */\n  function LineTool(onUpdateImage) {\n    var _this;\n    line_tool_classCallCheck(this, LineTool);\n    _this = _super.call(this);\n    _this.onUpdateImage = onUpdateImage; // We have to set these functions instead of just declaring them because\n    // paper.js tools hook up the listeners in the setter functions.\n    _this.onMouseMove = _this.handleMouseMove;\n    _this.onMouseDown = _this.handleMouseDown;\n    _this.onMouseDrag = _this.handleMouseDrag;\n    _this.onMouseUp = _this.handleMouseUp;\n    _this.colorState = null;\n    _this.active = false;\n    _this.startPoint = null;\n    _this.cursorPreview = null; // Raster to which to draw\n    _this.drawTarget = null;\n    return _this;\n  }\n  line_tool_createClass(LineTool, [{\n    key: \"setColor\",\n    value: function setColor(color) {\n      this.color = color;\n      this.tmpCanvas = bitmap_getBrushMark(this.size, this.color);\n    }\n  }, {\n    key: \"setLineSize\",\n    value: function setLineSize(size) {\n      // For performance, make sure this is an integer\n      this.size = Math.max(1, ~~size);\n      this.tmpCanvas = bitmap_getBrushMark(this.size, this.color);\n    } // Draw a brush mark at the given point\n  }, {\n    key: \"draw\",\n    value: function draw(x, y) {\n      var roundedUpRadius = Math.ceil(this.size / 2);\n      this.drawTarget.drawImage(this.tmpCanvas, new paper_full_default.a.Point(~~x - roundedUpRadius, ~~y - roundedUpRadius));\n    }\n  }, {\n    key: \"updateCursorIfNeeded\",\n    value: function updateCursorIfNeeded() {\n      if (!this.size) {\n        return;\n      } // The cursor preview was unattached from the view by an outside process,\n      // such as changing costumes or undo.\n      if (this.cursorPreview && !this.cursorPreview.parent) {\n        this.cursorPreview = null;\n      }\n      if (!this.cursorPreview || !(this.lastSize === this.size && this.lastColor === this.color)) {\n        if (this.cursorPreview) {\n          this.cursorPreview.remove();\n        }\n        this.tmpCanvas = bitmap_getBrushMark(this.size, this.color);\n        this.cursorPreview = new paper_full_default.a.Raster(this.tmpCanvas);\n        this.cursorPreview.guide = true;\n        this.cursorPreview.parent = getGuideLayer();\n        this.cursorPreview.data.isHelperItem = true;\n      }\n      this.lastSize = this.size;\n      this.lastColor = this.color;\n    }\n  }, {\n    key: \"handleMouseMove\",\n    value: function handleMouseMove(event) {\n      this.updateCursorIfNeeded();\n      this.cursorPreview.position = new paper_full_default.a.Point(~~event.point.x, ~~event.point.y);\n    }\n  }, {\n    key: \"handleMouseDown\",\n    value: function handleMouseDown(event) {\n      if (event.event.button > 0) return; // only first mouse button\n      this.active = true;\n      if (this.cursorPreview) this.cursorPreview.remove();\n      var tmpCanvas = layer_createCanvas();\n      this.drawTarget = new paper_full_default.a.Raster(tmpCanvas);\n      this.drawTarget.parent = getGuideLayer();\n      this.drawTarget.guide = true;\n      this.drawTarget.locked = true;\n      this.drawTarget.position = getRaster().position;\n      this.draw(event.point.x, event.point.y);\n      this.startPoint = event.point;\n    }\n  }, {\n    key: \"handleMouseDrag\",\n    value: function handleMouseDrag(event) {\n      if (event.event.button > 0 || !this.active) return; // only first mouse button\n      // Clear\n      var context = this.drawTarget.canvas.getContext('2d',{willReadFrequently:true});\n      context.clearRect(0, 0, ART_BOARD_WIDTH, ART_BOARD_HEIGHT);\n      forEachLinePoint(this.startPoint, event.point, this.draw.bind(this));\n    }\n  }, {\n    key: \"handleMouseUp\",\n    value: function handleMouseUp(event) {\n      if (event.event.button > 0 || !this.active) return; // only first mouse button\n      this.drawTarget.remove();\n      this.drawTarget = getRaster();\n      forEachLinePoint(this.startPoint, event.point, this.draw.bind(this));\n      this.drawTarget = null;\n      this.onUpdateImage();\n      this.lastPoint = null;\n      this.active = false;\n      this.updateCursorIfNeeded();\n      this.cursorPreview.position = new paper_full_default.a.Point(~~event.point.x, ~~event.point.y);\n    }\n  }, {\n    key: \"deactivateTool\",\n    value: function deactivateTool() {\n      this.active = false;\n      this.tmpCanvas = null;\n      if (this.cursorPreview) {\n        this.cursorPreview.remove();\n        this.cursorPreview = null;\n      }\n    }\n  }]);\n  return LineTool;\n}(paper_full_default.a.Tool);\n/* harmony default export */ var line_tool = (line_tool_LineTool);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/containers/bit-line-mode.jsx\nfunction bit_line_mode_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { bit_line_mode_typeof = function _typeof(obj) { return typeof obj; }; } else { bit_line_mode_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return bit_line_mode_typeof(obj); }\nfunction bit_line_mode_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction bit_line_mode_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction bit_line_mode_createClass(Constructor, protoProps, staticProps) { if (protoProps) bit_line_mode_defineProperties(Constructor.prototype, protoProps); if (staticProps) bit_line_mode_defineProperties(Constructor, staticProps); return Constructor; }\nfunction bit_line_mode_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) bit_line_mode_setPrototypeOf(subClass, superClass); }\nfunction bit_line_mode_setPrototypeOf(o, p) { bit_line_mode_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return bit_line_mode_setPrototypeOf(o, p); }\nfunction bit_line_mode_createSuper(Derived) { var hasNativeReflectConstruct = bit_line_mode_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = bit_line_mode_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = bit_line_mode_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return bit_line_mode_possibleConstructorReturn(this, result); }; }\nfunction bit_line_mode_possibleConstructorReturn(self, call) { if (call && (bit_line_mode_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return bit_line_mode_assertThisInitialized(self); }\nfunction bit_line_mode_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction bit_line_mode_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction bit_line_mode_getPrototypeOf(o) { bit_line_mode_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return bit_line_mode_getPrototypeOf(o); }\n\nvar bit_line_mode_BitLineMode = function (_React$Component) {\n  bit_line_mode_inherits(BitLineMode, _React$Component);\n  var _super = bit_line_mode_createSuper(BitLineMode);\n  function BitLineMode(props) {\n    var _this;\n    bit_line_mode_classCallCheck(this, BitLineMode);\n    _this = _super.call(this, props);\n    lodash_bindall_default()(bit_line_mode_assertThisInitialized(_this), ['activateTool', 'deactivateTool']);\n    return _this;\n  }\n  bit_line_mode_createClass(BitLineMode, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this.props.isBitLineModeActive) {\n        this.activateTool(this.props);\n      }\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(nextProps) {\n      if (this.tool && nextProps.color !== this.props.color) {\n        this.tool.setColor(nextProps.color);\n      }\n      if (this.tool && nextProps.bitBrushSize !== this.props.bitBrushSize) {\n        this.tool.setLineSize(nextProps.bitBrushSize);\n      }\n      if (nextProps.isBitLineModeActive && !this.props.isBitLineModeActive) {\n        this.activateTool();\n      } else if (!nextProps.isBitLineModeActive && this.props.isBitLineModeActive) {\n        this.deactivateTool();\n      }\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps) {\n      return nextProps.isBitLineModeActive !== this.props.isBitLineModeActive;\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.tool) {\n        this.deactivateTool();\n      }\n    }\n  }, {\n    key: \"activateTool\",\n    value: function activateTool() {\n      selection_clearSelection(this.props.clearSelectedItems);\n      this.props.clearGradient(); // Force the default line color if fill is MIXED or transparent\n      var color = this.props.color;\n      if (!color || color === MIXED) {\n        this.props.onChangeFillColor(DEFAULT_COLOR);\n        color = DEFAULT_COLOR;\n      }\n      this.tool = new line_tool(this.props.onUpdateImage);\n      this.tool.setColor(color);\n      this.tool.setLineSize(this.props.bitBrushSize);\n      this.tool.activate();\n    }\n  }, {\n    key: \"deactivateTool\",\n    value: function deactivateTool() {\n      this.tool.deactivateTool();\n      this.tool.remove();\n      this.tool = null;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return react_default.a.createElement(bit_line_mode, {\n        isSelected: this.props.isBitLineModeActive,\n        onMouseDown: this.props.handleMouseDown\n      });\n    }\n  }]);\n  return BitLineMode;\n}(react_default.a.Component);\nbit_line_mode_BitLineMode.propTypes = {\n  bitBrushSize: prop_types_default.a.number.isRequired,\n  clearGradient: prop_types_default.a.func.isRequired,\n  clearSelectedItems: prop_types_default.a.func.isRequired,\n  color: prop_types_default.a.string,\n  handleMouseDown: prop_types_default.a.func.isRequired,\n  isBitLineModeActive: prop_types_default.a.bool.isRequired,\n  onChangeFillColor: prop_types_default.a.func.isRequired,\n  onUpdateImage: prop_types_default.a.func.isRequired\n};\nvar bit_line_mode_mapStateToProps = function mapStateToProps(state) {\n  return {\n    bitBrushSize: state.scratchPaint.bitBrushSize,\n    color: state.scratchPaint.color.fillColor.primary,\n    isBitLineModeActive: state.scratchPaint.mode === Modes.BIT_LINE\n  };\n};\nvar bit_line_mode_mapDispatchToProps = function mapDispatchToProps(dispatch) {\n  return {\n    clearSelectedItems: function clearSelectedItems() {\n      dispatch(selected_items_clearSelectedItems());\n    },\n    clearGradient: function clearGradient() {\n      dispatch(fill_style_clearFillGradient());\n    },\n    handleMouseDown: function handleMouseDown() {\n      dispatch(modes_changeMode(Modes.BIT_LINE));\n    },\n    onChangeFillColor: function onChangeFillColor(fillColor) {\n      dispatch(changeFillColor(fillColor));\n    }\n  };\n};\n/* harmony default export */ var containers_bit_line_mode = (Object(es[\"b\" /* connect */])(bit_line_mode_mapStateToProps, bit_line_mode_mapDispatchToProps)(bit_line_mode_BitLineMode));\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/lib/color-style-proptype.js\n/* harmony default export */ var color_style_proptype = (prop_types[\"PropTypes\"].shape({\n  primary: prop_types[\"PropTypes\"].string,\n  secondary: prop_types[\"PropTypes\"].string,\n  gradientType: prop_types[\"PropTypes\"].oneOf(Object.keys(gradient_types)).isRequired\n}));\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/lib/cursors.js\nvar Cursors = {\n  DEFAULT: 'default',\n  GRAB: 'grab',\n  GRABBING: 'grabbing',\n  NONE: 'none',\n  RESIZE_EW: 'ew-resize',\n  RESIZE_NS: 'ns-resize',\n  RESIZE_NESW: 'nesw-resize',\n  RESIZE_NWSE: 'nwse-resize'\n};\n/* harmony default export */ var cursors = (Cursors);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/reducers/eye-dropper.js\nvar ACTIVATE_EYE_DROPPER = 'scratch-paint/eye-dropper/ACTIVATE_COLOR_PICKER';\nvar DEACTIVATE_EYE_DROPPER = 'scratch-paint/eye-dropper/DEACTIVATE_COLOR_PICKER';\nvar eye_dropper_initialState = {\n  active: false,\n  callback: function callback() {},\n  // this will either be `onChangeFillColor` or `onChangeOutlineColor`\n  previousTool: null // the tool that was previously active before eye dropper\n};\nvar eye_dropper_reducer = function reducer(state, action) {\n  if (typeof state === 'undefined') state = eye_dropper_initialState;\n  switch (action.type) {\n    case ACTIVATE_EYE_DROPPER:\n      return Object.assign({}, state, {\n        active: true,\n        callback: action.callback,\n        previousTool: action.previousMode\n      });\n    case DEACTIVATE_EYE_DROPPER:\n      return Object.assign({}, state, {\n        active: false,\n        callback: function callback() {},\n        previousTool: null\n      });\n    default:\n      return state;\n  }\n};\nvar activateEyeDropper = function activateEyeDropper(currentMode, callback) {\n  return {\n    type: ACTIVATE_EYE_DROPPER,\n    callback: callback,\n    previousMode: currentMode\n  };\n};\nvar deactivateEyeDropper = function deactivateEyeDropper() {\n  return {\n    type: DEACTIVATE_EYE_DROPPER\n  };\n};\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/reducers/cursor.js\nvar CHANGE_CURSOR = 'scratch-paint/cursor/CHANGE_CURSOR';\nvar cursor_initialState = cursors.DEFAULT;\nvar cursor_reducer = function reducer(state, action) {\n  if (typeof state === 'undefined') state = cursor_initialState;\n  switch (action.type) {\n    case CHANGE_CURSOR:\n      if (typeof action.cursorString === 'undefined') {\n        log.warn(\"Cursor should not be set to undefined. Use 'default'.\");\n        return state;\n      } else if (!Object.values(cursors).includes(action.cursorString)) {\n        log.warn(\"Cursor should be a valid cursor string. Got: \".concat(action.cursorString));\n      }\n      return action.cursorString;\n    case ACTIVATE_EYE_DROPPER:\n      return cursors.NONE;\n    case DEACTIVATE_EYE_DROPPER:\n      return cursors.DEFAULT;\n    default:\n      return state;\n  }\n}; // Action creators ==================================\n/**\n * Set the mouse cursor state to the given string\n * @param {string} cursorString The CSS cursor string.\n * @return {object} Redux action to change the cursor.\n */\nvar cursor_setCursor = function setCursor(cursorString) {\n  return {\n    type: CHANGE_CURSOR,\n    cursorString: cursorString\n  };\n};\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/helper/selection-tools/scale-tool.js\nfunction scale_tool_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = scale_tool_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction scale_tool_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return scale_tool_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return scale_tool_arrayLikeToArray(o, minLen); }\nfunction scale_tool_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction scale_tool_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction scale_tool_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction scale_tool_createClass(Constructor, protoProps, staticProps) { if (protoProps) scale_tool_defineProperties(Constructor.prototype, protoProps); if (staticProps) scale_tool_defineProperties(Constructor, staticProps); return Constructor; }\n\nvar MIN_SCALE_FACTOR = 0.0001;\n/**\n * Tool to handle scaling items by pulling on the handles around the edges of the bounding\n * box when in the bounding box tool.\n */\nvar scale_tool_ScaleTool = function () {\n  /**\n   * @param {Mode} mode Paint editor mode\n   * @param {!function} onUpdateImage A callback to call when the image visibly changes\n   */\n  function ScaleTool(mode, onUpdateImage) {\n    scale_tool_classCallCheck(this, ScaleTool);\n    this.isBitmap = mode in BitmapModes;\n    this.active = false;\n    this.boundsPath = null;\n    this.pivot = null;\n    this.origPivot = null;\n    this.corner = null;\n    this.origSize = null;\n    this.origCenter = null;\n    this.itemGroup = null; // Lowest item above all scale items in z index\n    this.itemToInsertBelow = null;\n    this.lastPoint = null;\n    this.onUpdateImage = onUpdateImage;\n  }\n  /**\n   * @param {!paper.HitResult} hitResult Data about the location of the mouse click\n   * @param {!object} boundsPath Where the boundaries of the hit item are\n   * @param {!Array.<paper.Item>} selectedItems Set of selected paper.Items\n   */\n  scale_tool_createClass(ScaleTool, [{\n    key: \"onMouseDown\",\n    value: function onMouseDown(hitResult, boundsPath, selectedItems) {\n      if (this.active) return;\n      this.active = true;\n      var index = hitResult.item.data.index;\n      this.pivot = boundsPath.bounds[this._getOpposingRectCornerNameByIndex(index)].clone();\n      this.origPivot = boundsPath.bounds[this._getOpposingRectCornerNameByIndex(index)].clone();\n      this.corner = boundsPath.bounds[this._getRectCornerNameByIndex(index)].clone();\n      this.selectionAnchor = boundsPath.selectionAnchor;\n      this.origSize = this.corner.subtract(this.pivot);\n      this.origCenter = boundsPath.bounds.center;\n      this.isCorner = this._isCorner(index);\n      this.centered = false;\n      this.lastSx = 1;\n      this.lastSy = 1;\n      this.boundsPath = boundsPath; // Set itemGroup\n      // get item to insert below so that scaled items stay in same z position\n      var items = selection_getItems({\n        match: function match(item) {\n          var _iterator = scale_tool_createForOfIteratorHelper(selectedItems),\n              _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var scaleItem = _step.value;\n              if (!scaleItem.isBelow(item)) {\n                return false;\n              }\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n          return true;\n        }\n      });\n      if (items.length > 0) {\n        this.itemToInsertBelow = items[0];\n      }\n      this.itemGroup = new paper_full_default.a.Group(selectedItems);\n      this.itemGroup.addChild(boundsPath);\n      this.itemGroup.insertBelow(this.itemToInsertBelow);\n      this.itemGroup.data.isHelperItem = true;\n    }\n  }, {\n    key: \"onMouseDrag\",\n    value: function onMouseDrag(event) {\n      if (!this.active) return;\n      var point = event.point;\n      var bounds = view_getActionBounds(this.isBitmap);\n      point.x = Math.max(bounds.left, Math.min(point.x, bounds.right));\n      point.y = Math.max(bounds.top, Math.min(point.y, bounds.bottom));\n      if (!this.lastPoint) this.lastPoint = event.lastPoint;\n      var delta = point.subtract(this.lastPoint);\n      this.lastPoint = point;\n      if (event.modifiers.alt) {\n        this.centered = true;\n        this.itemGroup.position = this.origCenter;\n        this.pivot = this.origCenter;\n      } else {\n        if (this.centered) {\n          // Reset position if we were just in alt\n          this.centered = false;\n          this.itemGroup.scale(1 / this.lastSx, 1 / this.lastSy, this.pivot);\n          if (this.selectionAnchor) {\n            this.selectionAnchor.scale(this.lastSx, this.lastSy);\n          }\n          this.lastSx = 1;\n          this.lastSy = 1;\n        }\n        this.pivot = this.origPivot;\n      }\n      this.corner = this.corner.add(delta);\n      var size = this.corner.subtract(this.pivot);\n      if (event.modifiers.alt) {\n        size = size.multiply(2);\n      }\n      var sx = 1.0;\n      var sy = 1.0;\n      if (Math.abs(this.origSize.x) > 0.0000001) {\n        sx = size.x / this.origSize.x;\n      }\n      if (Math.abs(this.origSize.y) > 0.0000001) {\n        sy = size.y / this.origSize.y;\n      }\n      var signx = sx > 0 ? 1 : -1;\n      var signy = sy > 0 ? 1 : -1;\n      if (this.isCorner && !event.modifiers.shift) {\n        sx = sy = Math.max(Math.abs(sx), Math.abs(sy));\n        sx *= signx;\n        sy *= signy;\n      }\n      sx = signx * Math.max(Math.abs(sx), MIN_SCALE_FACTOR);\n      sy = signy * Math.max(Math.abs(sy), MIN_SCALE_FACTOR);\n      this.itemGroup.scale(sx / this.lastSx, sy / this.lastSy, this.pivot);\n      if (this.selectionAnchor) {\n        this.selectionAnchor.scale(this.lastSx / sx, this.lastSy / sy);\n      }\n      this.lastSx = sx;\n      this.lastSy = sy;\n    }\n  }, {\n    key: \"onMouseUp\",\n    value: function onMouseUp() {\n      if (!this.active) return;\n      this.lastPoint = null;\n      this.pivot = null;\n      this.origPivot = null;\n      this.corner = null;\n      this.origSize = null;\n      this.origCenter = null;\n      this.lastSx = 1;\n      this.lastSy = 1;\n      this.centered = false;\n      if (!this.itemGroup) {\n        return;\n      }\n      this.boundsPath.remove();\n      this.boundsPath = null; // mark text items as scaled (for later use on font size calc)\n      for (var i = 0; i < this.itemGroup.children.length; i++) {\n        var child = this.itemGroup.children[i];\n        if (child.data.isPGTextItem) {\n          child.data.wasScaled = true;\n        }\n      }\n      if (this.itemToInsertBelow) {\n        // No increment step because itemGroup.children is getting depleted\n        for (var _i = 0; _i < this.itemGroup.children.length;) {\n          this.itemGroup.children[_i].insertBelow(this.itemToInsertBelow);\n        }\n        this.itemToInsertBelow = null;\n      } else if (this.itemGroup.layer) {\n        this.itemGroup.layer.addChildren(this.itemGroup.children);\n      }\n      this.itemGroup.remove();\n      this.onUpdateImage();\n      this.active = false;\n    }\n  }, {\n    key: \"_getRectCornerNameByIndex\",\n    value: function _getRectCornerNameByIndex(index) {\n      switch (index) {\n        case 0:\n          return 'bottomLeft';\n        case 1:\n          return 'leftCenter';\n        case 2:\n          return 'topLeft';\n        case 3:\n          return 'topCenter';\n        case 4:\n          return 'topRight';\n        case 5:\n          return 'rightCenter';\n        case 6:\n          return 'bottomRight';\n        case 7:\n          return 'bottomCenter';\n      }\n    }\n  }, {\n    key: \"_getOpposingRectCornerNameByIndex\",\n    value: function _getOpposingRectCornerNameByIndex(index) {\n      switch (index) {\n        case 0:\n          return 'topRight';\n        case 1:\n          return 'rightCenter';\n        case 2:\n          return 'bottomRight';\n        case 3:\n          return 'bottomCenter';\n        case 4:\n          return 'bottomLeft';\n        case 5:\n          return 'leftCenter';\n        case 6:\n          return 'topLeft';\n        case 7:\n          return 'topCenter';\n      }\n    }\n  }, {\n    key: \"_isCorner\",\n    value: function _isCorner(index) {\n      switch (index) {\n        case 0:\n        case 2:\n        case 4:\n        case 6:\n          return true;\n        default:\n          return false;\n      }\n    }\n  }]);\n  return ScaleTool;\n}();\n/* harmony default export */ var scale_tool = (scale_tool_ScaleTool);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/helper/selection-tools/rotate-tool.js\nfunction rotate_tool_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = rotate_tool_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction rotate_tool_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return rotate_tool_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return rotate_tool_arrayLikeToArray(o, minLen); }\nfunction rotate_tool_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction rotate_tool_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction rotate_tool_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction rotate_tool_createClass(Constructor, protoProps, staticProps) { if (protoProps) rotate_tool_defineProperties(Constructor.prototype, protoProps); if (staticProps) rotate_tool_defineProperties(Constructor, staticProps); return Constructor; }\n/**\n * Tool to handle rotation when dragging the rotation handle in the bounding box tool.\n */\nvar rotate_tool_RotateTool = function () {\n  /**\n   * @param {!function} onUpdateImage A callback to call when the image visibly changes\n   */\n  function RotateTool(onUpdateImage) {\n    rotate_tool_classCallCheck(this, RotateTool);\n    this.rotItems = [];\n    this.rotGroupPivot = null;\n    this.prevRot = 90;\n    this.onUpdateImage = onUpdateImage;\n  }\n  /**\n   * @param {!paper.HitResult} hitResult Data about the location of the mouse click\n   * @param {!object} boundsPath Where the boundaries of the hit item are\n   * @param {!Array.<paper.Item>} selectedItems Set of selected paper.Items\n   */\n  rotate_tool_createClass(RotateTool, [{\n    key: \"onMouseDown\",\n    value: function onMouseDown(hitResult, boundsPath, selectedItems) {\n      this.rotGroupPivot = boundsPath.bounds.center;\n      var _iterator = rotate_tool_createForOfIteratorHelper(selectedItems),\n          _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var item = _step.value;\n          // Rotate only root items\n          if (item.parent instanceof paper_full_default.a.Layer) {\n            this.rotItems.push(item);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      this.prevRot = 90;\n    }\n  }, {\n    key: \"onMouseDrag\",\n    value: function onMouseDrag(event) {\n      var rotAngle = event.point.subtract(this.rotGroupPivot).angle;\n      if (event.modifiers.shift) {\n        rotAngle = Math.round(rotAngle / 45) * 45;\n      }\n      for (var i = 0; i < this.rotItems.length; i++) {\n        var item = this.rotItems[i];\n        item.rotate(rotAngle - this.prevRot, this.rotGroupPivot);\n      }\n      this.prevRot = rotAngle;\n    }\n  }, {\n    key: \"onMouseUp\",\n    value: function onMouseUp(event) {\n      if (event.event.button > 0) return; // only first mouse button\n      this.rotItems.length = 0;\n      this.rotGroupPivot = null;\n      this.prevRot = 90;\n      this.onUpdateImage();\n    }\n  }]);\n  return RotateTool;\n}();\n/* harmony default export */ var rotate_tool = (rotate_tool_RotateTool);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/helper/selection-tools/move-tool.js\nfunction move_tool_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = move_tool_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction move_tool_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return move_tool_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return move_tool_arrayLikeToArray(o, minLen); }\nfunction move_tool_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction move_tool_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction move_tool_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction move_tool_createClass(Constructor, protoProps, staticProps) { if (protoProps) move_tool_defineProperties(Constructor.prototype, protoProps); if (staticProps) move_tool_defineProperties(Constructor, staticProps); return Constructor; }\n\n/** Snap to align selection center to rotation center within this distance */\nvar SNAPPING_THRESHOLD = 4;\nvar FADE_DISTANCE = 10;\n/**\n * Tool to handle dragging an item to reposition it in a selection mode.\n */\nvar move_tool_MoveTool = function () {\n  /**\n   * @param {Modes} mode Paint editor mode\n   * @param {function} setSelectedItems Callback to set the set of selected items in the Redux state\n   * @param {function} clearSelectedItems Callback to clear the set of selected items in the Redux state\n   * @param {!function} onUpdateImage A callback to call when the image visibly changes\n   * @param {?function} switchToTextTool A callback to call to switch to the text tool\n   */\n  function MoveTool(mode, setSelectedItems, clearSelectedItems, onUpdateImage, switchToTextTool) {\n    move_tool_classCallCheck(this, MoveTool);\n    this.mode = mode;\n    this.setSelectedItems = setSelectedItems;\n    this.clearSelectedItems = clearSelectedItems;\n    this.selectedItems = null;\n    this.selectionCenter = null;\n    this.onUpdateImage = onUpdateImage;\n    this.switchToTextTool = switchToTextTool;\n    this.boundsPath = null;\n    this.firstDrag = false;\n  }\n  /**\n   * @param {!object} hitProperties Describes the mouse event\n   * @param {!paper.HitResult} hitProperties.hitResult Data about the location of the mouse click\n   * @param {?boolean} hitProperties.clone Whether to clone on mouse down (e.g. alt key held)\n   * @param {?boolean} hitProperties.multiselect Whether to multiselect on mouse down (e.g. shift key held)\n   * @param {?boolean} hitProperties.doubleClicked True if this is the second click in a short amout of time\n   * @param {?boolean} hitProperties.subselect True if we allow selection of subgroups, false if we should\n   *     select the whole group.\n   */\n  move_tool_createClass(MoveTool, [{\n    key: \"onMouseDown\",\n    value: function onMouseDown(hitProperties) {\n      var item = hitProperties.hitResult.item;\n      if (!hitProperties.subselect) {\n        var root = getRootItem(hitProperties.hitResult.item);\n        item = isCompoundPathItem(root) || group_isGroup(root) ? root : hitProperties.hitResult.item;\n      }\n      if (item.selected) {\n        // Double click causes all points to be selected in subselect mode. If the target is text, it\n        // enters text edit.\n        if (hitProperties.doubleClicked) {\n          if (!hitProperties.multiselect) {\n            if (this.switchToTextTool && item instanceof paper_full_default.a.PointText) {\n              this.switchToTextTool();\n              return;\n            }\n            selection_clearSelection(this.clearSelectedItems);\n          }\n          this._select(item, true\n          /* state */\n          , hitProperties.subselect, true\n          /* fullySelect */\n          );\n        } else if (hitProperties.multiselect) {\n          this._select(item, false\n          /* state */\n          , hitProperties.subselect);\n        }\n      } else {\n        // deselect all by default if multiselect isn't on\n        if (!hitProperties.multiselect) {\n          selection_clearSelection(this.clearSelectedItems);\n        }\n        this._select(item, true, hitProperties.subselect);\n      }\n      if (hitProperties.clone) cloneSelection(hitProperties.subselect, this.onUpdateImage);\n      this.selectedItems = this.mode === Modes.RESHAPE ? selection_getSelectedLeafItems() : selection_getSelectedRootItems();\n      if (this.selectedItems.length === 0) {\n        return;\n      }\n      var selectionBounds;\n      var _iterator = move_tool_createForOfIteratorHelper(this.selectedItems),\n          _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var selectedItem = _step.value;\n          if (selectionBounds) {\n            selectionBounds = selectionBounds.unite(selectedItem.bounds);\n          } else {\n            selectionBounds = selectedItem.bounds;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      this.selectionCenter = selectionBounds.center;\n      if (this.boundsPath) {\n        this.selectedItems.push(this.boundsPath);\n      }\n      this.firstDrag = true;\n    }\n  }, {\n    key: \"setBoundsPath\",\n    value: function setBoundsPath(boundsPath) {\n      this.boundsPath = boundsPath;\n    }\n    /**\n     * Sets the selection state of an item.\n     * @param {!paper.Item} item Item to select or deselect\n     * @param {?boolean} state True if item should be selected, false if deselected\n     * @param {?boolean} subselect True if a subset of all points in an item are allowed to be\n     *     selected, false if items must be selected all or nothing.\n     * @param {?boolean} fullySelect True if in addition to the item being selected, all of its\n     *     control points should be selected. False if the item should be selected but not its\n     *     points. Only relevant when subselect is true.\n     */\n  }, {\n    key: \"_select\",\n    value: function _select(item, state, subselect, fullySelect) {\n      if (subselect) {\n        item.selected = false;\n        if (fullySelect) {\n          item.fullySelected = state;\n        } else {\n          item.selected = state;\n        }\n      } else {\n        selection_setItemSelection(item, state);\n      }\n      this.setSelectedItems();\n    }\n  }, {\n    key: \"onMouseDrag\",\n    value: function onMouseDrag(event) {\n      var point = event.point;\n      var actionBounds = view_getActionBounds(this.mode in BitmapModes);\n      point.x = Math.max(actionBounds.left, Math.min(point.x, actionBounds.right));\n      point.y = Math.max(actionBounds.top, Math.min(point.y, actionBounds.bottom));\n      var dragVector = point.subtract(event.downPoint);\n      var snapVector; // Snapping to align center. Not in reshape mode, because reshape doesn't show center crosshair\n      if (!event.modifiers.shift && this.mode !== Modes.RESHAPE) {\n        if (checkPointsClose(this.selectionCenter.add(dragVector), CENTER, SNAPPING_THRESHOLD / paper_full_default.a.view.zoom\n        /* threshold */\n        )) {\n          snapVector = CENTER.subtract(this.selectionCenter);\n        }\n      }\n      if (this.selectedItems.length === 0) {\n        return;\n      }\n      var bounds;\n      var _iterator2 = move_tool_createForOfIteratorHelper(this.selectedItems),\n          _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var item = _step2.value;\n          // add the position of the item before the drag started\n          // for later use in the snap calculation\n          if (!item.data.origPos) {\n            item.data.origPos = item.position;\n          }\n          if (snapVector) {\n            item.position = item.data.origPos.add(snapVector);\n          } else if (event.modifiers.shift) {\n            item.position = item.data.origPos.add(math_snapDeltaToAngle(dragVector, Math.PI / 4));\n          } else {\n            item.position = item.data.origPos.add(dragVector);\n          }\n          if (bounds) {\n            bounds = bounds.unite(item.bounds);\n          } else {\n            bounds = item.bounds;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      if (this.firstDrag) {\n        // Show the center crosshair above the selected item while dragging.\n        getDragCrosshairLayer().visible = true;\n        this.firstDrag = false;\n      } // The rotation center crosshair should be opaque over the entire selection bounding box, and fade out to\n      // totally transparent outside the selection bounding box.\n      var opacityMultiplier = 1;\n      var newCenter = this.selectionCenter.add(dragVector);\n      if (CENTER.y < bounds.top && CENTER.x < bounds.left || CENTER.y > bounds.bottom && CENTER.x < bounds.left || CENTER.y < bounds.top && CENTER.x > bounds.right || CENTER.y > bounds.bottom && CENTER.x > bounds.right) {\n        // rotation center is to one of the 4 corners of the selection bounding box\n        var distX = Math.max(CENTER.x - bounds.right, bounds.left - CENTER.x);\n        var distY = Math.max(CENTER.y - bounds.bottom, bounds.top - CENTER.y);\n        var dist = Math.sqrt(distX * distX + distY * distY);\n        opacityMultiplier = Math.max(0, 1 - dist / (FADE_DISTANCE / paper_full_default.a.view.zoom));\n      } else if (CENTER.y < bounds.top || CENTER.y > bounds.bottom) {\n        // rotation center is above or below the selection bounding box\n        opacityMultiplier = Math.max(0, 1 - (Math.abs(CENTER.y - newCenter.y) - bounds.height / 2) / (FADE_DISTANCE / paper_full_default.a.view.zoom));\n      } else if (CENTER.x < bounds.left || CENTER.x > bounds.right) {\n        // rotation center is left or right of the selection bounding box\n        opacityMultiplier = Math.max(0, 1 - (Math.abs(CENTER.x - newCenter.x) - bounds.width / 2) / (FADE_DISTANCE / paper_full_default.a.view.zoom));\n      } // else the rotation center is within selection bounds, always show drag crosshair at full opacity\n      getDragCrosshairLayer().opacity = CROSSHAIR_FULL_OPACITY * opacityMultiplier;\n    }\n  }, {\n    key: \"onMouseUp\",\n    value: function onMouseUp() {\n      this.firstDrag = false;\n      var moved = false; // resetting the items origin point for the next usage\n      var _iterator3 = move_tool_createForOfIteratorHelper(this.selectedItems),\n          _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var item = _step3.value;\n          if (item.data.origPos) {\n            if (!item.position.equals(item.data.origPos)) moved = true;\n            delete item.data.origPos;\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      this.selectedItems = null;\n      this.selectionCenter = null;\n      if (moved) {\n        this.onUpdateImage();\n      } // Hide the crosshair we showed earlier.\n      getDragCrosshairLayer().visible = false;\n    }\n  }]);\n  return MoveTool;\n}();\n/* harmony default export */ var move_tool = (move_tool_MoveTool);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/helper/selection-tools/bounding-box-tool.js\nfunction bounding_box_tool_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = bounding_box_tool_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction bounding_box_tool_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return bounding_box_tool_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return bounding_box_tool_arrayLikeToArray(o, minLen); }\nfunction bounding_box_tool_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction bounding_box_tool_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction bounding_box_tool_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction bounding_box_tool_createClass(Constructor, protoProps, staticProps) { if (protoProps) bounding_box_tool_defineProperties(Constructor.prototype, protoProps); if (staticProps) bounding_box_tool_defineProperties(Constructor, staticProps); return Constructor; }\n\nvar SELECTION_ANCHOR_SIZE = 12;\n/** SVG for the rotation icon on the bounding box */\nvar ARROW_PATH = 'M19.28,1.09C19.28.28,19,0,18.2,0c-1.67,0-3.34,0-5,0-.34,0-.88.24-1,.47a1.4,1.4,' + '0,0,0,.36,1.08,15.27,15.27,0,0,0,1.46,1.36A6.4,6.4,0,0,1,6.52,4,5.85,5.85,0,0,1,5.24,3,15.27,15.27,' + '0,0,0,6.7,1.61,1.4,1.4,0,0,0,7.06.54C7,.3,6.44.07,6.1.06c-1.67,0-3.34,0-5,0C.28,0,0,.31,0,1.12c0,1.67,' + '0,3.34,0,5a1.23,1.23,0,0,0,.49,1,1.22,1.22,0,0,0,1-.31A14.38,14.38,0,0,0,2.84,5.26l.73.62a9.45,9.45,' + '0,0,0,7.34,2,9.45,9.45,0,0,0,4.82-2.05l.73-.62a14.38,14.38,0,0,0,1.29,1.51,1.22,1.22,' + '0,0,0,1,.31,1.23,1.23,0,0,0,.49-1C19.31,4.43,19.29,2.76,19.28,1.09Z';\n/** Modes of the bounding box tool, which can do many things depending on how it's used. */\nvar BoundingBoxModes = keymirror_default()({\n  SCALE: null,\n  ROTATE: null,\n  MOVE: null\n});\n/**\n * Tool that handles transforming the selection and drawing a bounding box with handles.\n * On mouse down, the type of function (move, scale, rotate) is determined based on what is clicked\n * (scale handle, rotate handle, the object itself). This determines the mode of the tool, which then\n * delegates actions to the MoveTool, RotateTool or ScaleTool accordingly.\n * @param {!function} onUpdateImage A callback to call when the image visibly changes\n */\nvar bounding_box_tool_BoundingBoxTool = function () {\n  /**\n   * @param {Modes} mode Paint editor mode\n   * @param {function} setSelectedItems Callback to set the set of selected items in the Redux state\n   * @param {function} clearSelectedItems Callback to clear the set of selected items in the Redux state\n   * @param {function} setCursor Callback to set the visible mouse cursor\n   * @param {!function} onUpdateImage A callback to call when the image visibly changes\n   * @param {?function} switchToTextTool A callback to call to switch to the text tool\n   */\n  function BoundingBoxTool(mode, setSelectedItems, clearSelectedItems, setCursor, onUpdateImage, switchToTextTool) {\n    bounding_box_tool_classCallCheck(this, BoundingBoxTool);\n    this.dispatchSetCursor = setCursor;\n    this.onUpdateImage = onUpdateImage;\n    this.mode = null;\n    this.boundsPath = null;\n    this.boundsScaleHandles = [];\n    this.boundsRotHandles = [];\n    this._modeMap = {};\n    this._modeMap[BoundingBoxModes.SCALE] = new scale_tool(mode, onUpdateImage);\n    this._modeMap[BoundingBoxModes.ROTATE] = new rotate_tool(onUpdateImage);\n    this._modeMap[BoundingBoxModes.MOVE] = new move_tool(mode, setSelectedItems, clearSelectedItems, onUpdateImage, switchToTextTool);\n    this._currentCursor = null;\n  }\n  /**\n   * Should be called if the selection changes to update the bounds of the bounding box.\n   * @param {?Array<paper.Item>} selectedItems Array of selected items.\n   */\n  bounding_box_tool_createClass(BoundingBoxTool, [{\n    key: \"onSelectionChanged\",\n    value: function onSelectionChanged(selectedItems) {\n      if (selectedItems && selectedItems.length) {\n        this.setSelectionBounds();\n      } else {\n        this.removeBoundsPath();\n      }\n    }\n    /**\n     * @param {!MouseEvent} event The mouse event\n     * @param {boolean} clone Whether to clone on mouse down (e.g. alt key held)\n     * @param {boolean} multiselect Whether to multiselect on mouse down (e.g. shift key held)\n     * @param {?boolean} doubleClicked True if this is the second click in a short amout of time\n     * @param {paper.hitOptions} hitOptions The options with which to detect whether mouse down has hit\n     *     anything editable\n     * @return {boolean} True if there was a hit, false otherwise\n     */\n  }, {\n    key: \"onMouseDown\",\n    value: function onMouseDown(event, clone, multiselect, doubleClicked, hitOptions) {\n      if (event.event.button > 0) return; // only first mouse button\n      var _this$_determineMode = this._determineMode(event, multiselect, hitOptions),\n          hitResult = _this$_determineMode.hitResult,\n          mode = _this$_determineMode.mode;\n      if (!hitResult) {\n        if (!multiselect) {\n          this.removeBoundsPath();\n        }\n        return false;\n      }\n      this.mode = mode;\n      var hitProperties = {\n        hitResult: hitResult,\n        clone: clone,\n        multiselect: multiselect,\n        doubleClicked: doubleClicked\n      };\n      if (this.mode === BoundingBoxModes.MOVE) {\n        this._modeMap[this.mode].onMouseDown(hitProperties);\n        this.removeBoundsHandles();\n      } else if (this.mode === BoundingBoxModes.SCALE) {\n        this._modeMap[this.mode].onMouseDown(hitResult, this.boundsPath, selection_getSelectedRootItems());\n        this.removeBoundsHandles();\n      } else if (this.mode === BoundingBoxModes.ROTATE) {\n        this.setCursor(cursors.GRABBING);\n        this._modeMap[this.mode].onMouseDown(hitResult, this.boundsPath, selection_getSelectedRootItems()); // While transforming, don't show bounds\n        this.removeBoundsPath();\n      }\n      return true;\n    }\n  }, {\n    key: \"onMouseMove\",\n    value: function onMouseMove(event, hitOptions) {\n      this._updateCursor(event, hitOptions);\n    }\n  }, {\n    key: \"_updateCursor\",\n    value: function _updateCursor(event, hitOptions) {\n      var _this$_determineMode2 = this._determineMode(event, false, hitOptions),\n          mode = _this$_determineMode2.mode,\n          hitResult = _this$_determineMode2.hitResult;\n      if (hitResult) {\n        if (mode === BoundingBoxModes.MOVE) {\n          this.setCursor(cursors.DEFAULT);\n        } else if (mode === BoundingBoxModes.ROTATE) {\n          this.setCursor(cursors.GRAB);\n        } else if (mode === BoundingBoxModes.SCALE) {\n          this.setSelectionBounds();\n          if (this._impreciseEqual(hitResult.item.position.x, this.boundsPath.position.x)) {\n            this.setCursor(cursors.RESIZE_NS);\n          } else if (this._impreciseEqual(hitResult.item.position.y, this.boundsPath.position.y)) {\n            this.setCursor(cursors.RESIZE_EW);\n          } else if (hitResult.item.position.equals(this.boundsPath.bounds.bottomLeft) || hitResult.item.position.equals(this.boundsPath.bounds.topRight)) {\n            this.setCursor(cursors.RESIZE_NESW);\n          } else {\n            this.setCursor(cursors.RESIZE_NWSE);\n          }\n        }\n      } else {\n        this.setCursor(cursors.DEFAULT);\n      }\n    }\n  }, {\n    key: \"_impreciseEqual\",\n    value: function _impreciseEqual(a, b) {\n      // This is the same math paper.js uses to check if two numbers are \"equal\".\n      return Math.abs(a - b) < 1e-8;\n    }\n  }, {\n    key: \"_determineMode\",\n    value: function _determineMode(event, multiselect, hitOptions) {\n      var hitResults = paper_full_default.a.project.hitTestAll(event.point, hitOptions);\n      var mode; // Prefer scale to trigger over rotate, and scale and rotate to trigger over other hits\n      var hitResult = hitResults[0];\n      for (var i = 0; i < hitResults.length; i++) {\n        if (hitResults[i].item.data && hitResults[i].item.data.isScaleHandle) {\n          hitResult = hitResults[i];\n          mode = BoundingBoxModes.SCALE;\n          break;\n        } else if (hitResults[i].item.data && hitResults[i].item.data.isRotHandle) {\n          hitResult = hitResults[i];\n          mode = BoundingBoxModes.ROTATE;\n        }\n      }\n      if (!mode) {\n        mode = BoundingBoxModes.MOVE;\n      }\n      return {\n        mode: mode,\n        hitResult: hitResult\n      };\n    }\n  }, {\n    key: \"onMouseDrag\",\n    value: function onMouseDrag(event) {\n      if (event.event.button > 0 || !this.mode) return; // only first mouse button\n      this._modeMap[this.mode].onMouseDrag(event); // Set the cursor for moving a sprite once the drag has actually started (i.e. the mouse has been moved while\n      // pressed), so that the mouse doesn't \"flash\" to the grabbing cursor every time a sprite is clicked.\n      if (this.mode === BoundingBoxModes.MOVE) {\n        this.setCursor(cursors.GRABBING);\n      }\n    }\n  }, {\n    key: \"onMouseUp\",\n    value: function onMouseUp(event, hitOptions) {\n      if (event.event.button > 0 || !this.mode) return; // only first mouse button\n      this._modeMap[this.mode].onMouseUp(event); // After transforming, show bounds again\n      this.setSelectionBounds();\n      this.mode = null;\n      this._updateCursor(event, hitOptions);\n    }\n  }, {\n    key: \"setSelectionBounds\",\n    value: function setSelectionBounds() {\n      this.removeBoundsPath();\n      var items = selection_getSelectedRootItems();\n      if (items.length <= 0) return;\n      var rect = null;\n      var _iterator = bounding_box_tool_createForOfIteratorHelper(items),\n          _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var item = _step.value;\n          if (item instanceof paper_full_default.a.Raster && item.loaded === false) {\n            item.onLoad = this.setSelectionBounds.bind(this);\n            return;\n          }\n          if (rect) {\n            rect = rect.unite(item.bounds);\n          } else {\n            rect = item.bounds;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      if (!this.boundsPath) {\n        this.boundsPath = new paper_full_default.a.Group();\n        this.boundsRect = paper_full_default.a.Path.Rectangle(rect);\n        this.boundsRect.curves[0].divideAtTime(0.5);\n        this.boundsRect.curves[2].divideAtTime(0.5);\n        this.boundsRect.curves[4].divideAtTime(0.5);\n        this.boundsRect.curves[6].divideAtTime(0.5);\n        this.boundsPath.addChild(this.boundsRect);\n        var vRect = new paper_full_default.a.Path.Rectangle({\n          point: [-1, -6],\n          size: [2, 12],\n          radius: 1,\n          insert: false\n        });\n        var hRect = new paper_full_default.a.Path.Rectangle({\n          point: [-6, -1],\n          size: [12, 2],\n          radius: 1,\n          insert: false\n        });\n        var anchorIcon = vRect.unite(hRect);\n        this.boundsPath.addChild(anchorIcon);\n        this.boundsPath.selectionAnchor = anchorIcon;\n        this._modeMap[BoundingBoxModes.MOVE].setBoundsPath(this.boundsPath);\n      }\n      layer_setGuideItem(this.boundsPath);\n      this.boundsPath.data.isSelectionBound = true;\n      this.boundsPath.data.isHelperItem = true;\n      this.boundsPath.fillColor = null;\n      this.boundsPath.parent = getGuideLayer();\n      this.boundsPath.strokeWidth = 1 / paper_full_default.a.view.zoom;\n      this.boundsPath.strokeColor = getGuideColor();\n      this.boundsPath.selectionAnchor.scale(SELECTION_ANCHOR_SIZE / paper_full_default.a.view.zoom / this.boundsPath.selectionAnchor.bounds.width);\n      this.boundsPath.selectionAnchor.position = rect.center; // Make a template to copy\n      var boundsScaleCircleShadow = new paper_full_default.a.Path.Circle({\n        center: new paper_full_default.a.Point(0, 0),\n        radius: 5.5 / paper_full_default.a.view.zoom,\n        fillColor: 'black',\n        opacity: .12,\n        data: {\n          isHelperItem: true,\n          noSelect: true,\n          noHover: true\n        }\n      });\n      var boundsScaleCircle = new paper_full_default.a.Path.Circle({\n        center: new paper_full_default.a.Point(0, 0),\n        radius: 4 / paper_full_default.a.view.zoom,\n        fillColor: getGuideColor(),\n        data: {\n          isScaleHandle: true,\n          isHelperItem: true,\n          noSelect: true,\n          noHover: true\n        }\n      });\n      var boundsScaleHandle = new paper_full_default.a.Group([boundsScaleCircleShadow, boundsScaleCircle]);\n      boundsScaleHandle.parent = getGuideLayer();\n      for (var index = 0; index < this.boundsRect.segments.length; index++) {\n        var segment = this.boundsRect.segments[index];\n        if (index === 7) {\n          var offset = new paper_full_default.a.Point(0, 20);\n          var arrows = new paper_full_default.a.Path(ARROW_PATH);\n          arrows.translate(segment.point.add(offset).add(-10.5, -5));\n          var line = new paper_full_default.a.Path.Rectangle(segment.point.add(offset).subtract(1, 0), segment.point);\n          var rotHandle = arrows.unite(line);\n          line.remove();\n          arrows.remove();\n          rotHandle.scale(1 / paper_full_default.a.view.zoom, segment.point);\n          rotHandle.data = {\n            offset: offset,\n            isRotHandle: true,\n            isHelperItem: true,\n            noSelect: true,\n            noHover: true\n          };\n          rotHandle.fillColor = getGuideColor();\n          rotHandle.parent = getGuideLayer();\n          this.boundsRotHandles[index] = rotHandle;\n        }\n        this.boundsScaleHandles[index] = boundsScaleHandle.clone();\n        this.boundsScaleHandles[index].position = segment.point;\n        var _iterator2 = bounding_box_tool_createForOfIteratorHelper(this.boundsScaleHandles[index].children),\n            _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var child = _step2.value;\n            child.data.index = index;\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        this.boundsScaleHandles[index].data = {\n          index: index,\n          isScaleHandle: true,\n          isHelperItem: true,\n          noSelect: true,\n          noHover: true\n        };\n      } // Remove the template\n      boundsScaleHandle.remove();\n    }\n  }, {\n    key: \"removeBoundsPath\",\n    value: function removeBoundsPath() {\n      guides_removeBoundsPath();\n      this.boundsPath = null;\n      this.boundsRect = null;\n      this.boundsScaleHandles.length = 0;\n      this.boundsRotHandles.length = 0;\n    }\n  }, {\n    key: \"removeBoundsHandles\",\n    value: function removeBoundsHandles() {\n      guides_removeBoundsHandles();\n      this.boundsScaleHandles.length = 0;\n      this.boundsRotHandles.length = 0;\n    }\n  }, {\n    key: \"deactivateTool\",\n    value: function deactivateTool() {\n      this.removeBoundsPath();\n      this.setCursor(cursors.DEFAULT);\n    }\n  }, {\n    key: \"setCursor\",\n    value: function setCursor(cursorString) {\n      if (this._currentCursor !== cursorString) {\n        this.dispatchSetCursor(cursorString);\n        this._currentCursor = cursorString;\n      }\n    }\n  }]);\n  return BoundingBoxTool;\n}();\n/* harmony default export */ var bounding_box_tool = (bounding_box_tool_BoundingBoxTool);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/helper/selection-tools/nudge-tool.js\nfunction nudge_tool_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = nudge_tool_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction nudge_tool_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return nudge_tool_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return nudge_tool_arrayLikeToArray(o, minLen); }\nfunction nudge_tool_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction nudge_tool_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction nudge_tool_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction nudge_tool_createClass(Constructor, protoProps, staticProps) { if (protoProps) nudge_tool_defineProperties(Constructor.prototype, protoProps); if (staticProps) nudge_tool_defineProperties(Constructor, staticProps); return Constructor; }\n\nvar NUDGE_MORE_MULTIPLIER = 15;\n/**\n * Tool containing handlers for arrow key events for nudging the selection.\n * Note that this tool is built for selection mode, not reshape mode.\n */\nvar nudge_tool_NudgeTool = function () {\n  /**\n   * @param {Mode} mode Paint editor mode\n   * @param {function} boundingBoxTool to control the bounding box\n   * @param {!function} onUpdateImage A callback to call when the image visibly changes\n   */\n  function NudgeTool(mode, boundingBoxTool, onUpdateImage) {\n    nudge_tool_classCallCheck(this, NudgeTool);\n    this.boundingBoxTool = boundingBoxTool;\n    this.onUpdateImage = onUpdateImage;\n    this.boundingBoxTool.isBitmap = mode in BitmapModes;\n  }\n  nudge_tool_createClass(NudgeTool, [{\n    key: \"onKeyDown\",\n    value: function onKeyDown(event) {\n      if (event.event.target instanceof HTMLInputElement) {\n        // Ignore nudge if a text input field is focused\n        return;\n      }\n      var nudgeAmount = 1 / paper_full_default.a.view.zoom;\n      if (event.modifiers.shift) nudgeAmount *= NUDGE_MORE_MULTIPLIER;\n      var selected = selection_getSelectedRootItems();\n      if (selected.length === 0) return; // Get bounds. Don't let item bounds go out of bounds.\n      var rect;\n      var _iterator = nudge_tool_createForOfIteratorHelper(selected),\n          _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _item = _step.value;\n          if (rect) {\n            rect = rect.unite(_item.bounds);\n          } else {\n            rect = _item.bounds;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      var bounds = view_getActionBounds(this.boundingBoxTool.isBitmap);\n      var bottom = bounds.bottom - rect.top - 1;\n      var top = bounds.top - rect.bottom + 1;\n      var left = bounds.left - rect.right + 1;\n      var right = bounds.right - rect.left - 1;\n      var translation;\n      if (event.key === 'up') {\n        translation = new paper_full_default.a.Point(0, Math.min(bottom, Math.max(-nudgeAmount, top)));\n      } else if (event.key === 'down') {\n        translation = new paper_full_default.a.Point(0, Math.max(top, Math.min(nudgeAmount, bottom)));\n      } else if (event.key === 'left') {\n        translation = new paper_full_default.a.Point(Math.min(right, Math.max(-nudgeAmount, left)), 0);\n      } else if (event.key === 'right') {\n        translation = new paper_full_default.a.Point(Math.max(left, Math.min(nudgeAmount, right)), 0);\n      }\n      if (translation) {\n        var _iterator2 = nudge_tool_createForOfIteratorHelper(selected),\n            _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var item = _step2.value;\n            item.translate(translation);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        this.boundingBoxTool.setSelectionBounds();\n        event.preventDefault();\n      }\n    }\n  }, {\n    key: \"onKeyUp\",\n    value: function onKeyUp(event) {\n      var selected = selection_getSelectedRootItems();\n      if (selected.length === 0) return;\n      if (event.key === 'up' || event.key === 'down' || event.key === 'left' || event.key === 'right') {\n        this.onUpdateImage();\n      }\n    }\n  }]);\n  return NudgeTool;\n}();\n/* harmony default export */ var nudge_tool = (nudge_tool_NudgeTool);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/helper/bit-tools/oval-tool.js\nfunction oval_tool_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { oval_tool_typeof = function _typeof(obj) { return typeof obj; }; } else { oval_tool_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return oval_tool_typeof(obj); }\nfunction oval_tool_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction oval_tool_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction oval_tool_createClass(Constructor, protoProps, staticProps) { if (protoProps) oval_tool_defineProperties(Constructor.prototype, protoProps); if (staticProps) oval_tool_defineProperties(Constructor, staticProps); return Constructor; }\nfunction oval_tool_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) oval_tool_setPrototypeOf(subClass, superClass); }\nfunction oval_tool_setPrototypeOf(o, p) { oval_tool_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return oval_tool_setPrototypeOf(o, p); }\nfunction oval_tool_createSuper(Derived) { var hasNativeReflectConstruct = oval_tool_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = oval_tool_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = oval_tool_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return oval_tool_possibleConstructorReturn(this, result); }; }\nfunction oval_tool_possibleConstructorReturn(self, call) { if (call && (oval_tool_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return oval_tool_assertThisInitialized(self); }\nfunction oval_tool_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction oval_tool_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction oval_tool_getPrototypeOf(o) { oval_tool_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return oval_tool_getPrototypeOf(o); }\n\n/**\n * Tool for drawing ovals.\n */\nvar oval_tool_OvalTool = function (_paper$Tool) {\n  oval_tool_inherits(OvalTool, _paper$Tool);\n  var _super = oval_tool_createSuper(OvalTool);\n  oval_tool_createClass(OvalTool, null, [{\n    key: \"TOLERANCE\",\n    get: function get() {\n      return 2;\n    }\n    /**\n     * @param {function} setSelectedItems Callback to set the set of selected items in the Redux state\n     * @param {function} clearSelectedItems Callback to clear the set of selected items in the Redux state\n     * @param {function} setCursor Callback to set the visible mouse cursor\n     * @param {!function} onUpdateImage A callback to call when the image visibly changes\n     */\n  }]);\n  function OvalTool(setSelectedItems, clearSelectedItems, setCursor, onUpdateImage) {\n    var _this;\n    oval_tool_classCallCheck(this, OvalTool);\n    _this = _super.call(this);\n    _this.setSelectedItems = setSelectedItems;\n    _this.clearSelectedItems = clearSelectedItems;\n    _this.onUpdateImage = onUpdateImage;\n    _this.boundingBoxTool = new bounding_box_tool(Modes.BIT_OVAL, setSelectedItems, clearSelectedItems, setCursor, onUpdateImage);\n    var nudgeTool = new nudge_tool(Modes.BIT_OVAL, _this.boundingBoxTool, onUpdateImage); // We have to set these functions instead of just declaring them because\n    // paper.js tools hook up the listeners in the setter functions.\n    _this.onMouseDown = _this.handleMouseDown;\n    _this.onMouseDrag = _this.handleMouseDrag;\n    _this.onMouseMove = _this.handleMouseMove;\n    _this.onMouseUp = _this.handleMouseUp;\n    _this.onKeyUp = nudgeTool.onKeyUp;\n    _this.onKeyDown = nudgeTool.onKeyDown;\n    _this.oval = null;\n    _this.color = null;\n    _this.active = false;\n    return _this;\n  }\n  oval_tool_createClass(OvalTool, [{\n    key: \"getHitOptions\",\n    value: function getHitOptions() {\n      return {\n        segments: false,\n        stroke: true,\n        curves: false,\n        fill: true,\n        guide: false,\n        match: function match(hitResult) {\n          return hitResult.item.data && (hitResult.item.data.isScaleHandle || hitResult.item.data.isRotHandle) || hitResult.item.selected;\n        },\n        // Allow hits on bounding box and selected only\n        tolerance: OvalTool.TOLERANCE / paper_full_default.a.view.zoom\n      };\n    }\n    /**\n     * Should be called if the selection changes to update the bounds of the bounding box.\n     * @param {Array<paper.Item>} selectedItems Array of selected items.\n     */\n  }, {\n    key: \"onSelectionChanged\",\n    value: function onSelectionChanged(selectedItems) {\n      this.boundingBoxTool.onSelectionChanged(selectedItems);\n      if ((!this.oval || !this.oval.isInserted()) && selectedItems && selectedItems.length === 1 && selectedItems[0].shape === 'ellipse') {\n        // Infer that an undo occurred and get back the active oval\n        this.oval = selectedItems[0];\n        if (this.oval.data.zoomLevel !== paper_full_default.a.view.zoom) {\n          this.oval.strokeWidth = this.oval.strokeWidth / this.oval.data.zoomLevel * paper_full_default.a.view.zoom;\n          this.oval.data.zoomLevel = paper_full_default.a.view.zoom;\n          this.thickness = this.oval.strokeWidth;\n        }\n        this.filled = this.oval.strokeWidth === 0; // We don't need to set our color from the selected oval's color because the color state reducers will\n        // do that for us every time the selection changes.\n      } else if (this.oval && this.oval.isInserted() && !this.oval.selected) {\n        // Oval got deselected\n        this.commitOval();\n      }\n    }\n  }, {\n    key: \"styleOval\",\n    value: function styleOval() {\n      style_path_styleShape(this.oval, {\n        fillColor: this.filled ? this.color : null,\n        strokeColor: this.filled ? null : this.color,\n        strokeWidth: this.filled ? 0 : this.thickness\n      });\n    }\n  }, {\n    key: \"setColor\",\n    value: function setColor(color) {\n      this.color = color;\n      if (this.oval) this.styleOval();\n    }\n  }, {\n    key: \"setFilled\",\n    value: function setFilled(filled) {\n      if (this.filled === filled) return;\n      this.filled = filled;\n      if (this.oval && this.oval.isInserted()) {\n        this.styleOval();\n        this.onUpdateImage();\n      }\n    }\n  }, {\n    key: \"setThickness\",\n    value: function setThickness(thickness) {\n      if (this.thickness === thickness * paper_full_default.a.view.zoom) return;\n      this.thickness = thickness * paper_full_default.a.view.zoom;\n      if (this.oval && this.oval.isInserted() && !this.filled) {\n        this.oval.strokeWidth = this.thickness;\n      }\n      if (this.oval && this.oval.isInserted()) {\n        this.oval.data.zoomLevel = paper_full_default.a.view.zoom;\n        this.onUpdateImage();\n      }\n    }\n  }, {\n    key: \"handleMouseDown\",\n    value: function handleMouseDown(event) {\n      if (event.event.button > 0) return; // only first mouse button\n      this.active = true;\n      if (this.boundingBoxTool.onMouseDown(event, false\n      /* clone */\n      , false\n      /* multiselect */\n      , false\n      /* doubleClicked */\n      , this.getHitOptions())) {\n        this.isBoundingBoxMode = true;\n      } else {\n        this.isBoundingBoxMode = false;\n        selection_clearSelection(this.clearSelectedItems);\n        this.commitOval();\n        this.oval = new paper_full_default.a.Shape.Ellipse({\n          point: event.downPoint,\n          size: 0,\n          strokeScaling: false\n        });\n        this.styleOval();\n        this.oval.data = {\n          zoomLevel: paper_full_default.a.view.zoom\n        };\n      }\n    }\n  }, {\n    key: \"handleMouseDrag\",\n    value: function handleMouseDrag(event) {\n      if (event.event.button > 0 || !this.active) return; // only first mouse button\n      if (this.isBoundingBoxMode) {\n        this.boundingBoxTool.onMouseDrag(event);\n        return;\n      }\n      var downPoint = new paper_full_default.a.Point(event.downPoint.x, event.downPoint.y);\n      var point = new paper_full_default.a.Point(event.point.x, event.point.y);\n      var squareDimensions = math_getSquareDimensions(event.downPoint, event.point);\n      if (event.modifiers.shift) {\n        this.oval.size = squareDimensions.size.abs();\n      } else {\n        this.oval.size = downPoint.subtract(point);\n      }\n      if (event.modifiers.alt) {\n        this.oval.position = downPoint;\n      } else if (event.modifiers.shift) {\n        this.oval.position = squareDimensions.position;\n      } else {\n        this.oval.position = downPoint.subtract(this.oval.size.multiply(0.5));\n      }\n      this.styleOval();\n    }\n  }, {\n    key: \"handleMouseMove\",\n    value: function handleMouseMove(event) {\n      this.boundingBoxTool.onMouseMove(event, this.getHitOptions());\n    }\n  }, {\n    key: \"handleMouseUp\",\n    value: function handleMouseUp(event) {\n      if (event.event.button > 0 || !this.active) return; // only first mouse button\n      if (this.isBoundingBoxMode) {\n        this.boundingBoxTool.onMouseUp(event);\n        this.isBoundingBoxMode = null;\n        return;\n      }\n      if (this.oval) {\n        if (Math.abs(this.oval.size.width * this.oval.size.height) < OvalTool.TOLERANCE / paper_full_default.a.view.zoom) {\n          // Tiny oval created unintentionally?\n          this.oval.remove();\n          this.oval = null;\n        } else {\n          // Hit testing does not work correctly unless the width and height are positive\n          this.oval.size = new paper_full_default.a.Point(Math.abs(this.oval.size.width), Math.abs(this.oval.size.height));\n          this.oval.selected = true;\n          this.styleOval();\n          this.setSelectedItems();\n        }\n      }\n      this.active = false;\n      this.onUpdateImage();\n    }\n  }, {\n    key: \"commitOval\",\n    value: function commitOval() {\n      if (!this.oval || !this.oval.isInserted()) return;\n      bitmap_commitOvalToBitmap(this.oval, getRaster());\n      this.oval.remove();\n      this.oval = null;\n    }\n  }, {\n    key: \"deactivateTool\",\n    value: function deactivateTool() {\n      this.commitOval();\n      this.boundingBoxTool.deactivateTool();\n    }\n  }]);\n  return OvalTool;\n}(paper_full_default.a.Tool);\n/* harmony default export */ var oval_tool = (oval_tool_OvalTool);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/bit-oval-mode/oval.svg\nvar bit_oval_mode_oval = __webpack_require__(253);\nvar oval_default = __webpack_require__.n(bit_oval_mode_oval);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/components/bit-oval-mode/bit-oval-mode.jsx\n\nvar bit_oval_mode_BitOvalComponent = function BitOvalComponent(props) {\n  return react_default.a.createElement(tool_select_base_tool_select_base, {\n    imgDescriptor: lib_messages.oval,\n    imgSrc: oval_default.a,\n    isSelected: props.isSelected,\n    onMouseDown: props.onMouseDown\n  });\n};\nbit_oval_mode_BitOvalComponent.propTypes = {\n  isSelected: prop_types_default.a.bool.isRequired,\n  onMouseDown: prop_types_default.a.func.isRequired\n};\n/* harmony default export */ var bit_oval_mode = (bit_oval_mode_BitOvalComponent);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/containers/bit-oval-mode.jsx\nfunction bit_oval_mode_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { bit_oval_mode_typeof = function _typeof(obj) { return typeof obj; }; } else { bit_oval_mode_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return bit_oval_mode_typeof(obj); }\nfunction bit_oval_mode_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction bit_oval_mode_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction bit_oval_mode_createClass(Constructor, protoProps, staticProps) { if (protoProps) bit_oval_mode_defineProperties(Constructor.prototype, protoProps); if (staticProps) bit_oval_mode_defineProperties(Constructor, staticProps); return Constructor; }\nfunction bit_oval_mode_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) bit_oval_mode_setPrototypeOf(subClass, superClass); }\nfunction bit_oval_mode_setPrototypeOf(o, p) { bit_oval_mode_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return bit_oval_mode_setPrototypeOf(o, p); }\nfunction bit_oval_mode_createSuper(Derived) { var hasNativeReflectConstruct = bit_oval_mode_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = bit_oval_mode_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = bit_oval_mode_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return bit_oval_mode_possibleConstructorReturn(this, result); }; }\nfunction bit_oval_mode_possibleConstructorReturn(self, call) { if (call && (bit_oval_mode_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return bit_oval_mode_assertThisInitialized(self); }\nfunction bit_oval_mode_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction bit_oval_mode_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction bit_oval_mode_getPrototypeOf(o) { bit_oval_mode_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return bit_oval_mode_getPrototypeOf(o); }\n\nvar bit_oval_mode_BitOvalMode = function (_React$Component) {\n  bit_oval_mode_inherits(BitOvalMode, _React$Component);\n  var _super = bit_oval_mode_createSuper(BitOvalMode);\n  function BitOvalMode(props) {\n    var _this;\n    bit_oval_mode_classCallCheck(this, BitOvalMode);\n    _this = _super.call(this, props);\n    lodash_bindall_default()(bit_oval_mode_assertThisInitialized(_this), ['activateTool', 'deactivateTool']);\n    return _this;\n  }\n  bit_oval_mode_createClass(BitOvalMode, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this.props.isOvalModeActive) {\n        this.activateTool(this.props);\n      }\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(nextProps) {\n      if (this.tool) {\n        if (nextProps.color !== this.props.color) {\n          this.tool.setColor(nextProps.color);\n        }\n        if (nextProps.selectedItems !== this.props.selectedItems) {\n          this.tool.onSelectionChanged(nextProps.selectedItems);\n        }\n        if (nextProps.filled !== this.props.filled) {\n          this.tool.setFilled(nextProps.filled);\n        }\n        if (nextProps.thickness !== this.props.thickness || nextProps.zoom !== this.props.zoom) {\n          this.tool.setThickness(nextProps.thickness);\n        }\n      }\n      if (nextProps.isOvalModeActive && !this.props.isOvalModeActive) {\n        this.activateTool();\n      } else if (!nextProps.isOvalModeActive && this.props.isOvalModeActive) {\n        this.deactivateTool();\n      }\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps) {\n      return nextProps.isOvalModeActive !== this.props.isOvalModeActive;\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.tool) {\n        this.deactivateTool();\n      }\n    }\n  }, {\n    key: \"activateTool\",\n    value: function activateTool() {\n      selection_clearSelection(this.props.clearSelectedItems); // Force the default brush color if fill is MIXED or transparent\n      var fillColorPresent = this.props.color.primary !== MIXED && this.props.color.primary !== null;\n      if (!fillColorPresent) {\n        this.props.onChangeFillColor(DEFAULT_COLOR);\n      }\n      this.tool = new oval_tool(this.props.setSelectedItems, this.props.clearSelectedItems, this.props.setCursor, this.props.onUpdateImage);\n      this.tool.setColor(this.props.color);\n      this.tool.setFilled(this.props.filled);\n      this.tool.setThickness(this.props.thickness);\n      this.tool.activate();\n    }\n  }, {\n    key: \"deactivateTool\",\n    value: function deactivateTool() {\n      this.tool.deactivateTool();\n      this.tool.remove();\n      this.tool = null;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return react_default.a.createElement(bit_oval_mode, {\n        isSelected: this.props.isOvalModeActive,\n        onMouseDown: this.props.handleMouseDown\n      });\n    }\n  }]);\n  return BitOvalMode;\n}(react_default.a.Component);\nbit_oval_mode_BitOvalMode.propTypes = {\n  clearSelectedItems: prop_types_default.a.func.isRequired,\n  color: color_style_proptype,\n  filled: prop_types_default.a.bool,\n  handleMouseDown: prop_types_default.a.func.isRequired,\n  isOvalModeActive: prop_types_default.a.bool.isRequired,\n  onChangeFillColor: prop_types_default.a.func.isRequired,\n  onUpdateImage: prop_types_default.a.func.isRequired,\n  selectedItems: prop_types_default.a.arrayOf(prop_types_default.a.instanceOf(paper_full_default.a.Item)),\n  setCursor: prop_types_default.a.func.isRequired,\n  setSelectedItems: prop_types_default.a.func.isRequired,\n  thickness: prop_types_default.a.number.isRequired,\n  zoom: prop_types_default.a.number.isRequired\n};\nvar bit_oval_mode_mapStateToProps = function mapStateToProps(state) {\n  return {\n    color: state.scratchPaint.color.fillColor,\n    filled: state.scratchPaint.fillBitmapShapes,\n    isOvalModeActive: state.scratchPaint.mode === Modes.BIT_OVAL,\n    selectedItems: state.scratchPaint.selectedItems,\n    thickness: state.scratchPaint.bitBrushSize,\n    zoom: state.scratchPaint.viewBounds.scaling.x\n  };\n};\nvar bit_oval_mode_mapDispatchToProps = function mapDispatchToProps(dispatch) {\n  return {\n    clearSelectedItems: function clearSelectedItems() {\n      dispatch(selected_items_clearSelectedItems());\n    },\n    setCursor: function setCursor(cursorString) {\n      dispatch(cursor_setCursor(cursorString));\n    },\n    setSelectedItems: function setSelectedItems() {\n      dispatch(selected_items_setSelectedItems(selection_getSelectedLeafItems(), true\n      /* bitmapMode */\n      ));\n    },\n    handleMouseDown: function handleMouseDown() {\n      dispatch(modes_changeMode(Modes.BIT_OVAL));\n    },\n    onChangeFillColor: function onChangeFillColor(fillColor) {\n      dispatch(changeFillColor(fillColor));\n    }\n  };\n};\n/* harmony default export */ var containers_bit_oval_mode = (Object(es[\"b\" /* connect */])(bit_oval_mode_mapStateToProps, bit_oval_mode_mapDispatchToProps)(bit_oval_mode_BitOvalMode));\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/helper/bit-tools/rect-tool.js\nfunction rect_tool_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { rect_tool_typeof = function _typeof(obj) { return typeof obj; }; } else { rect_tool_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return rect_tool_typeof(obj); }\nfunction rect_tool_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction rect_tool_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction rect_tool_createClass(Constructor, protoProps, staticProps) { if (protoProps) rect_tool_defineProperties(Constructor.prototype, protoProps); if (staticProps) rect_tool_defineProperties(Constructor, staticProps); return Constructor; }\nfunction rect_tool_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) rect_tool_setPrototypeOf(subClass, superClass); }\nfunction rect_tool_setPrototypeOf(o, p) { rect_tool_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return rect_tool_setPrototypeOf(o, p); }\nfunction rect_tool_createSuper(Derived) { var hasNativeReflectConstruct = rect_tool_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = rect_tool_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = rect_tool_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return rect_tool_possibleConstructorReturn(this, result); }; }\nfunction rect_tool_possibleConstructorReturn(self, call) { if (call && (rect_tool_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return rect_tool_assertThisInitialized(self); }\nfunction rect_tool_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction rect_tool_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction rect_tool_getPrototypeOf(o) { rect_tool_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return rect_tool_getPrototypeOf(o); }\n\n/**\n * Tool for drawing rects.\n */\nvar rect_tool_RectTool = function (_paper$Tool) {\n  rect_tool_inherits(RectTool, _paper$Tool);\n  var _super = rect_tool_createSuper(RectTool);\n  rect_tool_createClass(RectTool, null, [{\n    key: \"TOLERANCE\",\n    get: function get() {\n      return 2;\n    }\n    /**\n     * @param {function} setSelectedItems Callback to set the set of selected items in the Redux state\n     * @param {function} clearSelectedItems Callback to clear the set of selected items in the Redux state\n     * @param {function} setCursor Callback to set the visible mouse cursor\n     * @param {!function} onUpdateImage A callback to call when the image visibly changes\n     */\n  }]);\n  function RectTool(setSelectedItems, clearSelectedItems, setCursor, onUpdateImage) {\n    var _this;\n    rect_tool_classCallCheck(this, RectTool);\n    _this = _super.call(this);\n    _this.setSelectedItems = setSelectedItems;\n    _this.clearSelectedItems = clearSelectedItems;\n    _this.onUpdateImage = onUpdateImage;\n    _this.boundingBoxTool = new bounding_box_tool(Modes.BIT_RECT, setSelectedItems, clearSelectedItems, setCursor, onUpdateImage);\n    var nudgeTool = new nudge_tool(Modes.BIT_RECT, _this.boundingBoxTool, onUpdateImage); // We have to set these functions instead of just declaring them because\n    // paper.js tools hook up the listeners in the setter functions.\n    _this.onMouseDown = _this.handleMouseDown;\n    _this.onMouseDrag = _this.handleMouseDrag;\n    _this.onMouseMove = _this.handleMouseMove;\n    _this.onMouseUp = _this.handleMouseUp;\n    _this.onKeyUp = nudgeTool.onKeyUp;\n    _this.onKeyDown = nudgeTool.onKeyDown;\n    _this.rect = null;\n    _this.color = null;\n    _this.active = false;\n    return _this;\n  }\n  rect_tool_createClass(RectTool, [{\n    key: \"getHitOptions\",\n    value: function getHitOptions() {\n      return {\n        segments: false,\n        stroke: true,\n        curves: false,\n        fill: true,\n        guide: false,\n        match: function match(hitResult) {\n          return hitResult.item.data && (hitResult.item.data.isScaleHandle || hitResult.item.data.isRotHandle) || hitResult.item.selected;\n        },\n        // Allow hits on bounding box and selected only\n        tolerance: RectTool.TOLERANCE / paper_full_default.a.view.zoom\n      };\n    }\n    /**\n     * Should be called if the selection changes to update the bounds of the bounding box.\n     * @param {Array<paper.Item>} selectedItems Array of selected items.\n     */\n  }, {\n    key: \"onSelectionChanged\",\n    value: function onSelectionChanged(selectedItems) {\n      this.boundingBoxTool.onSelectionChanged(selectedItems);\n      if ((!this.rect || !this.rect.isInserted()) && selectedItems && selectedItems.length === 1 && selectedItems[0].shape === 'rectangle') {\n        // Infer that an undo occurred and get back the active rect\n        this.rect = selectedItems[0];\n        if (this.rect.data.zoomLevel !== paper_full_default.a.view.zoom) {\n          this.rect.strokeWidth = this.rect.strokeWidth / this.rect.data.zoomLevel * paper_full_default.a.view.zoom;\n          this.rect.data.zoomLevel = paper_full_default.a.view.zoom;\n          this.thickness = this.rect.strokeWidth;\n        }\n        this.filled = this.rect.strokeWidth === 0;\n      } else if (this.rect && this.rect.isInserted() && !this.rect.selected) {\n        // Rectangle got deselected\n        this.commitRect();\n      }\n    }\n  }, {\n    key: \"styleRect\",\n    value: function styleRect() {\n      style_path_styleShape(this.rect, {\n        fillColor: this.filled ? this.color : null,\n        strokeColor: this.filled ? null : this.color,\n        strokeWidth: this.filled ? 0 : this.thickness\n      });\n    }\n  }, {\n    key: \"setColor\",\n    value: function setColor(color) {\n      this.color = color;\n      if (this.rect) this.styleRect();\n    }\n  }, {\n    key: \"setFilled\",\n    value: function setFilled(filled) {\n      if (this.filled === filled) return;\n      this.filled = filled;\n      if (this.rect && this.rect.isInserted()) {\n        this.styleRect();\n        this.onUpdateImage();\n      }\n    }\n  }, {\n    key: \"setThickness\",\n    value: function setThickness(thickness) {\n      if (this.thickness === thickness * paper_full_default.a.view.zoom) return;\n      this.thickness = thickness * paper_full_default.a.view.zoom;\n      if (this.rect && this.rect.isInserted() && !this.filled) {\n        this.rect.strokeWidth = this.thickness;\n      }\n      if (this.rect && this.rect.isInserted()) {\n        this.rect.data.zoomLevel = paper_full_default.a.view.zoom;\n        this.onUpdateImage();\n      }\n    }\n  }, {\n    key: \"handleMouseDown\",\n    value: function handleMouseDown(event) {\n      if (event.event.button > 0) return; // only first mouse button\n      this.active = true;\n      if (this.boundingBoxTool.onMouseDown(event, false\n      /* clone */\n      , false\n      /* multiselect */\n      , false\n      /* doubleClicked */\n      , this.getHitOptions())) {\n        this.isBoundingBoxMode = true;\n      } else {\n        this.isBoundingBoxMode = false;\n        selection_clearSelection(this.clearSelectedItems);\n        this.commitRect();\n      }\n    }\n  }, {\n    key: \"handleMouseDrag\",\n    value: function handleMouseDrag(event) {\n      if (event.event.button > 0 || !this.active) return; // only first mouse button\n      if (this.isBoundingBoxMode) {\n        this.boundingBoxTool.onMouseDrag(event);\n        return;\n      }\n      var dimensions = event.point.subtract(event.downPoint);\n      var baseRect = new paper_full_default.a.Rectangle(event.downPoint, event.point);\n      var squareDimensions = math_getSquareDimensions(event.downPoint, event.point);\n      if (event.modifiers.shift) {\n        baseRect.size = squareDimensions.size.abs();\n      }\n      if (this.rect) this.rect.remove();\n      this.rect = new paper_full_default.a.Shape.Rectangle(baseRect);\n      this.rect.strokeJoin = 'round';\n      this.rect.strokeScaling = false;\n      this.rect.data = {\n        zoomLevel: paper_full_default.a.view.zoom\n      };\n      this.styleRect();\n      if (event.modifiers.alt) {\n        this.rect.position = event.downPoint;\n      } else if (event.modifiers.shift) {\n        this.rect.position = squareDimensions.position;\n      } else {\n        this.rect.position = event.downPoint.add(dimensions.multiply(.5));\n      }\n    }\n  }, {\n    key: \"handleMouseMove\",\n    value: function handleMouseMove(event) {\n      this.boundingBoxTool.onMouseMove(event, this.getHitOptions());\n    }\n  }, {\n    key: \"handleMouseUp\",\n    value: function handleMouseUp(event) {\n      if (event.event.button > 0 || !this.active) return; // only first mouse button\n      if (this.isBoundingBoxMode) {\n        this.boundingBoxTool.onMouseUp(event);\n        this.isBoundingBoxMode = null;\n        return;\n      }\n      if (this.rect) {\n        if (Math.abs(this.rect.size.width * this.rect.size.height) < RectTool.TOLERANCE / paper_full_default.a.view.zoom) {\n          // Tiny shape created unintentionally?\n          this.rect.remove();\n          this.rect = null;\n        } else {\n          // Hit testing does not work correctly unless the width and height are positive\n          this.rect.size = new paper_full_default.a.Point(Math.abs(this.rect.size.width), Math.abs(this.rect.size.height));\n          this.rect.selected = true;\n          this.styleRect();\n          this.setSelectedItems();\n        }\n      }\n      this.active = false;\n      this.onUpdateImage();\n    }\n  }, {\n    key: \"commitRect\",\n    value: function commitRect() {\n      if (!this.rect || !this.rect.isInserted()) return;\n      bitmap_commitRectToBitmap(this.rect, getRaster());\n      this.rect.remove();\n      this.rect = null;\n    }\n  }, {\n    key: \"deactivateTool\",\n    value: function deactivateTool() {\n      this.commitRect();\n      this.boundingBoxTool.deactivateTool();\n    }\n  }]);\n  return RectTool;\n}(paper_full_default.a.Tool);\n/* harmony default export */ var rect_tool = (rect_tool_RectTool);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/bit-rect-mode/rectangle.svg\nvar rectangle = __webpack_require__(254);\nvar rectangle_default = __webpack_require__.n(rectangle);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/components/bit-rect-mode/bit-rect-mode.jsx\n\nvar bit_rect_mode_BitRectComponent = function BitRectComponent(props) {\n  return react_default.a.createElement(tool_select_base_tool_select_base, {\n    imgDescriptor: lib_messages.rect,\n    imgSrc: rectangle_default.a,\n    isSelected: props.isSelected,\n    onMouseDown: props.onMouseDown\n  });\n};\nbit_rect_mode_BitRectComponent.propTypes = {\n  isSelected: prop_types_default.a.bool.isRequired,\n  onMouseDown: prop_types_default.a.func.isRequired\n};\n/* harmony default export */ var bit_rect_mode = (bit_rect_mode_BitRectComponent);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/containers/bit-rect-mode.jsx\nfunction bit_rect_mode_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { bit_rect_mode_typeof = function _typeof(obj) { return typeof obj; }; } else { bit_rect_mode_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return bit_rect_mode_typeof(obj); }\nfunction bit_rect_mode_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction bit_rect_mode_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction bit_rect_mode_createClass(Constructor, protoProps, staticProps) { if (protoProps) bit_rect_mode_defineProperties(Constructor.prototype, protoProps); if (staticProps) bit_rect_mode_defineProperties(Constructor, staticProps); return Constructor; }\nfunction bit_rect_mode_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) bit_rect_mode_setPrototypeOf(subClass, superClass); }\nfunction bit_rect_mode_setPrototypeOf(o, p) { bit_rect_mode_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return bit_rect_mode_setPrototypeOf(o, p); }\nfunction bit_rect_mode_createSuper(Derived) { var hasNativeReflectConstruct = bit_rect_mode_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = bit_rect_mode_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = bit_rect_mode_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return bit_rect_mode_possibleConstructorReturn(this, result); }; }\nfunction bit_rect_mode_possibleConstructorReturn(self, call) { if (call && (bit_rect_mode_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return bit_rect_mode_assertThisInitialized(self); }\nfunction bit_rect_mode_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction bit_rect_mode_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction bit_rect_mode_getPrototypeOf(o) { bit_rect_mode_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return bit_rect_mode_getPrototypeOf(o); }\n\nvar bit_rect_mode_BitRectMode = function (_React$Component) {\n  bit_rect_mode_inherits(BitRectMode, _React$Component);\n  var _super = bit_rect_mode_createSuper(BitRectMode);\n  function BitRectMode(props) {\n    var _this;\n    bit_rect_mode_classCallCheck(this, BitRectMode);\n    _this = _super.call(this, props);\n    lodash_bindall_default()(bit_rect_mode_assertThisInitialized(_this), ['activateTool', 'deactivateTool']);\n    return _this;\n  }\n  bit_rect_mode_createClass(BitRectMode, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this.props.isRectModeActive) {\n        this.activateTool(this.props);\n      }\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(nextProps) {\n      if (this.tool) {\n        if (nextProps.color !== this.props.color) {\n          this.tool.setColor(nextProps.color);\n        }\n        if (nextProps.selectedItems !== this.props.selectedItems) {\n          this.tool.onSelectionChanged(nextProps.selectedItems);\n        }\n        if (nextProps.filled !== this.props.filled) {\n          this.tool.setFilled(nextProps.filled);\n        }\n        if (nextProps.thickness !== this.props.thickness || nextProps.zoom !== this.props.zoom) {\n          this.tool.setThickness(nextProps.thickness);\n        }\n      }\n      if (nextProps.isRectModeActive && !this.props.isRectModeActive) {\n        this.activateTool();\n      } else if (!nextProps.isRectModeActive && this.props.isRectModeActive) {\n        this.deactivateTool();\n      }\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps) {\n      return nextProps.isRectModeActive !== this.props.isRectModeActive;\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.tool) {\n        this.deactivateTool();\n      }\n    }\n  }, {\n    key: \"activateTool\",\n    value: function activateTool() {\n      selection_clearSelection(this.props.clearSelectedItems); // Force the default brush color if fill is MIXED or transparent\n      var fillColorPresent = this.props.color.primary !== MIXED && this.props.color.primary !== null;\n      if (!fillColorPresent) {\n        this.props.onChangeFillColor(DEFAULT_COLOR);\n      }\n      this.tool = new rect_tool(this.props.setSelectedItems, this.props.clearSelectedItems, this.props.setCursor, this.props.onUpdateImage);\n      this.tool.setColor(this.props.color);\n      this.tool.setFilled(this.props.filled);\n      this.tool.setThickness(this.props.thickness);\n      this.tool.activate();\n    }\n  }, {\n    key: \"deactivateTool\",\n    value: function deactivateTool() {\n      this.tool.deactivateTool();\n      this.tool.remove();\n      this.tool = null;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return react_default.a.createElement(bit_rect_mode, {\n        isSelected: this.props.isRectModeActive,\n        onMouseDown: this.props.handleMouseDown\n      });\n    }\n  }]);\n  return BitRectMode;\n}(react_default.a.Component);\nbit_rect_mode_BitRectMode.propTypes = {\n  clearSelectedItems: prop_types_default.a.func.isRequired,\n  color: color_style_proptype,\n  filled: prop_types_default.a.bool,\n  handleMouseDown: prop_types_default.a.func.isRequired,\n  isRectModeActive: prop_types_default.a.bool.isRequired,\n  onChangeFillColor: prop_types_default.a.func.isRequired,\n  onUpdateImage: prop_types_default.a.func.isRequired,\n  selectedItems: prop_types_default.a.arrayOf(prop_types_default.a.instanceOf(paper_full_default.a.Item)),\n  setCursor: prop_types_default.a.func.isRequired,\n  setSelectedItems: prop_types_default.a.func.isRequired,\n  thickness: prop_types_default.a.number.isRequired,\n  zoom: prop_types_default.a.number.isRequired\n};\nvar bit_rect_mode_mapStateToProps = function mapStateToProps(state) {\n  return {\n    color: state.scratchPaint.color.fillColor,\n    filled: state.scratchPaint.fillBitmapShapes,\n    isRectModeActive: state.scratchPaint.mode === Modes.BIT_RECT,\n    selectedItems: state.scratchPaint.selectedItems,\n    thickness: state.scratchPaint.bitBrushSize,\n    zoom: state.scratchPaint.viewBounds.scaling.x\n  };\n};\nvar bit_rect_mode_mapDispatchToProps = function mapDispatchToProps(dispatch) {\n  return {\n    clearSelectedItems: function clearSelectedItems() {\n      dispatch(selected_items_clearSelectedItems());\n    },\n    setCursor: function setCursor(cursorString) {\n      dispatch(cursor_setCursor(cursorString));\n    },\n    setSelectedItems: function setSelectedItems() {\n      dispatch(selected_items_setSelectedItems(selection_getSelectedLeafItems(), true\n      /* bitmapMode */\n      ));\n    },\n    handleMouseDown: function handleMouseDown() {\n      dispatch(modes_changeMode(Modes.BIT_RECT));\n    },\n    onChangeFillColor: function onChangeFillColor(fillColor) {\n      dispatch(changeFillColor(fillColor));\n    }\n  };\n};\n/* harmony default export */ var containers_bit_rect_mode = (Object(es[\"b\" /* connect */])(bit_rect_mode_mapStateToProps, bit_rect_mode_mapDispatchToProps)(bit_rect_mode_BitRectMode));\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/bit-fill-mode/fill.svg\nvar fill = __webpack_require__(602);\nvar fill_default = __webpack_require__.n(fill);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/components/bit-fill-mode/bit-fill-mode.jsx\n\nvar bit_fill_mode_BitFillComponent = function BitFillComponent(props) {\n  return react_default.a.createElement(tool_select_base_tool_select_base, {\n    imgDescriptor: lib_messages.fill,\n    imgSrc: fill_default.a,\n    isSelected: props.isSelected,\n    onMouseDown: props.onMouseDown\n  });\n};\nbit_fill_mode_BitFillComponent.propTypes = {\n  isSelected: prop_types_default.a.bool.isRequired,\n  onMouseDown: prop_types_default.a.func.isRequired\n};\n/* harmony default export */ var bit_fill_mode = (bit_fill_mode_BitFillComponent);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/reducers/fill-mode-gradient-type.js\n// Gradient type shown in the fill tool. This is the last gradient type explicitly chosen by the user,\n// and isn't overwritten by changing the selection.\nvar fill_mode_gradient_type_initialState = null;\nvar fill_mode_gradient_type_reducer = function reducer(state, action) {\n  if (typeof state === 'undefined') state = fill_mode_gradient_type_initialState;\n  switch (action.type) {\n    case CHANGE_FILL_GRADIENT_TYPE:\n      if (action.gradientType in gradient_types) {\n        return action.gradientType;\n      }\n      log.warn(\"Gradient type does not exist: \".concat(action.gradientType));\n    /* falls through */\n    default:\n      return state;\n  }\n}; // Action creators ==================================\n// Use this for user-initiated gradient type selections only.\n// See reducers/fill-style.js for other ways gradient type changes.\nvar fill_mode_gradient_type_changeGradientType = function changeGradientType(gradientType) {\n  return {\n    type: CHANGE_FILL_GRADIENT_TYPE,\n    gradientType: gradientType\n  };\n};\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/helper/bit-tools/fill-tool.js\nfunction fill_tool_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { fill_tool_typeof = function _typeof(obj) { return typeof obj; }; } else { fill_tool_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return fill_tool_typeof(obj); }\nfunction fill_tool_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction fill_tool_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction fill_tool_createClass(Constructor, protoProps, staticProps) { if (protoProps) fill_tool_defineProperties(Constructor.prototype, protoProps); if (staticProps) fill_tool_defineProperties(Constructor, staticProps); return Constructor; }\nfunction fill_tool_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) fill_tool_setPrototypeOf(subClass, superClass); }\nfunction fill_tool_setPrototypeOf(o, p) { fill_tool_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return fill_tool_setPrototypeOf(o, p); }\nfunction fill_tool_createSuper(Derived) { var hasNativeReflectConstruct = fill_tool_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = fill_tool_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = fill_tool_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return fill_tool_possibleConstructorReturn(this, result); }; }\nfunction fill_tool_possibleConstructorReturn(self, call) { if (call && (fill_tool_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return fill_tool_assertThisInitialized(self); }\nfunction fill_tool_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction fill_tool_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction fill_tool_getPrototypeOf(o) { fill_tool_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return fill_tool_getPrototypeOf(o); }\n\nvar TRANSPARENT = 'rgba(0,0,0,0)';\n/**\n * Tool for drawing fills.\n */\nvar fill_tool_FillTool = function (_paper$Tool) {\n  fill_tool_inherits(FillTool, _paper$Tool);\n  var _super = fill_tool_createSuper(FillTool);\n  /**\n   * @param {!function} onUpdateImage A callback to call when the image visibly changes\n   */\n  function FillTool(onUpdateImage) {\n    var _this;\n    fill_tool_classCallCheck(this, FillTool);\n    _this = _super.call(this);\n    _this.onUpdateImage = onUpdateImage; // We have to set these functions instead of just declaring them because\n    // paper.js tools hook up the listeners in the setter functions.\n    _this.onMouseDown = _this.handleMouseDown;\n    _this.onMouseDrag = _this.handleMouseDrag;\n    _this.color = null;\n    _this.color2 = null;\n    _this.gradientType = null;\n    _this.active = false;\n    return _this;\n  }\n  fill_tool_createClass(FillTool, [{\n    key: \"setColor\",\n    value: function setColor(color) {\n      this.color = color;\n    }\n  }, {\n    key: \"setColor2\",\n    value: function setColor2(color2) {\n      this.color2 = color2;\n    }\n  }, {\n    key: \"setGradientType\",\n    value: function setGradientType(gradientType) {\n      this.gradientType = gradientType;\n    }\n  }, {\n    key: \"handleMouseDown\",\n    value: function handleMouseDown(event) {\n      this.paint(event);\n    }\n  }, {\n    key: \"handleMouseDrag\",\n    value: function handleMouseDrag(event) {\n      this.paint(event);\n    }\n  }, {\n    key: \"paint\",\n    value: function paint(event) {\n      var _this2 = this;\n      var sourceContext = getRaster().getContext('2d',{willReadFrequently:true});\n      var destContext = sourceContext;\n      var color = this.color; // Paint to a mask instead of the original canvas when drawing\n      if (this.gradientType !== gradient_types.SOLID) {\n        var tmpCanvas = layer_createCanvas();\n        destContext = tmpCanvas.getContext('2d',{willReadFrequently:true});\n        color = 'black';\n      } else if (!color) {\n        // Null color means transparent because that is the standard in vector\n        color = TRANSPARENT;\n      }\n      var changed = false;\n      if (event.event.shiftKey) {\n        changed = floodFillAll(event.point.x, event.point.y, color, sourceContext, destContext);\n      } else {\n        changed = floodFill(event.point.x, event.point.y, color, sourceContext, destContext);\n      }\n      if (changed && this.gradientType !== gradient_types.SOLID) {\n        var raster = new paper_full_default.a.Raster({\n          insert: false\n        });\n        raster.canvas = destContext.canvas;\n        raster.onLoad = function () {\n          raster.position = getRaster().position; // Erase what's already there\n          getRaster().getContext().globalCompositeOperation = 'destination-out';\n          getRaster().drawImage(raster.canvas, new paper_full_default.a.Point());\n          getRaster().getContext().globalCompositeOperation = 'source-over'; // Create the gradient to be masked\n          var hitBounds = bitmap_getHitBounds(raster);\n          if (!hitBounds.area) return;\n          var gradient = new paper_full_default.a.Shape.Rectangle({\n            insert: false,\n            rectangle: {\n              topLeft: hitBounds.topLeft,\n              bottomRight: hitBounds.bottomRight\n            }\n          });\n          gradient.fillColor = style_path_createGradientObject(_this2.color, _this2.color2, _this2.gradientType, gradient.bounds, event.point);\n          var rasterGradient = gradient.rasterize(getRaster().resolution.width, false\n          /* insert */\n          ); // Mask gradient\n          raster.getContext().globalCompositeOperation = 'source-in';\n          raster.drawImage(rasterGradient.canvas, rasterGradient.bounds.topLeft); // Draw masked gradient into raster layer\n          getRaster().drawImage(raster.canvas, new paper_full_default.a.Point());\n          _this2.onUpdateImage();\n        };\n      } else if (changed) {\n        this.onUpdateImage();\n      }\n    }\n  }, {\n    key: \"deactivateTool\",\n    value: function deactivateTool() {}\n  }]);\n  return FillTool;\n}(paper_full_default.a.Tool);\n/* harmony default export */ var fill_tool = (fill_tool_FillTool);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/containers/bit-fill-mode.jsx\nfunction bit_fill_mode_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { bit_fill_mode_typeof = function _typeof(obj) { return typeof obj; }; } else { bit_fill_mode_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return bit_fill_mode_typeof(obj); }\nfunction bit_fill_mode_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction bit_fill_mode_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction bit_fill_mode_createClass(Constructor, protoProps, staticProps) { if (protoProps) bit_fill_mode_defineProperties(Constructor.prototype, protoProps); if (staticProps) bit_fill_mode_defineProperties(Constructor, staticProps); return Constructor; }\nfunction bit_fill_mode_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) bit_fill_mode_setPrototypeOf(subClass, superClass); }\nfunction bit_fill_mode_setPrototypeOf(o, p) { bit_fill_mode_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return bit_fill_mode_setPrototypeOf(o, p); }\nfunction bit_fill_mode_createSuper(Derived) { var hasNativeReflectConstruct = bit_fill_mode_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = bit_fill_mode_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = bit_fill_mode_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return bit_fill_mode_possibleConstructorReturn(this, result); }; }\nfunction bit_fill_mode_possibleConstructorReturn(self, call) { if (call && (bit_fill_mode_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return bit_fill_mode_assertThisInitialized(self); }\nfunction bit_fill_mode_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction bit_fill_mode_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction bit_fill_mode_getPrototypeOf(o) { bit_fill_mode_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return bit_fill_mode_getPrototypeOf(o); }\n\nvar bit_fill_mode_BitFillMode = function (_React$Component) {\n  bit_fill_mode_inherits(BitFillMode, _React$Component);\n  var _super = bit_fill_mode_createSuper(BitFillMode);\n  function BitFillMode(props) {\n    var _this;\n    bit_fill_mode_classCallCheck(this, BitFillMode);\n    _this = _super.call(this, props);\n    lodash_bindall_default()(bit_fill_mode_assertThisInitialized(_this), ['activateTool', 'deactivateTool']);\n    return _this;\n  }\n  bit_fill_mode_createClass(BitFillMode, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this.props.isFillModeActive) {\n        this.activateTool(this.props);\n      }\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(nextProps) {\n      if (this.tool) {\n        if (nextProps.color !== this.props.color) {\n          this.tool.setColor(nextProps.color);\n        }\n        if (nextProps.color2 !== this.props.color2) {\n          this.tool.setColor2(nextProps.color2);\n        }\n        if (nextProps.fillModeGradientType !== this.props.fillModeGradientType) {\n          this.tool.setGradientType(nextProps.fillModeGradientType);\n        }\n      }\n      if (nextProps.isFillModeActive && !this.props.isFillModeActive) {\n        this.activateTool();\n      } else if (!nextProps.isFillModeActive && this.props.isFillModeActive) {\n        this.deactivateTool();\n      }\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps) {\n      return nextProps.isFillModeActive !== this.props.isFillModeActive;\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.tool) {\n        this.deactivateTool();\n      }\n    }\n  }, {\n    key: \"activateTool\",\n    value: function activateTool() {\n      selection_clearSelection(this.props.clearSelectedItems); // Force the default brush color if fill is MIXED or transparent\n      var color = this.props.color;\n      if (this.props.color === MIXED) {\n        color = DEFAULT_COLOR;\n        this.props.onChangeFillColor(DEFAULT_COLOR, 0);\n      }\n      var gradientType = this.props.fillModeGradientType ? this.props.fillModeGradientType : this.props.styleGradientType;\n      var color2 = this.props.color2;\n      if (gradientType !== this.props.styleGradientType) {\n        if (this.props.styleGradientType === gradient_types.SOLID) {\n          color2 = style_path_generateSecondaryColor(color);\n          this.props.onChangeFillColor(color2, 1);\n        }\n        this.props.changeGradientType(gradientType);\n      }\n      if (this.props.color2 === MIXED) {\n        color2 = style_path_generateSecondaryColor();\n        this.props.onChangeFillColor(color2, 1);\n      }\n      this.tool = new fill_tool(this.props.onUpdateImage);\n      this.tool.setColor(color);\n      this.tool.setColor2(color2);\n      this.tool.setGradientType(gradientType);\n      this.tool.activate();\n    }\n  }, {\n    key: \"deactivateTool\",\n    value: function deactivateTool() {\n      this.tool.deactivateTool();\n      this.tool.remove();\n      this.tool = null;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return react_default.a.createElement(bit_fill_mode, {\n        isSelected: this.props.isFillModeActive,\n        onMouseDown: this.props.handleMouseDown\n      });\n    }\n  }]);\n  return BitFillMode;\n}(react_default.a.Component);\nbit_fill_mode_BitFillMode.propTypes = {\n  changeGradientType: prop_types_default.a.func.isRequired,\n  clearSelectedItems: prop_types_default.a.func.isRequired,\n  color: prop_types_default.a.string,\n  color2: prop_types_default.a.string,\n  styleGradientType: prop_types_default.a.oneOf(Object.keys(gradient_types)).isRequired,\n  fillModeGradientType: prop_types_default.a.oneOf(Object.keys(gradient_types)),\n  handleMouseDown: prop_types_default.a.func.isRequired,\n  isFillModeActive: prop_types_default.a.bool.isRequired,\n  onChangeFillColor: prop_types_default.a.func.isRequired,\n  onUpdateImage: prop_types_default.a.func.isRequired\n};\nvar bit_fill_mode_mapStateToProps = function mapStateToProps(state) {\n  return {\n    fillModeGradientType: state.scratchPaint.fillMode.gradientType,\n    // Last user-selected gradient type\n    color: state.scratchPaint.color.fillColor.primary,\n    color2: state.scratchPaint.color.fillColor.secondary,\n    styleGradientType: state.scratchPaint.color.fillColor.gradientType,\n    isFillModeActive: state.scratchPaint.mode === Modes.BIT_FILL\n  };\n};\nvar bit_fill_mode_mapDispatchToProps = function mapDispatchToProps(dispatch) {\n  return {\n    clearSelectedItems: function clearSelectedItems() {\n      dispatch(selected_items_clearSelectedItems());\n    },\n    changeGradientType: function changeGradientType(gradientType) {\n      dispatch(fill_mode_gradient_type_changeGradientType(gradientType));\n    },\n    handleMouseDown: function handleMouseDown() {\n      dispatch(modes_changeMode(Modes.BIT_FILL));\n    },\n    onChangeFillColor: function onChangeFillColor(fillColor, index) {\n      if (index === 0) {\n        dispatch(changeFillColor(fillColor));\n      } else if (index === 1) {\n        dispatch(changeFillColor2(fillColor));\n      }\n    }\n  };\n};\n/* harmony default export */ var containers_bit_fill_mode = (Object(es[\"b\" /* connect */])(bit_fill_mode_mapStateToProps, bit_fill_mode_mapDispatchToProps)(bit_fill_mode_BitFillMode));\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/bit-eraser-mode/eraser.svg\nvar eraser = __webpack_require__(255);\nvar eraser_default = __webpack_require__.n(eraser);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/components/bit-eraser-mode/bit-eraser-mode.jsx\n\nvar bit_eraser_mode_BitEraserComponent = function BitEraserComponent(props) {\n  return react_default.a.createElement(tool_select_base_tool_select_base, {\n    imgDescriptor: lib_messages.eraser,\n    imgSrc: eraser_default.a,\n    isSelected: props.isSelected,\n    onMouseDown: props.onMouseDown\n  });\n};\nbit_eraser_mode_BitEraserComponent.propTypes = {\n  isSelected: prop_types_default.a.bool.isRequired,\n  onMouseDown: prop_types_default.a.func.isRequired\n};\n/* harmony default export */ var bit_eraser_mode = (bit_eraser_mode_BitEraserComponent);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/containers/bit-eraser-mode.jsx\nfunction bit_eraser_mode_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { bit_eraser_mode_typeof = function _typeof(obj) { return typeof obj; }; } else { bit_eraser_mode_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return bit_eraser_mode_typeof(obj); }\nfunction bit_eraser_mode_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction bit_eraser_mode_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction bit_eraser_mode_createClass(Constructor, protoProps, staticProps) { if (protoProps) bit_eraser_mode_defineProperties(Constructor.prototype, protoProps); if (staticProps) bit_eraser_mode_defineProperties(Constructor, staticProps); return Constructor; }\nfunction bit_eraser_mode_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) bit_eraser_mode_setPrototypeOf(subClass, superClass); }\nfunction bit_eraser_mode_setPrototypeOf(o, p) { bit_eraser_mode_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return bit_eraser_mode_setPrototypeOf(o, p); }\nfunction bit_eraser_mode_createSuper(Derived) { var hasNativeReflectConstruct = bit_eraser_mode_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = bit_eraser_mode_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = bit_eraser_mode_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return bit_eraser_mode_possibleConstructorReturn(this, result); }; }\nfunction bit_eraser_mode_possibleConstructorReturn(self, call) { if (call && (bit_eraser_mode_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return bit_eraser_mode_assertThisInitialized(self); }\nfunction bit_eraser_mode_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction bit_eraser_mode_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction bit_eraser_mode_getPrototypeOf(o) { bit_eraser_mode_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return bit_eraser_mode_getPrototypeOf(o); }\n\nvar bit_eraser_mode_BitEraserMode = function (_React$Component) {\n  bit_eraser_mode_inherits(BitEraserMode, _React$Component);\n  var _super = bit_eraser_mode_createSuper(BitEraserMode);\n  function BitEraserMode(props) {\n    var _this;\n    bit_eraser_mode_classCallCheck(this, BitEraserMode);\n    _this = _super.call(this, props);\n    lodash_bindall_default()(bit_eraser_mode_assertThisInitialized(_this), ['activateTool', 'deactivateTool']);\n    return _this;\n  }\n  bit_eraser_mode_createClass(BitEraserMode, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this.props.isBitEraserModeActive) {\n        this.activateTool(this.props);\n      }\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(nextProps) {\n      if (this.tool && nextProps.bitEraserSize !== this.props.bitEraserSize) {\n        this.tool.setBrushSize(nextProps.bitEraserSize);\n      }\n      if (nextProps.isBitEraserModeActive && !this.props.isBitEraserModeActive) {\n        this.activateTool();\n      } else if (!nextProps.isBitEraserModeActive && this.props.isBitEraserModeActive) {\n        this.deactivateTool();\n      }\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps) {\n      return nextProps.isBitEraserModeActive !== this.props.isBitEraserModeActive;\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.tool) {\n        this.deactivateTool();\n      }\n    }\n  }, {\n    key: \"activateTool\",\n    value: function activateTool() {\n      selection_clearSelection(this.props.clearSelectedItems);\n      this.tool = new brush_tool(this.props.onUpdateImage, true\n      /* isEraser */\n      );\n      this.tool.setBrushSize(this.props.bitEraserSize);\n      this.tool.activate();\n    }\n  }, {\n    key: \"deactivateTool\",\n    value: function deactivateTool() {\n      this.tool.deactivateTool();\n      this.tool.remove();\n      this.tool = null;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return react_default.a.createElement(bit_eraser_mode, {\n        isSelected: this.props.isBitEraserModeActive,\n        onMouseDown: this.props.handleMouseDown\n      });\n    }\n  }]);\n  return BitEraserMode;\n}(react_default.a.Component);\nbit_eraser_mode_BitEraserMode.propTypes = {\n  bitEraserSize: prop_types_default.a.number.isRequired,\n  clearSelectedItems: prop_types_default.a.func.isRequired,\n  handleMouseDown: prop_types_default.a.func.isRequired,\n  isBitEraserModeActive: prop_types_default.a.bool.isRequired,\n  onUpdateImage: prop_types_default.a.func.isRequired\n};\nvar bit_eraser_mode_mapStateToProps = function mapStateToProps(state) {\n  return {\n    bitEraserSize: state.scratchPaint.bitEraserSize,\n    isBitEraserModeActive: state.scratchPaint.mode === Modes.BIT_ERASER\n  };\n};\nvar bit_eraser_mode_mapDispatchToProps = function mapDispatchToProps(dispatch) {\n  return {\n    clearSelectedItems: function clearSelectedItems() {\n      dispatch(selected_items_clearSelectedItems());\n    },\n    handleMouseDown: function handleMouseDown() {\n      dispatch(modes_changeMode(Modes.BIT_ERASER));\n    }\n  };\n};\n/* harmony default export */ var containers_bit_eraser_mode = (Object(es[\"b\" /* connect */])(bit_eraser_mode_mapStateToProps, bit_eraser_mode_mapDispatchToProps)(bit_eraser_mode_BitEraserMode));\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/helper/selection-tools/selection-box-tool.js\nfunction selection_box_tool_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction selection_box_tool_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction selection_box_tool_createClass(Constructor, protoProps, staticProps) { if (protoProps) selection_box_tool_defineProperties(Constructor.prototype, protoProps); if (staticProps) selection_box_tool_defineProperties(Constructor, staticProps); return Constructor; }\n\n/** Tool to handle drag selection. A dotted line box appears and everything enclosed is selected. */\nvar selection_box_tool_SelectionBoxTool = function () {\n  /**\n   * @param {!Modes} mode Current paint editor mode\n   * @param {function} setSelectedItems Callback to set the set of selected items in the Redux state\n   * @param {function} clearSelectedItems Callback to clear the set of selected items in the Redux state\n   */\n  function SelectionBoxTool(mode, setSelectedItems, clearSelectedItems) {\n    selection_box_tool_classCallCheck(this, SelectionBoxTool);\n    this.selectionRect = null;\n    this.mode = mode;\n    this.setSelectedItems = setSelectedItems;\n    this.clearSelectedItems = clearSelectedItems;\n  }\n  /**\n   * @param {boolean} multiselect Whether to multiselect on mouse down (e.g. shift key held)\n   */\n  selection_box_tool_createClass(SelectionBoxTool, [{\n    key: \"onMouseDown\",\n    value: function onMouseDown(multiselect) {\n      if (!multiselect) {\n        selection_clearSelection(this.clearSelectedItems);\n        this.clearSelectedItems();\n      }\n    }\n  }, {\n    key: \"onMouseDrag\",\n    value: function onMouseDrag(event) {\n      if (event.event.button > 0) return; // only first mouse button\n      if (this.selectionRect) {\n        this.selectionRect.remove();\n      }\n      this.selectionRect = guides_rectSelect(event);\n    }\n  }, {\n    key: \"onMouseUpVector\",\n    value: function onMouseUpVector(event) {\n      if (event.event.button > 0) return; // only first mouse button\n      if (this.selectionRect) {\n        selection_processRectangularSelection(event, this.selectionRect, this.mode);\n        this.selectionRect.remove();\n        this.selectionRect = null;\n        this.setSelectedItems();\n      }\n    }\n  }, {\n    key: \"onMouseUpBitmap\",\n    value: function onMouseUpBitmap(event) {\n      if (event.event.button > 0) return; // only first mouse button\n      if (this.selectionRect) {\n        var rect = new paper_full_default.a.Rectangle({\n          from: new paper_full_default.a.Point(Math.max(0, Math.round(this.selectionRect.bounds.topLeft.x)), Math.max(0, Math.round(this.selectionRect.bounds.topLeft.y))),\n          to: new paper_full_default.a.Point(Math.min(ART_BOARD_WIDTH, Math.round(this.selectionRect.bounds.bottomRight.x)), Math.min(ART_BOARD_HEIGHT, Math.round(this.selectionRect.bounds.bottomRight.y)))\n        }); // Trim/tighten selection bounds inwards to only the opaque region, excluding transparent pixels\n        rect = bitmap_getHitBounds(getRaster(), rect);\n        if (rect.area) {\n          // Pull selected raster to active layer\n          var raster = getRaster().getSubRaster(rect);\n          raster.parent = paper_full_default.a.project.activeLayer;\n          raster.canvas.getContext('2d',{willReadFrequently:true}).imageSmoothingEnabled = false;\n          raster.selected = true; // Gather a bit of extra data so that we can avoid aliasing at edges\n          var expanded = getRaster().getSubRaster(rect.expand(4));\n          expanded.remove();\n          raster.data = {\n            expanded: expanded\n          }; // Clear area from raster layer\n          var context = getRaster().getContext(true\n          /* modify */\n          );\n          context.clearRect(rect.x, rect.y, rect.width, rect.height);\n          this.setSelectedItems();\n        } // Remove dotted rectangle\n        this.selectionRect.remove();\n        this.selectionRect = null;\n      }\n    }\n  }]);\n  return SelectionBoxTool;\n}();\n/* harmony default export */ var selection_box_tool = (selection_box_tool_SelectionBoxTool);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/helper/bit-tools/select-tool.js\nfunction select_tool_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { select_tool_typeof = function _typeof(obj) { return typeof obj; }; } else { select_tool_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return select_tool_typeof(obj); }\nfunction select_tool_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction select_tool_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction select_tool_createClass(Constructor, protoProps, staticProps) { if (protoProps) select_tool_defineProperties(Constructor.prototype, protoProps); if (staticProps) select_tool_defineProperties(Constructor, staticProps); return Constructor; }\nfunction select_tool_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) select_tool_setPrototypeOf(subClass, superClass); }\nfunction select_tool_setPrototypeOf(o, p) { select_tool_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return select_tool_setPrototypeOf(o, p); }\nfunction select_tool_createSuper(Derived) { var hasNativeReflectConstruct = select_tool_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = select_tool_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = select_tool_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return select_tool_possibleConstructorReturn(this, result); }; }\nfunction select_tool_possibleConstructorReturn(self, call) { if (call && (select_tool_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return select_tool_assertThisInitialized(self); }\nfunction select_tool_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction select_tool_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction select_tool_getPrototypeOf(o) { select_tool_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return select_tool_getPrototypeOf(o); }\n\n/**\n * paper.Tool that handles select mode in bitmap. This is made up of 2 subtools.\n * - The selection box tool is active when the user clicks an empty space and drags.\n *   It selects all items in the rectangle.\n * - The bounding box tool is active if the user clicks on a non-empty space. It handles\n *   reshaping the selection.\n */\nvar select_tool_SelectTool = function (_paper$Tool) {\n  select_tool_inherits(SelectTool, _paper$Tool);\n  var _super = select_tool_createSuper(SelectTool);\n  select_tool_createClass(SelectTool, null, [{\n    key: \"TOLERANCE\",\n    /** The distance within which mouse events count as a hit against an item */\n    get: function get() {\n      return 2;\n    }\n    /**\n     * @param {function} setSelectedItems Callback to set the set of selected items in the Redux state\n     * @param {function} clearSelectedItems Callback to clear the set of selected items in the Redux state\n     * @param {function} setCursor Callback to set the visible mouse cursor\n     * @param {!function} onUpdateImage A callback to call when the image visibly changes\n     */\n  }]);\n  function SelectTool(setSelectedItems, clearSelectedItems, setCursor, onUpdateImage) {\n    var _this;\n    select_tool_classCallCheck(this, SelectTool);\n    _this = _super.call(this);\n    _this.onUpdateImage = onUpdateImage;\n    _this.boundingBoxTool = new bounding_box_tool(Modes.BIT_SELECT, setSelectedItems, clearSelectedItems, setCursor, onUpdateImage);\n    var nudgeTool = new nudge_tool(Modes.BIT_SELECT, _this.boundingBoxTool, onUpdateImage);\n    _this.selectionBoxTool = new selection_box_tool(Modes.BIT_SELECT, setSelectedItems, clearSelectedItems);\n    _this.selectionBoxMode = false;\n    _this.selection = null;\n    _this.active = false; // We have to set these functions instead of just declaring them because\n    // paper.js tools hook up the listeners in the setter functions.\n    _this.onMouseDown = _this.handleMouseDown;\n    _this.onMouseDrag = _this.handleMouseDrag;\n    _this.onMouseMove = _this.handleMouseMove;\n    _this.onMouseUp = _this.handleMouseUp;\n    _this.onKeyUp = nudgeTool.onKeyUp;\n    _this.onKeyDown = nudgeTool.onKeyDown;\n    _this.boundingBoxTool.setSelectionBounds();\n    return _this;\n  }\n  /**\n   * Should be called if the selection changes to update the bounds of the bounding box.\n   * @param {Array<paper.Item>} selectedItems Array of selected items.\n   */\n  select_tool_createClass(SelectTool, [{\n    key: \"onSelectionChanged\",\n    value: function onSelectionChanged(selectedItems) {\n      this.boundingBoxTool.onSelectionChanged(selectedItems);\n      if (this.selection && this.selection.parent && !this.selection.selected) {\n        // Selection got deselected\n        this.commitSelection();\n      }\n      if ((!this.selection || !this.selection.parent) && selectedItems && selectedItems.length === 1 && selectedItems[0] instanceof paper_full_default.a.Raster) {\n        // Track the new active selection. This may happen via undo, paste, or drag to select.\n        this.selection = selectedItems[0];\n      }\n    }\n    /**\n     * Returns the hit options to use when conducting hit tests.\n     * @return {object} See paper.Item.hitTest for definition of options\n     */\n  }, {\n    key: \"getHitOptions\",\n    value: function getHitOptions() {\n      // Tolerance needs to be scaled when the view is zoomed in in order to represent the same\n      // distance for the user to move the mouse.\n      return {\n        segments: true,\n        stroke: true,\n        curves: true,\n        fill: true,\n        guide: false,\n        tolerance: SelectTool.TOLERANCE / paper_full_default.a.view.zoom,\n        match: function match(hitResult) {\n          // Don't match helper items, unless they are handles.\n          if (!hitResult.item.data || !hitResult.item.data.isHelperItem) return true;\n          return hitResult.item.data.isScaleHandle || hitResult.item.data.isRotHandle;\n        }\n      };\n    }\n  }, {\n    key: \"handleMouseDown\",\n    value: function handleMouseDown(event) {\n      if (event.event.button > 0) return; // only first mouse button\n      this.active = true; // If bounding box tool does not find an item that was hit, rasterize the old selection,\n      // then use selection box tool.\n      if (!this.boundingBoxTool.onMouseDown(event, event.modifiers.alt, event.modifiers.shift, false\n      /* doubleClicked */\n      , this.getHitOptions())) {\n        this.commitSelection();\n        this.selectionBoxMode = true;\n        this.selectionBoxTool.onMouseDown(event.modifiers.shift);\n      }\n    }\n  }, {\n    key: \"handleMouseDrag\",\n    value: function handleMouseDrag(event) {\n      if (event.event.button > 0 || !this.active) return; // only first mouse button\n      if (this.selectionBoxMode) {\n        this.selectionBoxTool.onMouseDrag(event);\n      } else {\n        this.boundingBoxTool.onMouseDrag(event);\n      }\n    }\n  }, {\n    key: \"handleMouseMove\",\n    value: function handleMouseMove(event) {\n      this.boundingBoxTool.onMouseMove(event, this.getHitOptions());\n    }\n  }, {\n    key: \"handleMouseUp\",\n    value: function handleMouseUp(event) {\n      if (event.event.button > 0 || !this.active) return; // only first mouse button\n      if (this.selectionBoxMode) {\n        this.selectionBoxTool.onMouseUpBitmap(event);\n      } else {\n        this.boundingBoxTool.onMouseUp(event);\n      }\n      this.selectionBoxMode = false;\n      this.active = false;\n    }\n  }, {\n    key: \"commitSelection\",\n    value: function commitSelection() {\n      if (!this.selection || !this.selection.parent) return;\n      commitSelectionToBitmap(this.selection, getRaster());\n      this.selection.remove();\n      this.selection = null;\n      this.onUpdateImage();\n    }\n  }, {\n    key: \"deactivateTool\",\n    value: function deactivateTool() {\n      this.commitSelection();\n      this.boundingBoxTool.deactivateTool();\n      this.boundingBoxTool = null;\n      this.selectionBoxTool = null;\n    }\n  }]);\n  return SelectTool;\n}(paper_full_default.a.Tool);\n/* harmony default export */ var select_tool = (select_tool_SelectTool);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/bit-select-mode/marquee.svg\nvar marquee = __webpack_require__(603);\nvar marquee_default = __webpack_require__.n(marquee);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/components/bit-select-mode/bit-select-mode.jsx\n\nvar bit_select_mode_BitSelectComponent = function BitSelectComponent(props) {\n  return react_default.a.createElement(tool_select_base_tool_select_base, {\n    imgDescriptor: lib_messages.select,\n    imgSrc: marquee_default.a,\n    isSelected: props.isSelected,\n    onMouseDown: props.onMouseDown\n  });\n};\nbit_select_mode_BitSelectComponent.propTypes = {\n  isSelected: prop_types_default.a.bool.isRequired,\n  onMouseDown: prop_types_default.a.func.isRequired\n};\n/* harmony default export */ var bit_select_mode = (bit_select_mode_BitSelectComponent);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/containers/bit-select-mode.jsx\nfunction bit_select_mode_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { bit_select_mode_typeof = function _typeof(obj) { return typeof obj; }; } else { bit_select_mode_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return bit_select_mode_typeof(obj); }\nfunction bit_select_mode_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction bit_select_mode_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction bit_select_mode_createClass(Constructor, protoProps, staticProps) { if (protoProps) bit_select_mode_defineProperties(Constructor.prototype, protoProps); if (staticProps) bit_select_mode_defineProperties(Constructor, staticProps); return Constructor; }\nfunction bit_select_mode_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) bit_select_mode_setPrototypeOf(subClass, superClass); }\nfunction bit_select_mode_setPrototypeOf(o, p) { bit_select_mode_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return bit_select_mode_setPrototypeOf(o, p); }\nfunction bit_select_mode_createSuper(Derived) { var hasNativeReflectConstruct = bit_select_mode_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = bit_select_mode_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = bit_select_mode_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return bit_select_mode_possibleConstructorReturn(this, result); }; }\nfunction bit_select_mode_possibleConstructorReturn(self, call) { if (call && (bit_select_mode_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return bit_select_mode_assertThisInitialized(self); }\nfunction bit_select_mode_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction bit_select_mode_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction bit_select_mode_getPrototypeOf(o) { bit_select_mode_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return bit_select_mode_getPrototypeOf(o); }\n\nvar bit_select_mode_BitSelectMode = function (_React$Component) {\n  bit_select_mode_inherits(BitSelectMode, _React$Component);\n  var _super = bit_select_mode_createSuper(BitSelectMode);\n  function BitSelectMode(props) {\n    var _this;\n    bit_select_mode_classCallCheck(this, BitSelectMode);\n    _this = _super.call(this, props);\n    lodash_bindall_default()(bit_select_mode_assertThisInitialized(_this), ['activateTool', 'deactivateTool']);\n    return _this;\n  }\n  bit_select_mode_createClass(BitSelectMode, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this.props.isSelectModeActive) {\n        this.activateTool(this.props);\n      }\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(nextProps) {\n      if (this.tool && nextProps.selectedItems !== this.props.selectedItems) {\n        this.tool.onSelectionChanged(nextProps.selectedItems);\n      }\n      if (nextProps.isSelectModeActive && !this.props.isSelectModeActive) {\n        this.activateTool();\n      } else if (!nextProps.isSelectModeActive && this.props.isSelectModeActive) {\n        this.deactivateTool();\n      }\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps) {\n      return nextProps.isSelectModeActive !== this.props.isSelectModeActive;\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.tool) {\n        this.deactivateTool();\n      }\n    }\n  }, {\n    key: \"activateTool\",\n    value: function activateTool() {\n      this.props.clearGradient();\n      this.tool = new select_tool(this.props.setSelectedItems, this.props.clearSelectedItems, this.props.setCursor, this.props.onUpdateImage);\n      this.tool.activate();\n    }\n  }, {\n    key: \"deactivateTool\",\n    value: function deactivateTool() {\n      this.tool.deactivateTool();\n      this.tool.remove();\n      this.tool = null;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return react_default.a.createElement(bit_select_mode, {\n        isSelected: this.props.isSelectModeActive,\n        onMouseDown: this.props.handleMouseDown\n      });\n    }\n  }]);\n  return BitSelectMode;\n}(react_default.a.Component);\nbit_select_mode_BitSelectMode.propTypes = {\n  clearGradient: prop_types_default.a.func.isRequired,\n  clearSelectedItems: prop_types_default.a.func.isRequired,\n  handleMouseDown: prop_types_default.a.func.isRequired,\n  isSelectModeActive: prop_types_default.a.bool.isRequired,\n  onUpdateImage: prop_types_default.a.func.isRequired,\n  selectedItems: prop_types_default.a.arrayOf(prop_types_default.a.instanceOf(paper_full_default.a.Item)),\n  setCursor: prop_types_default.a.func.isRequired,\n  setSelectedItems: prop_types_default.a.func.isRequired\n};\nvar bit_select_mode_mapStateToProps = function mapStateToProps(state) {\n  return {\n    isSelectModeActive: state.scratchPaint.mode === Modes.BIT_SELECT,\n    selectedItems: state.scratchPaint.selectedItems\n  };\n};\nvar bit_select_mode_mapDispatchToProps = function mapDispatchToProps(dispatch) {\n  return {\n    clearGradient: function clearGradient() {\n      dispatch(fill_style_clearFillGradient());\n    },\n    clearSelectedItems: function clearSelectedItems() {\n      dispatch(selected_items_clearSelectedItems());\n    },\n    setCursor: function setCursor(cursorType) {\n      dispatch(cursor_setCursor(cursorType));\n    },\n    setSelectedItems: function setSelectedItems() {\n      dispatch(selected_items_setSelectedItems(selection_getSelectedLeafItems()));\n    },\n    handleMouseDown: function handleMouseDown() {\n      dispatch(modes_changeMode(Modes.BIT_SELECT));\n    }\n  };\n};\n/* harmony default export */ var containers_bit_select_mode = (Object(es[\"b\" /* connect */])(bit_select_mode_mapStateToProps, bit_select_mode_mapDispatchToProps)(bit_select_mode_BitSelectMode));\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/box/box.jsx\nvar box = __webpack_require__(256);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/button-group/button-group.css\nvar button_group = __webpack_require__(604);\nvar button_group_default = __webpack_require__.n(button_group);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/components/button-group/button-group.jsx\n\nvar button_group_ButtonGroup = function ButtonGroup(props) {\n  return react_default.a.createElement(\"div\", {\n    className: classnames_default()(props.className, button_group_default.a.buttonGroup)\n  }, props.children);\n};\nbutton_group_ButtonGroup.propTypes = {\n  children: prop_types_default.a.node.isRequired,\n  className: prop_types_default.a.string\n};\n/* harmony default export */ var button_group_button_group = (button_group_ButtonGroup);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/helper/blob-tools/broad-brush-helper.js\nfunction broad_brush_helper_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = broad_brush_helper_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction broad_brush_helper_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return broad_brush_helper_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return broad_brush_helper_arrayLikeToArray(o, minLen); }\nfunction broad_brush_helper_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction broad_brush_helper_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction broad_brush_helper_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction broad_brush_helper_createClass(Constructor, protoProps, staticProps) { if (protoProps) broad_brush_helper_defineProperties(Constructor.prototype, protoProps); if (staticProps) broad_brush_helper_defineProperties(Constructor, staticProps); return Constructor; }\n// Broadbrush based on http://paperjs.org/tutorials/interaction/working-with-mouse-vectors/\n/**\n * Broad brush functions to add as listeners on the mouse. Call them when the corresponding mouse event happens\n * to get the broad brush behavior.\n *\n * Broad brush draws strokes by drawing points equidistant from the mouse event, perpendicular to the\n * direction of motion. Shortcomings are that this path can cross itself, and 180 degree turns result\n * in a flat edge.\n *\n * @param {!Tool} tool paper.js mouse object\n */\nvar broad_brush_helper_BroadBrushHelper = function () {\n  function BroadBrushHelper() {\n    broad_brush_helper_classCallCheck(this, BroadBrushHelper);\n    // Direction vector of the last mouse move\n    this.lastVec = null; // End point of the last mouse move\n    this.lastPoint = null; // The path of the brush stroke we are building\n    this.finalPath = null; // Number of points of finalPath that have already been processed\n    this.smoothed = 0; // Number of steps to wait before performing another amortized smooth\n    this.smoothingThreshold = 20; // Mouse moves since mouse down\n    this.steps = 0; // End caps round out corners and are not merged into the path until the end.\n    this.endCaps = [];\n  }\n  broad_brush_helper_createClass(BroadBrushHelper, [{\n    key: \"onBroadMouseDown\",\n    value: function onBroadMouseDown(event, tool, options) {\n      this.steps = 0;\n      this.smoothed = 0;\n      this.lastVec = null;\n      tool.minDistance = Math.min(5, Math.max(2 / paper_full_default.a.view.zoom, options.brushSize / 2));\n      tool.maxDistance = options.brushSize;\n      if (event.event.button > 0) return; // only first mouse button\n      this.finalPath = new paper_full_default.a.Path.Circle({\n        center: event.point,\n        radius: options.brushSize / 2\n      });\n      styleBlob(this.finalPath, options);\n      this.lastPoint = event.point;\n    }\n  }, {\n    key: \"onBroadMouseDrag\",\n    value: function onBroadMouseDrag(event, tool, options) {\n      this.steps++;\n      var step = event.delta.normalize(options.brushSize / 2); // Add an end cap if the mouse has changed direction very quickly\n      if (this.lastVec) {\n        var angle = this.lastVec.getDirectedAngle(step);\n        if (Math.abs(angle) > 126) {\n          // This will cause us to skip simplifying this sharp angle. Running simplify on\n          // sharp angles causes the stroke to blob outwards.\n          this.simplify(1);\n          this.smoothed++; // If the angle is large, the broad brush tends to leave behind a flat edge.\n          // This code makes a shape to fill in that flat edge with a rounded cap.\n          var circ = new paper_full_default.a.Path.Circle(this.lastPoint, options.brushSize / 2);\n          circ.fillColor = options.fillColor;\n          var rect = new paper_full_default.a.Path.Rectangle(this.lastPoint.subtract(new paper_full_default.a.Point(-options.brushSize / 2, 0)), this.lastPoint.subtract(new paper_full_default.a.Point(options.brushSize / 2, this.lastVec.length)));\n          rect.fillColor = options.fillColor;\n          rect.rotate(this.lastVec.angle - 90, this.lastPoint);\n          var rect2 = new paper_full_default.a.Path.Rectangle(event.point.subtract(new paper_full_default.a.Point(-options.brushSize / 2, 0)), event.point.subtract(new paper_full_default.a.Point(options.brushSize / 2, event.delta.length)));\n          rect2.fillColor = options.fillColor;\n          rect2.rotate(step.angle - 90, event.point);\n          this.endCaps.push(this.union(circ, this.union(rect, rect2)));\n        }\n      }\n      step.angle += 90; // Move the first point out away from the drag so that the end of the path is rounded\n      if (this.steps === 1) {\n        // Replace circle with path\n        this.finalPath.remove();\n        this.finalPath = new paper_full_default.a.Path();\n        var handleVec = event.delta.normalize(options.brushSize / 2);\n        this.finalPath.add(new paper_full_default.a.Segment(this.lastPoint.subtract(handleVec), handleVec.rotate(-90), handleVec.rotate(90)));\n        styleBlob(this.finalPath, options);\n        this.finalPath.insert(0, new paper_full_default.a.Segment(this.lastPoint.subtract(step)));\n        this.finalPath.add(new paper_full_default.a.Segment(this.lastPoint.add(step)));\n      } // Update angle of the last brush step's points to match the average angle of the last mouse vector and this\n      // mouse vector (aka the vertex normal).\n      if (this.lastVec) {\n        var lastNormal = this.lastVec.normalize(options.brushSize / 2).rotate(90);\n        var averageNormal = new paper_full_default.a.Point(lastNormal.x + step.x, lastNormal.y + step.y).normalize(options.brushSize / 2);\n        this.finalPath.segments[0].point = this.lastPoint.subtract(averageNormal);\n        this.finalPath.segments[this.finalPath.segments.length - 1].point = this.lastPoint.add(averageNormal);\n      }\n      this.finalPath.add(event.point.add(step));\n      this.finalPath.insert(0, event.point.subtract(step));\n      if (this.finalPath.segments.length > this.smoothed + this.smoothingThreshold * 2) {\n        this.simplify(1);\n      }\n      this.lastVec = event.delta;\n      this.lastPoint = event.point;\n    }\n    /**\n     * Simplify the path so that it looks almost the same while trying to have a reasonable number of handles.\n     * Without this, there would be 2 handles for every mouse move, which would make the path produced basically\n     * uneditable. This version of simplify keeps track of how much of the path has already been simplified to\n     * avoid repeating work.\n     * @param {number} threshold The simplify algorithm must try to stay within this distance of the actual line.\n     *     The algorithm will be faster and able to remove more points the higher this number is.\n     *     Note that 1 is about the lowest this algorithm can do (the result is about the same when 1 is\n     *     passed in as when 0 is passed in)\n     */\n  }, {\n    key: \"simplify\",\n    value: function simplify(threshold) {\n      // Length of the current path\n      var length = this.finalPath.segments.length; // Number of new points added to front and end of path since last simplify\n      var newPoints = Math.floor((length - this.smoothed) / 2) + 1; // Where to cut. Don't go past the rounded start of the line (so there's always a tempPathMid)\n      var firstCutoff = Math.min(newPoints + 1, Math.floor(length / 2));\n      var lastCutoff = Math.max(length - 1 - newPoints, Math.floor(length / 2) + 1);\n      if (firstCutoff <= 1 || lastCutoff >= length - 1) {\n        // Entire path is simplified already\n        return;\n      } // Cut the path into 3 segments: the 2 ends where the new points are, and the middle, which will be\n      // staying the same\n      var tempPath1 = new paper_full_default.a.Path(this.finalPath.segments.slice(1, firstCutoff));\n      var tempPathMid = new paper_full_default.a.Path(this.finalPath.segments.slice(firstCutoff, lastCutoff));\n      var tempPath2 = new paper_full_default.a.Path(this.finalPath.segments.slice(lastCutoff, length - 1)); // Run simplify on the new ends. We need to graft the old handles back onto the newly\n      // simplified paths, since simplify removes the in handle from the start of the path, and\n      // the out handle from the end of the path it's simplifying.\n      var oldPath1End = tempPath1.segments[tempPath1.segments.length - 1];\n      var oldPath2End = tempPath2.segments[0];\n      tempPath1.simplify(threshold);\n      tempPath2.simplify(threshold);\n      var newPath1End = tempPath1.segments[tempPath1.segments.length - 1];\n      var newPath2End = tempPath2.segments[0];\n      newPath1End.handleOut = oldPath1End.handleOut;\n      newPath2End.handleIn = oldPath2End.handleIn; // Delete the old contents of finalPath and replace it with the newly simplified segments, concatenated\n      this.finalPath.removeSegments(1, this.finalPath.segments.length - 1);\n      this.finalPath.insertSegments(1, tempPath1.segments.concat(tempPathMid.segments).concat(tempPath2.segments)); // Remove temp paths\n      tempPath1.remove();\n      tempPath2.remove();\n      tempPathMid.remove(); // Update how many points have been smoothed so far so that we don't redo work when\n      // simplify is called next time.\n      this.smoothed = Math.max(2, this.finalPath.segments.length);\n    }\n    /**\n     * Like paper.Path.unite, but it removes the original 2 paths\n     * @param {paper.Path} path1 to merge\n     * @param {paper.Path} path2 to merge\n     * @return {paper.Path} merged path. Original paths 1 and 2 will be removed from the view.\n     */\n  }, {\n    key: \"union\",\n    value: function union(path1, path2) {\n      var temp = path1.unite(path2);\n      path1.remove();\n      path2.remove();\n      return temp;\n    }\n  }, {\n    key: \"onBroadMouseUp\",\n    value: function onBroadMouseUp(event, tool, options) {\n      // If there was only a single click, draw a circle.\n      if (this.steps === 0) {\n        this.endCaps.length = 0;\n        return this.finalPath;\n      }\n      var delta = this.lastVec; // If the mouse up is at the same point as the mouse drag event then we need\n      // the second to last point to get the right direction vector for the end cap\n      if (!event.point.equals(this.lastPoint)) {\n        // The given event.delta is the difference between the mouse down coords and the mouse up coords,\n        // but we want the difference between the last mouse drag coords and the mouse up coords.\n        delta = event.point.subtract(this.lastPoint);\n        var step = delta.normalize(options.brushSize / 2);\n        step.angle += 90;\n        var top = event.point.add(step);\n        var bottom = event.point.subtract(step);\n        this.finalPath.add(top);\n        this.finalPath.insert(0, bottom);\n      } // Simplify before adding end cap so cap doesn't get warped\n      this.simplify(1);\n      var handleVec = delta.normalize(options.brushSize / 2);\n      this.finalPath.add(new paper_full_default.a.Segment(event.point.add(handleVec), handleVec.rotate(90), handleVec.rotate(-90)));\n      this.finalPath.closePath(); // Resolve self-crossings\n      var newPath = this.finalPath.resolveCrossings().reorient(true\n      /* nonZero */\n      , true\n      /* clockwise */\n      ).reduce({\n        simplify: true\n      });\n      if (newPath !== this.finalPath) {\n        newPath.copyAttributes(this.finalPath);\n        newPath.fillColor = this.finalPath.fillColor;\n        this.finalPath.remove();\n        this.finalPath = newPath;\n      } // Try to merge end caps\n      var _iterator = broad_brush_helper_createForOfIteratorHelper(this.endCaps),\n          _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var cap = _step.value;\n          var temp = this.union(this.finalPath, cap);\n          if (temp.area >= this.finalPath.area && !(temp instanceof paper_full_default.a.CompoundPath && !(this.finalPath instanceof paper_full_default.a.CompoundPath))) {\n            this.finalPath = temp;\n          } else {\n            // If the union of the two shapes is smaller than the original shape,\n            // or it caused the path to become a compound path,\n            // then there must have been a glitch with paperjs's unite function.\n            // In this case, skip merging that segment. It's not great, but it's\n            // better than losing the whole path for instance. (Unfortunately, this\n            // happens reasonably often to scribbles, and this code doesn't catch\n            // all of the failures.)\n            this.finalPath.insertAbove(temp);\n            temp.remove();\n            log.warn('Skipping a merge.');\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      this.endCaps.length = 0;\n      return this.finalPath;\n    }\n  }]);\n  return BroadBrushHelper;\n}();\n/* harmony default export */ var broad_brush_helper = (broad_brush_helper_BroadBrushHelper);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/helper/blob-tools/segment-brush-helper.js\nfunction segment_brush_helper_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction segment_brush_helper_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction segment_brush_helper_createClass(Constructor, protoProps, staticProps) { if (protoProps) segment_brush_helper_defineProperties(Constructor.prototype, protoProps); if (staticProps) segment_brush_helper_defineProperties(Constructor, staticProps); return Constructor; }\n/**\n * Segment brush functions to add as listeners on the mouse. Call them when the corresponding mouse event happens\n * to get the broad brush behavior.\n *\n * Segment brush draws by creating a rounded rectangle for each mouse move event and merging all of\n * those shapes. Unlike the broad brush, the resulting shape will not self-intersect and when you make\n * 180 degree turns, you will get a rounded point as expected. Shortcomings include that performance is\n * worse, especially as the number of segments to join increase, and that there are problems in paper.js\n * with union on shapes with curves, so that chunks of the union tend to disappear.\n * (https://github.com/paperjs/paper.js/issues/1321)\n *\n * @param {!Tool} tool paper.js mouse object\n */\nvar segment_brush_helper_SegmentBrushHelper = function () {\n  function SegmentBrushHelper() {\n    segment_brush_helper_classCallCheck(this, SegmentBrushHelper);\n    this.lastPoint = null;\n    this.finalPath = null;\n    this.firstCircle = null;\n  }\n  segment_brush_helper_createClass(SegmentBrushHelper, [{\n    key: \"onSegmentMouseDown\",\n    value: function onSegmentMouseDown(event, tool, options) {\n      if (event.event.button > 0) return; // only first mouse button\n      tool.minDistance = 2 / paper_full_default.a.view.zoom;\n      tool.maxDistance = options.brushSize;\n      this.firstCircle = new paper_full_default.a.Path.Circle({\n        center: event.point,\n        radius: options.brushSize / 2\n      });\n      this.finalPath = this.firstCircle;\n      styleBlob(this.finalPath, options);\n      this.lastPoint = event.point;\n    }\n  }, {\n    key: \"onSegmentMouseDrag\",\n    value: function onSegmentMouseDrag(event, tool, options) {\n      if (event.event.button > 0) return; // only first mouse button\n      var step = event.delta.normalize(options.brushSize / 2);\n      var handleVec = step.clone();\n      handleVec.length = options.brushSize / 2;\n      handleVec.angle += 90;\n      var path = new paper_full_default.a.Path();\n      styleBlob(path, options); // Add handles to round the end caps\n      path.add(new paper_full_default.a.Segment(this.lastPoint.subtract(step), handleVec.multiply(-1), handleVec));\n      step.angle += 90;\n      path.add(event.lastPoint.add(step));\n      path.insert(0, event.lastPoint.subtract(step));\n      path.add(event.point.add(step));\n      path.insert(0, event.point.subtract(step)); // Add end cap\n      step.angle -= 90;\n      path.add(new paper_full_default.a.Segment(event.point.add(step), handleVec, handleVec.multiply(-1)));\n      path.closed = true; // The unite function on curved paths does not always work (sometimes deletes half the path)\n      // so we have to flatten.\n      path.flatten(Math.min(5, options.brushSize / 5));\n      this.lastPoint = event.point;\n      var newPath = this.finalPath.unite(path);\n      path.remove();\n      this.finalPath.remove();\n      this.finalPath = newPath;\n    }\n  }, {\n    key: \"onSegmentMouseUp\",\n    value: function onSegmentMouseUp(event) {\n      if (event.event.button > 0) return; // only first mouse button\n      // TODO: This smoothing tends to cut off large portions of the path! Would like to eventually\n      // add back smoothing, maybe a custom implementation that only applies to a subset of the line?\n      // Smooth the path. Make it unclosed first because smoothing of closed\n      // paths tends to cut off the path.\n      if (this.finalPath.segments && this.finalPath.segments.length > 4) {\n        this.finalPath.closed = false;\n        this.finalPath.simplify(2);\n        this.finalPath.closed = true; // Merge again with the first point, since it gets distorted when we unclose the path.\n        var temp = this.finalPath.unite(this.firstCircle);\n        this.finalPath.remove();\n        this.finalPath = temp;\n      }\n      return this.finalPath;\n    }\n  }]);\n  return SegmentBrushHelper;\n}();\n/* harmony default export */ var segment_brush_helper = (segment_brush_helper_SegmentBrushHelper);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/helper/blob-tools/blob.js\nfunction blob_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = blob_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction blob_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return blob_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return blob_arrayLikeToArray(o, minLen); }\nfunction blob_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction blob_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\nfunction blob_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { blob_ownKeys(Object(source), true).forEach(function (key) { blob_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { blob_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\nfunction blob_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction blob_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction blob_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction blob_createClass(Constructor, protoProps, staticProps) { if (protoProps) blob_defineProperties(Constructor.prototype, protoProps); if (staticProps) blob_defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * Shared code for the brush and eraser mode. Adds functions on the paper tool object\n * to handle mouse events, which are delegated to broad-brush-helper and segment-brush-helper\n * based on the brushSize in the state.\n */\nvar blob_Blobbiness = function () {\n  blob_createClass(Blobbiness, null, [{\n    key: \"BROAD\",\n    get: function get() {\n      return 'broadbrush';\n    }\n  }, {\n    key: \"SEGMENT\",\n    get: function get() {\n      return 'segmentbrush';\n    } // If brush size >= threshold use segment brush, else use broadbrush\n    // Segment brush has performance issues at low threshold, but broad brush has weird corners\n    // which get more obvious the bigger it is\n  }, {\n    key: \"THRESHOLD\",\n    get: function get() {\n      return 30 / paper_full_default.a.view.zoom;\n    }\n    /**\n     * @param {function} onUpdateImage call when the drawing has changed to let listeners know\n     * @param {function} clearSelectedItems Callback to clear the set of selected items in the Redux state\n     */\n  }]);\n  function Blobbiness(onUpdateImage, clearSelectedItems) {\n    blob_classCallCheck(this, Blobbiness);\n    this.broadBrushHelper = new broad_brush_helper();\n    this.segmentBrushHelper = new segment_brush_helper();\n    this.onUpdateImage = onUpdateImage;\n    this.clearSelectedItems = clearSelectedItems; // The following are stored to check whether these have changed and the cursor preview needs to be redrawn.\n    this.strokeColor = null;\n    this.brushSize = null;\n    this.fillColor = null;\n  }\n  /**\n   * Set configuration options for a blob\n   * @param {!object} options Configuration\n   * @param {!number} options.brushSize Width of blob marking made by mouse\n   * @param {!boolean} options.isEraser Whether the stroke should be treated as an erase path. If false,\n   *     the stroke is an additive path.\n   * @param {?string} options.fillColor Color of the brush stroke.\n   * @param {?string} options.strokeColor Color of the brush outline.\n   * @param {?number} options.strokeWidth Width of the brush outline.\n   */\n  blob_createClass(Blobbiness, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      var oldFillColor = this.options ? this.options.fillColor : 'black';\n      var oldStrokeColor = this.options ? this.options.strokeColor : null;\n      var oldStrokeWidth = this.options ? this.options.strokeWidth : null; // If values are mixed, it means the color was set by a selection contained multiple values.\n      // In this case keep drawing with the previous values if any. (For stroke width, null indicates\n      // mixed, because stroke width is required to be a number)\n      this.options = blob_objectSpread(blob_objectSpread({}, options), {}, {\n        fillColor: options.fillColor === MIXED ? oldFillColor : options.fillColor,\n        strokeColor: options.strokeColor === MIXED ? oldStrokeColor : options.strokeColor,\n        strokeWidth: options.strokeWidth === null ? oldStrokeWidth : options.strokeWidth\n      });\n      this.resizeCursorIfNeeded();\n    }\n    /**\n     * Adds handlers on the mouse tool to draw blobs. Initialize with configuration options for a blob.\n     * @param {!object} options Configuration\n     * @param {!number} options.brushSize Width of blob marking made by mouse\n     * @param {!boolean} options.isEraser Whether the stroke should be treated as an erase path. If false,\n     *     the stroke is an additive path.\n     * @param {?string} options.fillColor Color of the brush stroke.\n     * @param {?string} options.strokeColor Color of the brush outline.\n     * @param {?number} options.strokeWidth Width of the brush outline.\n     */\n  }, {\n    key: \"activateTool\",\n    value: function activateTool(options) {\n      this.tool = new paper_full_default.a.Tool();\n      this.cursorPreviewLastPoint = new paper_full_default.a.Point(-10000, -10000);\n      this.setOptions(options);\n      this.tool.active = false;\n      this.tool.fixedDistance = 1;\n      var blob = this;\n      this.tool.onMouseMove = function (event) {\n        blob.resizeCursorIfNeeded(event.point);\n        styleCursorPreview(blob.cursorPreview, blob.options);\n        blob.cursorPreview.bringToFront();\n        blob.cursorPreview.position = event.point;\n      };\n      this.tool.onMouseDown = function (event) {\n        blob.resizeCursorIfNeeded(event.point);\n        if (event.event.button > 0) return; // only first mouse button\n        this.active = true;\n        if (blob.options.brushSize < Blobbiness.THRESHOLD) {\n          blob.brush = Blobbiness.BROAD;\n          blob.broadBrushHelper.onBroadMouseDown(event, blob.tool, blob.options);\n        } else {\n          blob.brush = Blobbiness.SEGMENT;\n          blob.segmentBrushHelper.onSegmentMouseDown(event, blob.tool, blob.options);\n        }\n        blob.cursorPreview.bringToFront();\n        blob.cursorPreview.position = event.point;\n      };\n      this.tool.onMouseDrag = function (event) {\n        if (event.event.button > 0 || !this.active) return; // only first mouse button\n        if (blob.brush === Blobbiness.BROAD) {\n          blob.broadBrushHelper.onBroadMouseDrag(event, blob.tool, blob.options);\n        } else if (blob.brush === Blobbiness.SEGMENT) {\n          blob.segmentBrushHelper.onSegmentMouseDrag(event, blob.tool, blob.options);\n        } else {\n          log.warn(\"Brush type does not exist: \".concat(blob.brush));\n        }\n        blob.cursorPreview.bringToFront();\n        blob.cursorPreview.position = event.point;\n      };\n      this.tool.onMouseUp = function (event) {\n        if (event.event.button > 0 || !this.active) return; // only first mouse button\n        var lastPath;\n        if (blob.brush === Blobbiness.BROAD) {\n          lastPath = blob.broadBrushHelper.onBroadMouseUp(event, blob.tool, blob.options);\n        } else if (blob.brush === Blobbiness.SEGMENT) {\n          lastPath = blob.segmentBrushHelper.onSegmentMouseUp(event, blob.tool, blob.options);\n        } else {\n          log.warn(\"Brush type does not exist: \".concat(blob.brush));\n        }\n        if (blob.options.isEraser) {\n          blob.mergeEraser(lastPath);\n        } else {\n          blob.mergeBrush(lastPath);\n        } // Remove cursor preview during snapshot, then bring it back\n        blob.cursorPreview.remove();\n        blob.onUpdateImage();\n        blob.cursorPreview.parent = getGuideLayer(); // Reset\n        blob.brush = null;\n        this.fixedDistance = 1;\n        this.active = false;\n      };\n      this.tool.activate();\n    }\n  }, {\n    key: \"resizeCursorIfNeeded\",\n    value: function resizeCursorIfNeeded(point) {\n      if (!this.options) {\n        return;\n      } // The cursor preview was unattached from the view by an outside process,\n      // such as changing costumes or undo.\n      if (this.cursorPreview && !this.cursorPreview.parent) {\n        this.cursorPreview = null;\n      }\n      if (this.cursorPreview && this.brushSize === this.options.brushSize && this.fillColor === this.options.fillColor && this.strokeColor === this.options.strokeColor && this.cursorPreviewLastPoint.equals(point)) {\n        return;\n      }\n      if (typeof point !== 'undefined') {\n        this.cursorPreviewLastPoint = point;\n      }\n      if (!this.cursorPreview) {\n        this.cursorPreview = new paper_full_default.a.Shape.Ellipse({\n          point: this.cursorPreviewLastPoint,\n          size: this.options.brushSize / 2\n        });\n        this.cursorPreview.parent = getGuideLayer();\n        this.cursorPreview.data.isHelperItem = true;\n        layer_setGuideItem(this.cursorPreview);\n      }\n      this.cursorPreview.position = this.cursorPreviewLastPoint;\n      this.cursorPreview.radius = this.options.brushSize / 2;\n      this.brushSize = this.options.brushSize;\n      this.fillColor = this.options.fillColor;\n      this.strokeColor = this.options.strokeColor;\n      styleCursorPreview(this.cursorPreview, this.options);\n    }\n  }, {\n    key: \"mergeBrush\",\n    value: function mergeBrush(lastPath) {\n      var blob = this; // Get all path items to merge with\n      var paths = selection_getItems({\n        match: function match(item) {\n          return blob.isMergeable(lastPath, item) && item.parent instanceof paper_full_default.a.Layer; // don't merge with nested in group\n        }\n      });\n      var mergedPath = lastPath;\n      var i; // Move down z order to first overlapping item\n      for (i = paths.length - 1; i >= 0 && !this.touches(paths[i], lastPath); i--) {\n        continue;\n      }\n      var mergedPathIndex = i;\n      for (; i >= 0; i--) {\n        if (!this.touches(paths[i], lastPath)) {\n          continue;\n        }\n        if (!paths[i].getFillColor()) {// Ignore for merge. Paths without fill need to be in paths though,\n          // since they can visibly change if z order changes\n        } else if (this.colorMatch(paths[i], lastPath)) {\n          // Make sure the new shape isn't overlapped by anything that would\n          // visibly change if we change its z order\n          for (var j = mergedPathIndex; j > i; j--) {\n            if (this.touches(paths[j], paths[i])) {\n              continue;\n            }\n          } // Merge same fill color\n          var tempPath = mergedPath.unite(paths[i]);\n          tempPath.strokeColor = paths[i].strokeColor;\n          tempPath.strokeWidth = paths[i].strokeWidth;\n          if (mergedPath === lastPath) {\n            tempPath.insertAbove(paths[i]); // First intersected path determines z position of the new path\n          } else {\n            tempPath.insertAbove(mergedPath); // Rest of merges join z index of merged path\n            mergedPathIndex--; // Removed an item, so the merged path index decreases\n          }\n          mergedPath.remove();\n          mergedPath = tempPath;\n          paths[i].remove();\n          paths.splice(i, 1);\n        }\n      }\n    }\n  }, {\n    key: \"mergeEraser\",\n    value: function mergeEraser(lastPath) {\n      var blob = this; // Get all path items to merge with\n      // If there are selected items, try to erase from amongst those.\n      var items = selection_getItems({\n        match: function match(item) {\n          return item.selected && blob.isMergeable(lastPath, item) && blob.touches(lastPath, item) && // Boolean operations will produce incorrect results if directly applied to compound path children,\n          // so exclude those. Their parents are also selected so boolean operations will apply to them.\n          !isCompoundPathChild(item);\n        },\n        class: paper_full_default.a.PathItem\n      }); // Eraser didn't hit anything selected, so assume they meant to erase from all instead of from subset\n      // and deselect the selection\n      if (items.length === 0) {\n        selection_clearSelection(this.clearSelectedItems);\n        items = selection_getItems({\n          match: function match(item) {\n            return blob.isMergeable(lastPath, item) && blob.touches(lastPath, item) && !isCompoundPathChild(item);\n          },\n          class: paper_full_default.a.PathItem\n        });\n      }\n      for (var i = items.length - 1; i >= 0; i--) {\n        if (items[i] instanceof paper_full_default.a.Path && (!items[i].fillColor || items[i].fillColor._alpha === 0)) {\n          // Gather path segments\n          var _subpaths = [];\n          var firstSeg = items[i];\n          var intersections = firstSeg.getIntersections(lastPath);\n          for (var j = intersections.length - 1; j >= 0; j--) {\n            var split = firstSeg.splitAt(intersections[j]);\n            if (split) {\n              split.insertAbove(firstSeg);\n              _subpaths.push(split);\n            }\n          }\n          _subpaths.push(firstSeg); // Remove the ones that are within the eraser stroke boundary\n          for (var k = _subpaths.length - 1; k >= 0; k--) {\n            var segMidpoint = _subpaths[k].getLocationAt(_subpaths[k].length / 2).point;\n            if (lastPath.contains(segMidpoint)) {\n              _subpaths[k].remove();\n              _subpaths.splice(k, 1);\n            }\n          }\n          lastPath.remove();\n          continue;\n        } // Erase\n        var newPath = items[i].subtract(lastPath);\n        newPath.insertBelow(items[i]); // Gather path segments\n        var subpaths = [];\n        if (items[i] instanceof paper_full_default.a.Path && !items[i].closed) {\n          var _firstSeg = items[i].clone();\n          var _intersections = _firstSeg.getIntersections(lastPath); // keep first and last segments\n          for (var _j = _intersections.length - 1; _j >= 0; _j--) {\n            var _split = _firstSeg.splitAt(_intersections[_j]);\n            _split.insertAbove(_firstSeg);\n            subpaths.push(_split);\n          }\n          subpaths.push(_firstSeg);\n        } // Remove the ones that are within the eraser stroke boundary, or are already part of new path.\n        // This way subpaths only remain if they didn't get turned into a shape by subtract.\n        for (var _k = subpaths.length - 1; _k >= 0; _k--) {\n          var _segMidpoint = subpaths[_k].getLocationAt(subpaths[_k].length / 2).point;\n          if (lastPath.contains(_segMidpoint) || newPath.contains(_segMidpoint)) {\n            subpaths[_k].remove();\n            subpaths.splice(_k, 1);\n          }\n        }\n        if (newPath.children) {\n          this.separateCompoundPath(newPath);\n          newPath.remove();\n        }\n        items[i].remove();\n      }\n      lastPath.remove();\n    }\n  }, {\n    key: \"separateCompoundPath\",\n    value: function separateCompoundPath(compoundPath) {\n      if (!compoundPath.isClockwise()) {\n        compoundPath.reverse();\n      } // Divide topologically separate shapes into their own compound paths, instead of\n      // everything being stuck together.\n      var clockwiseChildren = [];\n      var ccwChildren = [];\n      for (var j = compoundPath.children.length - 1; j >= 0; j--) {\n        var child = compoundPath.children[j];\n        if (child.isClockwise()) {\n          clockwiseChildren.push(child);\n        } else {\n          ccwChildren.push(child);\n        }\n      } // Sort by area smallest to largest\n      clockwiseChildren.sort(function (a, b) {\n        return a.area - b.area;\n      });\n      ccwChildren.sort(function (a, b) {\n        return Math.abs(a.area) - Math.abs(b.area);\n      }); // Go smallest to largest non-hole, so larger non-holes don't get the smaller pieces' holes\n      for (var _j2 = 0; _j2 < clockwiseChildren.length; _j2++) {\n        var cw = clockwiseChildren[_j2];\n        cw.copyAttributes(compoundPath);\n        cw.fillColor = compoundPath.fillColor;\n        cw.strokeColor = compoundPath.strokeColor;\n        cw.strokeWidth = compoundPath.strokeWidth;\n        cw.insertAbove(compoundPath); // Go backward since we are deleting elements. Backwards is largest to smallest hole.\n        var newCw = cw;\n        for (var k = ccwChildren.length - 1; k >= 0; k--) {\n          var ccw = ccwChildren[k];\n          if (this.firstEnclosesSecond(cw, ccw)) {\n            var temp = newCw.subtract(ccw);\n            temp.insertAbove(compoundPath);\n            newCw.remove();\n            newCw = temp;\n            ccw.remove();\n            ccwChildren.splice(k, 1);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"colorMatch\",\n    value: function colorMatch(existingPath, addedPath) {\n      // Note: transparent fill colors do notdetect as touching\n      return existingPath.getFillColor().equals(addedPath.getFillColor()) && (addedPath.getStrokeColor() === existingPath.getStrokeColor() || // both null\n      addedPath.getStrokeColor() && addedPath.getStrokeColor().equals(existingPath.getStrokeColor())) && addedPath.getStrokeWidth() === existingPath.getStrokeWidth() && this.touches(existingPath, addedPath);\n    }\n  }, {\n    key: \"touches\",\n    value: function touches(path1, path2) {\n      // Two shapes are touching if their paths intersect\n      if (path1 && path2 && path1.intersects(path2)) {\n        return true;\n      }\n      return this.firstEnclosesSecond(path1, path2) || this.firstEnclosesSecond(path2, path1);\n    }\n  }, {\n    key: \"firstEnclosesSecond\",\n    value: function firstEnclosesSecond(path1, path2) {\n      // Two shapes are also touching if one is completely inside the other\n      if (path1 && path2 && path2.firstSegment && path2.firstSegment.point && path1.hitTest(path2.firstSegment.point)) {\n        return true;\n      } // TODO: clean up these no point paths\n      return false;\n    }\n  }, {\n    key: \"matchesAnyChild\",\n    value: function matchesAnyChild(group, path) {\n      var _iterator = blob_createForOfIteratorHelper(group.children),\n          _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var child = _step.value;\n          if (child.children && this.matchesAnyChild(path, child)) {\n            return true;\n          }\n          if (path === child) {\n            return true;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return false;\n    }\n  }, {\n    key: \"isMergeable\",\n    value: function isMergeable(newPath, existingPath) {\n      // Path or compound path\n      if (!(existingPath instanceof paper_full_default.a.PathItem)) {\n        return;\n      }\n      if (newPath.children) {\n        if (this.matchesAnyChild(newPath, existingPath)) {\n          // Don't merge with children of self\n          return false;\n        }\n      }\n      return existingPath !== newPath; // don't merge with self\n    }\n  }, {\n    key: \"deactivateTool\",\n    value: function deactivateTool() {\n      if (this.cursorPreview) {\n        this.cursorPreview.remove();\n        this.cursorPreview = null;\n      }\n      this.tool.remove();\n      this.tool = null;\n    }\n  }]);\n  return Blobbiness;\n}();\n/* harmony default export */ var blob_tools_blob = (blob_Blobbiness);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/brush-mode/brush.svg\nvar brush_mode_brush = __webpack_require__(257);\nvar brush_mode_brush_default = __webpack_require__.n(brush_mode_brush);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/components/brush-mode/brush-mode.jsx\n\nvar brush_mode_BrushModeComponent = function BrushModeComponent(props) {\n  return react_default.a.createElement(tool_select_base_tool_select_base, {\n    imgDescriptor: lib_messages.brush,\n    imgSrc: brush_mode_brush_default.a,\n    isSelected: props.isSelected,\n    onMouseDown: props.onMouseDown\n  });\n};\nbrush_mode_BrushModeComponent.propTypes = {\n  isSelected: prop_types_default.a.bool.isRequired,\n  onMouseDown: prop_types_default.a.func.isRequired\n};\n/* harmony default export */ var brush_mode = (brush_mode_BrushModeComponent);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/containers/brush-mode.jsx\nfunction brush_mode_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { brush_mode_typeof = function _typeof(obj) { return typeof obj; }; } else { brush_mode_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return brush_mode_typeof(obj); }\nfunction brush_mode_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\nfunction brush_mode_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { brush_mode_ownKeys(Object(source), true).forEach(function (key) { brush_mode_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { brush_mode_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\nfunction brush_mode_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction brush_mode_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction brush_mode_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction brush_mode_createClass(Constructor, protoProps, staticProps) { if (protoProps) brush_mode_defineProperties(Constructor.prototype, protoProps); if (staticProps) brush_mode_defineProperties(Constructor, staticProps); return Constructor; }\nfunction brush_mode_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) brush_mode_setPrototypeOf(subClass, superClass); }\nfunction brush_mode_setPrototypeOf(o, p) { brush_mode_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return brush_mode_setPrototypeOf(o, p); }\nfunction brush_mode_createSuper(Derived) { var hasNativeReflectConstruct = brush_mode_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = brush_mode_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = brush_mode_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return brush_mode_possibleConstructorReturn(this, result); }; }\nfunction brush_mode_possibleConstructorReturn(self, call) { if (call && (brush_mode_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return brush_mode_assertThisInitialized(self); }\nfunction brush_mode_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction brush_mode_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction brush_mode_getPrototypeOf(o) { brush_mode_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return brush_mode_getPrototypeOf(o); }\n\nvar brush_mode_BrushMode = function (_React$Component) {\n  brush_mode_inherits(BrushMode, _React$Component);\n  var _super = brush_mode_createSuper(BrushMode);\n  function BrushMode(props) {\n    var _this;\n    brush_mode_classCallCheck(this, BrushMode);\n    _this = _super.call(this, props);\n    lodash_bindall_default()(brush_mode_assertThisInitialized(_this), ['activateTool', 'deactivateTool']);\n    _this.blob = new blob_tools_blob(_this.props.onUpdateImage, _this.props.clearSelectedItems);\n    return _this;\n  }\n  brush_mode_createClass(BrushMode, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this.props.isBrushModeActive) {\n        this.activateTool(this.props);\n      }\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(nextProps) {\n      if (nextProps.isBrushModeActive && !this.props.isBrushModeActive) {\n        this.activateTool();\n      } else if (!nextProps.isBrushModeActive && this.props.isBrushModeActive) {\n        this.deactivateTool();\n      } else if (nextProps.isBrushModeActive && this.props.isBrushModeActive) {\n        var _nextProps$colorState = nextProps.colorState,\n            fillColor = _nextProps$colorState.fillColor,\n            strokeColor = _nextProps$colorState.strokeColor,\n            strokeWidth = _nextProps$colorState.strokeWidth;\n        this.blob.setOptions(brush_mode_objectSpread({\n          isEraser: false,\n          fillColor: fillColor.primary,\n          strokeColor: strokeColor.primary,\n          strokeWidth: strokeWidth\n        }, nextProps.brushModeState));\n      }\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps) {\n      return nextProps.isBrushModeActive !== this.props.isBrushModeActive;\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.blob.tool) {\n        this.deactivateTool();\n      }\n    }\n  }, {\n    key: \"activateTool\",\n    value: function activateTool() {\n      // TODO: Instead of clearing selection, consider a kind of \"draw inside\"\n      // analogous to how selection works with eraser\n      selection_clearSelection(this.props.clearSelectedItems);\n      this.props.clearGradient(); // Force the default brush color if fill is MIXED or transparent\n      var fillColor = this.props.colorState.fillColor.primary;\n      if (fillColor === MIXED || fillColor === null) {\n        this.props.onChangeFillColor(DEFAULT_COLOR);\n      }\n      this.blob.activateTool(brush_mode_objectSpread(brush_mode_objectSpread({\n        isEraser: false\n      }, this.props.colorState), this.props.brushModeState));\n    }\n  }, {\n    key: \"deactivateTool\",\n    value: function deactivateTool() {\n      this.blob.deactivateTool();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return react_default.a.createElement(brush_mode, {\n        isSelected: this.props.isBrushModeActive,\n        onMouseDown: this.props.handleMouseDown\n      });\n    }\n  }]);\n  return BrushMode;\n}(react_default.a.Component);\nbrush_mode_BrushMode.propTypes = {\n  brushModeState: prop_types_default.a.shape({\n    brushSize: prop_types_default.a.number.isRequired\n  }),\n  clearGradient: prop_types_default.a.func.isRequired,\n  clearSelectedItems: prop_types_default.a.func.isRequired,\n  colorState: prop_types_default.a.shape({\n    fillColor: color_style_proptype,\n    strokeColor: color_style_proptype,\n    strokeWidth: prop_types_default.a.number\n  }).isRequired,\n  handleMouseDown: prop_types_default.a.func.isRequired,\n  isBrushModeActive: prop_types_default.a.bool.isRequired,\n  onChangeFillColor: prop_types_default.a.func.isRequired,\n  onUpdateImage: prop_types_default.a.func.isRequired\n};\nvar brush_mode_mapStateToProps = function mapStateToProps(state) {\n  return {\n    brushModeState: state.scratchPaint.brushMode,\n    colorState: state.scratchPaint.color,\n    isBrushModeActive: state.scratchPaint.mode === Modes.BRUSH\n  };\n};\nvar brush_mode_mapDispatchToProps = function mapDispatchToProps(dispatch) {\n  return {\n    clearSelectedItems: function clearSelectedItems() {\n      dispatch(selected_items_clearSelectedItems());\n    },\n    clearGradient: function clearGradient() {\n      dispatch(fill_style_clearFillGradient());\n    },\n    handleMouseDown: function handleMouseDown() {\n      dispatch(modes_changeMode(Modes.BRUSH));\n    },\n    onChangeFillColor: function onChangeFillColor(fillColor) {\n      dispatch(changeFillColor(fillColor));\n    }\n  };\n};\n/* harmony default export */ var containers_brush_mode = (Object(es[\"b\" /* connect */])(brush_mode_mapStateToProps, brush_mode_mapDispatchToProps)(brush_mode_BrushMode));\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/reducers/eraser-mode.js\nvar CHANGE_ERASER_SIZE = 'scratch-paint/eraser-mode/CHANGE_ERASER_SIZE';\nvar eraser_mode_initialState = {\n  brushSize: 40\n};\nvar eraser_mode_reducer = function reducer(state, action) {\n  if (typeof state === 'undefined') state = eraser_mode_initialState;\n  switch (action.type) {\n    case CHANGE_ERASER_SIZE:\n      if (isNaN(action.brushSize)) {\n        log.warn(\"Invalid brush size: \".concat(action.brushSize));\n        return state;\n      }\n      return {\n        brushSize: Math.max(1, action.brushSize)\n      };\n    default:\n      return state;\n  }\n}; // Action creators ==================================\nvar eraser_mode_changeBrushSize = function changeBrushSize(brushSize) {\n  return {\n    type: CHANGE_ERASER_SIZE,\n    brushSize: brushSize\n  };\n};\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/eraser-mode/eraser.svg\nvar eraser_mode_eraser = __webpack_require__(258);\nvar eraser_mode_eraser_default = __webpack_require__.n(eraser_mode_eraser);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/components/eraser-mode/eraser-mode.jsx\n\nvar eraser_mode_EraserModeComponent = function EraserModeComponent(props) {\n  return react_default.a.createElement(tool_select_base_tool_select_base, {\n    imgDescriptor: lib_messages.eraser,\n    imgSrc: eraser_mode_eraser_default.a,\n    isSelected: props.isSelected,\n    onMouseDown: props.onMouseDown\n  });\n};\neraser_mode_EraserModeComponent.propTypes = {\n  isSelected: prop_types_default.a.bool.isRequired,\n  onMouseDown: prop_types_default.a.func.isRequired\n};\n/* harmony default export */ var eraser_mode = (eraser_mode_EraserModeComponent);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/containers/eraser-mode.jsx\nfunction eraser_mode_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { eraser_mode_typeof = function _typeof(obj) { return typeof obj; }; } else { eraser_mode_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return eraser_mode_typeof(obj); }\nfunction eraser_mode_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\nfunction eraser_mode_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { eraser_mode_ownKeys(Object(source), true).forEach(function (key) { eraser_mode_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { eraser_mode_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\nfunction eraser_mode_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction eraser_mode_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction eraser_mode_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction eraser_mode_createClass(Constructor, protoProps, staticProps) { if (protoProps) eraser_mode_defineProperties(Constructor.prototype, protoProps); if (staticProps) eraser_mode_defineProperties(Constructor, staticProps); return Constructor; }\nfunction eraser_mode_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) eraser_mode_setPrototypeOf(subClass, superClass); }\nfunction eraser_mode_setPrototypeOf(o, p) { eraser_mode_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return eraser_mode_setPrototypeOf(o, p); }\nfunction eraser_mode_createSuper(Derived) { var hasNativeReflectConstruct = eraser_mode_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = eraser_mode_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = eraser_mode_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return eraser_mode_possibleConstructorReturn(this, result); }; }\nfunction eraser_mode_possibleConstructorReturn(self, call) { if (call && (eraser_mode_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return eraser_mode_assertThisInitialized(self); }\nfunction eraser_mode_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction eraser_mode_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction eraser_mode_getPrototypeOf(o) { eraser_mode_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return eraser_mode_getPrototypeOf(o); }\n\nvar eraser_mode_EraserMode = function (_React$Component) {\n  eraser_mode_inherits(EraserMode, _React$Component);\n  var _super = eraser_mode_createSuper(EraserMode);\n  function EraserMode(props) {\n    var _this;\n    eraser_mode_classCallCheck(this, EraserMode);\n    _this = _super.call(this, props);\n    lodash_bindall_default()(eraser_mode_assertThisInitialized(_this), ['activateTool', 'deactivateTool']);\n    _this.blob = new blob_tools_blob(_this.props.onUpdateImage, _this.props.clearSelectedItems);\n    return _this;\n  }\n  eraser_mode_createClass(EraserMode, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this.props.isEraserModeActive) {\n        this.activateTool();\n      }\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(nextProps) {\n      if (nextProps.isEraserModeActive && !this.props.isEraserModeActive) {\n        this.activateTool();\n      } else if (!nextProps.isEraserModeActive && this.props.isEraserModeActive) {\n        this.deactivateTool();\n      } else if (nextProps.isEraserModeActive && this.props.isEraserModeActive) {\n        this.blob.setOptions(eraser_mode_objectSpread({\n          isEraser: true\n        }, nextProps.eraserModeState));\n      }\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps) {\n      return nextProps.isEraserModeActive !== this.props.isEraserModeActive;\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.blob.tool) {\n        this.deactivateTool();\n      }\n    }\n  }, {\n    key: \"activateTool\",\n    value: function activateTool() {\n      this.blob.activateTool(eraser_mode_objectSpread({\n        isEraser: true\n      }, this.props.eraserModeState));\n    }\n  }, {\n    key: \"deactivateTool\",\n    value: function deactivateTool() {\n      this.blob.deactivateTool();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return react_default.a.createElement(eraser_mode, {\n        isSelected: this.props.isEraserModeActive,\n        onMouseDown: this.props.handleMouseDown\n      });\n    }\n  }]);\n  return EraserMode;\n}(react_default.a.Component);\neraser_mode_EraserMode.propTypes = {\n  clearSelectedItems: prop_types_default.a.func.isRequired,\n  eraserModeState: prop_types_default.a.shape({\n    brushSize: prop_types_default.a.number.isRequired\n  }),\n  handleMouseDown: prop_types_default.a.func.isRequired,\n  isEraserModeActive: prop_types_default.a.bool.isRequired,\n  onUpdateImage: prop_types_default.a.func.isRequired\n};\nvar eraser_mode_mapStateToProps = function mapStateToProps(state) {\n  return {\n    eraserModeState: state.scratchPaint.eraserMode,\n    isEraserModeActive: state.scratchPaint.mode === Modes.ERASER\n  };\n};\nvar eraser_mode_mapDispatchToProps = function mapDispatchToProps(dispatch) {\n  return {\n    clearSelectedItems: function clearSelectedItems() {\n      dispatch(selected_items_clearSelectedItems());\n    },\n    changeBrushSize: function changeBrushSize(brushSize) {\n      dispatch(eraser_mode_changeBrushSize(brushSize));\n    },\n    handleMouseDown: function handleMouseDown() {\n      dispatch(modes_changeMode(Modes.ERASER));\n    }\n  };\n};\n/* harmony default export */ var containers_eraser_mode = (Object(es[\"b\" /* connect */])(eraser_mode_mapStateToProps, eraser_mode_mapDispatchToProps)(eraser_mode_EraserMode));\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/reducers/color-index.js\nvar CHANGE_COLOR_INDEX = 'scratch-paint/color-index/CHANGE_COLOR_INDEX';\nvar color_index_initialState = 0;\nvar color_index_reducer = function reducer(state, action) {\n  if (typeof state === 'undefined') state = color_index_initialState;\n  switch (action.type) {\n    case CHANGE_COLOR_INDEX:\n      if (action.index !== 1 && action.index !== 0) {\n        log.warn(\"Invalid color index: \".concat(action.index));\n        return state;\n      }\n      return action.index;\n    case CHANGE_FILL_GRADIENT_TYPE:\n      if (action.gradientType === gradient_types.SOLID) return 0;\n    /* falls through */\n    default:\n      return state;\n  }\n}; // Action creators ==================================\nvar changeColorIndex = function changeColorIndex(index) {\n  return {\n    type: CHANGE_COLOR_INDEX,\n    index: index\n  };\n};\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/reducers/modals.js\nvar _initialState;\nfunction modals_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nvar OPEN_MODAL = 'scratch-paint/modals/OPEN_MODAL';\nvar CLOSE_MODAL = 'scratch-paint/modals/CLOSE_MODAL';\nvar MODAL_FILL_COLOR = 'fillColor';\nvar MODAL_STROKE_COLOR = 'strokeColor';\nvar modals_initialState = (_initialState = {}, modals_defineProperty(_initialState, MODAL_FILL_COLOR, false), modals_defineProperty(_initialState, MODAL_STROKE_COLOR, false), _initialState);\nvar modals_reducer = function reducer(state, action) {\n  if (typeof state === 'undefined') state = modals_initialState;\n  switch (action.type) {\n    case OPEN_MODAL:\n      return Object.assign({}, modals_initialState, modals_defineProperty({}, action.modal, true));\n    case CLOSE_MODAL:\n      return Object.assign({}, modals_initialState, modals_defineProperty({}, action.modal, false));\n    default:\n      return state;\n  }\n};\nvar openModal = function openModal(modal) {\n  return {\n    type: OPEN_MODAL,\n    modal: modal\n  };\n};\nvar closeModal = function closeModal(modal) {\n  return {\n    type: CLOSE_MODAL,\n    modal: modal\n  };\n}; // Action creators ==================================\nvar openFillColor = function openFillColor() {\n  return openModal(MODAL_FILL_COLOR);\n};\nvar openStrokeColor = function openStrokeColor() {\n  return openModal(MODAL_STROKE_COLOR);\n};\nvar closeFillColor = function closeFillColor() {\n  return closeModal(MODAL_FILL_COLOR);\n};\nvar closeStrokeColor = function closeStrokeColor() {\n  return closeModal(MODAL_STROKE_COLOR);\n};\n// EXTERNAL MODULE: ./node_modules/parse-color/index.js\nvar parse_color = __webpack_require__(87);\nvar parse_color_default = __webpack_require__.n(parse_color);\n// EXTERNAL MODULE: ./node_modules/react-popover/index.js\nvar react_popover = __webpack_require__(164);\nvar react_popover_default = __webpack_require__.n(react_popover);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/color-button/no-fill.svg\nvar no_fill = __webpack_require__(170);\nvar no_fill_default = __webpack_require__.n(no_fill);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/color-button/mixed-fill.svg\nvar mixed_fill = __webpack_require__(202);\nvar mixed_fill_default = __webpack_require__.n(mixed_fill);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/color-button/color-button.css\nvar color_button = __webpack_require__(148);\nvar color_button_default = __webpack_require__.n(color_button);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/components/color-button/color-button.jsx\nfunction color_button_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar color_button_colorToBackground = function colorToBackground(color, color2, gradientType) {\n  if (color === MIXED || gradientType !== gradient_types.SOLID && color2 === MIXED) return 'white';\n  if (color === null) color = 'white';\n  if (color2 === null) color2 = 'white';\n  switch (gradientType) {\n    case gradient_types.SOLID:\n      return color;\n    case gradient_types.HORIZONTAL:\n      return \"linear-gradient(to right, \".concat(color, \", \").concat(color2, \")\");\n    case gradient_types.VERTICAL:\n      return \"linear-gradient(\".concat(color, \", \").concat(color2, \")\");\n    case gradient_types.RADIAL:\n      return \"radial-gradient(\".concat(color, \", \").concat(color2, \")\");\n    default:\n      log.error(\"Unrecognized gradient type: \".concat(gradientType));\n  }\n};\nvar color_button_ColorButtonComponent = function ColorButtonComponent(props) {\n  return react_default.a.createElement(\"div\", {\n    className: color_button_default.a.colorButton,\n    onClick: props.onClick\n  }, react_default.a.createElement(\"div\", {\n    className: classnames_default()(color_button_default.a.colorButtonSwatch, color_button_defineProperty({}, color_button_default.a.outlineSwatch, props.outline && !(props.color === MIXED))),\n    style: {\n      background: color_button_colorToBackground(props.color, props.color2, props.gradientType)\n    }\n  }, props.color === null && (props.gradientType === gradient_types.SOLID || props.color2 === null) ? react_default.a.createElement(\"img\", {\n    className: color_button_default.a.swatchIcon,\n    draggable: false,\n    src: no_fill_default.a\n  }) : props.color === MIXED || props.gradientType !== gradient_types.SOLID && props.color2 === MIXED ? react_default.a.createElement(\"img\", {\n    className: color_button_default.a.swatchIcon,\n    draggable: false,\n    src: mixed_fill_default.a\n  }) : null), react_default.a.createElement(\"div\", {\n    className: color_button_default.a.colorButtonArrow\n  }, \"\\u25BE\"));\n};\ncolor_button_ColorButtonComponent.propTypes = {\n  color: prop_types_default.a.string,\n  color2: prop_types_default.a.string,\n  gradientType: prop_types_default.a.oneOf(Object.keys(gradient_types)).isRequired,\n  onClick: prop_types_default.a.func.isRequired,\n  outline: prop_types_default.a.bool.isRequired\n};\ncolor_button_ColorButtonComponent.defaultProps = {\n  outline: false\n};\n/* harmony default export */ var color_button_color_button = (color_button_ColorButtonComponent);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/forms/slider.css\nvar slider = __webpack_require__(278);\nvar slider_default = __webpack_require__.n(slider);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/components/forms/slider.jsx\nfunction slider_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { slider_typeof = function _typeof(obj) { return typeof obj; }; } else { slider_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return slider_typeof(obj); }\nfunction slider_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction slider_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction slider_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction slider_createClass(Constructor, protoProps, staticProps) { if (protoProps) slider_defineProperties(Constructor.prototype, protoProps); if (staticProps) slider_defineProperties(Constructor, staticProps); return Constructor; }\nfunction slider_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) slider_setPrototypeOf(subClass, superClass); }\nfunction slider_setPrototypeOf(o, p) { slider_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return slider_setPrototypeOf(o, p); }\nfunction slider_createSuper(Derived) { var hasNativeReflectConstruct = slider_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = slider_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = slider_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return slider_possibleConstructorReturn(this, result); }; }\nfunction slider_possibleConstructorReturn(self, call) { if (call && (slider_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return slider_assertThisInitialized(self); }\nfunction slider_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction slider_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction slider_getPrototypeOf(o) { slider_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return slider_getPrototypeOf(o); }\n\nvar CONTAINER_WIDTH = 150;\nvar HANDLE_WIDTH = 26;\nvar slider_SliderComponent = function (_React$Component) {\n  slider_inherits(SliderComponent, _React$Component);\n  var _super = slider_createSuper(SliderComponent);\n  function SliderComponent(props) {\n    var _this;\n    slider_classCallCheck(this, SliderComponent);\n    _this = _super.call(this, props);\n    lodash_bindall_default()(slider_assertThisInitialized(_this), ['handleMouseDown', 'handleMouseUp', 'handleMouseMove', 'handleClickBackground', 'setBackground', 'setHandle']); // Distance from the left edge of the slider handle to the mouse down/click event\n    _this.handleClickOffset = 0;\n    return _this;\n  }\n  slider_createClass(SliderComponent, [{\n    key: \"handleMouseDown\",\n    value: function handleMouseDown(event) {\n      document.addEventListener('mousemove', this.handleMouseMove);\n      document.addEventListener('mouseup', this.handleMouseUp);\n      document.addEventListener('touchmove', this.handleMouseMove, {\n        passive: false\n      });\n      document.addEventListener('touchend', this.handleMouseUp);\n      this.handleClickOffset = getEventXY(event).x - this.handle.getBoundingClientRect().left;\n    }\n  }, {\n    key: \"handleMouseUp\",\n    value: function handleMouseUp() {\n      document.removeEventListener('mousemove', this.handleMouseMove);\n      document.removeEventListener('mouseup', this.handleMouseUp);\n      document.removeEventListener('touchmove', this.handleMouseMove, {\n        passive: false\n      });\n      document.removeEventListener('touchend', this.handleMouseUp);\n    }\n  }, {\n    key: \"handleMouseMove\",\n    value: function handleMouseMove(event) {\n      event.preventDefault();\n      this.props.onChange(this.scaleMouseToSliderPosition(event));\n    }\n  }, {\n    key: \"handleClickBackground\",\n    value: function handleClickBackground(event) {\n      // Because the slider handle is a child of the \"background\" element this handler is registered to, it calls this\n      // when clicked as well. We only want to change the slider value if the user clicked on the background itself.\n      if (event.target !== this.background) return; // Move slider handle's center to the cursor\n      this.handleClickOffset = HANDLE_WIDTH / 2;\n      this.props.onChange(this.scaleMouseToSliderPosition(event));\n    }\n  }, {\n    key: \"scaleMouseToSliderPosition\",\n    value: function scaleMouseToSliderPosition(event) {\n      var _getEventXY = getEventXY(event),\n          x = _getEventXY.x;\n      var backgroundBBox = this.background.getBoundingClientRect();\n      var scaledX = x - backgroundBBox.left - this.handleClickOffset;\n      return Math.max(0, Math.min(100, 100 * scaledX / (backgroundBBox.width - HANDLE_WIDTH)));\n    }\n  }, {\n    key: \"setBackground\",\n    value: function setBackground(ref) {\n      this.background = ref;\n    }\n  }, {\n    key: \"setHandle\",\n    value: function setHandle(ref) {\n      this.handle = ref;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _classNames;\n      var halfHandleWidth = HANDLE_WIDTH / 2;\n      var pixelMin = halfHandleWidth;\n      var pixelMax = CONTAINER_WIDTH - halfHandleWidth;\n      var handleOffset = pixelMin + (pixelMax - pixelMin) * (this.props.value / 100) - halfHandleWidth;\n      return react_default.a.createElement(\"div\", {\n        className: classnames_default()((_classNames = {}, slider_defineProperty(_classNames, slider_default.a.container, true), slider_defineProperty(_classNames, slider_default.a.last, this.props.lastSlider), _classNames)),\n        ref: this.setBackground,\n        style: {\n          backgroundImage: this.props.background\n        },\n        onClick: this.handleClickBackground\n      }, react_default.a.createElement(\"div\", {\n        className: slider_default.a.handle,\n        ref: this.setHandle,\n        style: {\n          left: \"\".concat(handleOffset, \"px\")\n        },\n        onMouseDown: this.handleMouseDown,\n        onTouchStart: this.handleMouseDown\n      }));\n    }\n  }]);\n  return SliderComponent;\n}(react_default.a.Component);\nslider_SliderComponent.propTypes = {\n  background: prop_types_default.a.string,\n  lastSlider: prop_types_default.a.bool,\n  onChange: prop_types_default.a.func.isRequired,\n  value: prop_types_default.a.number.isRequired\n};\nslider_SliderComponent.defaultProps = {\n  background: 'yellow'\n};\n/* harmony default export */ var forms_slider = (slider_SliderComponent);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/labeled-icon-button/labeled-icon-button.css\nvar labeled_icon_button = __webpack_require__(279);\nvar labeled_icon_button_default = __webpack_require__.n(labeled_icon_button);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/components/labeled-icon-button/labeled-icon-button.jsx\nfunction labeled_icon_button_extends() { labeled_icon_button_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return labeled_icon_button_extends.apply(this, arguments); }\nfunction labeled_icon_button_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = labeled_icon_button_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction labeled_icon_button_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @todo This file should be pulled out into a shared library with scratch-gui,\nconsolidating this component with icon-button.jsx in gui.\nSee #13 */\n\nvar labeled_icon_button_LabeledIconButton = function LabeledIconButton(_ref) {\n  var className = _ref.className,\n      hideLabel = _ref.hideLabel,\n      imgAlt = _ref.imgAlt,\n      imgSrc = _ref.imgSrc,\n      onClick = _ref.onClick,\n      title = _ref.title,\n      props = labeled_icon_button_objectWithoutProperties(_ref, [\"className\", \"hideLabel\", \"imgAlt\", \"imgSrc\", \"onClick\", \"title\"]);\n  return react_default.a.createElement(components_button_button, labeled_icon_button_extends({\n    className: classnames_default()(className, labeled_icon_button_default.a.modEditField),\n    onClick: onClick\n  }, props), react_default.a.createElement(\"img\", {\n    alt: imgAlt || title,\n    className: labeled_icon_button_default.a.editFieldIcon,\n    draggable: false,\n    src: imgSrc,\n    title: title\n  }), !hideLabel && react_default.a.createElement(\"span\", {\n    className: labeled_icon_button_default.a.editFieldTitle\n  }, title));\n};\nlabeled_icon_button_LabeledIconButton.propTypes = {\n  className: prop_types_default.a.string,\n  hideLabel: prop_types_default.a.bool,\n  highlighted: prop_types_default.a.bool,\n  imgAlt: prop_types_default.a.string,\n  imgSrc: prop_types_default.a.string.isRequired,\n  onClick: prop_types_default.a.func.isRequired,\n  title: prop_types_default.a.string.isRequired\n};\n/* harmony default export */ var labeled_icon_button_labeled_icon_button = (labeled_icon_button_LabeledIconButton);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/color-picker/color-picker.css\nvar color_picker = __webpack_require__(17);\nvar color_picker_default = __webpack_require__.n(color_picker);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/color-picker/icons/eye-dropper.svg\nvar eye_dropper = __webpack_require__(605);\nvar eye_dropper_default = __webpack_require__.n(eye_dropper);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/color-picker/icons/fill-horz-gradient-enabled.svg\nvar fill_horz_gradient_enabled = __webpack_require__(606);\nvar fill_horz_gradient_enabled_default = __webpack_require__.n(fill_horz_gradient_enabled);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/color-picker/icons/fill-radial-enabled.svg\nvar fill_radial_enabled = __webpack_require__(607);\nvar fill_radial_enabled_default = __webpack_require__.n(fill_radial_enabled);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/color-picker/icons/fill-solid-enabled.svg\nvar fill_solid_enabled = __webpack_require__(608);\nvar fill_solid_enabled_default = __webpack_require__.n(fill_solid_enabled);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/color-picker/icons/fill-vert-gradient-enabled.svg\nvar fill_vert_gradient_enabled = __webpack_require__(609);\nvar fill_vert_gradient_enabled_default = __webpack_require__.n(fill_vert_gradient_enabled);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/color-picker/icons/swap.svg\nvar swap = __webpack_require__(610);\nvar swap_default = __webpack_require__.n(swap);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/components/color-picker/color-picker.jsx\nfunction color_picker_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { color_picker_typeof = function _typeof(obj) { return typeof obj; }; } else { color_picker_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return color_picker_typeof(obj); }\nfunction color_picker_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction color_picker_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction color_picker_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction color_picker_createClass(Constructor, protoProps, staticProps) { if (protoProps) color_picker_defineProperties(Constructor.prototype, protoProps); if (staticProps) color_picker_defineProperties(Constructor, staticProps); return Constructor; }\nfunction color_picker_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) color_picker_setPrototypeOf(subClass, superClass); }\nfunction color_picker_setPrototypeOf(o, p) { color_picker_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return color_picker_setPrototypeOf(o, p); }\nfunction color_picker_createSuper(Derived) { var hasNativeReflectConstruct = color_picker_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = color_picker_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = color_picker_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return color_picker_possibleConstructorReturn(this, result); }; }\nfunction color_picker_possibleConstructorReturn(self, call) { if (call && (color_picker_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return color_picker_assertThisInitialized(self); }\nfunction color_picker_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction color_picker_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction color_picker_getPrototypeOf(o) { color_picker_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return color_picker_getPrototypeOf(o); }\n\nvar color_picker_hsvToHex = function hsvToHex(h, s, v) {\n  return (// Scale hue back up to [0, 360] from [0, 100]\n    parse_color_default()(\"hsv(\".concat(3.6 * h, \", \").concat(s, \", \").concat(v, \")\")).hex\n  );\n};\nvar color_picker_messages = Object(index_es[\"d\" /* defineMessages */])({\n  swap: {\n    \"id\": \"paint.colorPicker.swap\",\n    \"defaultMessage\": \"Swap\"\n  }\n});\nvar color_picker_ColorPickerComponent = function (_React$Component) {\n  color_picker_inherits(ColorPickerComponent, _React$Component);\n  var _super = color_picker_createSuper(ColorPickerComponent);\n  function ColorPickerComponent() {\n    color_picker_classCallCheck(this, ColorPickerComponent);\n    return _super.apply(this, arguments);\n  }\n  color_picker_createClass(ColorPickerComponent, [{\n    key: \"_makeBackground\",\n    value: function _makeBackground(channel) {\n      var stops = []; // Generate the color slider background CSS gradients by adding\n      // color stops depending on the slider.\n      for (var n = 100; n >= 0; n -= 10) {\n        switch (channel) {\n          case 'hue':\n            stops.push(color_picker_hsvToHex(n, this.props.saturation, this.props.brightness));\n            break;\n          case 'saturation':\n            stops.push(color_picker_hsvToHex(this.props.hue, n, this.props.brightness));\n            break;\n          case 'brightness':\n            stops.push(color_picker_hsvToHex(this.props.hue, this.props.saturation, n));\n            break;\n          default:\n            throw new Error(\"Unknown channel for color sliders: \".concat(channel));\n        }\n      } // The sliders are a rounded capsule shape, and the slider handles are circles. As a consequence, when the\n      // slider handle is fully to one side, its center is actually moved away from the start/end of the slider by\n      // the slider handle's radius, meaning that the effective range of the slider excludes the rounded caps.\n      // To compensate for this, position the first stop to where the rounded cap ends, and position the last stop\n      // to where the rounded cap begins.\n      var halfHandleWidth = HANDLE_WIDTH / 2;\n      stops[0] += \" 0 \".concat(halfHandleWidth, \"px\");\n      stops[stops.length - 1] += \" \".concat(CONTAINER_WIDTH - halfHandleWidth, \"px 100%\");\n      return \"linear-gradient(to left, \".concat(stops.join(','), \")\");\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _classNames, _classNames2, _classNames3, _classNames4, _classNames5, _classNames6, _classNames7, _classNames8;\n      return react_default.a.createElement(\"div\", {\n        className: color_picker_default.a.colorPickerContainer,\n        dir: this.props.rtl ? 'rtl' : 'ltr'\n      }, this.props.shouldShowGradientTools ? react_default.a.createElement(\"div\", null, react_default.a.createElement(\"div\", {\n        className: color_picker_default.a.row\n      }, react_default.a.createElement(\"div\", {\n        className: color_picker_default.a.gradientPickerRow\n      }, react_default.a.createElement(\"img\", {\n        className: classnames_default()((_classNames = {}, color_picker_defineProperty(_classNames, color_picker_default.a.inactiveGradient, this.props.gradientType !== gradient_types.SOLID), color_picker_defineProperty(_classNames, color_picker_default.a.clickable, true), _classNames)),\n        draggable: false,\n        src: fill_solid_enabled_default.a,\n        onClick: this.props.onChangeGradientTypeSolid\n      }), react_default.a.createElement(\"img\", {\n        className: classnames_default()((_classNames2 = {}, color_picker_defineProperty(_classNames2, color_picker_default.a.inactiveGradient, this.props.gradientType !== gradient_types.HORIZONTAL), color_picker_defineProperty(_classNames2, color_picker_default.a.clickable, true), _classNames2)),\n        draggable: false,\n        src: fill_horz_gradient_enabled_default.a,\n        onClick: this.props.onChangeGradientTypeHorizontal\n      }), react_default.a.createElement(\"img\", {\n        className: classnames_default()((_classNames3 = {}, color_picker_defineProperty(_classNames3, color_picker_default.a.inactiveGradient, this.props.gradientType !== gradient_types.VERTICAL), color_picker_defineProperty(_classNames3, color_picker_default.a.clickable, true), _classNames3)),\n        draggable: false,\n        src: fill_vert_gradient_enabled_default.a,\n        onClick: this.props.onChangeGradientTypeVertical\n      }), react_default.a.createElement(\"img\", {\n        className: classnames_default()((_classNames4 = {}, color_picker_defineProperty(_classNames4, color_picker_default.a.inactiveGradient, this.props.gradientType !== gradient_types.RADIAL), color_picker_defineProperty(_classNames4, color_picker_default.a.clickable, true), _classNames4)),\n        draggable: false,\n        src: fill_radial_enabled_default.a,\n        onClick: this.props.onChangeGradientTypeRadial\n      }))), react_default.a.createElement(\"div\", {\n        className: color_picker_default.a.divider\n      }), this.props.gradientType === gradient_types.SOLID ? null : react_default.a.createElement(\"div\", {\n        className: color_picker_default.a.row\n      }, react_default.a.createElement(\"div\", {\n        className: classnames_default()(color_picker_default.a.gradientPickerRow, color_picker_default.a.gradientSwatchesRow)\n      }, react_default.a.createElement(\"div\", {\n        className: classnames_default()((_classNames5 = {}, color_picker_defineProperty(_classNames5, color_picker_default.a.clickable, true), color_picker_defineProperty(_classNames5, color_picker_default.a.swatch, true), color_picker_defineProperty(_classNames5, color_picker_default.a.largeSwatch, true), color_picker_defineProperty(_classNames5, color_picker_default.a.activeSwatch, this.props.colorIndex === 0), _classNames5)),\n        style: {\n          backgroundColor: this.props.color === null || this.props.color === MIXED ? 'white' : this.props.color\n        },\n        onClick: this.props.onSelectColor\n      }, this.props.color === null ? react_default.a.createElement(\"img\", {\n        className: color_picker_default.a.largeSwatchIcon,\n        draggable: false,\n        src: no_fill_default.a\n      }) : this.props.color === MIXED ? react_default.a.createElement(\"img\", {\n        className: color_picker_default.a.largeSwatchIcon,\n        draggable: false,\n        src: mixed_fill_default.a\n      }) : null), react_default.a.createElement(labeled_icon_button_labeled_icon_button, {\n        className: color_picker_default.a.swapButton,\n        imgSrc: swap_default.a,\n        title: this.props.intl.formatMessage(color_picker_messages.swap),\n        onClick: this.props.onSwap\n      }), react_default.a.createElement(\"div\", {\n        className: classnames_default()((_classNames6 = {}, color_picker_defineProperty(_classNames6, color_picker_default.a.clickable, true), color_picker_defineProperty(_classNames6, color_picker_default.a.swatch, true), color_picker_defineProperty(_classNames6, color_picker_default.a.largeSwatch, true), color_picker_defineProperty(_classNames6, color_picker_default.a.activeSwatch, this.props.colorIndex === 1), _classNames6)),\n        style: {\n          backgroundColor: this.props.color2 === null || this.props.color2 === MIXED ? 'white' : this.props.color2\n        },\n        onClick: this.props.onSelectColor2\n      }, this.props.color2 === null ? react_default.a.createElement(\"img\", {\n        className: color_picker_default.a.largeSwatchIcon,\n        draggable: false,\n        src: no_fill_default.a\n      }) : this.props.color2 === MIXED ? react_default.a.createElement(\"img\", {\n        className: color_picker_default.a.largeSwatchIcon,\n        draggable: false,\n        src: mixed_fill_default.a\n      }) : null)))) : null, react_default.a.createElement(\"div\", {\n        className: color_picker_default.a.row\n      }, react_default.a.createElement(\"div\", {\n        className: color_picker_default.a.rowHeader\n      }, react_default.a.createElement(\"span\", {\n        className: color_picker_default.a.labelName\n      }, react_default.a.createElement(index_es[\"a\" /* FormattedMessage */], {\n        defaultMessage: \"Color\",\n        id: \"paint.paintEditor.hue\"\n      })), react_default.a.createElement(\"span\", {\n        className: color_picker_default.a.labelReadout\n      }, Math.round(this.props.hue))), react_default.a.createElement(\"div\", {\n        className: color_picker_default.a.rowSlider\n      }, react_default.a.createElement(forms_slider, {\n        background: this._makeBackground('hue'),\n        value: this.props.hue,\n        onChange: this.props.onHueChange\n      }))), react_default.a.createElement(\"div\", {\n        className: color_picker_default.a.row\n      }, react_default.a.createElement(\"div\", {\n        className: color_picker_default.a.rowHeader\n      }, react_default.a.createElement(\"span\", {\n        className: color_picker_default.a.labelName\n      }, react_default.a.createElement(index_es[\"a\" /* FormattedMessage */], {\n        defaultMessage: \"Saturation\",\n        id: \"paint.paintEditor.saturation\"\n      })), react_default.a.createElement(\"span\", {\n        className: color_picker_default.a.labelReadout\n      }, Math.round(this.props.saturation))), react_default.a.createElement(\"div\", {\n        className: color_picker_default.a.rowSlider\n      }, react_default.a.createElement(forms_slider, {\n        background: this._makeBackground('saturation'),\n        value: this.props.saturation,\n        onChange: this.props.onSaturationChange\n      }))), react_default.a.createElement(\"div\", {\n        className: color_picker_default.a.row\n      }, react_default.a.createElement(\"div\", {\n        className: color_picker_default.a.rowHeader\n      }, react_default.a.createElement(\"span\", {\n        className: color_picker_default.a.labelName\n      }, react_default.a.createElement(index_es[\"a\" /* FormattedMessage */], {\n        defaultMessage: \"Brightness\",\n        id: \"paint.paintEditor.brightness\"\n      })), react_default.a.createElement(\"span\", {\n        className: color_picker_default.a.labelReadout\n      }, Math.round(this.props.brightness))), react_default.a.createElement(\"div\", {\n        className: color_picker_default.a.rowSlider\n      }, react_default.a.createElement(forms_slider, {\n        lastSlider: true,\n        background: this._makeBackground('brightness'),\n        value: this.props.brightness,\n        onChange: this.props.onBrightnessChange\n      }))), react_default.a.createElement(\"div\", {\n        className: color_picker_default.a.swatchRow\n      }, react_default.a.createElement(\"div\", {\n        className: color_picker_default.a.swatches\n      }, this.props.mode === Modes.BIT_LINE || this.props.mode === Modes.BIT_RECT || this.props.mode === Modes.BIT_OVAL || this.props.mode === Modes.BIT_TEXT ? null : react_default.a.createElement(\"div\", {\n        className: classnames_default()((_classNames7 = {}, color_picker_defineProperty(_classNames7, color_picker_default.a.clickable, true), color_picker_defineProperty(_classNames7, color_picker_default.a.swatch, true), color_picker_defineProperty(_classNames7, color_picker_default.a.activeSwatch, this.props.colorIndex === 0 && this.props.color === null || this.props.colorIndex === 1 && this.props.color2 === null), _classNames7)),\n        onClick: this.props.onTransparent\n      }, react_default.a.createElement(\"img\", {\n        className: color_picker_default.a.swatchIcon,\n        draggable: false,\n        src: no_fill_default.a\n      }))), react_default.a.createElement(\"div\", {\n        className: color_picker_default.a.swatches\n      }, react_default.a.createElement(\"div\", {\n        className: classnames_default()((_classNames8 = {}, color_picker_defineProperty(_classNames8, color_picker_default.a.clickable, true), color_picker_defineProperty(_classNames8, color_picker_default.a.swatch, true), color_picker_defineProperty(_classNames8, color_picker_default.a.activeSwatch, this.props.isEyeDropping), _classNames8)),\n        onClick: this.props.onActivateEyeDropper\n      }, react_default.a.createElement(\"img\", {\n        className: color_picker_default.a.swatchIcon,\n        draggable: false,\n        src: eye_dropper_default.a\n      })))));\n    }\n  }]);\n  return ColorPickerComponent;\n}(react_default.a.Component);\ncolor_picker_ColorPickerComponent.propTypes = {\n  brightness: prop_types_default.a.number.isRequired,\n  color: prop_types_default.a.string,\n  color2: prop_types_default.a.string,\n  colorIndex: prop_types_default.a.number.isRequired,\n  gradientType: prop_types_default.a.oneOf(Object.keys(gradient_types)).isRequired,\n  hue: prop_types_default.a.number.isRequired,\n  intl: index_es[\"f\" /* intlShape */].isRequired,\n  isEyeDropping: prop_types_default.a.bool.isRequired,\n  mode: prop_types_default.a.oneOf(Object.keys(Modes)),\n  onActivateEyeDropper: prop_types_default.a.func.isRequired,\n  onBrightnessChange: prop_types_default.a.func.isRequired,\n  onChangeGradientTypeHorizontal: prop_types_default.a.func.isRequired,\n  onChangeGradientTypeRadial: prop_types_default.a.func.isRequired,\n  onChangeGradientTypeSolid: prop_types_default.a.func.isRequired,\n  onChangeGradientTypeVertical: prop_types_default.a.func.isRequired,\n  onHueChange: prop_types_default.a.func.isRequired,\n  onSaturationChange: prop_types_default.a.func.isRequired,\n  onSelectColor: prop_types_default.a.func.isRequired,\n  onSelectColor2: prop_types_default.a.func.isRequired,\n  onSwap: prop_types_default.a.func,\n  onTransparent: prop_types_default.a.func.isRequired,\n  rtl: prop_types_default.a.bool.isRequired,\n  saturation: prop_types_default.a.number.isRequired,\n  shouldShowGradientTools: prop_types_default.a.bool.isRequired\n};\n/* harmony default export */ var color_picker_color_picker = (Object(index_es[\"e\" /* injectIntl */])(color_picker_ColorPickerComponent));\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/containers/color-picker.jsx\nfunction containers_color_picker_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { containers_color_picker_typeof = function _typeof(obj) { return typeof obj; }; } else { containers_color_picker_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return containers_color_picker_typeof(obj); }\nfunction containers_color_picker_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction containers_color_picker_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction containers_color_picker_createClass(Constructor, protoProps, staticProps) { if (protoProps) containers_color_picker_defineProperties(Constructor.prototype, protoProps); if (staticProps) containers_color_picker_defineProperties(Constructor, staticProps); return Constructor; }\nfunction containers_color_picker_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) containers_color_picker_setPrototypeOf(subClass, superClass); }\nfunction containers_color_picker_setPrototypeOf(o, p) { containers_color_picker_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return containers_color_picker_setPrototypeOf(o, p); }\nfunction containers_color_picker_createSuper(Derived) { var hasNativeReflectConstruct = containers_color_picker_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = containers_color_picker_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = containers_color_picker_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return containers_color_picker_possibleConstructorReturn(this, result); }; }\nfunction containers_color_picker_possibleConstructorReturn(self, call) { if (call && (containers_color_picker_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return containers_color_picker_assertThisInitialized(self); }\nfunction containers_color_picker_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction containers_color_picker_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction containers_color_picker_getPrototypeOf(o) { containers_color_picker_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return containers_color_picker_getPrototypeOf(o); }\n\nvar color_picker_colorStringToHsv = function colorStringToHsv(hexString) {\n  var hsv = parse_color_default()(hexString).hsv; // Hue comes out in [0, 360], limit to [0, 100]\n  hsv[0] = hsv[0] / 3.6; // Black is parsed as {0, 0, 0}, but turn saturation up to 100\n  // to make it easier to see slider values.\n  if (hsv[1] === 0 && hsv[2] === 0) {\n    hsv[1] = 100;\n  }\n  return hsv;\n};\nvar containers_color_picker_hsvToHex = function hsvToHex(h, s, v) {\n  return (// Scale hue back up to [0, 360] from [0, 100]\n    parse_color_default()(\"hsv(\".concat(3.6 * h, \", \").concat(s, \", \").concat(v, \")\")).hex\n  );\n}; // Important! This component ignores new color props except when isEyeDropping\n// This is to make the HSV <=> RGB conversion stable. The sliders manage their\n// own changes until unmounted or color changes with props.isEyeDropping = true.\nvar color_picker_ColorPicker = function (_React$Component) {\n  containers_color_picker_inherits(ColorPicker, _React$Component);\n  var _super = containers_color_picker_createSuper(ColorPicker);\n  function ColorPicker(props) {\n    var _this;\n    containers_color_picker_classCallCheck(this, ColorPicker);\n    _this = _super.call(this, props);\n    lodash_bindall_default()(containers_color_picker_assertThisInitialized(_this), ['getHsv', 'handleChangeGradientTypeHorizontal', 'handleChangeGradientTypeRadial', 'handleChangeGradientTypeSolid', 'handleChangeGradientTypeVertical', 'handleHueChange', 'handleSaturationChange', 'handleBrightnessChange', 'handleTransparent', 'handleActivateEyeDropper']);\n    var color = props.colorIndex === 0 ? props.color : props.color2;\n    var hsv = _this.getHsv(color);\n    _this.state = {\n      hue: hsv[0],\n      saturation: hsv[1],\n      brightness: hsv[2]\n    };\n    return _this;\n  }\n  containers_color_picker_createClass(ColorPicker, [{\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(newProps) {\n      var color = newProps.colorIndex === 0 ? this.props.color : this.props.color2;\n      var newColor = newProps.colorIndex === 0 ? newProps.color : newProps.color2;\n      var colorSetByEyedropper = this.props.isEyeDropping && color !== newColor;\n      if (colorSetByEyedropper || this.props.colorIndex !== newProps.colorIndex) {\n        var hsv = this.getHsv(newColor);\n        this.setState({\n          hue: hsv[0],\n          saturation: hsv[1],\n          brightness: hsv[2]\n        });\n      }\n    }\n  }, {\n    key: \"getHsv\",\n    value: function getHsv(color) {\n      var isTransparent = color === null;\n      var isMixed = color === MIXED;\n      return isTransparent || isMixed ? [50, 100, 100] : color_picker_colorStringToHsv(color);\n    }\n  }, {\n    key: \"handleHueChange\",\n    value: function handleHueChange(hue) {\n      var _this2 = this;\n      this.setState({\n        hue: hue\n      }, function () {\n        _this2.handleColorChange();\n      });\n    }\n  }, {\n    key: \"handleSaturationChange\",\n    value: function handleSaturationChange(saturation) {\n      var _this3 = this;\n      this.setState({\n        saturation: saturation\n      }, function () {\n        _this3.handleColorChange();\n      });\n    }\n  }, {\n    key: \"handleBrightnessChange\",\n    value: function handleBrightnessChange(brightness) {\n      var _this4 = this;\n      this.setState({\n        brightness: brightness\n      }, function () {\n        _this4.handleColorChange();\n      });\n    }\n  }, {\n    key: \"handleColorChange\",\n    value: function handleColorChange() {\n      this.props.onChangeColor(containers_color_picker_hsvToHex(this.state.hue, this.state.saturation, this.state.brightness));\n    }\n  }, {\n    key: \"handleTransparent\",\n    value: function handleTransparent() {\n      this.props.onChangeColor(null);\n    }\n  }, {\n    key: \"handleActivateEyeDropper\",\n    value: function handleActivateEyeDropper() {\n      this.props.onActivateEyeDropper(paper_full_default.a.tool, // get the currently active tool from paper\n      this.props.onChangeColor);\n    }\n  }, {\n    key: \"handleChangeGradientTypeHorizontal\",\n    value: function handleChangeGradientTypeHorizontal() {\n      this.props.onChangeGradientType(gradient_types.HORIZONTAL);\n    }\n  }, {\n    key: \"handleChangeGradientTypeRadial\",\n    value: function handleChangeGradientTypeRadial() {\n      this.props.onChangeGradientType(gradient_types.RADIAL);\n    }\n  }, {\n    key: \"handleChangeGradientTypeSolid\",\n    value: function handleChangeGradientTypeSolid() {\n      this.props.onChangeGradientType(gradient_types.SOLID);\n    }\n  }, {\n    key: \"handleChangeGradientTypeVertical\",\n    value: function handleChangeGradientTypeVertical() {\n      this.props.onChangeGradientType(gradient_types.VERTICAL);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return react_default.a.createElement(color_picker_color_picker, {\n        brightness: this.state.brightness,\n        color: this.props.color,\n        color2: this.props.color2,\n        colorIndex: this.props.colorIndex,\n        gradientType: this.props.gradientType,\n        hue: this.state.hue,\n        isEyeDropping: this.props.isEyeDropping,\n        mode: this.props.mode,\n        rtl: this.props.rtl,\n        saturation: this.state.saturation,\n        shouldShowGradientTools: this.props.shouldShowGradientTools,\n        onActivateEyeDropper: this.handleActivateEyeDropper,\n        onBrightnessChange: this.handleBrightnessChange,\n        onChangeGradientTypeHorizontal: this.handleChangeGradientTypeHorizontal,\n        onChangeGradientTypeRadial: this.handleChangeGradientTypeRadial,\n        onChangeGradientTypeSolid: this.handleChangeGradientTypeSolid,\n        onChangeGradientTypeVertical: this.handleChangeGradientTypeVertical,\n        onHueChange: this.handleHueChange,\n        onSaturationChange: this.handleSaturationChange,\n        onSelectColor: this.props.onSelectColor,\n        onSelectColor2: this.props.onSelectColor2,\n        onSwap: this.props.onSwap,\n        onTransparent: this.handleTransparent\n      });\n    }\n  }]);\n  return ColorPicker;\n}(react_default.a.Component);\ncolor_picker_ColorPicker.propTypes = {\n  color: prop_types_default.a.string,\n  color2: prop_types_default.a.string,\n  colorIndex: prop_types_default.a.number.isRequired,\n  gradientType: prop_types_default.a.oneOf(Object.keys(gradient_types)).isRequired,\n  isEyeDropping: prop_types_default.a.bool.isRequired,\n  mode: prop_types_default.a.oneOf(Object.keys(Modes)),\n  onActivateEyeDropper: prop_types_default.a.func.isRequired,\n  onChangeColor: prop_types_default.a.func.isRequired,\n  onChangeGradientType: prop_types_default.a.func,\n  onSelectColor: prop_types_default.a.func.isRequired,\n  onSelectColor2: prop_types_default.a.func.isRequired,\n  onSwap: prop_types_default.a.func,\n  rtl: prop_types_default.a.bool.isRequired,\n  shouldShowGradientTools: prop_types_default.a.bool.isRequired\n};\nvar color_picker_mapStateToProps = function mapStateToProps(state) {\n  return {\n    colorIndex: state.scratchPaint.fillMode.colorIndex,\n    isEyeDropping: state.scratchPaint.color.eyeDropper.active,\n    mode: state.scratchPaint.mode,\n    rtl: state.scratchPaint.layout.rtl\n  };\n};\nvar color_picker_mapDispatchToProps = function mapDispatchToProps(dispatch) {\n  return {\n    clearSelectedItems: function clearSelectedItems() {\n      dispatch(selected_items_clearSelectedItems());\n    },\n    onActivateEyeDropper: function onActivateEyeDropper(currentTool, callback) {\n      dispatch(activateEyeDropper(currentTool, callback));\n    },\n    onSelectColor: function onSelectColor() {\n      dispatch(changeColorIndex(0));\n    },\n    onSelectColor2: function onSelectColor2() {\n      dispatch(changeColorIndex(1));\n    }\n  };\n};\n/* harmony default export */ var containers_color_picker = (Object(es[\"b\" /* connect */])(color_picker_mapStateToProps, color_picker_mapDispatchToProps)(color_picker_ColorPicker));\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/input-group/input-group.css\nvar input_group = __webpack_require__(339);\nvar input_group_default = __webpack_require__.n(input_group);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/components/input-group/input-group.jsx\nfunction input_group_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar input_group_InputGroup = function InputGroup(props) {\n  return react_default.a.createElement(\"div\", {\n    className: classnames_default()(props.className, input_group_default.a.inputGroup, input_group_defineProperty({}, input_group_default.a.disabled, props.disabled)),\n    dir: props.rtl ? 'rtl' : ''\n  }, props.children);\n};\ninput_group_InputGroup.propTypes = {\n  children: prop_types_default.a.node.isRequired,\n  className: prop_types_default.a.string,\n  disabled: prop_types_default.a.bool,\n  rtl: prop_types_default.a.bool\n};\n/* harmony default export */ var input_group_input_group = (input_group_InputGroup);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/forms/label.css\nvar forms_label = __webpack_require__(280);\nvar label_default = __webpack_require__.n(forms_label);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/components/forms/label.jsx\n/* DO NOT EDIT\n@todo This file is copied from GUI and should be pulled out into a shared library.\nSee https://github.com/LLK/scratch-paint/issues/13 */\n\nvar label_Label = function Label(props) {\n  return react_default.a.createElement(\"label\", {\n    className: label_default.a.inputGroup\n  }, react_default.a.createElement(\"span\", {\n    className: props.secondary ? label_default.a.inputLabelSecondary : label_default.a.inputLabel\n  }, props.text), props.children);\n};\nlabel_Label.propTypes = {\n  children: prop_types_default.a.node,\n  secondary: prop_types_default.a.bool,\n  text: prop_types_default.a.string.isRequired\n};\nlabel_Label.defaultProps = {\n  secondary: false\n};\n/* harmony default export */ var components_forms_label = (label_Label);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/components/color-indicator.jsx\n\nvar color_indicator_ColorIndicatorComponent = function ColorIndicatorComponent(props) {\n  return react_default.a.createElement(input_group_input_group, {\n    className: props.className,\n    disabled: props.disabled\n  }, react_default.a.createElement(react_popover_default.a, {\n    body: react_default.a.createElement(containers_color_picker, {\n      color: props.color,\n      color2: props.color2,\n      gradientType: props.gradientType,\n      shouldShowGradientTools: props.shouldShowGradientTools,\n      onChangeColor: props.onChangeColor,\n      onChangeGradientType: props.onChangeGradientType,\n      onSwap: props.onSwap\n    }),\n    isOpen: props.colorModalVisible,\n    preferPlace: \"below\",\n    onOuterAction: props.onCloseColor\n  }, react_default.a.createElement(components_forms_label, {\n    text: props.label\n  }, react_default.a.createElement(color_button_color_button, {\n    color: props.color,\n    color2: props.color2,\n    gradientType: props.gradientType,\n    onClick: props.onOpenColor,\n    outline: props.outline\n  }))));\n};\ncolor_indicator_ColorIndicatorComponent.propTypes = {\n  className: prop_types_default.a.string,\n  disabled: prop_types_default.a.bool.isRequired,\n  color: prop_types_default.a.string,\n  color2: prop_types_default.a.string,\n  colorModalVisible: prop_types_default.a.bool.isRequired,\n  gradientType: prop_types_default.a.oneOf(Object.keys(gradient_types)).isRequired,\n  label: prop_types_default.a.string.isRequired,\n  onChangeColor: prop_types_default.a.func.isRequired,\n  onChangeGradientType: prop_types_default.a.func.isRequired,\n  onCloseColor: prop_types_default.a.func.isRequired,\n  onOpenColor: prop_types_default.a.func.isRequired,\n  onSwap: prop_types_default.a.func.isRequired,\n  outline: prop_types_default.a.bool.isRequired,\n  shouldShowGradientTools: prop_types_default.a.bool.isRequired\n};\n/* harmony default export */ var color_indicator = (color_indicator_ColorIndicatorComponent);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/containers/color-indicator.jsx\nfunction color_indicator_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { color_indicator_typeof = function _typeof(obj) { return typeof obj; }; } else { color_indicator_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return color_indicator_typeof(obj); }\nfunction color_indicator_extends() { color_indicator_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return color_indicator_extends.apply(this, arguments); }\nfunction color_indicator_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction color_indicator_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction color_indicator_createClass(Constructor, protoProps, staticProps) { if (protoProps) color_indicator_defineProperties(Constructor.prototype, protoProps); if (staticProps) color_indicator_defineProperties(Constructor, staticProps); return Constructor; }\nfunction color_indicator_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) color_indicator_setPrototypeOf(subClass, superClass); }\nfunction color_indicator_setPrototypeOf(o, p) { color_indicator_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return color_indicator_setPrototypeOf(o, p); }\nfunction color_indicator_createSuper(Derived) { var hasNativeReflectConstruct = color_indicator_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = color_indicator_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = color_indicator_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return color_indicator_possibleConstructorReturn(this, result); }; }\nfunction color_indicator_possibleConstructorReturn(self, call) { if (call && (color_indicator_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return color_indicator_assertThisInitialized(self); }\nfunction color_indicator_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction color_indicator_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction color_indicator_getPrototypeOf(o) { color_indicator_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return color_indicator_getPrototypeOf(o); }\n\nvar color_indicator_makeColorIndicator = function makeColorIndicator(label, isStroke) {\n  var ColorIndicator = function (_React$Component) {\n    color_indicator_inherits(ColorIndicator, _React$Component);\n    var _super = color_indicator_createSuper(ColorIndicator);\n    function ColorIndicator(props) {\n      var _this;\n      color_indicator_classCallCheck(this, ColorIndicator);\n      _this = _super.call(this, props);\n      lodash_bindall_default()(color_indicator_assertThisInitialized(_this), ['handleChangeColor', 'handleChangeGradientType', 'handleCloseColor', 'handleSwap']); // Flag to track whether an svg-update-worthy change has been made\n      _this._hasChanged = false;\n      return _this;\n    }\n    color_indicator_createClass(ColorIndicator, [{\n      key: \"componentWillReceiveProps\",\n      value: function componentWillReceiveProps(newProps) {\n        var _this$props = this.props,\n            colorModalVisible = _this$props.colorModalVisible,\n            onUpdateImage = _this$props.onUpdateImage;\n        if (colorModalVisible && !newProps.colorModalVisible) {\n          // Submit the new SVG, which also stores a single undo/redo action.\n          if (this._hasChanged) onUpdateImage();\n          this._hasChanged = false;\n        }\n      }\n    }, {\n      key: \"handleChangeColor\",\n      value: function handleChangeColor(newColor) {\n        // Stroke-selector-specific logic: if we change the stroke color from \"none\" to something visible, ensure\n        // there's a nonzero stroke width. If we change the stroke color to \"none\", set the stroke width to zero.\n        if (isStroke) {\n          // Whether the old color style in this color indicator was null (completely transparent).\n          // If it's a solid color, this means that the first color is null.\n          // If it's a gradient, this means both colors are null.\n          var oldStyleWasNull = this.props.gradientType === gradient_types.SOLID ? this.props.color === null : this.props.color === null && this.props.color2 === null;\n          var otherColor = this.props.colorIndex === 1 ? this.props.color : this.props.color2; // Whether the new color style in this color indicator is null.\n          var newStyleIsNull = this.props.gradientType === gradient_types.SOLID ? newColor === null : newColor === null && otherColor === null;\n          if (oldStyleWasNull && !newStyleIsNull) {\n            this._hasChanged = style_path_applyStrokeWidthToSelection(1, this.props.textEditTarget) || this._hasChanged;\n            this.props.onChangeStrokeWidth(1);\n          } else if (!oldStyleWasNull && newStyleIsNull) {\n            this._hasChanged = style_path_applyStrokeWidthToSelection(0, this.props.textEditTarget) || this._hasChanged;\n            this.props.onChangeStrokeWidth(0);\n          }\n        }\n        var formatIsBitmap = format_isBitmap(this.props.format); // Apply color and update redux, but do not update svg until picker closes.\n        var isDifferent = style_path_applyColorToSelection(newColor, this.props.colorIndex, this.props.gradientType === gradient_types.SOLID, // In bitmap mode, only the fill color selector is used, but it applies to stroke if fillBitmapShapes\n        // is set to true via the \"Fill\"/\"Outline\" selector button\n        isStroke || formatIsBitmap && !this.props.fillBitmapShapes, this.props.textEditTarget);\n        this._hasChanged = this._hasChanged || isDifferent;\n        this.props.onChangeColor(newColor, this.props.colorIndex);\n      }\n    }, {\n      key: \"handleChangeGradientType\",\n      value: function handleChangeGradientType(gradientType) {\n        var formatIsBitmap = format_isBitmap(this.props.format); // Apply color and update redux, but do not update svg until picker closes.\n        var isDifferent = style_path_applyGradientTypeToSelection(gradientType, isStroke || formatIsBitmap && !this.props.fillBitmapShapes, this.props.textEditTarget);\n        this._hasChanged = this._hasChanged || isDifferent;\n        var hasSelectedItems = selection_getSelectedLeafItems().length > 0;\n        if (hasSelectedItems) {\n          if (isDifferent) {\n            // Recalculates the swatch colors\n            this.props.setSelectedItems(this.props.format);\n          }\n        }\n        if (this.props.gradientType === gradient_types.SOLID && gradientType !== gradient_types.SOLID) {\n          // Generate color 2 and change to the 2nd swatch when switching from solid to gradient\n          if (!hasSelectedItems) {\n            this.props.onChangeColor(style_path_generateSecondaryColor(this.props.color), 1);\n          }\n          this.props.onChangeColorIndex(1);\n        }\n        if (this.props.onChangeGradientType) this.props.onChangeGradientType(gradientType);\n      }\n    }, {\n      key: \"handleCloseColor\",\n      value: function handleCloseColor() {\n        // If the eyedropper is currently being used, don't\n        // close the color menu.\n        if (this.props.isEyeDropping) return; // Otherwise, close the color menu and\n        // also reset the color index to indicate\n        // that `color1` is selected.\n        this.props.onCloseColor();\n        this.props.onChangeColorIndex(0);\n      }\n    }, {\n      key: \"handleSwap\",\n      value: function handleSwap() {\n        if (selection_getSelectedLeafItems().length) {\n          var formatIsBitmap = format_isBitmap(this.props.format);\n          var isDifferent = style_path_swapColorsInSelection(isStroke || formatIsBitmap && !this.props.fillBitmapShapes, this.props.textEditTarget);\n          this.props.setSelectedItems(this.props.format);\n          this._hasChanged = this._hasChanged || isDifferent;\n        } else {\n          var color1 = this.props.color;\n          var color2 = this.props.color2;\n          color1 = color1 === null || color1 === MIXED ? color1 : parse_color_default()(color1).hex;\n          color2 = color2 === null || color2 === MIXED ? color2 : parse_color_default()(color2).hex;\n          this.props.onChangeColor(color1, 1);\n          this.props.onChangeColor(color2, 0);\n        }\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        return react_default.a.createElement(color_indicator, color_indicator_extends({}, this.props, {\n          label: this.props.intl.formatMessage(label),\n          outline: isStroke,\n          onChangeColor: this.handleChangeColor,\n          onChangeGradientType: this.handleChangeGradientType,\n          onCloseColor: this.handleCloseColor,\n          onSwap: this.handleSwap\n        }));\n      }\n    }]);\n    return ColorIndicator;\n  }(react_default.a.Component);\n  ColorIndicator.propTypes = {\n    colorIndex: prop_types_default.a.number.isRequired,\n    disabled: prop_types_default.a.bool.isRequired,\n    color: prop_types_default.a.string,\n    color2: prop_types_default.a.string,\n    colorModalVisible: prop_types_default.a.bool.isRequired,\n    fillBitmapShapes: prop_types_default.a.bool.isRequired,\n    format: prop_types_default.a.oneOf(Object.keys(Formats)),\n    gradientType: prop_types_default.a.oneOf(Object.keys(gradient_types)).isRequired,\n    intl: index_es[\"f\" /* intlShape */],\n    isEyeDropping: prop_types_default.a.bool.isRequired,\n    onChangeColorIndex: prop_types_default.a.func.isRequired,\n    onChangeColor: prop_types_default.a.func.isRequired,\n    onChangeGradientType: prop_types_default.a.func,\n    onChangeStrokeWidth: prop_types_default.a.func,\n    onCloseColor: prop_types_default.a.func.isRequired,\n    onUpdateImage: prop_types_default.a.func.isRequired,\n    setSelectedItems: prop_types_default.a.func.isRequired,\n    textEditTarget: prop_types_default.a.number\n  };\n  return Object(index_es[\"e\" /* injectIntl */])(ColorIndicator);\n};\n/* harmony default export */ var containers_color_indicator = (color_indicator_makeColorIndicator);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/containers/fill-color-indicator.jsx\n\nvar fill_color_indicator_messages = Object(index_es[\"d\" /* defineMessages */])({\n  label: {\n    \"id\": \"paint.paintEditor.fill\",\n    \"defaultMessage\": \"Fill\"\n  }\n});\nvar FillColorIndicator = containers_color_indicator(fill_color_indicator_messages.label, false);\nvar fill_color_indicator_mapStateToProps = function mapStateToProps(state) {\n  return {\n    colorIndex: state.scratchPaint.fillMode.colorIndex,\n    disabled: state.scratchPaint.mode === Modes.LINE,\n    color: state.scratchPaint.color.fillColor.primary,\n    color2: state.scratchPaint.color.fillColor.secondary,\n    colorModalVisible: state.scratchPaint.modals.fillColor,\n    fillBitmapShapes: state.scratchPaint.fillBitmapShapes,\n    format: state.scratchPaint.format,\n    gradientType: state.scratchPaint.color.fillColor.gradientType,\n    isEyeDropping: state.scratchPaint.color.eyeDropper.active,\n    mode: state.scratchPaint.mode,\n    shouldShowGradientTools: state.scratchPaint.mode in GradientToolsModes,\n    textEditTarget: state.scratchPaint.textEditTarget\n  };\n};\nvar fill_color_indicator_mapDispatchToProps = function mapDispatchToProps(dispatch) {\n  return {\n    onChangeColorIndex: function onChangeColorIndex(index) {\n      dispatch(changeColorIndex(index));\n    },\n    onChangeColor: function onChangeColor(fillColor, index) {\n      if (index === 0) {\n        dispatch(changeFillColor(fillColor));\n      } else if (index === 1) {\n        dispatch(changeFillColor2(fillColor));\n      }\n    },\n    onOpenColor: function onOpenColor() {\n      dispatch(openFillColor());\n    },\n    onCloseColor: function onCloseColor() {\n      dispatch(closeFillColor());\n    },\n    onChangeGradientType: function onChangeGradientType(gradientType) {\n      dispatch(fill_mode_gradient_type_changeGradientType(gradientType));\n    },\n    setSelectedItems: function setSelectedItems(format) {\n      dispatch(selected_items_setSelectedItems(selection_getSelectedLeafItems(), format_isBitmap(format)));\n    }\n  };\n};\n/* harmony default export */ var fill_color_indicator = (Object(es[\"b\" /* connect */])(fill_color_indicator_mapStateToProps, fill_color_indicator_mapDispatchToProps)(FillColorIndicator));\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/helper/hover.js\nfunction hover_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = hover_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction hover_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return hover_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return hover_arrayLikeToArray(o, minLen); }\nfunction hover_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @param {!MouseEvent} event mouse event\n * @param {?object} hitOptions hit options to use\n * @param {?boolean} subselect Whether items within groups can be hovered. If false, the\n *    entire group should be hovered.\n * @return {paper.Item} the hovered item or null if there is none\n */\nvar hover_getHoveredItem = function getHoveredItem(event, hitOptions, subselect) {\n  var oldMatch = hitOptions.match;\n  hitOptions.match = function (hitResult) {\n    if (hitResult.item.data && hitResult.item.data.noHover) return false;\n    return oldMatch ? oldMatch(hitResult) : true;\n  };\n  var hitResults = paper_full_default.a.project.hitTestAll(event.point, hitOptions);\n  if (hitResults.length === 0) {\n    return null;\n  } // Get highest z-index result\n  var hitResult;\n  var _iterator = hover_createForOfIteratorHelper(hitResults),\n      _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var result = _step.value;\n      if (!hitResult || math_sortItemsByZIndex(hitResult.item, result.item) < 0) {\n        hitResult = result;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  var item = hitResult.item; // If the hovered item is already selected, then there should be no hovered item.\n  if (!item || item.selected) {\n    return null;\n  }\n  var hoverGuide;\n  if (isBoundsItem(item)) {\n    hoverGuide = guides_hoverBounds(item);\n  } else if (!subselect && group_isGroupChild(item)) {\n    hoverGuide = guides_hoverBounds(getRootItem(item));\n  } else {\n    hoverGuide = guides_hoverItem(item);\n  }\n  hoverGuide.data.hitResult = hitResult;\n  return hoverGuide;\n};\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/helper/tools/fill-tool.js\nfunction tools_fill_tool_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { tools_fill_tool_typeof = function _typeof(obj) { return typeof obj; }; } else { tools_fill_tool_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return tools_fill_tool_typeof(obj); }\nfunction tools_fill_tool_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction tools_fill_tool_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction tools_fill_tool_createClass(Constructor, protoProps, staticProps) { if (protoProps) tools_fill_tool_defineProperties(Constructor.prototype, protoProps); if (staticProps) tools_fill_tool_defineProperties(Constructor, staticProps); return Constructor; }\nfunction tools_fill_tool_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) tools_fill_tool_setPrototypeOf(subClass, superClass); }\nfunction tools_fill_tool_setPrototypeOf(o, p) { tools_fill_tool_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return tools_fill_tool_setPrototypeOf(o, p); }\nfunction tools_fill_tool_createSuper(Derived) { var hasNativeReflectConstruct = tools_fill_tool_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = tools_fill_tool_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = tools_fill_tool_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return tools_fill_tool_possibleConstructorReturn(this, result); }; }\nfunction tools_fill_tool_possibleConstructorReturn(self, call) { if (call && (tools_fill_tool_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return tools_fill_tool_assertThisInitialized(self); }\nfunction tools_fill_tool_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction tools_fill_tool_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction tools_fill_tool_getPrototypeOf(o) { tools_fill_tool_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return tools_fill_tool_getPrototypeOf(o); }\n\nvar tools_fill_tool_FillTool = function (_paper$Tool) {\n  tools_fill_tool_inherits(FillTool, _paper$Tool);\n  var _super = tools_fill_tool_createSuper(FillTool);\n  tools_fill_tool_createClass(FillTool, null, [{\n    key: \"TOLERANCE\",\n    get: function get() {\n      return 2;\n    }\n    /**\n     * @param {function} setHoveredItem Callback to set the hovered item\n     * @param {function} clearHoveredItem Callback to clear the hovered item\n     * @param {!function} onUpdateImage A callback to call when the image visibly changes\n     */\n  }]);\n  function FillTool(setHoveredItem, clearHoveredItem, onUpdateImage) {\n    var _this;\n    tools_fill_tool_classCallCheck(this, FillTool);\n    _this = _super.call(this);\n    _this.setHoveredItem = setHoveredItem;\n    _this.clearHoveredItem = clearHoveredItem;\n    _this.onUpdateImage = onUpdateImage; // We have to set these functions instead of just declaring them because\n    // paper.js tools hook up the listeners in the setter functions.\n    _this.onMouseMove = _this.handleMouseMove;\n    _this.onMouseUp = _this.handleMouseUp; // Color to fill with\n    _this.fillColor = null;\n    _this.fillColor2 = null;\n    _this.gradientType = null; // The path that's being hovered over.\n    _this.fillItem = null; // The style property that we're applying the color to (either fill or stroke).\n    _this.fillProperty = null; // If we're hovering over a hole in a compound path, we can't just recolor it. This is the\n    // added item that's the same shape as the hole that's drawn over the hole when we fill a hole.\n    _this.addedFillItem = null;\n    _this.fillItemOrigColor = null;\n    _this.prevHoveredItemId = null;\n    return _this;\n  }\n  tools_fill_tool_createClass(FillTool, [{\n    key: \"getHitOptions\",\n    value: function getHitOptions() {\n      var isAlmostClosedPath = function isAlmostClosedPath(item) {\n        return item instanceof paper_full_default.a.Path && item.segments.length > 2 && item.lastSegment.point.getDistance(item.firstSegment.point) < 8;\n      };\n      return {\n        segments: false,\n        stroke: true,\n        curves: false,\n        fill: true,\n        guide: false,\n        match: function match(hitResult) {\n          // Allow fills to be hit only if the item has a fill already or the path is closed/nearly closed\n          var hitFill = hitResult.item.hasFill() || hitResult.item.closed || isAlmostClosedPath(hitResult.item);\n          if (hitResult.item instanceof paper_full_default.a.Path && ( // Disallow hits that don't qualify for the fill criteria, but only if they're fills\n          hitFill || hitResult.type !== 'fill')) {\n            return true;\n          }\n          if (hitResult.item instanceof paper_full_default.a.PointText) {\n            return true;\n          }\n        },\n        hitUnfilledPaths: true,\n        // If the color is transparent/none, then we need to be able to hit \"invisible\" outlines so that we don't\n        // prevent ourselves from hitting an outline when we make it transparent via the fill preview, causing it to\n        // flicker back and forth between transparent/its previous color as we hit it, then stop hitting it, etc.\n        // If the color *is* visible, then don't hit \"invisible\" outlines, since this would add visible outlines to\n        // non-outlined shapes when you hovered over where their outlines would be.\n        hitUnstrokedPaths: this.gradientType === gradient_types.SOLID && this.fillColor === null,\n        tolerance: FillTool.TOLERANCE / paper_full_default.a.view.zoom\n      };\n    }\n  }, {\n    key: \"setFillColor\",\n    value: function setFillColor(fillColor) {\n      this.fillColor = fillColor;\n    }\n  }, {\n    key: \"setFillColor2\",\n    value: function setFillColor2(fillColor2) {\n      this.fillColor2 = fillColor2;\n    }\n  }, {\n    key: \"setGradientType\",\n    value: function setGradientType(gradientType) {\n      this.gradientType = gradientType;\n    }\n    /**\n     * To be called when the hovered item changes. When the select tool hovers over a\n     * new item, it compares against this to see if a hover item change event needs to\n     * be fired.\n     * @param {paper.Item} prevHoveredItemId ID of the highlight item that indicates the mouse is\n     *     over a given item currently\n     */\n  }, {\n    key: \"setPrevHoveredItemId\",\n    value: function setPrevHoveredItemId(prevHoveredItemId) {\n      this.prevHoveredItemId = prevHoveredItemId;\n    }\n  }, {\n    key: \"handleMouseMove\",\n    value: function handleMouseMove(event) {\n      var hoveredItem = hover_getHoveredItem(event, this.getHitOptions(), true\n      /* subselect */\n      );\n      if (!hoveredItem && this.prevHoveredItemId || // There is no longer a hovered item\n      hoveredItem && !this.prevHoveredItemId || // There is now a hovered item\n      hoveredItem && this.prevHoveredItemId && hoveredItem.id !== this.prevHoveredItemId) {\n        // hovered item changed\n        this.setHoveredItem(hoveredItem ? hoveredItem.id : null);\n      }\n      var hitItem = hoveredItem ? hoveredItem.data.origItem : null;\n      var hitType = hoveredItem ? hoveredItem.data.hitResult.type : null; // The hit \"target\" changes if we switch items or switch between fill/outline on the same item\n      var hitTargetChanged = hitItem !== this.fillItem || hitType !== this.fillProperty; // Still hitting the same thing\n      if (!hitTargetChanged) {\n        // Only radial gradient needs to be updated\n        if (this.gradientType === gradient_types.RADIAL) {\n          this._setFillItemColor(this.fillColor, this.fillColor2, this.gradientType, event.point);\n        }\n        return;\n      }\n      if (this.fillItem) {\n        if (this.addedFillItem) {\n          this.addedFillItem.remove();\n          this.addedFillItem = null;\n        } else {\n          this._setFillItemColor(this.fillItemOrigColor);\n        }\n        this.fillItemOrigColor = null;\n        this.fillItem = null;\n        this.fillProperty = null;\n      }\n      if (hitItem) {\n        this.fillItem = hitItem;\n        this.fillProperty = hitType;\n        var colorProp = hitType === 'fill' ? 'fillColor' : 'strokeColor';\n        this.fillItemOrigColor = hitItem[colorProp];\n        if (hitItem.parent instanceof paper_full_default.a.CompoundPath && hitItem.area < 0 && hitType === 'fill') {\n          // hole\n          if (!this.fillColor) {\n            // Hole filled with transparent is no-op\n            this.fillItem = null;\n            this.fillProperty = null;\n            this.fillItemOrigColor = null;\n            return;\n          } // Make an item to fill the hole\n          this.addedFillItem = hitItem.clone();\n          this.addedFillItem.setClockwise(true);\n          this.addedFillItem.data.noHover = true;\n          this.addedFillItem.data.origItem = hitItem; // This usually fixes it so there isn't a teeny tiny gap in between the fill and the outline\n          // when filling in a hole\n          math_expandBy(this.addedFillItem, .1);\n          this.addedFillItem.insertAbove(hitItem.parent);\n        } else if (this.fillItem.parent instanceof paper_full_default.a.CompoundPath) {\n          this.fillItemOrigColor = hitItem.parent[colorProp];\n        }\n        this._setFillItemColor(this.fillColor, this.fillColor2, this.gradientType, event.point);\n      }\n    }\n  }, {\n    key: \"handleMouseUp\",\n    value: function handleMouseUp(event) {\n      if (event.event.button > 0) return; // only first mouse button\n      if (this.fillItem) {\n        // If the hole we're filling in is the same color as the parent, and parent has no outline, remove the hole\n        if (this.addedFillItem && this._noStroke(this.fillItem.parent) && this.addedFillItem.fillColor.type !== 'gradient' && this.fillItem.parent.fillColor.toCSS() === this.addedFillItem.fillColor.toCSS()) {\n          this.addedFillItem.remove();\n          this.addedFillItem = null;\n          var parent = this.fillItem.parent;\n          this.fillItem.remove();\n          parent = parent.reduce();\n          parent.fillColor = this.fillColor;\n        } else if (this.addedFillItem) {\n          // Fill in a hole.\n          this.addedFillItem.data.noHover = false;\n        } else if (!this.fillColor && this.fillItem.data && this.fillItem.data.origItem) {\n          // Filling a hole filler with transparent returns it to being gone\n          // instead of making a shape that's transparent\n          var group = this.fillItem.parent;\n          this.fillItem.remove();\n          if (!(group instanceof paper_full_default.a.Layer) && group.children.length === 1) {\n            group.reduce();\n          }\n        }\n        this.clearHoveredItem();\n        this.fillItem = null;\n        this.fillProperty = null;\n        this.addedFillItem = null;\n        this.fillItemOrigColor = null;\n        this.onUpdateImage();\n      }\n    }\n  }, {\n    key: \"_noStroke\",\n    value: function _noStroke(item) {\n      return !item.strokeColor || item.strokeColor.alpha === 0 || item.strokeWidth === 0;\n    } // Either pass in a fully defined paper.Color as color1,\n    // or pass in 2 color strings, a gradient type, and a pointer location\n  }, {\n    key: \"_setFillItemColor\",\n    value: function _setFillItemColor(color1, color2, gradientType, pointerLocation) {\n      var item = this._getFillItem();\n      if (!item) return;\n      var colorProp = this.fillProperty === 'fill' ? 'fillColor' : 'strokeColor'; // Only create a gradient if specifically requested, else use color1 directly\n      // This ensures we do not set a gradient by accident (see scratch-paint#830).\n      if (gradientType && gradientType !== gradient_types.SOLID) {\n        item[colorProp] = style_path_createGradientObject(color1, color2, gradientType, item.bounds, pointerLocation, item.strokeWidth);\n      } else {\n        item[colorProp] = color1;\n      }\n    }\n  }, {\n    key: \"_getFillItem\",\n    value: function _getFillItem() {\n      if (this.addedFillItem) {\n        return this.addedFillItem;\n      } else if (this.fillItem && this.fillItem.parent instanceof paper_full_default.a.CompoundPath) {\n        return this.fillItem.parent;\n      }\n      return this.fillItem;\n    }\n  }, {\n    key: \"deactivateTool\",\n    value: function deactivateTool() {\n      if (this.fillItem) {\n        this._setFillItemColor(this.fillItemOrigColor);\n        this.fillItemOrigColor = null;\n        this.fillItem = null;\n        this.fillProperty = null;\n      }\n      this.clearHoveredItem();\n      this.setHoveredItem = null;\n      this.clearHoveredItem = null;\n    }\n  }]);\n  return FillTool;\n}(paper_full_default.a.Tool);\n/* harmony default export */ var tools_fill_tool = (tools_fill_tool_FillTool);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/fill-mode/fill.svg\nvar fill_mode_fill = __webpack_require__(611);\nvar fill_mode_fill_default = __webpack_require__.n(fill_mode_fill);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/components/fill-mode/fill-mode.jsx\n\nvar fill_mode_FillModeComponent = function FillModeComponent(props) {\n  return react_default.a.createElement(tool_select_base_tool_select_base, {\n    imgDescriptor: lib_messages.fill,\n    imgSrc: fill_mode_fill_default.a,\n    isSelected: props.isSelected,\n    onMouseDown: props.onMouseDown\n  });\n};\nfill_mode_FillModeComponent.propTypes = {\n  isSelected: prop_types_default.a.bool.isRequired,\n  onMouseDown: prop_types_default.a.func.isRequired\n};\n/* harmony default export */ var fill_mode = (fill_mode_FillModeComponent);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/containers/fill-mode.jsx\nfunction fill_mode_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { fill_mode_typeof = function _typeof(obj) { return typeof obj; }; } else { fill_mode_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return fill_mode_typeof(obj); }\nfunction fill_mode_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction fill_mode_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction fill_mode_createClass(Constructor, protoProps, staticProps) { if (protoProps) fill_mode_defineProperties(Constructor.prototype, protoProps); if (staticProps) fill_mode_defineProperties(Constructor, staticProps); return Constructor; }\nfunction fill_mode_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) fill_mode_setPrototypeOf(subClass, superClass); }\nfunction fill_mode_setPrototypeOf(o, p) { fill_mode_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return fill_mode_setPrototypeOf(o, p); }\nfunction fill_mode_createSuper(Derived) { var hasNativeReflectConstruct = fill_mode_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = fill_mode_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = fill_mode_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return fill_mode_possibleConstructorReturn(this, result); }; }\nfunction fill_mode_possibleConstructorReturn(self, call) { if (call && (fill_mode_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return fill_mode_assertThisInitialized(self); }\nfunction fill_mode_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction fill_mode_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction fill_mode_getPrototypeOf(o) { fill_mode_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return fill_mode_getPrototypeOf(o); }\n\nvar fill_mode_FillMode = function (_React$Component) {\n  fill_mode_inherits(FillMode, _React$Component);\n  var _super = fill_mode_createSuper(FillMode);\n  function FillMode(props) {\n    var _this;\n    fill_mode_classCallCheck(this, FillMode);\n    _this = _super.call(this, props);\n    lodash_bindall_default()(fill_mode_assertThisInitialized(_this), ['activateTool', 'deactivateTool']);\n    return _this;\n  }\n  fill_mode_createClass(FillMode, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this.props.isFillModeActive) {\n        this.activateTool(this.props);\n      }\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(nextProps) {\n      if (this.tool) {\n        if (nextProps.fillColor !== this.props.fillColor) {\n          this.tool.setFillColor(nextProps.fillColor);\n        }\n        if (nextProps.fillColor2 !== this.props.fillColor2) {\n          this.tool.setFillColor2(nextProps.fillColor2);\n        }\n        if (nextProps.hoveredItemId !== this.props.hoveredItemId) {\n          this.tool.setPrevHoveredItemId(nextProps.hoveredItemId);\n        }\n        if (nextProps.fillModeGradientType !== this.props.fillModeGradientType) {\n          this.tool.setGradientType(nextProps.fillModeGradientType);\n        }\n      }\n      if (nextProps.isFillModeActive && !this.props.isFillModeActive) {\n        this.activateTool();\n      } else if (!nextProps.isFillModeActive && this.props.isFillModeActive) {\n        this.deactivateTool();\n      }\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps) {\n      return nextProps.isFillModeActive !== this.props.isFillModeActive;\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.tool) {\n        this.deactivateTool();\n      }\n    }\n  }, {\n    key: \"activateTool\",\n    value: function activateTool() {\n      selection_clearSelection(this.props.clearSelectedItems); // Force the default fill color if fill is MIXED\n      var fillColor = this.props.fillColor;\n      if (this.props.fillColor === MIXED) {\n        fillColor = DEFAULT_COLOR;\n        this.props.onChangeFillColor(DEFAULT_COLOR, 0);\n      }\n      var gradientType = this.props.fillModeGradientType ? this.props.fillModeGradientType : this.props.fillStyleGradientType;\n      var fillColor2 = this.props.fillColor2;\n      if (gradientType !== this.props.fillStyleGradientType) {\n        if (this.props.fillStyleGradientType === gradient_types.SOLID) {\n          fillColor2 = style_path_generateSecondaryColor(fillColor);\n          this.props.onChangeFillColor(fillColor2, 1);\n        }\n        this.props.changeGradientType(gradientType);\n      }\n      if (this.props.fillColor2 === MIXED) {\n        fillColor2 = style_path_generateSecondaryColor(fillColor);\n        this.props.onChangeFillColor(fillColor2, 1);\n      }\n      this.tool = new tools_fill_tool(this.props.setHoveredItem, this.props.clearHoveredItem, this.props.onUpdateImage);\n      this.tool.setFillColor(fillColor);\n      this.tool.setFillColor2(fillColor2);\n      this.tool.setGradientType(gradientType);\n      this.tool.setPrevHoveredItemId(this.props.hoveredItemId);\n      this.tool.activate();\n    }\n  }, {\n    key: \"deactivateTool\",\n    value: function deactivateTool() {\n      this.tool.deactivateTool();\n      this.tool.remove();\n      this.tool = null;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return react_default.a.createElement(fill_mode, {\n        isSelected: this.props.isFillModeActive,\n        onMouseDown: this.props.handleMouseDown\n      });\n    }\n  }]);\n  return FillMode;\n}(react_default.a.Component);\nfill_mode_FillMode.propTypes = {\n  changeGradientType: prop_types_default.a.func.isRequired,\n  clearHoveredItem: prop_types_default.a.func.isRequired,\n  clearSelectedItems: prop_types_default.a.func.isRequired,\n  fillColor: prop_types_default.a.string,\n  fillColor2: prop_types_default.a.string,\n  fillStyleGradientType: prop_types_default.a.oneOf(Object.keys(gradient_types)).isRequired,\n  fillModeGradientType: prop_types_default.a.oneOf(Object.keys(gradient_types)),\n  handleMouseDown: prop_types_default.a.func.isRequired,\n  hoveredItemId: prop_types_default.a.number,\n  isFillModeActive: prop_types_default.a.bool.isRequired,\n  onChangeFillColor: prop_types_default.a.func.isRequired,\n  onUpdateImage: prop_types_default.a.func.isRequired,\n  setHoveredItem: prop_types_default.a.func.isRequired\n};\nvar fill_mode_mapStateToProps = function mapStateToProps(state) {\n  return {\n    fillModeGradientType: state.scratchPaint.fillMode.gradientType,\n    // Last user-selected gradient type\n    fillColor: state.scratchPaint.color.fillColor.primary,\n    fillColor2: state.scratchPaint.color.fillColor.secondary,\n    fillStyleGradientType: state.scratchPaint.color.fillColor.gradientType,\n    // Selected item(s)' gradient type\n    hoveredItemId: state.scratchPaint.hoveredItemId,\n    isFillModeActive: state.scratchPaint.mode === Modes.FILL\n  };\n};\nvar fill_mode_mapDispatchToProps = function mapDispatchToProps(dispatch) {\n  return {\n    setHoveredItem: function setHoveredItem(hoveredItemId) {\n      dispatch(hover_setHoveredItem(hoveredItemId));\n    },\n    clearHoveredItem: function clearHoveredItem() {\n      dispatch(hover_clearHoveredItem());\n    },\n    clearSelectedItems: function clearSelectedItems() {\n      dispatch(selected_items_clearSelectedItems());\n    },\n    changeGradientType: function changeGradientType(gradientType) {\n      dispatch(fill_mode_gradient_type_changeGradientType(gradientType));\n    },\n    handleMouseDown: function handleMouseDown() {\n      dispatch(modes_changeMode(Modes.FILL));\n    },\n    onChangeFillColor: function onChangeFillColor(fillColor, index) {\n      if (index === 0) {\n        dispatch(changeFillColor(fillColor));\n      } else if (index === 1) {\n        dispatch(changeFillColor2(fillColor));\n      }\n    }\n  };\n};\n/* harmony default export */ var containers_fill_mode = (Object(es[\"b\" /* connect */])(fill_mode_mapStateToProps, fill_mode_mapDispatchToProps)(fill_mode_FillMode));\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/helper/snapping.js\n/**\n * @param {paper.Point} point1 point 1\n * @param {paper.Point} point2 point 2\n * @param {number} tolerance Distance allowed between points that are \"touching\"\n * @return {boolean} true if points are within the tolerance distance.\n */\nvar snapping_touching = function touching(point1, point2, tolerance) {\n  return point1.getDistance(point2, true) < Math.pow(tolerance / paper_full_default.a.view.zoom, 2);\n};\n/**\n * @param {!paper.Point} point Point to check line endpoint hits against\n * @param {!number} tolerance Distance within which it counts as a hit\n * @param {?paper.Path} excludePath Path to exclude from hit test, if any. For instance, you\n *     are drawing a line and don't want it to snap to its own start point.\n * @return {object} data about the end point of an unclosed path, if any such point is within the\n *     tolerance distance of the given point, or null if none exists.\n */\nvar snapping_endPointHit = function endPointHit(point, tolerance, excludePath) {\n  var lines = selection_getItems({\n    class: paper_full_default.a.Path\n  }); // Prefer more recent lines\n  for (var i = lines.length - 1; i >= 0; i--) {\n    if (lines[i].closed) {\n      continue;\n    }\n    if (!(lines[i].parent instanceof paper_full_default.a.Layer)) {\n      // Don't connect to lines inside of groups\n      continue;\n    }\n    if (excludePath && lines[i] === excludePath) {\n      continue;\n    }\n    if (lines[i].firstSegment && snapping_touching(lines[i].firstSegment.point, point, tolerance)) {\n      return {\n        path: lines[i],\n        segment: lines[i].firstSegment,\n        isFirst: true\n      };\n    }\n    if (lines[i].lastSegment && snapping_touching(lines[i].lastSegment.point, point, tolerance)) {\n      return {\n        path: lines[i],\n        segment: lines[i].lastSegment,\n        isFirst: false\n      };\n    }\n  }\n  return null;\n};\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/reducers/stroke-width.js\nvar CHANGE_STROKE_WIDTH = 'scratch-paint/stroke-width/CHANGE_STROKE_WIDTH';\nvar MAX_STROKE_WIDTH = 100;\nvar stroke_width_initialState = 4;\nvar stroke_width_reducer = function reducer(state, action) {\n  if (typeof state === 'undefined') state = stroke_width_initialState;\n  switch (action.type) {\n    case CHANGE_STROKE_WIDTH:\n      if (isNaN(action.strokeWidth)) {\n        log.warn(\"Invalid brush size: \".concat(action.strokeWidth));\n        return state;\n      }\n      return Math.min(MAX_STROKE_WIDTH, Math.max(0, action.strokeWidth));\n    case CHANGE_SELECTED_ITEMS:\n      // Don't change state if no selection\n      if (!action.selectedItems || !action.selectedItems.length) {\n        return state;\n      } // Bitmap mode doesn't have stroke width\n      if (action.bitmapMode) {\n        return state;\n      }\n      return style_path_getColorsFromSelection(action.selectedItems, action.bitmapMode).strokeWidth;\n    default:\n      return state;\n  }\n}; // Action creators ==================================\nvar changeStrokeWidth = function changeStrokeWidth(strokeWidth) {\n  return {\n    type: CHANGE_STROKE_WIDTH,\n    strokeWidth: strokeWidth\n  };\n};\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/reducers/stroke-style.js\nfunction stroke_style_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\nfunction stroke_style_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { stroke_style_ownKeys(Object(source), true).forEach(function (key) { stroke_style_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { stroke_style_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\nfunction stroke_style_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nvar CHANGE_STROKE_COLOR = 'scratch-paint/stroke-style/CHANGE_STROKE_COLOR';\nvar CHANGE_STROKE_COLOR_2 = 'scratch-paint/stroke-style/CHANGE_STROKE_COLOR_2';\nvar CHANGE_STROKE_GRADIENT_TYPE = 'scratch-paint/stroke-style/CHANGE_STROKE_GRADIENT_TYPE';\nvar CLEAR_STROKE_GRADIENT = 'scratch-paint/stroke-style/CLEAR_STROKE_GRADIENT';\nvar stroke_style_DEFAULT_COLOR = '#000000';\nvar stroke_style_reducer = make_color_style_reducer({\n  changePrimaryColorAction: CHANGE_STROKE_COLOR,\n  changeSecondaryColorAction: CHANGE_STROKE_COLOR_2,\n  changeGradientTypeAction: CHANGE_STROKE_GRADIENT_TYPE,\n  clearGradientAction: CLEAR_STROKE_GRADIENT,\n  defaultColor: stroke_style_DEFAULT_COLOR,\n  selectionPrimaryColorKey: 'strokeColor',\n  selectionSecondaryColorKey: 'strokeColor2',\n  selectionGradientTypeKey: 'strokeGradientType'\n}); // This is mostly the same as the generated reducer, but with one piece of extra logic to set the color to null when the\n// stroke width is set to 0.\n// https://redux.js.org/recipes/structuring-reducers/reusing-reducer-logic\nvar stroke_style_strokeReducer = function strokeReducer(state, action) {\n  if (action.type === CHANGE_STROKE_WIDTH && Math.max(action.strokeWidth, 0) === 0) {\n    // TODO: this preserves the gradient type when you change the stroke width to 0.\n    // Alternatively, we could set gradientType to SOLID instead of setting secondary to null, but since\n    // the stroke width is automatically set to 0 as soon as a \"null\" color is detected (including a gradient for\n    // which both colors are null), that would change the gradient type back to solid if you selected null for both\n    // gradient colors.\n    return stroke_style_objectSpread(stroke_style_objectSpread({}, state), {}, {\n      primary: null,\n      secondary: null\n    });\n  }\n  return stroke_style_reducer(state, action);\n}; // Action creators ==================================\nvar changeStrokeColor = function changeStrokeColor(strokeColor) {\n  return {\n    type: CHANGE_STROKE_COLOR,\n    color: strokeColor\n  };\n};\nvar changeStrokeColor2 = function changeStrokeColor2(strokeColor) {\n  return {\n    type: CHANGE_STROKE_COLOR_2,\n    color: strokeColor\n  };\n};\nvar changeStrokeGradientType = function changeStrokeGradientType(gradientType) {\n  return {\n    type: CHANGE_STROKE_GRADIENT_TYPE,\n    gradientType: gradientType\n  };\n};\nvar stroke_style_clearStrokeGradient = function clearStrokeGradient() {\n  return {\n    type: CLEAR_STROKE_GRADIENT\n  };\n};\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/line-mode/line.svg\nvar line_mode_line = __webpack_require__(612);\nvar line_mode_line_default = __webpack_require__.n(line_mode_line);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/components/line-mode/line-mode.jsx\n\nvar line_mode_LineModeComponent = function LineModeComponent(props) {\n  return react_default.a.createElement(tool_select_base_tool_select_base, {\n    imgDescriptor: lib_messages.line,\n    imgSrc: line_mode_line_default.a,\n    isSelected: props.isSelected,\n    onMouseDown: props.onMouseDown\n  });\n};\nline_mode_LineModeComponent.propTypes = {\n  isSelected: prop_types_default.a.bool.isRequired,\n  onMouseDown: prop_types_default.a.func.isRequired\n};\n/* harmony default export */ var line_mode = (line_mode_LineModeComponent);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/containers/line-mode.jsx\nfunction line_mode_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { line_mode_typeof = function _typeof(obj) { return typeof obj; }; } else { line_mode_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return line_mode_typeof(obj); }\nfunction line_mode_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction line_mode_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction line_mode_createClass(Constructor, protoProps, staticProps) { if (protoProps) line_mode_defineProperties(Constructor.prototype, protoProps); if (staticProps) line_mode_defineProperties(Constructor, staticProps); return Constructor; }\nfunction line_mode_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) line_mode_setPrototypeOf(subClass, superClass); }\nfunction line_mode_setPrototypeOf(o, p) { line_mode_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return line_mode_setPrototypeOf(o, p); }\nfunction line_mode_createSuper(Derived) { var hasNativeReflectConstruct = line_mode_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = line_mode_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = line_mode_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return line_mode_possibleConstructorReturn(this, result); }; }\nfunction line_mode_possibleConstructorReturn(self, call) { if (call && (line_mode_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return line_mode_assertThisInitialized(self); }\nfunction line_mode_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction line_mode_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction line_mode_getPrototypeOf(o) { line_mode_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return line_mode_getPrototypeOf(o); }\n\nvar line_mode_LineMode = function (_React$Component) {\n  line_mode_inherits(LineMode, _React$Component);\n  var _super = line_mode_createSuper(LineMode);\n  line_mode_createClass(LineMode, null, [{\n    key: \"SNAP_TOLERANCE\",\n    get: function get() {\n      return 6;\n    }\n  }, {\n    key: \"DEFAULT_COLOR\",\n    get: function get() {\n      return '#000000';\n    }\n  }]);\n  function LineMode(props) {\n    var _this;\n    line_mode_classCallCheck(this, LineMode);\n    _this = _super.call(this, props);\n    lodash_bindall_default()(line_mode_assertThisInitialized(_this), ['activateTool', 'deactivateTool', 'drawHitPoint', 'onMouseDown', 'onMouseMove', 'onMouseDrag', 'onMouseUp']);\n    return _this;\n  }\n  line_mode_createClass(LineMode, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this.props.isLineModeActive) {\n        this.activateTool();\n      }\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(nextProps) {\n      if (nextProps.isLineModeActive && !this.props.isLineModeActive) {\n        this.activateTool();\n      } else if (!nextProps.isLineModeActive && this.props.isLineModeActive) {\n        this.deactivateTool();\n      }\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps) {\n      return nextProps.isLineModeActive !== this.props.isLineModeActive;\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.tool) {\n        this.deactivateTool();\n      }\n    }\n  }, {\n    key: \"activateTool\",\n    value: function activateTool() {\n      selection_clearSelection(this.props.clearSelectedItems); // Force the default line color if stroke is MIXED or transparent\n      var strokeColor1 = this.props.colorState.strokeColor.primary;\n      var strokeColor2 = this.props.colorState.strokeColor.secondary;\n      if (strokeColor1 === MIXED || strokeColor1 === null && (strokeColor2 === null || strokeColor2 === MIXED)) {\n        this.props.onChangeStrokeColor(LineMode.DEFAULT_COLOR);\n      }\n      if (strokeColor2 === MIXED) {\n        this.props.clearStrokeGradient();\n      } // Force a minimum stroke width\n      if (!this.props.colorState.strokeWidth) {\n        this.props.onChangeStrokeWidth(1);\n      }\n      this.tool = new paper_full_default.a.Tool();\n      this.active = false;\n      this.path = null;\n      this.hitResult = null;\n      var lineMode = this;\n      this.tool.onMouseDown = function (event) {\n        if (event.event.button > 0) return; // only first mouse button\n        lineMode.onMouseDown(event);\n      };\n      this.tool.onMouseMove = function (event) {\n        lineMode.onMouseMove(event);\n      };\n      this.tool.onMouseDrag = function (event) {\n        if (event.event.button > 0) return; // only first mouse button\n        lineMode.onMouseDrag(event);\n      };\n      this.tool.onMouseUp = function (event) {\n        if (event.event.button > 0) return; // only first mouse button\n        lineMode.onMouseUp(event);\n      };\n      this.tool.activate();\n    }\n  }, {\n    key: \"onMouseDown\",\n    value: function onMouseDown(event) {\n      if (event.event.button > 0) return; // only first mouse button\n      this.active = true; // If you click near a point, continue that line instead of making a new line\n      this.hitResult = snapping_endPointHit(event.point, LineMode.SNAP_TOLERANCE);\n      if (this.hitResult) {\n        this.path = this.hitResult.path;\n        style_path_styleShape(this.path, {\n          fillColor: null,\n          strokeColor: this.props.colorState.strokeColor,\n          strokeWidth: this.props.colorState.strokeWidth\n        });\n        if (this.hitResult.isFirst) {\n          this.path.reverse();\n        }\n        this.path.lastSegment.handleOut = null; // Make sure added line isn't made curvy\n        this.path.add(this.hitResult.segment.point); // Add second point, which is what will move when dragged\n      } // If not near other path, start a new path\n      if (!this.path) {\n        this.path = new paper_full_default.a.Path();\n        this.path.strokeCap = 'round';\n        style_path_styleShape(this.path, {\n          fillColor: null,\n          strokeColor: this.props.colorState.strokeColor,\n          strokeWidth: this.props.colorState.strokeWidth\n        });\n        this.path.add(event.point);\n        this.path.add(event.point); // Add second point, which is what will move when dragged\n      }\n    }\n  }, {\n    key: \"drawHitPoint\",\n    value: function drawHitPoint(hitResult) {\n      // If near another path's endpoint, draw hit point to indicate that paths would merge\n      if (hitResult) {\n        var hitPath = hitResult.path;\n        if (hitResult.isFirst) {\n          guides_drawHitPoint(hitPath.firstSegment.point);\n        } else {\n          guides_drawHitPoint(hitPath.lastSegment.point);\n        }\n      }\n    }\n  }, {\n    key: \"onMouseMove\",\n    value: function onMouseMove(event) {\n      if (this.hitResult) {\n        removeHitPoint();\n      }\n      this.hitResult = snapping_endPointHit(event.point, LineMode.SNAP_TOLERANCE);\n      this.drawHitPoint(this.hitResult);\n    }\n  }, {\n    key: \"onMouseDrag\",\n    value: function onMouseDrag(event) {\n      if (event.event.button > 0 || !this.active) return; // only first mouse button\n      // Clear the last hit result\n      if (this.hitResult) {\n        removeHitPoint();\n        this.hitResult = null;\n      } // If shift is held, act like event.point always lies on a straight or 45 degree line from the last point\n      var endPoint = event.point;\n      if (event.modifiers.shift) {\n        var line = event.point.subtract(this.path.lastSegment.previous.point);\n        endPoint = this.path.lastSegment.previous.point.add(math_snapDeltaToAngle(line, Math.PI / 4));\n      } // Find an end point that endPoint is close to (to snap lines together)\n      if (this.path && !this.path.closed && this.path.segments.length > 3 && snapping_touching(this.path.firstSegment.point, endPoint, LineMode.SNAP_TOLERANCE)) {\n        this.hitResult = {\n          path: this.path,\n          segment: this.path.firstSegment,\n          isFirst: true\n        };\n      } else {\n        this.hitResult = snapping_endPointHit(endPoint, LineMode.SNAP_TOLERANCE, this.path);\n      } // If shift is being held, we shouldn't snap to end points that change the slope by too much.\n      // In that case, clear the hit result.\n      if (this.hitResult && event.modifiers.shift) {\n        var lineToSnap = this.hitResult.segment.point.subtract(this.path.lastSegment.previous.point);\n        var lineToEndPoint = endPoint.subtract(this.path.lastSegment.previous.point);\n        if (lineToSnap.normalize().getDistance(lineToEndPoint.normalize()) > 1e-2) {\n          this.hitResult = null;\n        }\n      } // If near another path's endpoint, or this path's beginpoint, clip to it to suggest\n      // joining/closing the paths.\n      if (this.hitResult) {\n        this.drawHitPoint(this.hitResult);\n        this.path.lastSegment.point = this.hitResult.segment.point;\n      } else {\n        this.path.lastSegment.point = endPoint;\n      }\n      style_path_styleShape(this.path, {\n        fillColor: null,\n        strokeColor: this.props.colorState.strokeColor,\n        strokeWidth: this.props.colorState.strokeWidth\n      });\n    }\n  }, {\n    key: \"onMouseUp\",\n    value: function onMouseUp(event) {\n      if (event.event.button > 0 || !this.active) return; // only first mouse button\n      // If I single clicked, don't do anything\n      if (this.path.segments.length < 2 || this.path.segments.length === 2 && snapping_touching(this.path.firstSegment.point, event.point, LineMode.SNAP_TOLERANCE) && !this.hitResult) {\n        // Let lines be short if you're connecting them\n        this.path.remove();\n        this.path = null;\n        return;\n      } else if (!this.hitResult && snapping_touching(this.path.lastSegment.point, this.path.segments[this.path.segments.length - 2].point, LineMode.SNAP_TOLERANCE)) {\n        // Single click or short drag on an existing path end point\n        this.path.removeSegment(this.path.segments.length - 1);\n        this.path = null;\n        return;\n      } // If I intersect other line end points, join or close\n      if (this.hitResult) {\n        this.path.removeSegment(this.path.segments.length - 1);\n        if (this.path.firstSegment.point.equals(this.hitResult.segment.point)) {\n          this.path.firstSegment.handleIn = null; // Make sure added line isn't made curvy\n          // close path\n          this.path.closed = true;\n        } else {\n          // joining two paths\n          if (!this.hitResult.isFirst) {\n            this.hitResult.path.reverse();\n          }\n          this.hitResult.path.firstSegment.handleIn = null; // Make sure added line isn't made curvy\n          this.path.join(this.hitResult.path);\n        }\n        removeHitPoint();\n        this.hitResult = null;\n      }\n      style_path_styleShape(this.path, {\n        fillColor: null,\n        strokeColor: this.props.colorState.strokeColor,\n        strokeWidth: this.props.colorState.strokeWidth\n      });\n      if (this.path) {\n        this.props.onUpdateImage();\n        this.path = null;\n      }\n      this.active = false;\n    }\n  }, {\n    key: \"deactivateTool\",\n    value: function deactivateTool() {\n      this.tool.remove();\n      this.tool = null;\n      if (this.hitResult) {\n        removeHitPoint();\n        this.hitResult = null;\n      }\n      if (this.path) {\n        this.path = null;\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return react_default.a.createElement(line_mode, {\n        isSelected: this.props.isLineModeActive,\n        onMouseDown: this.props.handleMouseDown\n      });\n    }\n  }]);\n  return LineMode;\n}(react_default.a.Component);\nline_mode_LineMode.propTypes = {\n  clearSelectedItems: prop_types_default.a.func.isRequired,\n  clearStrokeGradient: prop_types_default.a.func.isRequired,\n  colorState: prop_types_default.a.shape({\n    fillColor: color_style_proptype,\n    strokeColor: color_style_proptype,\n    strokeWidth: prop_types_default.a.number\n  }).isRequired,\n  handleMouseDown: prop_types_default.a.func.isRequired,\n  isLineModeActive: prop_types_default.a.bool.isRequired,\n  onChangeStrokeColor: prop_types_default.a.func.isRequired,\n  onChangeStrokeWidth: prop_types_default.a.func.isRequired,\n  onUpdateImage: prop_types_default.a.func.isRequired\n};\nvar line_mode_mapStateToProps = function mapStateToProps(state) {\n  return {\n    colorState: state.scratchPaint.color,\n    isLineModeActive: state.scratchPaint.mode === Modes.LINE\n  };\n};\nvar line_mode_mapDispatchToProps = function mapDispatchToProps(dispatch) {\n  return {\n    clearSelectedItems: function clearSelectedItems() {\n      dispatch(selected_items_clearSelectedItems());\n    },\n    clearStrokeGradient: function clearStrokeGradient() {\n      dispatch(stroke_style_clearStrokeGradient());\n    },\n    handleMouseDown: function handleMouseDown() {\n      dispatch(modes_changeMode(Modes.LINE));\n    },\n    onChangeStrokeColor: function onChangeStrokeColor(strokeColor) {\n      dispatch(changeStrokeColor(strokeColor));\n    },\n    onChangeStrokeWidth: function onChangeStrokeWidth(strokeWidth) {\n      dispatch(changeStrokeWidth(strokeWidth));\n    }\n  };\n};\n/* harmony default export */ var containers_line_mode = (Object(es[\"b\" /* connect */])(line_mode_mapStateToProps, line_mode_mapDispatchToProps)(line_mode_LineMode));\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/helper/tools/eye-dropper.js\nfunction eye_dropper_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { eye_dropper_typeof = function _typeof(obj) { return typeof obj; }; } else { eye_dropper_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return eye_dropper_typeof(obj); }\nfunction eye_dropper_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction eye_dropper_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction eye_dropper_createClass(Constructor, protoProps, staticProps) { if (protoProps) eye_dropper_defineProperties(Constructor.prototype, protoProps); if (staticProps) eye_dropper_defineProperties(Constructor, staticProps); return Constructor; }\nfunction eye_dropper_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) eye_dropper_setPrototypeOf(subClass, superClass); }\nfunction eye_dropper_setPrototypeOf(o, p) { eye_dropper_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return eye_dropper_setPrototypeOf(o, p); }\nfunction eye_dropper_createSuper(Derived) { var hasNativeReflectConstruct = eye_dropper_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = eye_dropper_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = eye_dropper_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return eye_dropper_possibleConstructorReturn(this, result); }; }\nfunction eye_dropper_possibleConstructorReturn(self, call) { if (call && (eye_dropper_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return eye_dropper_assertThisInitialized(self); }\nfunction eye_dropper_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction eye_dropper_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction eye_dropper_getPrototypeOf(o) { eye_dropper_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return eye_dropper_getPrototypeOf(o); }\nvar LOUPE_RADIUS = 20;\nvar ZOOM_SCALE = 3;\nvar eye_dropper_EyeDropperTool = function (_paper$Tool) {\n  eye_dropper_inherits(EyeDropperTool, _paper$Tool);\n  var _super = eye_dropper_createSuper(EyeDropperTool);\n  function EyeDropperTool(canvas, width, height, pixelRatio, zoom, offsetX, offsetY, isBitmap) {\n    var _this;\n    eye_dropper_classCallCheck(this, EyeDropperTool);\n    _this = _super.call(this);\n    var layer = isBitmap ? getRaster().layer : paper_full_default.a.project.activeLayer;\n    var contentRaster3x = layer.rasterize(72 * ZOOM_SCALE * paper_full_default.a.view.zoom, false\n    /* insert */\n    , paper_full_default.a.view.bounds);\n    var backgroundRaster3x = getBackgroundGuideLayer().rasterize(72 * ZOOM_SCALE * paper_full_default.a.view.zoom, false\n    /* insert */\n    , paper_full_default.a.view.bounds); // Canvas from which loupe is cut, shows art and grid\n    _this.bufferCanvas = layer_createCanvas(canvas.width * ZOOM_SCALE, canvas.height * ZOOM_SCALE);\n    var bufferCanvasContext = _this.bufferCanvas.getContext('2d',{willReadFrequently:true}); // Canvas to sample colors from; just the art\n    _this.colorCanvas = layer_createCanvas(canvas.width * ZOOM_SCALE, canvas.height * ZOOM_SCALE);\n    var colorCanvasContext = _this.colorCanvas.getContext('2d',{willReadFrequently:true});\n    backgroundRaster3x.onLoad = function () {\n      bufferCanvasContext.drawImage(backgroundRaster3x.canvas, 0, 0);\n      contentRaster3x.onLoad = function () {\n        colorCanvasContext.drawImage(contentRaster3x.canvas, 0, 0);\n        bufferCanvasContext.drawImage(_this.colorCanvas, 0, 0);\n        _this.bufferLoaded = true;\n      };\n      if (contentRaster3x.loaded) contentRaster3x.onLoad();\n    };\n    _this.onMouseDown = _this.handleMouseDown;\n    _this.onMouseUp = _this.handleMouseUp;\n    _this.onMouseMove = _this.handleMouseMove;\n    _this.canvas = canvas;\n    _this.pixelRatio = pixelRatio;\n    _this.zoom = zoom;\n    _this.offsetX = offsetX;\n    _this.offsetY = offsetY;\n    _this.width = width * _this.zoom * _this.pixelRatio;\n    _this.height = height * _this.zoom * _this.pixelRatio;\n    _this.rect = canvas.getBoundingClientRect();\n    _this.colorString = '';\n    _this.pickX = -1;\n    _this.pickY = -1;\n    _this.hideLoupe = true;\n    return _this;\n  }\n  eye_dropper_createClass(EyeDropperTool, [{\n    key: \"handleMouseMove\",\n    value: function handleMouseMove(event) {\n      // Set the pickX/Y for the color picker loop to pick up\n      this.pickX = (event.point.x - this.offsetX) * this.zoom * this.pixelRatio;\n      this.pickY = (event.point.y - this.offsetY) * this.zoom * this.pixelRatio; // check if the x/y are outside of the canvas\n      this.hideLoupe = this.pickX > this.width || this.pickX < 0 || this.pickY > this.height || this.pickY < 0;\n    }\n  }, {\n    key: \"handleMouseDown\",\n    value: function handleMouseDown(event) {\n      // Nothing special on mousedown, just send to move handler which will show the loupe,\n      // and the mouse up handler submits the color. This allows touch to drag\n      // with the loupe visible to find the correct color\n      this.handleMouseMove(event);\n    }\n  }, {\n    key: \"handleMouseUp\",\n    value: function handleMouseUp() {\n      if (!this.hideLoupe) {\n        var colorInfo = this.getColorInfo(this.pickX, this.pickY, this.hideLoupe);\n        if (!colorInfo) return;\n        if (colorInfo.color[3] === 0) {\n          // Alpha 0\n          this.colorString = null;\n          return;\n        }\n        var r = colorInfo.color[0];\n        var g = colorInfo.color[1];\n        var b = colorInfo.color[2]; // from https://github.com/LLK/scratch-gui/blob/77e54a80a31b6cd4684d4b2a70f1aeec671f229e/src/containers/stage.jsx#L218-L222\n        // formats the color info from the canvas into hex for parsing by the color picker\n        var componentToString = function componentToString(c) {\n          var hex = c.toString(16);\n          return hex.length === 1 ? \"0\".concat(hex) : hex;\n        };\n        this.colorString = \"#\".concat(componentToString(r)).concat(componentToString(g)).concat(componentToString(b));\n      }\n    }\n  }, {\n    key: \"getColorInfo\",\n    value: function getColorInfo(x, y, hideLoupe) {\n      var artX = x / this.pixelRatio;\n      var artY = y / this.pixelRatio;\n      if (!this.bufferLoaded) return null;\n      var colorContext = this.colorCanvas.getContext('2d',{willReadFrequently:true});\n      var bufferContext = this.bufferCanvas.getContext('2d',{willReadFrequently:true});\n      var colors = colorContext.getImageData(artX * ZOOM_SCALE, artY * ZOOM_SCALE, 1, 1);\n      return {\n        x: x,\n        y: y,\n        color: colors.data,\n        data: bufferContext.getImageData(ZOOM_SCALE * (artX - LOUPE_RADIUS), ZOOM_SCALE * (artY - LOUPE_RADIUS), LOUPE_RADIUS * 2 * ZOOM_SCALE, LOUPE_RADIUS * 2 * ZOOM_SCALE).data,\n        hideLoupe: hideLoupe\n      };\n    }\n  }]);\n  return EyeDropperTool;\n}(paper_full_default.a.Tool);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/loupe/loupe.css\nvar loupe = __webpack_require__(613);\nvar loupe_default = __webpack_require__.n(loupe);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/components/loupe/loupe.jsx\nfunction loupe_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { loupe_typeof = function _typeof(obj) { return typeof obj; }; } else { loupe_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return loupe_typeof(obj); }\nfunction loupe_extends() { loupe_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return loupe_extends.apply(this, arguments); }\nfunction loupe_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = loupe_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction loupe_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\nfunction loupe_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction loupe_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction loupe_createClass(Constructor, protoProps, staticProps) { if (protoProps) loupe_defineProperties(Constructor.prototype, protoProps); if (staticProps) loupe_defineProperties(Constructor, staticProps); return Constructor; }\nfunction loupe_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) loupe_setPrototypeOf(subClass, superClass); }\nfunction loupe_setPrototypeOf(o, p) { loupe_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return loupe_setPrototypeOf(o, p); }\nfunction loupe_createSuper(Derived) { var hasNativeReflectConstruct = loupe_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = loupe_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = loupe_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return loupe_possibleConstructorReturn(this, result); }; }\nfunction loupe_possibleConstructorReturn(self, call) { if (call && (loupe_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return loupe_assertThisInitialized(self); }\nfunction loupe_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction loupe_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction loupe_getPrototypeOf(o) { loupe_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return loupe_getPrototypeOf(o); }\n\nvar loupe_LoupeComponent = function (_React$Component) {\n  loupe_inherits(LoupeComponent, _React$Component);\n  var _super = loupe_createSuper(LoupeComponent);\n  function LoupeComponent(props) {\n    var _this;\n    loupe_classCallCheck(this, LoupeComponent);\n    _this = _super.call(this, props);\n    lodash_bindall_default()(loupe_assertThisInitialized(_this), ['setCanvas']);\n    return _this;\n  }\n  loupe_createClass(LoupeComponent, [{\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      this.draw();\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var boxSize = 5;\n      var boxLineWidth = 1;\n      var colorRingWidth = 15;\n      var loupeRadius = ZOOM_SCALE * LOUPE_RADIUS;\n      var loupeDiameter = loupeRadius * 2;\n      var color = this.props.colorInfo.color;\n      var ctx = this.canvas.getContext('2d',{willReadFrequently:true});\n      this.canvas.width = loupeDiameter;\n      this.canvas.height = loupeDiameter;\n      ctx.fillStyle = 'white';\n      ctx.fillRect(0, 0, loupeDiameter, loupeDiameter); // In order to scale the image data, must draw to a tmp canvas first\n      var tmpCanvas = document.createElement('canvas');\n      tmpCanvas.width = loupeDiameter;\n      tmpCanvas.height = loupeDiameter;\n      var tmpCtx = tmpCanvas.getContext('2d',{willReadFrequently:true});\n      var imageData = tmpCtx.createImageData(loupeDiameter, loupeDiameter); // Since the color info comes from elsewhere there is no guarantee\n      // about the size. Make sure it matches to prevent data.set from throwing.\n      // See issue #966 for example of how that can happen.\n      if (this.props.colorInfo.data.length === imageData.data.length) {\n        imageData.data.set(this.props.colorInfo.data);\n      } else {\n      //console.warn('Image data size mismatch drawing loupe'); // eslint-disable-line no-console\n      }\n      tmpCtx.putImageData(imageData, 0, 0); // Scale the loupe canvas and draw the zoomed image\n      ctx.drawImage(tmpCanvas, 0, 0); // Draw an outlined square at the cursor position (cursor is hidden)\n      ctx.lineWidth = boxLineWidth;\n      ctx.strokeStyle = 'black';\n      ctx.fillStyle = \"rgba(\".concat(color[0], \", \").concat(color[1], \", \").concat(color[2], \", \").concat(color[3], \")\");\n      ctx.beginPath();\n      ctx.rect(loupeRadius - boxSize / 2, loupeRadius - boxSize / 2, boxSize, boxSize);\n      ctx.fill();\n      ctx.stroke(); // Draw a thick ring around the loupe showing the current color\n      ctx.strokeStyle = \"rgba(\".concat(color[0], \", \").concat(color[1], \", \").concat(color[2], \", \").concat(color[3], \")\");\n      ctx.lineWidth = colorRingWidth;\n      ctx.beginPath();\n      ctx.moveTo(loupeDiameter, loupeDiameter);\n      ctx.arc(loupeRadius, loupeRadius, loupeRadius, 0, 2 * Math.PI);\n      ctx.stroke();\n    }\n  }, {\n    key: \"setCanvas\",\n    value: function setCanvas(element) {\n      this.canvas = element; // Make sure to draw a frame when this component is first mounted\n      // Check for null ref because refs are called with null when unmounted\n      if (this.canvas) {\n        this.draw();\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          colorInfo = _this$props.colorInfo,\n          pixelRatio = _this$props.pixelRatio,\n          boxProps = loupe_objectWithoutProperties(_this$props, [\"colorInfo\", \"pixelRatio\"]);\n      var loupeDiameter = ZOOM_SCALE * LOUPE_RADIUS * 2;\n      return react_default.a.createElement(box[\"a\" /* default */], loupe_extends({}, boxProps, {\n        className: loupe_default.a.eyeDropper,\n        componentRef: this.setCanvas,\n        element: \"canvas\",\n        height: LOUPE_RADIUS * 2,\n        style: {\n          top: colorInfo.y / pixelRatio - loupeDiameter / 2,\n          left: colorInfo.x / pixelRatio - loupeDiameter / 2,\n          width: loupeDiameter,\n          height: loupeDiameter\n        },\n        width: LOUPE_RADIUS * 2\n      }));\n    }\n  }]);\n  return LoupeComponent;\n}(react_default.a.Component);\nloupe_LoupeComponent.propTypes = {\n  colorInfo: prop_types_default.a.shape({\n    color: prop_types_default.a.instanceOf(Uint8ClampedArray),\n    // this is the [r,g,b,a] array\n    x: prop_types_default.a.number,\n    y: prop_types_default.a.number,\n    data: prop_types_default.a.instanceOf(Uint8ClampedArray)\n  }),\n  pixelRatio: prop_types_default.a.number.isRequired\n};\n/* harmony default export */ var loupe_loupe = (loupe_LoupeComponent);\n// EXTERNAL MODULE: ./node_modules/react-responsive/dist/react-responsive.js\nvar react_responsive = __webpack_require__(143);\nvar react_responsive_default = __webpack_require__.n(react_responsive);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/helper/order.js\nfunction order_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = order_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction order_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return order_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return order_arrayLikeToArray(o, minLen); }\nfunction order_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nvar order_bringToFront = function bringToFront(onUpdateImage) {\n  var items = selection_getSelectedRootItems();\n  var _iterator = order_createForOfIteratorHelper(items),\n      _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var item = _step.value;\n      item.bringToFront();\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  onUpdateImage();\n};\nvar order_sendToBack = function sendToBack(onUpdateImage) {\n  var items = selection_getSelectedRootItems();\n  for (var i = items.length - 1; i >= 0; i--) {\n    items[i].sendToBack();\n  }\n  onUpdateImage();\n};\nvar order_bringForward = function bringForward(onUpdateImage) {\n  var items = selection_getSelectedRootItems(); // Already at front\n  if (items.length === 0 || !items[items.length - 1].nextSibling) {\n    return;\n  }\n  var nextSibling = items[items.length - 1].nextSibling;\n  for (var i = items.length - 1; i >= 0; i--) {\n    items[i].insertAbove(nextSibling);\n  }\n  onUpdateImage();\n};\nvar order_sendBackward = function sendBackward(onUpdateImage) {\n  var items = selection_getSelectedRootItems(); // Already at front\n  if (items.length === 0 || !items[0].previousSibling) {\n    return;\n  }\n  var previousSibling = items[0].previousSibling;\n  var _iterator2 = order_createForOfIteratorHelper(items),\n      _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var item = _step2.value;\n      item.insertBelow(previousSibling);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  onUpdateImage();\n};\nvar order_shouldShowSendBackward = function shouldShowSendBackward() {\n  var items = selection_getSelectedRootItems();\n  if (items.length === 0 || !items[0].previousSibling) {\n    return false;\n  }\n  return true;\n};\nvar order_shouldShowBringForward = function shouldShowBringForward() {\n  var items = selection_getSelectedRootItems();\n  if (items.length === 0 || !items[items.length - 1].nextSibling) {\n    return false;\n  }\n  return true;\n};\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/components/forms/buffered-input-hoc.jsx\nfunction buffered_input_hoc_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { buffered_input_hoc_typeof = function _typeof(obj) { return typeof obj; }; } else { buffered_input_hoc_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return buffered_input_hoc_typeof(obj); }\nfunction buffered_input_hoc_extends() { buffered_input_hoc_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return buffered_input_hoc_extends.apply(this, arguments); }\nfunction buffered_input_hoc_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction buffered_input_hoc_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction buffered_input_hoc_createClass(Constructor, protoProps, staticProps) { if (protoProps) buffered_input_hoc_defineProperties(Constructor.prototype, protoProps); if (staticProps) buffered_input_hoc_defineProperties(Constructor, staticProps); return Constructor; }\nfunction buffered_input_hoc_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) buffered_input_hoc_setPrototypeOf(subClass, superClass); }\nfunction buffered_input_hoc_setPrototypeOf(o, p) { buffered_input_hoc_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return buffered_input_hoc_setPrototypeOf(o, p); }\nfunction buffered_input_hoc_createSuper(Derived) { var hasNativeReflectConstruct = buffered_input_hoc_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = buffered_input_hoc_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = buffered_input_hoc_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return buffered_input_hoc_possibleConstructorReturn(this, result); }; }\nfunction buffered_input_hoc_possibleConstructorReturn(self, call) { if (call && (buffered_input_hoc_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return buffered_input_hoc_assertThisInitialized(self); }\nfunction buffered_input_hoc_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction buffered_input_hoc_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction buffered_input_hoc_getPrototypeOf(o) { buffered_input_hoc_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return buffered_input_hoc_getPrototypeOf(o); }\n/* DO NOT EDIT\n@todo This file is copied from GUI and should be pulled out into a shared library.\nSee https://github.com/LLK/scratch-paint/issues/13 */\n/**\n * Higher Order Component to manage inputs that submit on blur and <enter>\n * @param {React.Component} Input text input that consumes onChange, onBlur, onKeyPress\n * @returns {React.Component} Buffered input that calls onSubmit on blur and <enter>\n */\n/* harmony default export */ var buffered_input_hoc = (function (Input) {\n  var BufferedInput = function (_React$Component) {\n    buffered_input_hoc_inherits(BufferedInput, _React$Component);\n    var _super = buffered_input_hoc_createSuper(BufferedInput);\n    function BufferedInput(props) {\n      var _this;\n      buffered_input_hoc_classCallCheck(this, BufferedInput);\n      _this = _super.call(this, props);\n      lodash_bindall_default()(buffered_input_hoc_assertThisInitialized(_this), ['handleChange', 'handleKeyPress', 'handleFlush']);\n      _this.state = {\n        value: null\n      };\n      return _this;\n    }\n    buffered_input_hoc_createClass(BufferedInput, [{\n      key: \"handleKeyPress\",\n      value: function handleKeyPress(e) {\n        if (e.key === 'Enter') {\n          this.handleFlush();\n          e.target.blur();\n        }\n      }\n    }, {\n      key: \"handleFlush\",\n      value: function handleFlush() {\n        var isNumeric = typeof this.props.value === 'number';\n        var validatesNumeric = isNumeric ? !isNaN(this.state.value) : true;\n        if (this.state.value !== null && validatesNumeric) {\n          this.props.onSubmit(isNumeric ? Number(this.state.value) : this.state.value);\n        }\n        this.setState({\n          value: null\n        });\n      }\n    }, {\n      key: \"handleChange\",\n      value: function handleChange(e) {\n        this.setState({\n          value: e.target.value\n        });\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var bufferedValue = this.state.value === null ? this.props.value : this.state.value;\n        return react_default.a.createElement(Input, buffered_input_hoc_extends({}, this.props, {\n          value: bufferedValue,\n          onBlur: this.handleFlush,\n          onChange: this.handleChange,\n          onKeyPress: this.handleKeyPress\n        }));\n      }\n    }]);\n    return BufferedInput;\n  }(react_default.a.Component);\n  BufferedInput.propTypes = {\n    onSubmit: prop_types_default.a.func.isRequired,\n    value: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.number])\n  };\n  return BufferedInput;\n});\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/dropdown/dropdown.css\nvar dropdown = __webpack_require__(175);\nvar dropdown_default = __webpack_require__.n(dropdown);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/dropdown/dropdown-caret.svg\nvar dropdown_caret = __webpack_require__(614);\nvar dropdown_caret_default = __webpack_require__.n(dropdown_caret);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/components/dropdown/dropdown.jsx\nfunction dropdown_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { dropdown_typeof = function _typeof(obj) { return typeof obj; }; } else { dropdown_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return dropdown_typeof(obj); }\nfunction dropdown_extends() { dropdown_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return dropdown_extends.apply(this, arguments); }\nfunction dropdown_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction dropdown_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction dropdown_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction dropdown_createClass(Constructor, protoProps, staticProps) { if (protoProps) dropdown_defineProperties(Constructor.prototype, protoProps); if (staticProps) dropdown_defineProperties(Constructor, staticProps); return Constructor; }\nfunction dropdown_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) dropdown_setPrototypeOf(subClass, superClass); }\nfunction dropdown_setPrototypeOf(o, p) { dropdown_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return dropdown_setPrototypeOf(o, p); }\nfunction dropdown_createSuper(Derived) { var hasNativeReflectConstruct = dropdown_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = dropdown_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = dropdown_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return dropdown_possibleConstructorReturn(this, result); }; }\nfunction dropdown_possibleConstructorReturn(self, call) { if (call && (dropdown_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return dropdown_assertThisInitialized(self); }\nfunction dropdown_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction dropdown_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction dropdown_getPrototypeOf(o) { dropdown_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return dropdown_getPrototypeOf(o); }\n\nvar dropdown_Dropdown = function (_React$Component) {\n  dropdown_inherits(Dropdown, _React$Component);\n  var _super = dropdown_createSuper(Dropdown);\n  function Dropdown(props) {\n    var _this;\n    dropdown_classCallCheck(this, Dropdown);\n    _this = _super.call(this, props);\n    lodash_bindall_default()(dropdown_assertThisInitialized(_this), ['handleClosePopover', 'handleToggleOpenState', 'isOpen']);\n    _this.state = {\n      isOpen: false\n    };\n    return _this;\n  }\n  dropdown_createClass(Dropdown, [{\n    key: \"handleClosePopover\",\n    value: function handleClosePopover() {\n      this.setState({\n        isOpen: false\n      });\n    }\n  }, {\n    key: \"handleToggleOpenState\",\n    value: function handleToggleOpenState() {\n      var newState = !this.state.isOpen;\n      this.setState({\n        isOpen: newState\n      });\n      if (newState && this.props.onOpen) {\n        this.props.onOpen();\n      }\n    }\n  }, {\n    key: \"isOpen\",\n    value: function isOpen() {\n      return this.state.isOpen;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _classNames;\n      return react_default.a.createElement(react_popover_default.a, dropdown_extends({\n        body: this.props.popoverContent,\n        isOpen: this.state.isOpen,\n        preferPlace: \"below\",\n        onOuterAction: this.props.onOuterAction ? this.props.onOuterAction : this.handleClosePopover\n      }, this.props), react_default.a.createElement(\"div\", {\n        className: classnames_default()(dropdown_default.a.dropdown, this.props.className, (_classNames = {}, dropdown_defineProperty(_classNames, dropdown_default.a.modOpen, this.state.isOpen), dropdown_defineProperty(_classNames, dropdown_default.a.modClosed, !this.state.isOpen), _classNames)),\n        onClick: this.handleToggleOpenState\n      }, this.props.children, react_default.a.createElement(\"img\", {\n        className: classnames_default()(dropdown_default.a.dropdownIcon, dropdown_defineProperty({}, dropdown_default.a.modCaretUp, this.state.isOpen)),\n        draggable: false,\n        src: dropdown_caret_default.a\n      })));\n    }\n  }]);\n  return Dropdown;\n}(react_default.a.Component);\ndropdown_Dropdown.propTypes = {\n  children: prop_types_default.a.node.isRequired,\n  className: prop_types_default.a.string,\n  onOpen: prop_types_default.a.func,\n  onOuterAction: prop_types_default.a.func,\n  popoverContent: prop_types_default.a.node.isRequired\n};\n/* harmony default export */ var dropdown_dropdown = (dropdown_Dropdown);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/forms/input.css\nvar input = __webpack_require__(281);\nvar input_default = __webpack_require__.n(input);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/components/forms/input.jsx\nfunction input_extends() { input_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return input_extends.apply(this, arguments); }\nfunction input_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction input_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = input_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction input_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* DO NOT EDIT\n@todo This file is copied from GUI and should be pulled out into a shared library.\nSee https://github.com/LLK/scratch-paint/issues/13 */\n/* NOTE:\nEdited to add range prop\n*/\n\nvar input_Input = function Input(props) {\n  var _classNames;\n  var small = props.small,\n      range = props.range,\n      componentProps = input_objectWithoutProperties(props, [\"small\", \"range\"]);\n  return react_default.a.createElement(\"input\", input_extends({}, componentProps, {\n    className: classnames_default()(input_default.a.inputForm, props.className, (_classNames = {}, input_defineProperty(_classNames, input_default.a.inputSmall, small && !range), input_defineProperty(_classNames, input_default.a.inputSmallRange, small && range), _classNames))\n  }));\n};\ninput_Input.propTypes = {\n  className: prop_types_default.a.string,\n  range: prop_types_default.a.bool,\n  small: prop_types_default.a.bool\n};\ninput_Input.defaultProps = {\n  range: false,\n  small: false\n};\n/* harmony default export */ var forms_input = (input_Input);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/lib/layout-constants.js\n/* harmony default export */ var layout_constants = ({\n  fullSizeEditorMinWidth: 1274\n});\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/lib/hide-label.js\nvar localeTooBig = ['ab', 'ca', 'cy', 'de', 'et', 'el', 'ga', 'gd', 'gl', 'mi', 'nl', 'ja', 'ja-Hira', 'nb', 'nn', 'rap', 'th', 'sr', 'sk', 'sl', 'fi', 'sv', 'sw', 'vi', 'tr', 'uk'];\nvar hide_label_hideLabel = function hideLabel(locale) {\n  return localeTooBig.includes(locale);\n};\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/fixed-tools/fixed-tools.css\nvar fixed_tools = __webpack_require__(46);\nvar fixed_tools_default = __webpack_require__.n(fixed_tools);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/fixed-tools/icons/group.svg\nvar icons_group = __webpack_require__(615);\nvar group_default = __webpack_require__.n(icons_group);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/fixed-tools/icons/redo.svg\nvar icons_redo = __webpack_require__(616);\nvar redo_default = __webpack_require__.n(icons_redo);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/fixed-tools/icons/send-back.svg\nvar send_back = __webpack_require__(340);\nvar send_back_default = __webpack_require__.n(send_back);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/fixed-tools/icons/send-backward.svg\nvar send_backward = __webpack_require__(617);\nvar send_backward_default = __webpack_require__.n(send_backward);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/fixed-tools/icons/send-forward.svg\nvar send_forward = __webpack_require__(618);\nvar send_forward_default = __webpack_require__.n(send_forward);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/fixed-tools/icons/send-front.svg\nvar send_front = __webpack_require__(341);\nvar send_front_default = __webpack_require__.n(send_front);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/fixed-tools/icons/undo.svg\nvar icons_undo = __webpack_require__(619);\nvar undo_default = __webpack_require__.n(icons_undo);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/fixed-tools/icons/ungroup.svg\nvar ungroup = __webpack_require__(620);\nvar ungroup_default = __webpack_require__.n(ungroup);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/components/fixed-tools/fixed-tools.jsx\nfunction fixed_tools_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\nvar fixed_tools_BufferedInput = buffered_input_hoc(forms_input);\nvar fixed_tools_messages = Object(index_es[\"d\" /* defineMessages */])({\n  costume: {\n    \"id\": \"paint.paintEditor.costume\",\n    \"defaultMessage\": \"Costume\"\n  },\n  group: {\n    \"id\": \"paint.paintEditor.group\",\n    \"defaultMessage\": \"Group\"\n  },\n  ungroup: {\n    \"id\": \"paint.paintEditor.ungroup\",\n    \"defaultMessage\": \"Ungroup\"\n  },\n  undo: {\n    \"id\": \"paint.paintEditor.undo\",\n    \"defaultMessage\": \"Undo\"\n  },\n  redo: {\n    \"id\": \"paint.paintEditor.redo\",\n    \"defaultMessage\": \"Redo\"\n  },\n  forward: {\n    \"id\": \"paint.paintEditor.forward\",\n    \"defaultMessage\": \"Forward\"\n  },\n  backward: {\n    \"id\": \"paint.paintEditor.backward\",\n    \"defaultMessage\": \"Backward\"\n  },\n  front: {\n    \"id\": \"paint.paintEditor.front\",\n    \"defaultMessage\": \"Front\"\n  },\n  back: {\n    \"id\": \"paint.paintEditor.back\",\n    \"defaultMessage\": \"Back\"\n  },\n  more: {\n    \"id\": \"paint.paintEditor.more\",\n    \"defaultMessage\": \"More\"\n  }\n});\nvar fixed_tools_FixedToolsComponent = function FixedToolsComponent(props) {\n  var redoDisabled = !props.canRedo();\n  var undoDisabled = !props.canUndo();\n  return react_default.a.createElement(\"div\", {\n    className: fixed_tools_default.a.row\n  }, react_default.a.createElement(input_group_input_group, null, react_default.a.createElement(react_responsive_default.a, {\n    minWidth: layout_constants.fullSizeEditorMinWidth\n  }, react_default.a.createElement(components_forms_label, {\n    text: props.intl.formatMessage(fixed_tools_messages.costume)\n  }, react_default.a.createElement(fixed_tools_BufferedInput, {\n    className: fixed_tools_default.a.costumeInput,\n    type: \"text\",\n    value: props.name,\n    onSubmit: props.onUpdateName\n  }))), react_default.a.createElement(react_responsive_default.a, {\n    maxWidth: layout_constants.fullSizeEditorMinWidth - 1\n  }, react_default.a.createElement(fixed_tools_BufferedInput, {\n    className: fixed_tools_default.a.costumeInput,\n    type: \"text\",\n    value: props.name,\n    onSubmit: props.onUpdateName\n  }))), react_default.a.createElement(input_group_input_group, null, react_default.a.createElement(button_group_button_group, null, react_default.a.createElement(components_button_button, {\n    className: classnames_default()(fixed_tools_default.a.buttonGroupButton, fixed_tools_defineProperty({}, fixed_tools_default.a.modNoEndBorder, !redoDisabled)),\n    disabled: undoDisabled,\n    onClick: props.onUndo\n  }, react_default.a.createElement(\"img\", {\n    alt: props.intl.formatMessage(fixed_tools_messages.undo),\n    className: classnames_default()(fixed_tools_default.a.buttonGroupButtonIcon, fixed_tools_default.a.undoIcon),\n    draggable: false,\n    src: undo_default.a\n  })), react_default.a.createElement(components_button_button, {\n    className: classnames_default()(fixed_tools_default.a.buttonGroupButton, fixed_tools_defineProperty({}, fixed_tools_default.a.modStartBorder, !redoDisabled)),\n    disabled: redoDisabled,\n    onClick: props.onRedo\n  }, react_default.a.createElement(\"img\", {\n    alt: props.intl.formatMessage(fixed_tools_messages.redo),\n    className: fixed_tools_default.a.buttonGroupButtonIcon,\n    draggable: false,\n    src: redo_default.a\n  })))), isVector(props.format) ? react_default.a.createElement(input_group_input_group, {\n    className: fixed_tools_default.a.modDashedBorder\n  }, react_default.a.createElement(labeled_icon_button_labeled_icon_button, {\n    disabled: !group_shouldShowGroup(),\n    hideLabel: hide_label_hideLabel(props.intl.locale),\n    imgSrc: group_default.a,\n    title: props.intl.formatMessage(fixed_tools_messages.group),\n    onClick: props.onGroup\n  }), react_default.a.createElement(labeled_icon_button_labeled_icon_button, {\n    disabled: !group_shouldShowUngroup(),\n    hideLabel: hide_label_hideLabel(props.intl.locale),\n    imgSrc: ungroup_default.a,\n    title: props.intl.formatMessage(fixed_tools_messages.ungroup),\n    onClick: props.onUngroup\n  })) : null, isVector(props.format) ? react_default.a.createElement(input_group_input_group, {\n    className: fixed_tools_default.a.modDashedBorder\n  }, react_default.a.createElement(labeled_icon_button_labeled_icon_button, {\n    disabled: !order_shouldShowBringForward(),\n    hideLabel: hide_label_hideLabel(props.intl.locale),\n    imgSrc: send_forward_default.a,\n    title: props.intl.formatMessage(fixed_tools_messages.forward),\n    onClick: props.onSendForward\n  }), react_default.a.createElement(labeled_icon_button_labeled_icon_button, {\n    disabled: !order_shouldShowSendBackward(),\n    hideLabel: hide_label_hideLabel(props.intl.locale),\n    imgSrc: send_backward_default.a,\n    title: props.intl.formatMessage(fixed_tools_messages.backward),\n    onClick: props.onSendBackward\n  })) : null, isVector(props.format) ? react_default.a.createElement(react_responsive_default.a, {\n    minWidth: layout_constants.fullSizeEditorMinWidth\n  }, react_default.a.createElement(input_group_input_group, {\n    className: fixed_tools_default.a.row\n  }, react_default.a.createElement(labeled_icon_button_labeled_icon_button, {\n    disabled: !order_shouldShowBringForward(),\n    hideLabel: hide_label_hideLabel(props.intl.locale),\n    imgSrc: send_front_default.a,\n    title: props.intl.formatMessage(fixed_tools_messages.front),\n    onClick: props.onSendToFront\n  }), react_default.a.createElement(labeled_icon_button_labeled_icon_button, {\n    disabled: !order_shouldShowSendBackward(),\n    hideLabel: hide_label_hideLabel(props.intl.locale),\n    imgSrc: send_back_default.a,\n    title: props.intl.formatMessage(fixed_tools_messages.back),\n    onClick: props.onSendToBack\n  }))) : null, isVector(props.format) ? react_default.a.createElement(react_responsive_default.a, {\n    maxWidth: layout_constants.fullSizeEditorMinWidth - 1\n  }, react_default.a.createElement(input_group_input_group, null, react_default.a.createElement(dropdown_dropdown, {\n    className: fixed_tools_default.a.modUnselect,\n    enterExitTransitionDurationMs: 20,\n    popoverContent: react_default.a.createElement(input_group_input_group, {\n      className: fixed_tools_default.a.modContextMenu,\n      rtl: props.rtl\n    }, react_default.a.createElement(components_button_button, {\n      className: classnames_default()(fixed_tools_default.a.modMenuItem, fixed_tools_defineProperty({}, fixed_tools_default.a.modDisabled, !order_shouldShowBringForward())),\n      disabled: !order_shouldShowBringForward(),\n      onClick: props.onSendToFront\n    }, react_default.a.createElement(\"img\", {\n      className: fixed_tools_default.a.menuItemIcon,\n      draggable: false,\n      src: send_front_default.a\n    }), react_default.a.createElement(\"span\", null, props.intl.formatMessage(fixed_tools_messages.front))), react_default.a.createElement(components_button_button, {\n      className: classnames_default()(fixed_tools_default.a.modMenuItem, fixed_tools_defineProperty({}, fixed_tools_default.a.modDisabled, !order_shouldShowSendBackward())),\n      disabled: !order_shouldShowSendBackward(),\n      onClick: props.onSendToBack\n    }, react_default.a.createElement(\"img\", {\n      className: fixed_tools_default.a.menuItemIcon,\n      draggable: false,\n      src: send_back_default.a\n    }), react_default.a.createElement(\"span\", null, props.intl.formatMessage(fixed_tools_messages.back)))),\n    tipSize: .01\n  }, props.intl.formatMessage(fixed_tools_messages.more)))) : null);\n};\nfixed_tools_FixedToolsComponent.propTypes = {\n  canRedo: prop_types_default.a.func.isRequired,\n  canUndo: prop_types_default.a.func.isRequired,\n  format: prop_types_default.a.oneOf(Object.keys(Formats)),\n  intl: index_es[\"f\" /* intlShape */],\n  name: prop_types_default.a.string,\n  onGroup: prop_types_default.a.func.isRequired,\n  onRedo: prop_types_default.a.func.isRequired,\n  onSendBackward: prop_types_default.a.func.isRequired,\n  onSendForward: prop_types_default.a.func.isRequired,\n  onSendToBack: prop_types_default.a.func.isRequired,\n  onSendToFront: prop_types_default.a.func.isRequired,\n  onUndo: prop_types_default.a.func.isRequired,\n  onUngroup: prop_types_default.a.func.isRequired,\n  onUpdateName: prop_types_default.a.func.isRequired,\n  rtl: prop_types_default.a.bool.isRequired\n};\nvar fixed_tools_mapStateToProps = function mapStateToProps(state) {\n  return {\n    format: state.scratchPaint.format,\n    rtl: state.scratchPaint.layout.rtl,\n    selectedItems: state.scratchPaint.selectedItems,\n    undoState: state.scratchPaint.undo\n  };\n};\n/* harmony default export */ var fixed_tools_fixed_tools = (Object(es[\"b\" /* connect */])(fixed_tools_mapStateToProps)(Object(index_es[\"e\" /* injectIntl */])(fixed_tools_FixedToolsComponent)));\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/reducers/text-edit-target.js\nvar CHANGE_TEXT_EDIT_TARGET = 'scratch-paint/text-tool/CHANGE_TEXT_EDIT_TARGET';\nvar text_edit_target_initialState = null;\nvar text_edit_target_reducer = function reducer(state, action) {\n  if (typeof state === 'undefined') state = text_edit_target_initialState;\n  switch (action.type) {\n    case CHANGE_TEXT_EDIT_TARGET:\n      if (typeof action.textEditTargetId === 'undefined') {\n        log.warn(\"Text edit target should not be set to undefined. Use null.\");\n        return state;\n      } else if (typeof action.textEditTargetId === 'undefined' || isNaN(action.textEditTargetId)) {\n        log.warn(\"Text edit target should be an item ID number. Got: \".concat(action.textEditTargetId));\n        return state;\n      }\n      return action.textEditTargetId;\n    default:\n      return state;\n  }\n}; // Action creators ==================================\n/**\n * Set the currently-being-edited text field to the given item ID\n * @param {?number} textEditTargetId The paper.Item ID of the active text field.\n *     Leave empty if there is no text editing target.\n * @return {object} Redux action to change the text edit target.\n */\nvar text_edit_target_setTextEditTarget = function setTextEditTarget(textEditTargetId) {\n  return {\n    type: CHANGE_TEXT_EDIT_TARGET,\n    textEditTargetId: textEditTargetId ? textEditTargetId : null\n  };\n};\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/reducers/layout.js\nvar SET_LAYOUT = 'scratch-paint/layout/SET_LAYOUT';\nvar layout_initialState = {\n  rtl: false\n};\nvar layouts = ['ltr', 'rtl'];\nvar layout_reducer = function reducer(state, action) {\n  if (typeof state === 'undefined') state = layout_initialState;\n  switch (action.type) {\n    case SET_LAYOUT:\n      if (layouts.indexOf(action.layout) === -1) {\n        log.warn(\"Unrecognized layout provided: \".concat(action.layout));\n        return state;\n      }\n      return {\n        rtl: action.layout === 'rtl'\n      };\n    default:\n      return state;\n  }\n}; // Action creators ==================================\n/**\n * Change the layout to the new layout\n * @param {string} layout either 'ltr' or 'rtl'\n * @return {object} Redux action to change the selected items.\n */\nvar layout_setLayout = function setLayout(layout) {\n  return {\n    type: SET_LAYOUT,\n    layout: layout\n  };\n};\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/containers/fixed-tools.jsx\nfunction fixed_tools_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { fixed_tools_typeof = function _typeof(obj) { return typeof obj; }; } else { fixed_tools_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return fixed_tools_typeof(obj); }\nfunction fixed_tools_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction fixed_tools_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction fixed_tools_createClass(Constructor, protoProps, staticProps) { if (protoProps) fixed_tools_defineProperties(Constructor.prototype, protoProps); if (staticProps) fixed_tools_defineProperties(Constructor, staticProps); return Constructor; }\nfunction fixed_tools_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) fixed_tools_setPrototypeOf(subClass, superClass); }\nfunction fixed_tools_setPrototypeOf(o, p) { fixed_tools_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return fixed_tools_setPrototypeOf(o, p); }\nfunction fixed_tools_createSuper(Derived) { var hasNativeReflectConstruct = fixed_tools_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = fixed_tools_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = fixed_tools_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return fixed_tools_possibleConstructorReturn(this, result); }; }\nfunction fixed_tools_possibleConstructorReturn(self, call) { if (call && (fixed_tools_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return fixed_tools_assertThisInitialized(self); }\nfunction fixed_tools_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction fixed_tools_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction fixed_tools_getPrototypeOf(o) { fixed_tools_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return fixed_tools_getPrototypeOf(o); }\n\nvar fixed_tools_FixedTools = function (_React$Component) {\n  fixed_tools_inherits(FixedTools, _React$Component);\n  var _super = fixed_tools_createSuper(FixedTools);\n  function FixedTools(props) {\n    var _this;\n    fixed_tools_classCallCheck(this, FixedTools);\n    _this = _super.call(this, props);\n    lodash_bindall_default()(fixed_tools_assertThisInitialized(_this), ['handleSendBackward', 'handleSendForward', 'handleSendToBack', 'handleSendToFront', 'handleSetSelectedItems', 'handleGroup', 'handleUngroup']);\n    return _this;\n  }\n  fixed_tools_createClass(FixedTools, [{\n    key: \"handleGroup\",\n    value: function handleGroup() {\n      group_groupSelection(this.props.clearSelectedItems, this.handleSetSelectedItems, this.props.onUpdateImage);\n    }\n  }, {\n    key: \"handleUngroup\",\n    value: function handleUngroup() {\n      group_ungroupSelection(this.props.clearSelectedItems, this.handleSetSelectedItems, this.props.onUpdateImage);\n    }\n  }, {\n    key: \"handleSendBackward\",\n    value: function handleSendBackward() {\n      order_sendBackward(this.props.onUpdateImage);\n    }\n  }, {\n    key: \"handleSendForward\",\n    value: function handleSendForward() {\n      order_bringForward(this.props.onUpdateImage);\n    }\n  }, {\n    key: \"handleSendToBack\",\n    value: function handleSendToBack() {\n      order_sendToBack(this.props.onUpdateImage);\n    }\n  }, {\n    key: \"handleSendToFront\",\n    value: function handleSendToFront() {\n      order_bringToFront(this.props.onUpdateImage);\n    }\n  }, {\n    key: \"handleSetSelectedItems\",\n    value: function handleSetSelectedItems() {\n      this.props.setSelectedItems(this.props.format);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return react_default.a.createElement(fixed_tools_fixed_tools, {\n        canRedo: this.props.canRedo,\n        canUndo: this.props.canUndo,\n        name: this.props.name,\n        onGroup: this.handleGroup,\n        onRedo: this.props.onRedo,\n        onSendBackward: this.handleSendBackward,\n        onSendForward: this.handleSendForward,\n        onSendToBack: this.handleSendToBack,\n        onSendToFront: this.handleSendToFront,\n        onUndo: this.props.onUndo,\n        onUngroup: this.handleUngroup,\n        onUpdateImage: this.props.onUpdateImage,\n        onUpdateName: this.props.onUpdateName\n      });\n    }\n  }]);\n  return FixedTools;\n}(react_default.a.Component);\nfixed_tools_FixedTools.propTypes = {\n  canRedo: prop_types_default.a.func.isRequired,\n  canUndo: prop_types_default.a.func.isRequired,\n  clearSelectedItems: prop_types_default.a.func.isRequired,\n  format: prop_types_default.a.oneOf(Object.keys(Formats)),\n  name: prop_types_default.a.string,\n  onRedo: prop_types_default.a.func.isRequired,\n  onUndo: prop_types_default.a.func.isRequired,\n  onUpdateImage: prop_types_default.a.func.isRequired,\n  onUpdateName: prop_types_default.a.func.isRequired,\n  setSelectedItems: prop_types_default.a.func.isRequired\n};\nvar containers_fixed_tools_mapStateToProps = function mapStateToProps(state) {\n  return {\n    changeColorToEyeDropper: state.scratchPaint.color.eyeDropper.callback,\n    format: state.scratchPaint.format,\n    isEyeDropping: state.scratchPaint.color.eyeDropper.active,\n    mode: state.scratchPaint.mode,\n    pasteOffset: state.scratchPaint.clipboard.pasteOffset,\n    previousTool: state.scratchPaint.color.eyeDropper.previousTool,\n    selectedItems: state.scratchPaint.selectedItems,\n    viewBounds: state.scratchPaint.viewBounds\n  };\n};\nvar fixed_tools_mapDispatchToProps = function mapDispatchToProps(dispatch) {\n  return {\n    changeMode: function changeMode(mode) {\n      dispatch(modes_changeMode(mode));\n    },\n    clearSelectedItems: function clearSelectedItems() {\n      dispatch(selected_items_clearSelectedItems());\n    },\n    handleSwitchToBitmap: function handleSwitchToBitmap() {\n      dispatch(format_changeFormat(Formats.BITMAP));\n    },\n    handleSwitchToVector: function handleSwitchToVector() {\n      dispatch(format_changeFormat(Formats.VECTOR));\n    },\n    removeTextEditTarget: function removeTextEditTarget() {\n      dispatch(text_edit_target_setTextEditTarget());\n    },\n    setLayout: function setLayout(layout) {\n      dispatch(layout_setLayout(layout));\n    },\n    setSelectedItems: function setSelectedItems(format) {\n      dispatch(selected_items_setSelectedItems(selection_getSelectedLeafItems(), format_isBitmap(format)));\n    },\n    onDeactivateEyeDropper: function onDeactivateEyeDropper() {\n      // set redux values to default for eye dropper reducer\n      dispatch(deactivateEyeDropper());\n    }\n  };\n};\n/* harmony default export */ var containers_fixed_tools = (Object(es[\"b\" /* connect */])(containers_fixed_tools_mapStateToProps, fixed_tools_mapDispatchToProps)(fixed_tools_FixedTools));\n// EXTERNAL MODULE: ./node_modules/lodash.omit/index.js\nvar lodash_omit = __webpack_require__(49);\nvar lodash_omit_default = __webpack_require__.n(lodash_omit);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/hocs/copy-paste-hoc.jsx\nfunction copy_paste_hoc_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { copy_paste_hoc_typeof = function _typeof(obj) { return typeof obj; }; } else { copy_paste_hoc_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return copy_paste_hoc_typeof(obj); }\nfunction copy_paste_hoc_extends() { copy_paste_hoc_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return copy_paste_hoc_extends.apply(this, arguments); }\nfunction copy_paste_hoc_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = copy_paste_hoc_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction copy_paste_hoc_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return copy_paste_hoc_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return copy_paste_hoc_arrayLikeToArray(o, minLen); }\nfunction copy_paste_hoc_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction copy_paste_hoc_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction copy_paste_hoc_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction copy_paste_hoc_createClass(Constructor, protoProps, staticProps) { if (protoProps) copy_paste_hoc_defineProperties(Constructor.prototype, protoProps); if (staticProps) copy_paste_hoc_defineProperties(Constructor, staticProps); return Constructor; }\nfunction copy_paste_hoc_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) copy_paste_hoc_setPrototypeOf(subClass, superClass); }\nfunction copy_paste_hoc_setPrototypeOf(o, p) { copy_paste_hoc_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return copy_paste_hoc_setPrototypeOf(o, p); }\nfunction copy_paste_hoc_createSuper(Derived) { var hasNativeReflectConstruct = copy_paste_hoc_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = copy_paste_hoc_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = copy_paste_hoc_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return copy_paste_hoc_possibleConstructorReturn(this, result); }; }\nfunction copy_paste_hoc_possibleConstructorReturn(self, call) { if (call && (copy_paste_hoc_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return copy_paste_hoc_assertThisInitialized(self); }\nfunction copy_paste_hoc_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction copy_paste_hoc_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction copy_paste_hoc_getPrototypeOf(o) { copy_paste_hoc_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return copy_paste_hoc_getPrototypeOf(o); }\n\nvar copy_paste_hoc_CopyPasteHOC = function CopyPasteHOC(WrappedComponent) {\n  var CopyPasteWrapper = function (_React$Component) {\n    copy_paste_hoc_inherits(CopyPasteWrapper, _React$Component);\n    var _super = copy_paste_hoc_createSuper(CopyPasteWrapper);\n    function CopyPasteWrapper(props) {\n      var _this;\n      copy_paste_hoc_classCallCheck(this, CopyPasteWrapper);\n      _this = _super.call(this, props);\n      lodash_bindall_default()(copy_paste_hoc_assertThisInitialized(_this), ['handleCopy', 'handlePaste']);\n      return _this;\n    }\n    copy_paste_hoc_createClass(CopyPasteWrapper, [{\n      key: \"handleCopy\",\n      value: function handleCopy() {\n        var selectedItems = [];\n        if (this.props.mode === Modes.RESHAPE) {\n          var leafItems = selection_getSelectedLeafItems(); // Copy root of compound paths\n          var _iterator = copy_paste_hoc_createForOfIteratorHelper(leafItems),\n              _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var item = _step.value;\n              if (item.parent && item.parent instanceof paper_full_default.a.CompoundPath) {\n                selectedItems.push(item.parent);\n              } else {\n                selectedItems.push(item);\n              }\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        } else {\n          selectedItems = selection_getSelectedRootItems();\n        }\n        if (selectedItems.length === 0) {\n          if (format_isBitmap(this.props.format)) {\n            var raster = bitmap_getTrimmedRaster(false\n            /* shouldInsert */\n            );\n            if (!raster) return;\n            selectedItems.push(raster);\n          } else {\n            selectedItems = selection_getAllRootItems();\n          }\n        }\n        var clipboardItems = [];\n        for (var i = 0; i < selectedItems.length; i++) {\n          var jsonItem = selectedItems[i].exportJSON({\n            asString: false\n          });\n          clipboardItems.push(jsonItem);\n        }\n        this.props.setClipboardItems(clipboardItems);\n      }\n    }, {\n      key: \"handlePaste\",\n      value: function handlePaste() {\n        selection_clearSelection(this.props.clearSelectedItems);\n        if (this.props.clipboardItems.length === 0) return;\n        var items = [];\n        for (var i = 0; i < this.props.clipboardItems.length; i++) {\n          var item = paper_full_default.a.Base.importJSON(this.props.clipboardItems[i]);\n          if (item) {\n            items.push(item);\n          }\n        }\n        if (!items.length) return; // If pasting a group or non-raster to bitmap, rasterize first\n        if (format_isBitmap(this.props.format) && !(items.length === 1 && items[0] instanceof paper_full_default.a.Raster)) {\n          var group = new paper_full_default.a.Group(items);\n          items = [group.rasterize()];\n          group.remove();\n        }\n        for (var _i = 0, _items = items; _i < _items.length; _i++) {\n          var _item = _items[_i];\n          var placedItem = paper_full_default.a.project.getActiveLayer().addChild(_item);\n          placedItem.selected = true;\n          placedItem.position.x += 10 * this.props.pasteOffset;\n          placedItem.position.y += 10 * this.props.pasteOffset;\n        }\n        this.props.incrementPasteOffset();\n        this.props.setSelectedItems(this.props.format);\n        this.props.onUpdateImage();\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var componentProps = lodash_omit_default()(this.props, ['clearSelectedItems', 'clipboardItems', 'format', 'incrementPasteOffset', 'mode', 'pasteOffset', 'setClipboardItems', 'setSelectedItems']);\n        return react_default.a.createElement(WrappedComponent, copy_paste_hoc_extends({\n          onCopyToClipboard: this.handleCopy,\n          onPasteFromClipboard: this.handlePaste\n        }, componentProps));\n      }\n    }]);\n    return CopyPasteWrapper;\n  }(react_default.a.Component);\n  CopyPasteWrapper.propTypes = {\n    clearSelectedItems: prop_types_default.a.func.isRequired,\n    clipboardItems: prop_types_default.a.arrayOf(prop_types_default.a.array),\n    format: prop_types_default.a.oneOf(Object.keys(Formats)),\n    incrementPasteOffset: prop_types_default.a.func.isRequired,\n    mode: prop_types_default.a.oneOf(Object.keys(Modes)),\n    onUpdateImage: prop_types_default.a.func.isRequired,\n    pasteOffset: prop_types_default.a.number,\n    setClipboardItems: prop_types_default.a.func.isRequired,\n    setSelectedItems: prop_types_default.a.func.isRequired\n  };\n  var mapStateToProps = function mapStateToProps(state) {\n    return {\n      clipboardItems: state.scratchPaint.clipboard.items,\n      format: state.scratchPaint.format,\n      mode: state.scratchPaint.mode,\n      pasteOffset: state.scratchPaint.clipboard.pasteOffset\n    };\n  };\n  var mapDispatchToProps = function mapDispatchToProps(dispatch) {\n    return {\n      setClipboardItems: function setClipboardItems(items) {\n        dispatch(clipboard_setClipboardItems(items));\n      },\n      incrementPasteOffset: function incrementPasteOffset() {\n        dispatch(clipboard_incrementPasteOffset());\n      },\n      clearSelectedItems: function clearSelectedItems() {\n        dispatch(selected_items_clearSelectedItems());\n      },\n      setSelectedItems: function setSelectedItems(format) {\n        dispatch(selected_items_setSelectedItems(selection_getSelectedLeafItems(), format_isBitmap(format)));\n      }\n    };\n  };\n  return Object(es[\"b\" /* connect */])(mapStateToProps, mapDispatchToProps)(CopyPasteWrapper);\n};\n/* harmony default export */ var copy_paste_hoc = (copy_paste_hoc_CopyPasteHOC);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/reducers/brush-mode.js\nvar CHANGE_BRUSH_SIZE = 'scratch-paint/brush-mode/CHANGE_BRUSH_SIZE';\nvar brush_mode_initialState = {\n  brushSize: 10\n};\nvar brush_mode_reducer = function reducer(state, action) {\n  if (typeof state === 'undefined') state = brush_mode_initialState;\n  switch (action.type) {\n    case CHANGE_BRUSH_SIZE:\n      if (isNaN(action.brushSize)) {\n        log.warn(\"Invalid brush size: \".concat(action.brushSize));\n        return state;\n      }\n      return {\n        brushSize: Math.max(1, action.brushSize)\n      };\n    default:\n      return state;\n  }\n}; // Action creators ==================================\nvar brush_mode_changeBrushSize = function changeBrushSize(brushSize) {\n  return {\n    type: CHANGE_BRUSH_SIZE,\n    brushSize: brushSize\n  };\n};\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/reducers/bit-brush-size.js\n // Bit brush size affects bit brush width, circle/rectangle outline drawing width, and line width\n// in the bitmap paint editor.\nvar CHANGE_BIT_BRUSH_SIZE = 'scratch-paint/brush-mode/CHANGE_BIT_BRUSH_SIZE';\nvar bit_brush_size_initialState = 10;\nvar bit_brush_size_reducer = function reducer(state, action) {\n  if (typeof state === 'undefined') state = bit_brush_size_initialState;\n  switch (action.type) {\n    case CHANGE_BIT_BRUSH_SIZE:\n      if (isNaN(action.brushSize)) {\n        log.warn(\"Invalid brush size: \".concat(action.brushSize));\n        return state;\n      }\n      return Math.max(1, action.brushSize);\n    case CHANGE_SELECTED_ITEMS:\n      {\n        // Don't change state if no selection\n        if (!action.selectedItems || !action.selectedItems.length) {\n          return state;\n        } // Vector mode doesn't have bit width\n        if (!action.bitmapMode) {\n          return state;\n        }\n        var colorState = style_path_getColorsFromSelection(action.selectedItems, action.bitmapMode);\n        if (colorState.thickness) return colorState.thickness;\n        return state;\n      }\n    default:\n      return state;\n  }\n}; // Action creators ==================================\nvar changeBitBrushSize = function changeBitBrushSize(brushSize) {\n  return {\n    type: CHANGE_BIT_BRUSH_SIZE,\n    brushSize: brushSize\n  };\n};\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/reducers/bit-eraser-size.js\nvar CHANGE_BIT_ERASER_SIZE = 'scratch-paint/eraser-mode/CHANGE_BIT_ERASER_SIZE';\nvar bit_eraser_size_initialState = 40;\nvar bit_eraser_size_reducer = function reducer(state, action) {\n  if (typeof state === 'undefined') state = bit_eraser_size_initialState;\n  switch (action.type) {\n    case CHANGE_BIT_ERASER_SIZE:\n      if (isNaN(action.eraserSize)) {\n        log.warn(\"Invalid eraser size: \".concat(action.eraserSize));\n        return state;\n      }\n      return Math.max(1, action.eraserSize);\n    default:\n      return state;\n  }\n}; // Action creators ==================================\nvar changeBitEraserSize = function changeBitEraserSize(eraserSize) {\n  return {\n    type: CHANGE_BIT_ERASER_SIZE,\n    eraserSize: eraserSize\n  };\n};\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/reducers/fill-bitmap-shapes.js\nvar SET_FILLED = 'scratch-paint/fill-bitmap-shapes/SET_FILLED';\nvar fill_bitmap_shapes_initialState = true;\nvar fill_bitmap_shapes_reducer = function reducer(state, action) {\n  if (typeof state === 'undefined') state = fill_bitmap_shapes_initialState;\n  switch (action.type) {\n    case SET_FILLED:\n      return action.filled;\n    case CHANGE_SELECTED_ITEMS:\n      if (action.bitmapMode && action.selectedItems && action.selectedItems[0] instanceof paper_full_default.a.Shape) {\n        return action.selectedItems[0].strokeWidth === 0;\n      }\n      return state;\n    default:\n      return state;\n  }\n}; // Action creators ==================================\nvar setShapesFilled = function setShapesFilled(filled) {\n  return {\n    type: SET_FILLED,\n    filled: filled\n  };\n};\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/lib/fonts.js\nvar Fonts = {\n  SANS_SERIF: 'Sans Serif',\n  SERIF: 'Serif',\n  HANDWRITING: 'Handwriting',\n  MARKER: 'Marker',\n  CURLY: 'Curly',\n  PIXEL: 'Pixel',\n  CHINESE: '\"Microsoft YaHei\", \"微软雅黑\", STXihei, \"华文细黑\"',\n  JAPANESE: '\"ヒラギノ角ゴ Pro W3\", \"Hiragino Kaku Gothic Pro\", Osaka, \"メイリオ\", Meiryo, \"ＭＳ Ｐゴシック\", \"MS PGothic\"',\n  KOREAN: 'Malgun Gothic'\n};\n/* harmony default export */ var fonts = (Fonts);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/font-dropdown/font-dropdown.css\nvar font_dropdown = __webpack_require__(31);\nvar font_dropdown_default = __webpack_require__.n(font_dropdown);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/components/font-dropdown/font-dropdown.jsx\n\nvar font_dropdown_ModeToolsComponent = function ModeToolsComponent(props) {\n  return react_default.a.createElement(dropdown_dropdown, {\n    className: classnames_default()(font_dropdown_default.a.modUnselect, font_dropdown_default.a.fontDropdown),\n    enterExitTransitionDurationMs: 60,\n    popoverContent: react_default.a.createElement(input_group_input_group, {\n      className: font_dropdown_default.a.modContextMenu\n    }, react_default.a.createElement(components_button_button, {\n      className: classnames_default()(font_dropdown_default.a.modMenuItem),\n      onClick: props.onChoose,\n      onMouseOver: props.onHoverSansSerif\n    }, react_default.a.createElement(\"span\", {\n      className: font_dropdown_default.a.sansSerif\n    }, props.getFontName(fonts.SANS_SERIF))), react_default.a.createElement(components_button_button, {\n      className: classnames_default()(font_dropdown_default.a.modMenuItem),\n      onClick: props.onChoose,\n      onMouseOver: props.onHoverSerif\n    }, react_default.a.createElement(\"span\", {\n      className: font_dropdown_default.a.serif\n    }, props.getFontName(fonts.SERIF))), react_default.a.createElement(components_button_button, {\n      className: classnames_default()(font_dropdown_default.a.modMenuItem),\n      onClick: props.onChoose,\n      onMouseOver: props.onHoverHandwriting\n    }, react_default.a.createElement(\"span\", {\n      className: font_dropdown_default.a.handwriting\n    }, props.getFontName(fonts.HANDWRITING))), react_default.a.createElement(components_button_button, {\n      className: classnames_default()(font_dropdown_default.a.modMenuItem),\n      onClick: props.onChoose,\n      onMouseOver: props.onHoverMarker\n    }, react_default.a.createElement(\"span\", {\n      className: font_dropdown_default.a.marker\n    }, props.getFontName(fonts.MARKER))), react_default.a.createElement(components_button_button, {\n      className: classnames_default()(font_dropdown_default.a.modMenuItem),\n      onClick: props.onChoose,\n      onMouseOver: props.onHoverCurly\n    }, react_default.a.createElement(\"span\", {\n      className: font_dropdown_default.a.curly\n    }, props.getFontName(fonts.CURLY))), react_default.a.createElement(components_button_button, {\n      className: classnames_default()(font_dropdown_default.a.modMenuItem),\n      onClick: props.onChoose,\n      onMouseOver: props.onHoverPixel\n    }, react_default.a.createElement(\"span\", {\n      className: font_dropdown_default.a.pixel\n    }, props.getFontName(fonts.PIXEL))), react_default.a.createElement(components_button_button, {\n      className: classnames_default()(font_dropdown_default.a.modMenuItem),\n      onClick: props.onChoose,\n      onMouseOver: props.onHoverChinese\n    }, react_default.a.createElement(\"span\", {\n      className: font_dropdown_default.a.chinese\n    }, props.getFontName(fonts.CHINESE))), react_default.a.createElement(components_button_button, {\n      className: classnames_default()(font_dropdown_default.a.modMenuItem),\n      onClick: props.onChoose,\n      onMouseOver: props.onHoverJapanese\n    }, react_default.a.createElement(\"span\", {\n      className: font_dropdown_default.a.japanese\n    }, props.getFontName(fonts.JAPANESE))), react_default.a.createElement(components_button_button, {\n      className: classnames_default()(font_dropdown_default.a.modMenuItem),\n      onClick: props.onChoose,\n      onMouseOver: props.onHoverKorean\n    }, react_default.a.createElement(\"span\", {\n      className: font_dropdown_default.a.korean\n    }, props.getFontName(fonts.KOREAN)))),\n    ref: props.componentRef,\n    tipSize: .01,\n    onOpen: props.onOpenDropdown,\n    onOuterAction: props.onClickOutsideDropdown\n  }, react_default.a.createElement(\"span\", {\n    className: classnames_default()(props.getFontStyle(props.font), font_dropdown_default.a.displayedFontName)\n  }, props.getFontName(props.font)));\n};\nfont_dropdown_ModeToolsComponent.propTypes = {\n  componentRef: prop_types_default.a.func.isRequired,\n  font: prop_types_default.a.string,\n  getFontName: prop_types_default.a.func.isRequired,\n  getFontStyle: prop_types_default.a.func.isRequired,\n  onChoose: prop_types_default.a.func.isRequired,\n  onClickOutsideDropdown: prop_types_default.a.func,\n  onHoverChinese: prop_types_default.a.func,\n  onHoverCurly: prop_types_default.a.func,\n  onHoverHandwriting: prop_types_default.a.func,\n  onHoverJapanese: prop_types_default.a.func,\n  onHoverKorean: prop_types_default.a.func,\n  onHoverMarker: prop_types_default.a.func,\n  onHoverPixel: prop_types_default.a.func,\n  onHoverSansSerif: prop_types_default.a.func,\n  onHoverSerif: prop_types_default.a.func,\n  onOpenDropdown: prop_types_default.a.func\n};\n/* harmony default export */ var font_dropdown_font_dropdown = (font_dropdown_ModeToolsComponent);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/reducers/font.js\nvar CHANGE_FONT = 'scratch-paint/fonts/CHANGE_FONT';\nvar font_initialState = fonts.SANS_SERIF;\nvar font_reducer = function reducer(state, action) {\n  if (typeof state === 'undefined') state = font_initialState;\n  switch (action.type) {\n    case CHANGE_FONT:\n      if (!action.font) return state;\n      return action.font;\n    default:\n      return state;\n  }\n}; // Action creators ==================================\nvar font_changeFont = function changeFont(font) {\n  return {\n    type: CHANGE_FONT,\n    font: font\n  };\n};\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/containers/font-dropdown.jsx\nfunction font_dropdown_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { font_dropdown_typeof = function _typeof(obj) { return typeof obj; }; } else { font_dropdown_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return font_dropdown_typeof(obj); }\nfunction font_dropdown_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = font_dropdown_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction font_dropdown_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return font_dropdown_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return font_dropdown_arrayLikeToArray(o, minLen); }\nfunction font_dropdown_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction font_dropdown_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction font_dropdown_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction font_dropdown_createClass(Constructor, protoProps, staticProps) { if (protoProps) font_dropdown_defineProperties(Constructor.prototype, protoProps); if (staticProps) font_dropdown_defineProperties(Constructor, staticProps); return Constructor; }\nfunction font_dropdown_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) font_dropdown_setPrototypeOf(subClass, superClass); }\nfunction font_dropdown_setPrototypeOf(o, p) { font_dropdown_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return font_dropdown_setPrototypeOf(o, p); }\nfunction font_dropdown_createSuper(Derived) { var hasNativeReflectConstruct = font_dropdown_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = font_dropdown_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = font_dropdown_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return font_dropdown_possibleConstructorReturn(this, result); }; }\nfunction font_dropdown_possibleConstructorReturn(self, call) { if (call && (font_dropdown_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return font_dropdown_assertThisInitialized(self); }\nfunction font_dropdown_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction font_dropdown_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction font_dropdown_getPrototypeOf(o) { font_dropdown_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return font_dropdown_getPrototypeOf(o); }\n\nvar font_dropdown_FontDropdown = function (_React$Component) {\n  font_dropdown_inherits(FontDropdown, _React$Component);\n  var _super = font_dropdown_createSuper(FontDropdown);\n  function FontDropdown(props) {\n    var _this;\n    font_dropdown_classCallCheck(this, FontDropdown);\n    _this = _super.call(this, props);\n    lodash_bindall_default()(font_dropdown_assertThisInitialized(_this), ['getFontStyle', 'getFontName', 'handleChangeFontSerif', 'handleChangeFontSansSerif', 'handleChangeFontHandwriting', 'handleChangeFontMarker', 'handleChangeFontCurly', 'handleChangeFontPixel', 'handleChangeFontChinese', 'handleChangeFontJapanese', 'handleChangeFontKorean', 'handleOpenDropdown', 'handleClickOutsideDropdown', 'setDropdown', 'handleChoose']);\n    return _this;\n  }\n  font_dropdown_createClass(FontDropdown, [{\n    key: \"getFontStyle\",\n    value: function getFontStyle(font) {\n      switch (font) {\n        case fonts.SERIF:\n          return font_dropdown_default.a.serif;\n        case fonts.SANS_SERIF:\n          return font_dropdown_default.a.sansSerif;\n        case fonts.HANDWRITING:\n          return font_dropdown_default.a.handwriting;\n        case fonts.MARKER:\n          return font_dropdown_default.a.marker;\n        case fonts.CURLY:\n          return font_dropdown_default.a.curly;\n        case fonts.PIXEL:\n          return font_dropdown_default.a.pixel;\n        case fonts.CHINESE:\n          return font_dropdown_default.a.chinese;\n        case fonts.JAPANESE:\n          return font_dropdown_default.a.japanese;\n        case fonts.KOREAN:\n          return font_dropdown_default.a.korean;\n        default:\n          return '';\n      }\n    }\n  }, {\n    key: \"getFontName\",\n    value: function getFontName(font) {\n      switch (font) {\n        case fonts.CHINESE:\n          return '中文';\n        case fonts.KOREAN:\n          return '한국어';\n        case fonts.JAPANESE:\n          return '日本語';\n        default:\n          return font;\n      }\n    }\n  }, {\n    key: \"handleChangeFontSansSerif\",\n    value: function handleChangeFontSansSerif() {\n      if (this.dropDown.isOpen()) {\n        this.props.changeFont(fonts.SANS_SERIF);\n      }\n    }\n  }, {\n    key: \"handleChangeFontSerif\",\n    value: function handleChangeFontSerif() {\n      if (this.dropDown.isOpen()) {\n        this.props.changeFont(fonts.SERIF);\n      }\n    }\n  }, {\n    key: \"handleChangeFontHandwriting\",\n    value: function handleChangeFontHandwriting() {\n      if (this.dropDown.isOpen()) {\n        this.props.changeFont(fonts.HANDWRITING);\n      }\n    }\n  }, {\n    key: \"handleChangeFontMarker\",\n    value: function handleChangeFontMarker() {\n      if (this.dropDown.isOpen()) {\n        this.props.changeFont(fonts.MARKER);\n      }\n    }\n  }, {\n    key: \"handleChangeFontCurly\",\n    value: function handleChangeFontCurly() {\n      if (this.dropDown.isOpen()) {\n        this.props.changeFont(fonts.CURLY);\n      }\n    }\n  }, {\n    key: \"handleChangeFontPixel\",\n    value: function handleChangeFontPixel() {\n      if (this.dropDown.isOpen()) {\n        this.props.changeFont(fonts.PIXEL);\n      }\n    }\n  }, {\n    key: \"handleChangeFontChinese\",\n    value: function handleChangeFontChinese() {\n      if (this.dropDown.isOpen()) {\n        this.props.changeFont(fonts.CHINESE);\n      }\n    }\n  }, {\n    key: \"handleChangeFontJapanese\",\n    value: function handleChangeFontJapanese() {\n      if (this.dropDown.isOpen()) {\n        this.props.changeFont(fonts.JAPANESE);\n      }\n    }\n  }, {\n    key: \"handleChangeFontKorean\",\n    value: function handleChangeFontKorean() {\n      if (this.dropDown.isOpen()) {\n        this.props.changeFont(fonts.KOREAN);\n      }\n    }\n  }, {\n    key: \"handleChoose\",\n    value: function handleChoose() {\n      if (this.dropDown.isOpen()) {\n        this.dropDown.handleClosePopover();\n        this.props.onUpdateImage();\n      }\n    }\n  }, {\n    key: \"handleOpenDropdown\",\n    value: function handleOpenDropdown() {\n      this.savedFont = this.props.font;\n      this.savedSelection = selection_getSelectedLeafItems();\n    }\n  }, {\n    key: \"handleClickOutsideDropdown\",\n    value: function handleClickOutsideDropdown(e) {\n      e.stopPropagation();\n      this.dropDown.handleClosePopover(); // Cancel font change\n      var _iterator = font_dropdown_createForOfIteratorHelper(this.savedSelection),\n          _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var item = _step.value;\n          if (item instanceof paper_full_default.a.PointText) {\n            item.font = this.savedFont;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      this.props.changeFont(this.savedFont);\n      this.savedFont = null;\n      this.savedSelection = null;\n    }\n  }, {\n    key: \"setDropdown\",\n    value: function setDropdown(element) {\n      this.dropDown = element;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return react_default.a.createElement(font_dropdown_font_dropdown, {\n        componentRef: this.setDropdown,\n        font: this.props.font,\n        getFontName: this.getFontName,\n        getFontStyle: this.getFontStyle,\n        onChoose: this.handleChoose,\n        onClickOutsideDropdown: this.handleClickOutsideDropdown,\n        onHoverChinese: this.handleChangeFontChinese,\n        onHoverCurly: this.handleChangeFontCurly,\n        onHoverHandwriting: this.handleChangeFontHandwriting,\n        onHoverJapanese: this.handleChangeFontJapanese,\n        onHoverKorean: this.handleChangeFontKorean,\n        onHoverMarker: this.handleChangeFontMarker,\n        onHoverPixel: this.handleChangeFontPixel,\n        onHoverSansSerif: this.handleChangeFontSansSerif,\n        onHoverSerif: this.handleChangeFontSerif,\n        onOpenDropdown: this.handleOpenDropdown\n      });\n    }\n  }]);\n  return FontDropdown;\n}(react_default.a.Component);\nfont_dropdown_FontDropdown.propTypes = {\n  changeFont: prop_types_default.a.func.isRequired,\n  font: prop_types_default.a.string,\n  onUpdateImage: prop_types_default.a.func.isRequired\n};\nvar font_dropdown_mapStateToProps = function mapStateToProps(state) {\n  return {\n    font: state.scratchPaint.font\n  };\n};\nvar font_dropdown_mapDispatchToProps = function mapDispatchToProps(dispatch) {\n  return {\n    changeFont: function changeFont(font) {\n      dispatch(font_changeFont(font));\n    }\n  };\n};\n/* harmony default export */ var containers_font_dropdown = (Object(es[\"b\" /* connect */])(font_dropdown_mapStateToProps, font_dropdown_mapDispatchToProps)(font_dropdown_FontDropdown));\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/components/forms/live-input-hoc.jsx\nfunction live_input_hoc_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { live_input_hoc_typeof = function _typeof(obj) { return typeof obj; }; } else { live_input_hoc_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return live_input_hoc_typeof(obj); }\nfunction live_input_hoc_extends() { live_input_hoc_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return live_input_hoc_extends.apply(this, arguments); }\nfunction live_input_hoc_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction live_input_hoc_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction live_input_hoc_createClass(Constructor, protoProps, staticProps) { if (protoProps) live_input_hoc_defineProperties(Constructor.prototype, protoProps); if (staticProps) live_input_hoc_defineProperties(Constructor, staticProps); return Constructor; }\nfunction live_input_hoc_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) live_input_hoc_setPrototypeOf(subClass, superClass); }\nfunction live_input_hoc_setPrototypeOf(o, p) { live_input_hoc_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return live_input_hoc_setPrototypeOf(o, p); }\nfunction live_input_hoc_createSuper(Derived) { var hasNativeReflectConstruct = live_input_hoc_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = live_input_hoc_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = live_input_hoc_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return live_input_hoc_possibleConstructorReturn(this, result); }; }\nfunction live_input_hoc_possibleConstructorReturn(self, call) { if (call && (live_input_hoc_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return live_input_hoc_assertThisInitialized(self); }\nfunction live_input_hoc_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction live_input_hoc_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction live_input_hoc_getPrototypeOf(o) { live_input_hoc_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return live_input_hoc_getPrototypeOf(o); }\n\n/**\n * Higher Order Component to manage inputs that submit on change and <enter>\n * @param {React.Component} Input text input that consumes onChange, onBlur, onKeyPress\n * @returns {React.Component} Live input that calls onSubmit on change and <enter>\n */\n/* harmony default export */ var live_input_hoc = (function (Input) {\n  var LiveInput = function (_React$Component) {\n    live_input_hoc_inherits(LiveInput, _React$Component);\n    var _super = live_input_hoc_createSuper(LiveInput);\n    function LiveInput(props) {\n      var _this;\n      live_input_hoc_classCallCheck(this, LiveInput);\n      _this = _super.call(this, props);\n      lodash_bindall_default()(live_input_hoc_assertThisInitialized(_this), ['handleChange', 'handleKeyPress', 'handleFlush']);\n      _this.state = {\n        value: null\n      };\n      return _this;\n    }\n    live_input_hoc_createClass(LiveInput, [{\n      key: \"handleKeyPress\",\n      value: function handleKeyPress(e) {\n        if (e.key === 'Enter') {\n          this.handleChange(e);\n          e.target.blur();\n        }\n      }\n    }, {\n      key: \"handleFlush\",\n      value: function handleFlush() {\n        this.setState({\n          value: null\n        });\n      }\n    }, {\n      key: \"handleChange\",\n      value: function handleChange(e) {\n        var isNumeric = typeof this.props.value === 'number';\n        var validatesNumeric = isNumeric ? !isNaN(e.target.value) : true;\n        if (e.target.value !== null && validatesNumeric) {\n          var val = Number(e.target.value);\n          if (typeof this.props.max !== 'undefined' && val > Number(this.props.max)) {\n            val = this.props.max;\n          }\n          if (typeof this.props.min !== 'undefined' && val < Number(this.props.min)) {\n            val = this.props.min;\n          }\n          this.props.onSubmit(val);\n        }\n        this.setState({\n          value: e.target.value\n        });\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var liveValue = this.state.value === null ? this.props.value : this.state.value;\n        return react_default.a.createElement(Input, live_input_hoc_extends({}, this.props, {\n          value: liveValue,\n          onBlur: this.handleFlush,\n          onChange: this.handleChange,\n          onKeyPress: this.handleKeyPress\n        }));\n      }\n    }]);\n    return LiveInput;\n  }(react_default.a.Component);\n  LiveInput.propTypes = {\n    max: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),\n    min: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),\n    onSubmit: prop_types_default.a.func.isRequired,\n    value: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.number])\n  };\n  return LiveInput;\n});\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/mode-tools/mode-tools.css\nvar mode_tools = __webpack_require__(55);\nvar mode_tools_default = __webpack_require__.n(mode_tools);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/mode-tools/icons/copy.svg\nvar copy = __webpack_require__(621);\nvar copy_default = __webpack_require__.n(copy);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/mode-tools/icons/paste.svg\nvar paste = __webpack_require__(622);\nvar paste_default = __webpack_require__.n(paste);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/mode-tools/icons/delete.svg\nvar icons_delete = __webpack_require__(342);\nvar delete_default = __webpack_require__.n(icons_delete);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/mode-tools/icons/curved-point.svg\nvar curved_point = __webpack_require__(623);\nvar curved_point_default = __webpack_require__.n(curved_point);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/mode-tools/icons/flip-horizontal.svg\nvar flip_horizontal = __webpack_require__(624);\nvar flip_horizontal_default = __webpack_require__.n(flip_horizontal);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/mode-tools/icons/flip-vertical.svg\nvar flip_vertical = __webpack_require__(625);\nvar flip_vertical_default = __webpack_require__.n(flip_vertical);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/mode-tools/icons/straight-point.svg\nvar straight_point = __webpack_require__(626);\nvar straight_point_default = __webpack_require__.n(straight_point);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/bit-oval-mode/oval-outlined.svg\nvar oval_outlined = __webpack_require__(627);\nvar oval_outlined_default = __webpack_require__.n(oval_outlined);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/bit-rect-mode/rectangle-outlined.svg\nvar rectangle_outlined = __webpack_require__(628);\nvar rectangle_outlined_default = __webpack_require__.n(rectangle_outlined);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/components/mode-tools/mode-tools.jsx\n\n\n\nvar mode_tools_LiveInput = live_input_hoc(forms_input);\nvar mode_tools_ModeToolsComponent = function ModeToolsComponent(props) {\n  var messages = Object(index_es[\"d\" /* defineMessages */])({\n    brushSize: {\n      \"id\": \"paint.modeTools.brushSize\",\n      \"defaultMessage\": \"Size\"\n    },\n    eraserSize: {\n      \"id\": \"paint.modeTools.eraserSize\",\n      \"defaultMessage\": \"Eraser size\"\n    },\n    copy: {\n      \"id\": \"paint.modeTools.copy\",\n      \"defaultMessage\": \"Copy\"\n    },\n    paste: {\n      \"id\": \"paint.modeTools.paste\",\n      \"defaultMessage\": \"Paste\"\n    },\n    delete: {\n      \"id\": \"paint.modeTools.delete\",\n      \"defaultMessage\": \"Delete\"\n    },\n    curved: {\n      \"id\": \"paint.modeTools.curved\",\n      \"defaultMessage\": \"Curved\"\n    },\n    pointed: {\n      \"id\": \"paint.modeTools.pointed\",\n      \"defaultMessage\": \"Pointed\"\n    },\n    thickness: {\n      \"id\": \"paint.modeTools.thickness\",\n      \"defaultMessage\": \"Thickness\"\n    },\n    flipHorizontal: {\n      \"id\": \"paint.modeTools.flipHorizontal\",\n      \"defaultMessage\": \"Flip Horizontal\"\n    },\n    flipVertical: {\n      \"id\": \"paint.modeTools.flipVertical\",\n      \"defaultMessage\": \"Flip Vertical\"\n    },\n    filled: {\n      \"id\": \"paint.modeTools.filled\",\n      \"defaultMessage\": \"Filled\"\n    },\n    outlined: {\n      \"id\": \"paint.modeTools.outlined\",\n      \"defaultMessage\": \"Outlined\"\n    }\n  });\n  switch (props.mode) {\n    case Modes.BRUSH:\n    /* falls through */\n    case Modes.BIT_BRUSH:\n    /* falls through */\n    case Modes.BIT_LINE:\n      {\n        var currentIcon = isVector(props.format) ? brush_mode_brush_default.a : props.mode === Modes.BIT_LINE ? line_default.a : brush_default.a;\n        var currentBrushValue = format_isBitmap(props.format) ? props.bitBrushSize : props.brushValue;\n        var changeFunction = format_isBitmap(props.format) ? props.onBitBrushSliderChange : props.onBrushSliderChange;\n        var currentMessage = props.mode === Modes.BIT_LINE ? messages.thickness : messages.brushSize;\n        return react_default.a.createElement(\"div\", {\n          className: classnames_default()(props.className, mode_tools_default.a.modeTools)\n        }, react_default.a.createElement(\"div\", null, react_default.a.createElement(\"img\", {\n          alt: props.intl.formatMessage(currentMessage),\n          className: mode_tools_default.a.modeToolsIcon,\n          draggable: false,\n          src: currentIcon\n        })), react_default.a.createElement(mode_tools_LiveInput, {\n          range: true,\n          small: true,\n          max: MAX_STROKE_WIDTH,\n          min: \"1\",\n          type: \"number\",\n          value: currentBrushValue,\n          onSubmit: changeFunction\n        }));\n      }\n    case Modes.BIT_ERASER:\n    /* falls through */\n    case Modes.ERASER:\n      {\n        var _currentIcon = isVector(props.format) ? eraser_mode_eraser_default.a : eraser_default.a;\n        var currentEraserValue = format_isBitmap(props.format) ? props.bitEraserSize : props.eraserValue;\n        var _changeFunction = format_isBitmap(props.format) ? props.onBitEraserSliderChange : props.onEraserSliderChange;\n        return react_default.a.createElement(\"div\", {\n          className: classnames_default()(props.className, mode_tools_default.a.modeTools)\n        }, react_default.a.createElement(\"div\", null, react_default.a.createElement(\"img\", {\n          alt: props.intl.formatMessage(messages.eraserSize),\n          className: mode_tools_default.a.modeToolsIcon,\n          draggable: false,\n          src: _currentIcon\n        })), react_default.a.createElement(mode_tools_LiveInput, {\n          range: true,\n          small: true,\n          max: MAX_STROKE_WIDTH,\n          min: \"1\",\n          type: \"number\",\n          value: currentEraserValue,\n          onSubmit: _changeFunction\n        }));\n      }\n    case Modes.RESHAPE:\n      return react_default.a.createElement(\"div\", {\n        className: classnames_default()(props.className, mode_tools_default.a.modeTools)\n      }, react_default.a.createElement(input_group_input_group, {\n        className: classnames_default()(mode_tools_default.a.modDashedBorder, mode_tools_default.a.modLabeledIconHeight)\n      }, react_default.a.createElement(labeled_icon_button_labeled_icon_button, {\n        disabled: !props.hasSelectedUncurvedPoints,\n        hideLabel: hide_label_hideLabel(props.intl.locale),\n        imgSrc: curved_point_default.a,\n        title: props.intl.formatMessage(messages.curved),\n        onClick: props.onCurvePoints\n      }), react_default.a.createElement(labeled_icon_button_labeled_icon_button, {\n        disabled: !props.hasSelectedUnpointedPoints,\n        hideLabel: hide_label_hideLabel(props.intl.locale),\n        imgSrc: straight_point_default.a,\n        title: props.intl.formatMessage(messages.pointed),\n        onClick: props.onPointPoints\n      })), react_default.a.createElement(input_group_input_group, {\n        className: classnames_default()(mode_tools_default.a.modLabeledIconHeight)\n      }, react_default.a.createElement(labeled_icon_button_labeled_icon_button, {\n        hideLabel: hide_label_hideLabel(props.intl.locale),\n        imgSrc: delete_default.a,\n        title: props.intl.formatMessage(messages.delete),\n        onClick: props.onDelete\n      })));\n    case Modes.BIT_SELECT:\n    /* falls through */\n    case Modes.SELECT:\n      return react_default.a.createElement(\"div\", {\n        className: classnames_default()(props.className, mode_tools_default.a.modeTools)\n      }, react_default.a.createElement(input_group_input_group, {\n        className: classnames_default()(mode_tools_default.a.modDashedBorder, mode_tools_default.a.modLabeledIconHeight)\n      }, react_default.a.createElement(labeled_icon_button_labeled_icon_button, {\n        hideLabel: hide_label_hideLabel(props.intl.locale),\n        imgSrc: copy_default.a,\n        title: props.intl.formatMessage(messages.copy),\n        onClick: props.onCopyToClipboard\n      }), react_default.a.createElement(labeled_icon_button_labeled_icon_button, {\n        disabled: !(props.clipboardItems.length > 0),\n        hideLabel: hide_label_hideLabel(props.intl.locale),\n        imgSrc: paste_default.a,\n        title: props.intl.formatMessage(messages.paste),\n        onClick: props.onPasteFromClipboard\n      })), react_default.a.createElement(input_group_input_group, {\n        className: classnames_default()(mode_tools_default.a.modDashedBorder, mode_tools_default.a.modLabeledIconHeight)\n      }, react_default.a.createElement(labeled_icon_button_labeled_icon_button, {\n        hideLabel: hide_label_hideLabel(props.intl.locale),\n        imgSrc: delete_default.a,\n        title: props.intl.formatMessage(messages.delete),\n        onClick: props.onDelete\n      })), react_default.a.createElement(input_group_input_group, {\n        className: classnames_default()(mode_tools_default.a.modLabeledIconHeight)\n      }, react_default.a.createElement(labeled_icon_button_labeled_icon_button, {\n        hideLabel: props.intl.locale !== 'en',\n        imgSrc: flip_horizontal_default.a,\n        title: props.intl.formatMessage(messages.flipHorizontal),\n        onClick: props.onFlipHorizontal\n      }), react_default.a.createElement(labeled_icon_button_labeled_icon_button, {\n        hideLabel: props.intl.locale !== 'en',\n        imgSrc: flip_vertical_default.a,\n        title: props.intl.formatMessage(messages.flipVertical),\n        onClick: props.onFlipVertical\n      })));\n    case Modes.BIT_TEXT:\n    /* falls through */\n    case Modes.TEXT:\n      return react_default.a.createElement(\"div\", {\n        className: classnames_default()(props.className, mode_tools_default.a.modeTools)\n      }, react_default.a.createElement(input_group_input_group, null, react_default.a.createElement(containers_font_dropdown, {\n        onUpdateImage: props.onUpdateImage\n      })));\n    case Modes.BIT_RECT:\n    /* falls through */\n    case Modes.BIT_OVAL:\n      {\n        var fillIcon = props.mode === Modes.BIT_RECT ? rectangle_default.a : oval_default.a;\n        var outlineIcon = props.mode === Modes.BIT_RECT ? rectangle_outlined_default.a : oval_outlined_default.a;\n        return react_default.a.createElement(\"div\", {\n          className: classnames_default()(props.className, mode_tools_default.a.modeTools)\n        }, react_default.a.createElement(input_group_input_group, null, react_default.a.createElement(labeled_icon_button_labeled_icon_button, {\n          highlighted: props.fillBitmapShapes,\n          imgSrc: fillIcon,\n          title: props.intl.formatMessage(messages.filled),\n          onClick: props.onFillShapes\n        })), react_default.a.createElement(input_group_input_group, null, react_default.a.createElement(labeled_icon_button_labeled_icon_button, {\n          highlighted: !props.fillBitmapShapes,\n          imgSrc: outlineIcon,\n          title: props.intl.formatMessage(messages.outlined),\n          onClick: props.onOutlineShapes\n        })), props.fillBitmapShapes ? null : react_default.a.createElement(input_group_input_group, null, react_default.a.createElement(components_forms_label, {\n          text: props.intl.formatMessage(messages.thickness)\n        }, react_default.a.createElement(mode_tools_LiveInput, {\n          range: true,\n          small: true,\n          max: MAX_STROKE_WIDTH,\n          min: \"1\",\n          type: \"number\",\n          value: props.bitBrushSize,\n          onSubmit: props.onBitBrushSliderChange\n        }))));\n      }\n    default:\n      // Leave empty for now, if mode not supported\n      return react_default.a.createElement(\"div\", {\n        className: classnames_default()(props.className, mode_tools_default.a.modeTools)\n      });\n  }\n};\nmode_tools_ModeToolsComponent.propTypes = {\n  bitBrushSize: prop_types_default.a.number,\n  bitEraserSize: prop_types_default.a.number,\n  brushValue: prop_types_default.a.number,\n  className: prop_types_default.a.string,\n  clipboardItems: prop_types_default.a.arrayOf(prop_types_default.a.array),\n  eraserValue: prop_types_default.a.number,\n  fillBitmapShapes: prop_types_default.a.bool,\n  format: prop_types_default.a.oneOf(Object.keys(Formats)),\n  hasSelectedUncurvedPoints: prop_types_default.a.bool,\n  hasSelectedUnpointedPoints: prop_types_default.a.bool,\n  intl: index_es[\"f\" /* intlShape */].isRequired,\n  mode: prop_types_default.a.string.isRequired,\n  onBitBrushSliderChange: prop_types_default.a.func.isRequired,\n  onBitEraserSliderChange: prop_types_default.a.func.isRequired,\n  onBrushSliderChange: prop_types_default.a.func.isRequired,\n  onCopyToClipboard: prop_types_default.a.func.isRequired,\n  onCurvePoints: prop_types_default.a.func.isRequired,\n  onDelete: prop_types_default.a.func.isRequired,\n  onEraserSliderChange: prop_types_default.a.func,\n  onFillShapes: prop_types_default.a.func.isRequired,\n  onFlipHorizontal: prop_types_default.a.func.isRequired,\n  onFlipVertical: prop_types_default.a.func.isRequired,\n  onOutlineShapes: prop_types_default.a.func.isRequired,\n  onPasteFromClipboard: prop_types_default.a.func.isRequired,\n  onPointPoints: prop_types_default.a.func.isRequired,\n  onUpdateImage: prop_types_default.a.func.isRequired\n};\nvar mode_tools_mapStateToProps = function mapStateToProps(state) {\n  return {\n    mode: state.scratchPaint.mode,\n    format: state.scratchPaint.format,\n    fillBitmapShapes: state.scratchPaint.fillBitmapShapes,\n    bitBrushSize: state.scratchPaint.bitBrushSize,\n    bitEraserSize: state.scratchPaint.bitEraserSize,\n    brushValue: state.scratchPaint.brushMode.brushSize,\n    clipboardItems: state.scratchPaint.clipboard.items,\n    eraserValue: state.scratchPaint.eraserMode.brushSize\n  };\n};\nvar mode_tools_mapDispatchToProps = function mapDispatchToProps(dispatch) {\n  return {\n    onBrushSliderChange: function onBrushSliderChange(brushSize) {\n      dispatch(brush_mode_changeBrushSize(brushSize));\n    },\n    onBitBrushSliderChange: function onBitBrushSliderChange(bitBrushSize) {\n      dispatch(changeBitBrushSize(bitBrushSize));\n    },\n    onBitEraserSliderChange: function onBitEraserSliderChange(eraserSize) {\n      dispatch(changeBitEraserSize(eraserSize));\n    },\n    onEraserSliderChange: function onEraserSliderChange(eraserSize) {\n      dispatch(eraser_mode_changeBrushSize(eraserSize));\n    },\n    onFillShapes: function onFillShapes() {\n      dispatch(setShapesFilled(true));\n    },\n    onOutlineShapes: function onOutlineShapes() {\n      dispatch(setShapesFilled(false));\n    }\n  };\n};\n/* harmony default export */ var mode_tools_mode_tools = (Object(es[\"b\" /* connect */])(mode_tools_mapStateToProps, mode_tools_mapDispatchToProps)(Object(index_es[\"e\" /* injectIntl */])(mode_tools_ModeToolsComponent)));\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/containers/mode-tools.jsx\nfunction mode_tools_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { mode_tools_typeof = function _typeof(obj) { return typeof obj; }; } else { mode_tools_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return mode_tools_typeof(obj); }\nfunction mode_tools_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = mode_tools_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction mode_tools_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return mode_tools_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return mode_tools_arrayLikeToArray(o, minLen); }\nfunction mode_tools_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction mode_tools_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction mode_tools_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction mode_tools_createClass(Constructor, protoProps, staticProps) { if (protoProps) mode_tools_defineProperties(Constructor.prototype, protoProps); if (staticProps) mode_tools_defineProperties(Constructor, staticProps); return Constructor; }\nfunction mode_tools_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) mode_tools_setPrototypeOf(subClass, superClass); }\nfunction mode_tools_setPrototypeOf(o, p) { mode_tools_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return mode_tools_setPrototypeOf(o, p); }\nfunction mode_tools_createSuper(Derived) { var hasNativeReflectConstruct = mode_tools_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = mode_tools_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = mode_tools_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return mode_tools_possibleConstructorReturn(this, result); }; }\nfunction mode_tools_possibleConstructorReturn(self, call) { if (call && (mode_tools_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return mode_tools_assertThisInitialized(self); }\nfunction mode_tools_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction mode_tools_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction mode_tools_getPrototypeOf(o) { mode_tools_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return mode_tools_getPrototypeOf(o); }\n\nvar mode_tools_ModeTools = function (_React$Component) {\n  mode_tools_inherits(ModeTools, _React$Component);\n  var _super = mode_tools_createSuper(ModeTools);\n  function ModeTools(props) {\n    var _this;\n    mode_tools_classCallCheck(this, ModeTools);\n    _this = _super.call(this, props);\n    lodash_bindall_default()(mode_tools_assertThisInitialized(_this), ['_getSelectedUncurvedPoints', '_getSelectedUnpointedPoints', 'hasSelectedUncurvedPoints', 'hasSelectedUnpointedPoints', 'handleCurvePoints', 'handleFlipHorizontal', 'handleFlipVertical', 'handleDelete', 'handlePasteFromClipboard', 'handlePointPoints']);\n    return _this;\n  }\n  mode_tools_createClass(ModeTools, [{\n    key: \"_getSelectedUncurvedPoints\",\n    value: function _getSelectedUncurvedPoints() {\n      var items = [];\n      var selectedItems = selection_getSelectedLeafItems();\n      var _iterator = mode_tools_createForOfIteratorHelper(selectedItems),\n          _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var item = _step.value;\n          if (!item.segments) continue;\n          var _iterator2 = mode_tools_createForOfIteratorHelper(item.segments),\n              _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var seg = _step2.value;\n              if (seg.selected) {\n                var prev = seg.getPrevious();\n                var next = seg.getNext();\n                var isCurved = (!prev || seg.handleIn.length > 0) && (!next || seg.handleOut.length > 0) && (prev && next ? seg.handleOut.isColinear(seg.handleIn) : true);\n                if (!isCurved) items.push(seg);\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return items;\n    }\n  }, {\n    key: \"_getSelectedUnpointedPoints\",\n    value: function _getSelectedUnpointedPoints() {\n      var points = [];\n      var selectedItems = selection_getSelectedLeafItems();\n      var _iterator3 = mode_tools_createForOfIteratorHelper(selectedItems),\n          _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var item = _step3.value;\n          if (!item.segments) continue;\n          var _iterator4 = mode_tools_createForOfIteratorHelper(item.segments),\n              _step4;\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var seg = _step4.value;\n              if (seg.selected) {\n                if (seg.handleIn.length > 0 || seg.handleOut.length > 0) {\n                  points.push(seg);\n                }\n              }\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return points;\n    }\n  }, {\n    key: \"hasSelectedUncurvedPoints\",\n    value: function hasSelectedUncurvedPoints() {\n      var points = this._getSelectedUncurvedPoints();\n      return points.length > 0;\n    }\n  }, {\n    key: \"hasSelectedUnpointedPoints\",\n    value: function hasSelectedUnpointedPoints() {\n      var points = this._getSelectedUnpointedPoints();\n      return points.length > 0;\n    }\n  }, {\n    key: \"handleCurvePoints\",\n    value: function handleCurvePoints() {\n      var changed;\n      var points = this._getSelectedUncurvedPoints();\n      var _iterator5 = mode_tools_createForOfIteratorHelper(points),\n          _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var point = _step5.value;\n          var prev = point.getPrevious();\n          var next = point.getNext();\n          var noHandles = point.handleIn.length === 0 && point.handleOut.length === 0;\n          if (!prev && !next) {\n            continue;\n          } else if (prev && next && noHandles) {\n            // Handles are parallel to the line from prev to next\n            point.handleIn = prev.point.subtract(next.point).normalize().multiply(prev.getCurve().length * HANDLE_RATIO);\n          } else if (prev && !next && point.handleIn.length === 0) {\n            // Point is end point\n            // Direction is average of normal at the point and direction to prev point, using the\n            // normal that points out from the convex side\n            // Lenth is curve length * HANDLE_RATIO\n            var convexity = prev.getCurve().getCurvatureAtTime(.5) < 0 ? -1 : 1;\n            point.handleIn = prev.getCurve().getNormalAtTime(1).multiply(convexity).add(prev.point.subtract(point.point).normalize()).normalize().multiply(prev.getCurve().length * HANDLE_RATIO);\n          } else if (next && !prev && point.handleOut.length === 0) {\n            // Point is start point\n            // Direction is average of normal at the point and direction to prev point, using the\n            // normal that points out from the convex side\n            // Lenth is curve length * HANDLE_RATIO\n            var _convexity = point.getCurve().getCurvatureAtTime(.5) < 0 ? -1 : 1;\n            point.handleOut = point.getCurve().getNormalAtTime(0).multiply(_convexity).add(next.point.subtract(point.point).normalize()).normalize().multiply(point.getCurve().length * HANDLE_RATIO);\n          } // Point guaranteed to have a handle now. Make the second handle match the length and direction of first.\n          // This defines a curved point.\n          if (point.handleIn.length > 0 && next) {\n            point.handleOut = point.handleIn.multiply(-1);\n          } else if (point.handleOut.length > 0 && prev) {\n            point.handleIn = point.handleOut.multiply(-1);\n          }\n          changed = true;\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n      if (changed) {\n        this.props.setSelectedItems(this.props.format);\n        this.props.onUpdateImage();\n      }\n    }\n  }, {\n    key: \"handlePointPoints\",\n    value: function handlePointPoints() {\n      var changed;\n      var points = this._getSelectedUnpointedPoints();\n      var _iterator6 = mode_tools_createForOfIteratorHelper(points),\n          _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var point = _step6.value;\n          var noHandles = point.handleIn.length === 0 && point.handleOut.length === 0;\n          if (!noHandles) {\n            point.handleIn = null;\n            point.handleOut = null;\n            changed = true;\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n      if (changed) {\n        this.props.setSelectedItems(this.props.format);\n        this.props.onUpdateImage();\n      }\n    }\n  }, {\n    key: \"_handleFlip\",\n    value: function _handleFlip(horizontalScale, verticalScale, selectedItems) {\n      if (selectedItems.length === 0) {\n        // If nothing is selected, select everything\n        selectedItems = selection_getAllRootItems();\n      } // Record old indices\n      var _iterator7 = mode_tools_createForOfIteratorHelper(selectedItems),\n          _step7;\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var item = _step7.value;\n          item.data.index = item.index;\n        } // Group items so that they flip as a unit\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n      var itemGroup = new paper_full_default.a.Group(selectedItems); // Flip\n      itemGroup.scale(horizontalScale, verticalScale);\n      math_ensureClockwise(itemGroup); // Remove flipped item from group and insert at old index. Must insert from bottom index up.\n      for (var i = 0; i < selectedItems.length; i++) {\n        itemGroup.layer.insertChild(selectedItems[i].data.index, selectedItems[i]);\n        selectedItems[i].data.index = null;\n      }\n      itemGroup.remove();\n      this.props.onUpdateImage();\n    }\n  }, {\n    key: \"handleFlipHorizontal\",\n    value: function handleFlipHorizontal() {\n      var selectedItems = selection_getSelectedRootItems();\n      if (format_isBitmap(this.props.format) && selectedItems.length === 0) {\n        getRaster().canvas = bitmap_flipBitmapHorizontal(getRaster().canvas);\n        this.props.onUpdateImage();\n      } else {\n        this._handleFlip(-1, 1, selectedItems);\n      }\n    }\n  }, {\n    key: \"handleFlipVertical\",\n    value: function handleFlipVertical() {\n      var selectedItems = selection_getSelectedRootItems();\n      if (format_isBitmap(this.props.format) && selectedItems.length === 0) {\n        getRaster().canvas = bitmap_flipBitmapVertical(getRaster().canvas);\n        this.props.onUpdateImage();\n      } else {\n        this._handleFlip(1, -1, selectedItems);\n      }\n    }\n  }, {\n    key: \"handlePasteFromClipboard\",\n    value: function handlePasteFromClipboard() {\n      if (this.props.onPasteFromClipboard()) {\n        this.props.onUpdateImage();\n      }\n    }\n  }, {\n    key: \"handleDelete\",\n    value: function handleDelete() {\n      if (!this.props.selectedItems.length) {\n        if (format_isBitmap(this.props.format)) {\n          bitmap_selectAllBitmap(this.props.clearSelectedItems);\n        } else if (this.props.mode === Modes.RESHAPE) {\n          selectAllSegments();\n        } else {\n          selectAllItems();\n        }\n      }\n      if (selection_deleteSelection(this.props.mode, this.props.onUpdateImage)) {\n        this.props.setSelectedItems(this.props.format);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return react_default.a.createElement(mode_tools_mode_tools, {\n        hasSelectedUncurvedPoints: this.hasSelectedUncurvedPoints(),\n        hasSelectedUnpointedPoints: this.hasSelectedUnpointedPoints(),\n        onCopyToClipboard: this.props.onCopyToClipboard,\n        onCurvePoints: this.handleCurvePoints,\n        onDelete: this.handleDelete,\n        onFlipHorizontal: this.handleFlipHorizontal,\n        onFlipVertical: this.handleFlipVertical,\n        onPasteFromClipboard: this.handlePasteFromClipboard,\n        onPointPoints: this.handlePointPoints,\n        onUpdateImage: this.props.onUpdateImage\n      });\n    }\n  }]);\n  return ModeTools;\n}(react_default.a.Component);\nmode_tools_ModeTools.propTypes = {\n  clearSelectedItems: prop_types_default.a.func.isRequired,\n  format: prop_types_default.a.oneOf(Object.keys(Formats)),\n  mode: prop_types_default.a.oneOf(Object.keys(Modes)),\n  onCopyToClipboard: prop_types_default.a.func.isRequired,\n  onPasteFromClipboard: prop_types_default.a.func.isRequired,\n  onUpdateImage: prop_types_default.a.func.isRequired,\n  // Listen on selected items to update hasSelectedPoints\n  selectedItems: prop_types_default.a.arrayOf(prop_types_default.a.instanceOf(paper_full_default.a.Item)),\n  // eslint-disable-line react/no-unused-prop-types\n  setSelectedItems: prop_types_default.a.func.isRequired\n};\nvar containers_mode_tools_mapStateToProps = function mapStateToProps(state) {\n  return {\n    format: state.scratchPaint.format,\n    mode: state.scratchPaint.mode,\n    selectedItems: state.scratchPaint.selectedItems\n  };\n};\nvar containers_mode_tools_mapDispatchToProps = function mapDispatchToProps(dispatch) {\n  return {\n    clearSelectedItems: function clearSelectedItems() {\n      dispatch(selected_items_clearSelectedItems());\n    },\n    setSelectedItems: function setSelectedItems(format) {\n      dispatch(selected_items_setSelectedItems(selection_getSelectedLeafItems(), format_isBitmap(format)));\n    }\n  };\n};\n/* harmony default export */ var containers_mode_tools = (copy_paste_hoc(Object(es[\"b\" /* connect */])(containers_mode_tools_mapStateToProps, containers_mode_tools_mapDispatchToProps)(mode_tools_ModeTools)));\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/helper/tools/oval-tool.js\nfunction tools_oval_tool_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { tools_oval_tool_typeof = function _typeof(obj) { return typeof obj; }; } else { tools_oval_tool_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return tools_oval_tool_typeof(obj); }\nfunction tools_oval_tool_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction tools_oval_tool_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction tools_oval_tool_createClass(Constructor, protoProps, staticProps) { if (protoProps) tools_oval_tool_defineProperties(Constructor.prototype, protoProps); if (staticProps) tools_oval_tool_defineProperties(Constructor, staticProps); return Constructor; }\nfunction tools_oval_tool_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) tools_oval_tool_setPrototypeOf(subClass, superClass); }\nfunction tools_oval_tool_setPrototypeOf(o, p) { tools_oval_tool_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return tools_oval_tool_setPrototypeOf(o, p); }\nfunction tools_oval_tool_createSuper(Derived) { var hasNativeReflectConstruct = tools_oval_tool_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = tools_oval_tool_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = tools_oval_tool_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return tools_oval_tool_possibleConstructorReturn(this, result); }; }\nfunction tools_oval_tool_possibleConstructorReturn(self, call) { if (call && (tools_oval_tool_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return tools_oval_tool_assertThisInitialized(self); }\nfunction tools_oval_tool_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction tools_oval_tool_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction tools_oval_tool_getPrototypeOf(o) { tools_oval_tool_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return tools_oval_tool_getPrototypeOf(o); }\n\n/**\n * Tool for drawing ovals.\n */\nvar tools_oval_tool_OvalTool = function (_paper$Tool) {\n  tools_oval_tool_inherits(OvalTool, _paper$Tool);\n  var _super = tools_oval_tool_createSuper(OvalTool);\n  tools_oval_tool_createClass(OvalTool, null, [{\n    key: \"TOLERANCE\",\n    get: function get() {\n      return 2;\n    }\n    /**\n     * @param {function} setSelectedItems Callback to set the set of selected items in the Redux state\n     * @param {function} clearSelectedItems Callback to clear the set of selected items in the Redux state\n     * @param {function} setCursor Callback to set the visible mouse cursor\n     * @param {!function} onUpdateImage A callback to call when the image visibly changes\n     */\n  }]);\n  function OvalTool(setSelectedItems, clearSelectedItems, setCursor, onUpdateImage) {\n    var _this;\n    tools_oval_tool_classCallCheck(this, OvalTool);\n    _this = _super.call(this);\n    _this.setSelectedItems = setSelectedItems;\n    _this.clearSelectedItems = clearSelectedItems;\n    _this.onUpdateImage = onUpdateImage;\n    _this.boundingBoxTool = new bounding_box_tool(Modes.OVAL, setSelectedItems, clearSelectedItems, setCursor, onUpdateImage);\n    var nudgeTool = new nudge_tool(Modes.OVAL, _this.boundingBoxTool, onUpdateImage); // We have to set these functions instead of just declaring them because\n    // paper.js tools hook up the listeners in the setter functions.\n    _this.onMouseDown = _this.handleMouseDown;\n    _this.onMouseDrag = _this.handleMouseDrag;\n    _this.onMouseMove = _this.handleMouseMove;\n    _this.onMouseUp = _this.handleMouseUp;\n    _this.onKeyUp = nudgeTool.onKeyUp;\n    _this.onKeyDown = nudgeTool.onKeyDown;\n    _this.oval = null;\n    _this.colorState = null;\n    _this.isBoundingBoxMode = null;\n    _this.active = false;\n    return _this;\n  }\n  tools_oval_tool_createClass(OvalTool, [{\n    key: \"getHitOptions\",\n    value: function getHitOptions() {\n      return {\n        segments: true,\n        stroke: true,\n        curves: true,\n        fill: true,\n        guide: false,\n        match: function match(hitResult) {\n          return hitResult.item.data && (hitResult.item.data.isScaleHandle || hitResult.item.data.isRotHandle) || hitResult.item.selected;\n        },\n        // Allow hits on bounding box and selected only\n        tolerance: OvalTool.TOLERANCE / paper_full_default.a.view.zoom\n      };\n    }\n    /**\n     * Should be called if the selection changes to update the bounds of the bounding box.\n     * @param {Array<paper.Item>} selectedItems Array of selected items.\n     */\n  }, {\n    key: \"onSelectionChanged\",\n    value: function onSelectionChanged(selectedItems) {\n      this.boundingBoxTool.onSelectionChanged(selectedItems);\n    }\n  }, {\n    key: \"setColorState\",\n    value: function setColorState(colorState) {\n      this.colorState = colorState;\n    }\n  }, {\n    key: \"handleMouseDown\",\n    value: function handleMouseDown(event) {\n      if (event.event.button > 0) return; // only first mouse button\n      this.active = true;\n      if (this.boundingBoxTool.onMouseDown(event, false\n      /* clone */\n      , false\n      /* multiselect */\n      , false\n      /* doubleClicked */\n      , this.getHitOptions())) {\n        this.isBoundingBoxMode = true;\n      } else {\n        this.isBoundingBoxMode = false;\n        selection_clearSelection(this.clearSelectedItems);\n        this.oval = new paper_full_default.a.Shape.Ellipse({\n          point: event.downPoint,\n          size: 0\n        });\n        style_path_styleShape(this.oval, this.colorState);\n      }\n    }\n  }, {\n    key: \"handleMouseDrag\",\n    value: function handleMouseDrag(event) {\n      if (event.event.button > 0 || !this.active) return; // only first mouse button\n      if (this.isBoundingBoxMode) {\n        this.boundingBoxTool.onMouseDrag(event);\n        return;\n      }\n      var downPoint = new paper_full_default.a.Point(event.downPoint.x, event.downPoint.y);\n      var point = new paper_full_default.a.Point(event.point.x, event.point.y);\n      var squareDimensions = math_getSquareDimensions(event.downPoint, event.point);\n      if (event.modifiers.shift) {\n        this.oval.size = squareDimensions.size.abs();\n      } else {\n        this.oval.size = downPoint.subtract(point);\n      }\n      if (event.modifiers.alt) {\n        this.oval.position = downPoint;\n      } else if (event.modifiers.shift) {\n        this.oval.position = squareDimensions.position;\n      } else {\n        this.oval.position = downPoint.subtract(this.oval.size.multiply(0.5));\n      }\n      style_path_styleShape(this.oval, this.colorState);\n    }\n  }, {\n    key: \"handleMouseMove\",\n    value: function handleMouseMove(event) {\n      this.boundingBoxTool.onMouseMove(event, this.getHitOptions());\n    }\n  }, {\n    key: \"handleMouseUp\",\n    value: function handleMouseUp(event) {\n      if (event.event.button > 0 || !this.active) return; // only first mouse button\n      if (this.isBoundingBoxMode) {\n        this.boundingBoxTool.onMouseUp(event);\n        this.isBoundingBoxMode = null;\n        return;\n      }\n      if (this.oval) {\n        if (Math.abs(this.oval.size.width * this.oval.size.height) < OvalTool.TOLERANCE / paper_full_default.a.view.zoom) {\n          // Tiny oval created unintentionally?\n          this.oval.remove();\n          this.oval = null;\n        } else {\n          var ovalPath = this.oval.toPath(true\n          /* insert */\n          );\n          this.oval.remove();\n          this.oval = null;\n          ovalPath.selected = true;\n          this.setSelectedItems();\n          this.onUpdateImage();\n        }\n      }\n      this.active = false;\n    }\n  }, {\n    key: \"deactivateTool\",\n    value: function deactivateTool() {\n      this.boundingBoxTool.deactivateTool();\n    }\n  }]);\n  return OvalTool;\n}(paper_full_default.a.Tool);\n/* harmony default export */ var tools_oval_tool = (tools_oval_tool_OvalTool);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/oval-mode/oval.svg\nvar oval_mode_oval = __webpack_require__(629);\nvar oval_mode_oval_default = __webpack_require__.n(oval_mode_oval);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/components/oval-mode/oval-mode.jsx\n\nvar oval_mode_OvalModeComponent = function OvalModeComponent(props) {\n  return react_default.a.createElement(tool_select_base_tool_select_base, {\n    imgDescriptor: lib_messages.oval,\n    imgSrc: oval_mode_oval_default.a,\n    isSelected: props.isSelected,\n    onMouseDown: props.onMouseDown\n  });\n};\noval_mode_OvalModeComponent.propTypes = {\n  isSelected: prop_types_default.a.bool.isRequired,\n  onMouseDown: prop_types_default.a.func.isRequired\n};\n/* harmony default export */ var oval_mode = (oval_mode_OvalModeComponent);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/containers/oval-mode.jsx\nfunction oval_mode_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { oval_mode_typeof = function _typeof(obj) { return typeof obj; }; } else { oval_mode_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return oval_mode_typeof(obj); }\nfunction oval_mode_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction oval_mode_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction oval_mode_createClass(Constructor, protoProps, staticProps) { if (protoProps) oval_mode_defineProperties(Constructor.prototype, protoProps); if (staticProps) oval_mode_defineProperties(Constructor, staticProps); return Constructor; }\nfunction oval_mode_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) oval_mode_setPrototypeOf(subClass, superClass); }\nfunction oval_mode_setPrototypeOf(o, p) { oval_mode_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return oval_mode_setPrototypeOf(o, p); }\nfunction oval_mode_createSuper(Derived) { var hasNativeReflectConstruct = oval_mode_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = oval_mode_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = oval_mode_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return oval_mode_possibleConstructorReturn(this, result); }; }\nfunction oval_mode_possibleConstructorReturn(self, call) { if (call && (oval_mode_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return oval_mode_assertThisInitialized(self); }\nfunction oval_mode_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction oval_mode_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction oval_mode_getPrototypeOf(o) { oval_mode_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return oval_mode_getPrototypeOf(o); }\n\nvar oval_mode_OvalMode = function (_React$Component) {\n  oval_mode_inherits(OvalMode, _React$Component);\n  var _super = oval_mode_createSuper(OvalMode);\n  function OvalMode(props) {\n    var _this;\n    oval_mode_classCallCheck(this, OvalMode);\n    _this = _super.call(this, props);\n    lodash_bindall_default()(oval_mode_assertThisInitialized(_this), ['activateTool', 'deactivateTool', 'validateColorState']);\n    return _this;\n  }\n  oval_mode_createClass(OvalMode, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this.props.isOvalModeActive) {\n        this.activateTool(this.props);\n      }\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(nextProps) {\n      if (this.tool && nextProps.colorState !== this.props.colorState) {\n        this.tool.setColorState(nextProps.colorState);\n      }\n      if (this.tool && nextProps.selectedItems !== this.props.selectedItems) {\n        this.tool.onSelectionChanged(nextProps.selectedItems);\n      }\n      if (nextProps.isOvalModeActive && !this.props.isOvalModeActive) {\n        this.activateTool();\n      } else if (!nextProps.isOvalModeActive && this.props.isOvalModeActive) {\n        this.deactivateTool();\n      }\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps) {\n      return nextProps.isOvalModeActive !== this.props.isOvalModeActive;\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.tool) {\n        this.deactivateTool();\n      }\n    }\n  }, {\n    key: \"activateTool\",\n    value: function activateTool() {\n      selection_clearSelection(this.props.clearSelectedItems);\n      this.validateColorState();\n      this.tool = new tools_oval_tool(this.props.setSelectedItems, this.props.clearSelectedItems, this.props.setCursor, this.props.onUpdateImage);\n      this.tool.setColorState(this.props.colorState);\n      this.tool.activate();\n    }\n  }, {\n    key: \"deactivateTool\",\n    value: function deactivateTool() {\n      this.tool.deactivateTool();\n      this.tool.remove();\n      this.tool = null;\n    }\n  }, {\n    key: \"validateColorState\",\n    value: function validateColorState() {\n      // Make sure that at least one of fill/stroke is set, and that MIXED is not one of the colors.\n      // If fill and stroke color are both missing, set fill to default and stroke to transparent.\n      // If exactly one of fill or stroke color is set, set the other one to transparent.\n      var strokeWidth = this.props.colorState.strokeWidth;\n      var fillColor1 = this.props.colorState.fillColor.primary;\n      var fillColor2 = this.props.colorState.fillColor.secondary;\n      var fillGradient = this.props.colorState.fillColor.gradientType;\n      var strokeColor1 = this.props.colorState.strokeColor.primary;\n      var strokeColor2 = this.props.colorState.strokeColor.secondary;\n      var strokeGradient = this.props.colorState.strokeColor.gradientType;\n      if (fillColor2 === MIXED) {\n        this.props.clearFillGradient();\n        fillColor2 = null;\n        fillGradient = gradient_types.SOLID;\n      }\n      if (strokeColor2 === MIXED) {\n        this.props.clearStrokeGradient();\n        strokeColor2 = null;\n        strokeGradient = gradient_types.SOLID;\n      }\n      var fillColorMissing = fillColor1 === MIXED || fillGradient === gradient_types.SOLID && fillColor1 === null || fillGradient !== gradient_types.SOLID && fillColor1 === null && fillColor2 === null;\n      var strokeColorMissing = strokeColor1 === MIXED || strokeWidth === null || strokeWidth === 0 || strokeGradient === gradient_types.SOLID && strokeColor1 === null || strokeGradient !== gradient_types.SOLID && strokeColor1 === null && strokeColor2 === null;\n      if (fillColorMissing && strokeColorMissing) {\n        this.props.onChangeFillColor(DEFAULT_COLOR);\n        this.props.clearFillGradient();\n        this.props.onChangeStrokeColor(null);\n        this.props.clearStrokeGradient();\n      } else if (fillColorMissing && !strokeColorMissing) {\n        this.props.onChangeFillColor(null);\n        this.props.clearFillGradient();\n      } else if (!fillColorMissing && strokeColorMissing) {\n        this.props.onChangeStrokeColor(null);\n        this.props.clearStrokeGradient();\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return react_default.a.createElement(oval_mode, {\n        isSelected: this.props.isOvalModeActive,\n        onMouseDown: this.props.handleMouseDown\n      });\n    }\n  }]);\n  return OvalMode;\n}(react_default.a.Component);\noval_mode_OvalMode.propTypes = {\n  clearFillGradient: prop_types_default.a.func.isRequired,\n  clearStrokeGradient: prop_types_default.a.func.isRequired,\n  clearSelectedItems: prop_types_default.a.func.isRequired,\n  colorState: prop_types_default.a.shape({\n    fillColor: color_style_proptype,\n    strokeColor: color_style_proptype,\n    strokeWidth: prop_types_default.a.number\n  }).isRequired,\n  handleMouseDown: prop_types_default.a.func.isRequired,\n  isOvalModeActive: prop_types_default.a.bool.isRequired,\n  onChangeFillColor: prop_types_default.a.func.isRequired,\n  onChangeStrokeColor: prop_types_default.a.func.isRequired,\n  onUpdateImage: prop_types_default.a.func.isRequired,\n  selectedItems: prop_types_default.a.arrayOf(prop_types_default.a.instanceOf(paper_full_default.a.Item)),\n  setCursor: prop_types_default.a.func.isRequired,\n  setSelectedItems: prop_types_default.a.func.isRequired\n};\nvar oval_mode_mapStateToProps = function mapStateToProps(state) {\n  return {\n    colorState: state.scratchPaint.color,\n    isOvalModeActive: state.scratchPaint.mode === Modes.OVAL,\n    selectedItems: state.scratchPaint.selectedItems\n  };\n};\nvar oval_mode_mapDispatchToProps = function mapDispatchToProps(dispatch) {\n  return {\n    clearSelectedItems: function clearSelectedItems() {\n      dispatch(selected_items_clearSelectedItems());\n    },\n    clearFillGradient: function clearFillGradient() {\n      dispatch(fill_style_clearFillGradient());\n    },\n    clearStrokeGradient: function clearStrokeGradient() {\n      dispatch(stroke_style_clearStrokeGradient());\n    },\n    setCursor: function setCursor(cursorString) {\n      dispatch(cursor_setCursor(cursorString));\n    },\n    setSelectedItems: function setSelectedItems() {\n      dispatch(selected_items_setSelectedItems(selection_getSelectedLeafItems(), false\n      /* bitmapMode */\n      ));\n    },\n    handleMouseDown: function handleMouseDown() {\n      dispatch(modes_changeMode(Modes.OVAL));\n    },\n    onChangeFillColor: function onChangeFillColor(fillColor) {\n      dispatch(changeFillColor(fillColor));\n    },\n    onChangeStrokeColor: function onChangeStrokeColor(strokeColor) {\n      dispatch(changeStrokeColor(strokeColor));\n    }\n  };\n};\n/* harmony default export */ var containers_oval_mode = (Object(es[\"b\" /* connect */])(oval_mode_mapStateToProps, oval_mode_mapDispatchToProps)(oval_mode_OvalMode));\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/helper/tools/rect-tool.js\nfunction tools_rect_tool_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { tools_rect_tool_typeof = function _typeof(obj) { return typeof obj; }; } else { tools_rect_tool_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return tools_rect_tool_typeof(obj); }\nfunction tools_rect_tool_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction tools_rect_tool_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction tools_rect_tool_createClass(Constructor, protoProps, staticProps) { if (protoProps) tools_rect_tool_defineProperties(Constructor.prototype, protoProps); if (staticProps) tools_rect_tool_defineProperties(Constructor, staticProps); return Constructor; }\nfunction tools_rect_tool_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) tools_rect_tool_setPrototypeOf(subClass, superClass); }\nfunction tools_rect_tool_setPrototypeOf(o, p) { tools_rect_tool_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return tools_rect_tool_setPrototypeOf(o, p); }\nfunction tools_rect_tool_createSuper(Derived) { var hasNativeReflectConstruct = tools_rect_tool_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = tools_rect_tool_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = tools_rect_tool_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return tools_rect_tool_possibleConstructorReturn(this, result); }; }\nfunction tools_rect_tool_possibleConstructorReturn(self, call) { if (call && (tools_rect_tool_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return tools_rect_tool_assertThisInitialized(self); }\nfunction tools_rect_tool_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction tools_rect_tool_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction tools_rect_tool_getPrototypeOf(o) { tools_rect_tool_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return tools_rect_tool_getPrototypeOf(o); }\n\n/**\n * Tool for drawing rectangles.\n */\nvar tools_rect_tool_RectTool = function (_paper$Tool) {\n  tools_rect_tool_inherits(RectTool, _paper$Tool);\n  var _super = tools_rect_tool_createSuper(RectTool);\n  tools_rect_tool_createClass(RectTool, null, [{\n    key: \"TOLERANCE\",\n    get: function get() {\n      return 2;\n    }\n    /**\n     * @param {function} setSelectedItems Callback to set the set of selected items in the Redux state\n     * @param {function} clearSelectedItems Callback to clear the set of selected items in the Redux state\n     * @param {function} setCursor Callback to set the visible mouse cursor\n     * @param {!function} onUpdateImage A callback to call when the image visibly changes\n     */\n  }]);\n  function RectTool(setSelectedItems, clearSelectedItems, setCursor, onUpdateImage) {\n    var _this;\n    tools_rect_tool_classCallCheck(this, RectTool);\n    _this = _super.call(this);\n    _this.setSelectedItems = setSelectedItems;\n    _this.clearSelectedItems = clearSelectedItems;\n    _this.onUpdateImage = onUpdateImage;\n    _this.boundingBoxTool = new bounding_box_tool(Modes.RECT, setSelectedItems, clearSelectedItems, setCursor, onUpdateImage);\n    var nudgeTool = new nudge_tool(Modes.RECT, _this.boundingBoxTool, onUpdateImage); // We have to set these functions instead of just declaring them because\n    // paper.js tools hook up the listeners in the setter functions.\n    _this.onMouseDown = _this.handleMouseDown;\n    _this.onMouseMove = _this.handleMouseMove;\n    _this.onMouseDrag = _this.handleMouseDrag;\n    _this.onMouseUp = _this.handleMouseUp;\n    _this.onKeyUp = nudgeTool.onKeyUp;\n    _this.onKeyDown = nudgeTool.onKeyDown;\n    _this.rect = null;\n    _this.colorState = null;\n    _this.isBoundingBoxMode = null;\n    _this.active = false;\n    return _this;\n  }\n  tools_rect_tool_createClass(RectTool, [{\n    key: \"getHitOptions\",\n    value: function getHitOptions() {\n      return {\n        segments: true,\n        stroke: true,\n        curves: true,\n        fill: true,\n        guide: false,\n        match: function match(hitResult) {\n          return hitResult.item.data && (hitResult.item.data.isScaleHandle || hitResult.item.data.isRotHandle) || hitResult.item.selected;\n        },\n        // Allow hits on bounding box and selected only\n        tolerance: RectTool.TOLERANCE / paper_full_default.a.view.zoom\n      };\n    }\n    /**\n     * Should be called if the selection changes to update the bounds of the bounding box.\n     * @param {Array<paper.Item>} selectedItems Array of selected items.\n     */\n  }, {\n    key: \"onSelectionChanged\",\n    value: function onSelectionChanged(selectedItems) {\n      this.boundingBoxTool.onSelectionChanged(selectedItems);\n    }\n  }, {\n    key: \"setColorState\",\n    value: function setColorState(colorState) {\n      this.colorState = colorState;\n    }\n  }, {\n    key: \"handleMouseDown\",\n    value: function handleMouseDown(event) {\n      if (event.event.button > 0) return; // only first mouse button\n      this.active = true;\n      if (this.boundingBoxTool.onMouseDown(event, false\n      /* clone */\n      , false\n      /* multiselect */\n      , false\n      /* doubleClicked */\n      , this.getHitOptions())) {\n        this.isBoundingBoxMode = true;\n      } else {\n        this.isBoundingBoxMode = false;\n        selection_clearSelection(this.clearSelectedItems);\n      }\n    }\n  }, {\n    key: \"handleMouseDrag\",\n    value: function handleMouseDrag(event) {\n      if (event.event.button > 0 || !this.active) return; // only first mouse button\n      if (this.isBoundingBoxMode) {\n        this.boundingBoxTool.onMouseDrag(event);\n        return;\n      }\n      if (this.rect) {\n        this.rect.remove();\n      }\n      var rect = new paper_full_default.a.Rectangle(event.downPoint, event.point);\n      var squareDimensions = math_getSquareDimensions(event.downPoint, event.point);\n      if (event.modifiers.shift) {\n        rect.size = squareDimensions.size.abs();\n      }\n      this.rect = new paper_full_default.a.Path.Rectangle(rect);\n      if (event.modifiers.alt) {\n        this.rect.position = event.downPoint;\n      } else if (event.modifiers.shift) {\n        this.rect.position = squareDimensions.position;\n      } else {\n        var dimensions = event.point.subtract(event.downPoint);\n        this.rect.position = event.downPoint.add(dimensions.multiply(0.5));\n      }\n      style_path_styleShape(this.rect, this.colorState);\n    }\n  }, {\n    key: \"handleMouseUp\",\n    value: function handleMouseUp(event) {\n      if (event.event.button > 0 || !this.active) return; // only first mouse button\n      if (this.isBoundingBoxMode) {\n        this.boundingBoxTool.onMouseUp(event);\n        this.isBoundingBoxMode = null;\n        return;\n      }\n      if (this.rect) {\n        if (this.rect.area < RectTool.TOLERANCE / paper_full_default.a.view.zoom) {\n          // Tiny rectangle created unintentionally?\n          this.rect.remove();\n          this.rect = null;\n        } else {\n          this.rect.selected = true;\n          this.setSelectedItems();\n          this.onUpdateImage();\n          this.rect = null;\n        }\n      }\n      this.active = false;\n    }\n  }, {\n    key: \"handleMouseMove\",\n    value: function handleMouseMove(event) {\n      this.boundingBoxTool.onMouseMove(event, this.getHitOptions());\n    }\n  }, {\n    key: \"deactivateTool\",\n    value: function deactivateTool() {\n      this.boundingBoxTool.deactivateTool();\n    }\n  }]);\n  return RectTool;\n}(paper_full_default.a.Tool);\n/* harmony default export */ var tools_rect_tool = (tools_rect_tool_RectTool);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/rect-mode/rectangle.svg\nvar rect_mode_rectangle = __webpack_require__(630);\nvar rect_mode_rectangle_default = __webpack_require__.n(rect_mode_rectangle);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/components/rect-mode/rect-mode.jsx\n\nvar rect_mode_RectModeComponent = function RectModeComponent(props) {\n  return react_default.a.createElement(tool_select_base_tool_select_base, {\n    imgDescriptor: lib_messages.rect,\n    imgSrc: rect_mode_rectangle_default.a,\n    isSelected: props.isSelected,\n    onMouseDown: props.onMouseDown\n  });\n};\nrect_mode_RectModeComponent.propTypes = {\n  isSelected: prop_types_default.a.bool.isRequired,\n  onMouseDown: prop_types_default.a.func.isRequired\n};\n/* harmony default export */ var rect_mode = (rect_mode_RectModeComponent);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/containers/rect-mode.jsx\nfunction rect_mode_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { rect_mode_typeof = function _typeof(obj) { return typeof obj; }; } else { rect_mode_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return rect_mode_typeof(obj); }\nfunction rect_mode_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction rect_mode_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction rect_mode_createClass(Constructor, protoProps, staticProps) { if (protoProps) rect_mode_defineProperties(Constructor.prototype, protoProps); if (staticProps) rect_mode_defineProperties(Constructor, staticProps); return Constructor; }\nfunction rect_mode_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) rect_mode_setPrototypeOf(subClass, superClass); }\nfunction rect_mode_setPrototypeOf(o, p) { rect_mode_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return rect_mode_setPrototypeOf(o, p); }\nfunction rect_mode_createSuper(Derived) { var hasNativeReflectConstruct = rect_mode_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = rect_mode_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = rect_mode_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return rect_mode_possibleConstructorReturn(this, result); }; }\nfunction rect_mode_possibleConstructorReturn(self, call) { if (call && (rect_mode_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return rect_mode_assertThisInitialized(self); }\nfunction rect_mode_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction rect_mode_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction rect_mode_getPrototypeOf(o) { rect_mode_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return rect_mode_getPrototypeOf(o); }\n\nvar rect_mode_RectMode = function (_React$Component) {\n  rect_mode_inherits(RectMode, _React$Component);\n  var _super = rect_mode_createSuper(RectMode);\n  function RectMode(props) {\n    var _this;\n    rect_mode_classCallCheck(this, RectMode);\n    _this = _super.call(this, props);\n    lodash_bindall_default()(rect_mode_assertThisInitialized(_this), ['activateTool', 'deactivateTool', 'validateColorState']);\n    return _this;\n  }\n  rect_mode_createClass(RectMode, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this.props.isRectModeActive) {\n        this.activateTool(this.props);\n      }\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(nextProps) {\n      if (this.tool && nextProps.colorState !== this.props.colorState) {\n        this.tool.setColorState(nextProps.colorState);\n      }\n      if (this.tool && nextProps.selectedItems !== this.props.selectedItems) {\n        this.tool.onSelectionChanged(nextProps.selectedItems);\n      }\n      if (nextProps.isRectModeActive && !this.props.isRectModeActive) {\n        this.activateTool();\n      } else if (!nextProps.isRectModeActive && this.props.isRectModeActive) {\n        this.deactivateTool();\n      }\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps) {\n      return nextProps.isRectModeActive !== this.props.isRectModeActive;\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.tool) {\n        this.deactivateTool();\n      }\n    }\n  }, {\n    key: \"activateTool\",\n    value: function activateTool() {\n      selection_clearSelection(this.props.clearSelectedItems);\n      this.validateColorState();\n      this.tool = new tools_rect_tool(this.props.setSelectedItems, this.props.clearSelectedItems, this.props.setCursor, this.props.onUpdateImage);\n      this.tool.setColorState(this.props.colorState);\n      this.tool.activate();\n    }\n  }, {\n    key: \"validateColorState\",\n    value: function validateColorState() {\n      // TODO move to shared class\n      // Make sure that at least one of fill/stroke is set, and that MIXED is not one of the colors.\n      // If fill and stroke color are both missing, set fill to default and stroke to transparent.\n      // If exactly one of fill or stroke color is set, set the other one to transparent.\n      var strokeWidth = this.props.colorState.strokeWidth;\n      var fillColor1 = this.props.colorState.fillColor.primary;\n      var fillColor2 = this.props.colorState.fillColor.secondary;\n      var fillGradient = this.props.colorState.fillColor.gradientType;\n      var strokeColor1 = this.props.colorState.strokeColor.primary;\n      var strokeColor2 = this.props.colorState.strokeColor.secondary;\n      var strokeGradient = this.props.colorState.strokeColor.gradientType;\n      if (fillColor2 === MIXED) {\n        this.props.clearFillGradient();\n        fillColor2 = null;\n        fillGradient = gradient_types.SOLID;\n      }\n      if (strokeColor2 === MIXED) {\n        this.props.clearStrokeGradient();\n        strokeColor2 = null;\n        strokeGradient = gradient_types.SOLID;\n      }\n      var fillColorMissing = fillColor1 === MIXED || fillGradient === gradient_types.SOLID && fillColor1 === null || fillGradient !== gradient_types.SOLID && fillColor1 === null && fillColor2 === null;\n      var strokeColorMissing = strokeColor1 === MIXED || strokeWidth === null || strokeWidth === 0 || strokeGradient === gradient_types.SOLID && strokeColor1 === null || strokeGradient !== gradient_types.SOLID && strokeColor1 === null && strokeColor2 === null;\n      if (fillColorMissing && strokeColorMissing) {\n        this.props.onChangeFillColor(DEFAULT_COLOR);\n        this.props.clearFillGradient();\n        this.props.onChangeStrokeColor(null);\n        this.props.clearStrokeGradient();\n      } else if (fillColorMissing && !strokeColorMissing) {\n        this.props.onChangeFillColor(null);\n        this.props.clearFillGradient();\n      } else if (!fillColorMissing && strokeColorMissing) {\n        this.props.onChangeStrokeColor(null);\n        this.props.clearStrokeGradient();\n      }\n    }\n  }, {\n    key: \"deactivateTool\",\n    value: function deactivateTool() {\n      this.tool.deactivateTool();\n      this.tool.remove();\n      this.tool = null;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return react_default.a.createElement(rect_mode, {\n        isSelected: this.props.isRectModeActive,\n        onMouseDown: this.props.handleMouseDown\n      });\n    }\n  }]);\n  return RectMode;\n}(react_default.a.Component);\nrect_mode_RectMode.propTypes = {\n  clearFillGradient: prop_types_default.a.func.isRequired,\n  clearStrokeGradient: prop_types_default.a.func.isRequired,\n  clearSelectedItems: prop_types_default.a.func.isRequired,\n  colorState: prop_types_default.a.shape({\n    fillColor: color_style_proptype,\n    strokeColor: color_style_proptype,\n    strokeWidth: prop_types_default.a.number\n  }).isRequired,\n  handleMouseDown: prop_types_default.a.func.isRequired,\n  isRectModeActive: prop_types_default.a.bool.isRequired,\n  onChangeFillColor: prop_types_default.a.func.isRequired,\n  onChangeStrokeColor: prop_types_default.a.func.isRequired,\n  onUpdateImage: prop_types_default.a.func.isRequired,\n  selectedItems: prop_types_default.a.arrayOf(prop_types_default.a.instanceOf(paper_full_default.a.Item)),\n  setCursor: prop_types_default.a.func.isRequired,\n  setSelectedItems: prop_types_default.a.func.isRequired\n};\nvar rect_mode_mapStateToProps = function mapStateToProps(state) {\n  return {\n    colorState: state.scratchPaint.color,\n    isRectModeActive: state.scratchPaint.mode === Modes.RECT,\n    selectedItems: state.scratchPaint.selectedItems\n  };\n};\nvar rect_mode_mapDispatchToProps = function mapDispatchToProps(dispatch) {\n  return {\n    clearSelectedItems: function clearSelectedItems() {\n      dispatch(selected_items_clearSelectedItems());\n    },\n    clearFillGradient: function clearFillGradient() {\n      dispatch(fill_style_clearFillGradient());\n    },\n    clearStrokeGradient: function clearStrokeGradient() {\n      dispatch(stroke_style_clearStrokeGradient());\n    },\n    setSelectedItems: function setSelectedItems() {\n      dispatch(selected_items_setSelectedItems(selection_getSelectedLeafItems(), false\n      /* bitmapMode */\n      ));\n    },\n    setCursor: function setCursor(cursorString) {\n      dispatch(cursor_setCursor(cursorString));\n    },\n    handleMouseDown: function handleMouseDown() {\n      dispatch(modes_changeMode(Modes.RECT));\n    },\n    onChangeFillColor: function onChangeFillColor(fillColor) {\n      dispatch(changeFillColor(fillColor));\n    },\n    onChangeStrokeColor: function onChangeStrokeColor(strokeColor) {\n      dispatch(changeStrokeColor(strokeColor));\n    }\n  };\n};\n/* harmony default export */ var containers_rect_mode = (Object(es[\"b\" /* connect */])(rect_mode_mapStateToProps, rect_mode_mapDispatchToProps)(rect_mode_RectMode));\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/helper/selection-tools/point-tool.js\nfunction point_tool_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = point_tool_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction point_tool_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return point_tool_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return point_tool_arrayLikeToArray(o, minLen); }\nfunction point_tool_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction point_tool_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction point_tool_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction point_tool_createClass(Constructor, protoProps, staticProps) { if (protoProps) point_tool_defineProperties(Constructor.prototype, protoProps); if (staticProps) point_tool_defineProperties(Constructor, staticProps); return Constructor; }\n\n/** Subtool of ReshapeTool for moving control points. */\nvar point_tool_PointTool = function () {\n  /**\n   * @param {function} setSelectedItems Callback to set the set of selected items in the Redux state\n   * @param {function} clearSelectedItems Callback to clear the set of selected items in the Redux state\n   * @param {!function} onUpdateImage A callback to call when the image visibly changes\n   */\n  function PointTool(setSelectedItems, clearSelectedItems, onUpdateImage) {\n    point_tool_classCallCheck(this, PointTool);\n    /**\n     * Deselection often does not happen until mouse up. If the mouse is dragged before\n     * mouse up, deselection is cancelled. This variable keeps track of which paper.Item to deselect.\n     */\n    this.deselectOnMouseUp = null;\n    /**\n     * Delete control point does not happen until mouse up. If the mouse is dragged before\n     * mouse up, delete is cancelled. This variable keeps track of the hitResult that triggers delete.\n     */\n    this.deleteOnMouseUp = null;\n    /**\n     * There are 2 cases for deselection: Deselect this, or deselect everything but this.\n     * When invert deselect is true, deselect everything but the item in deselectOnMouseUp.\n     */\n    this.invertDeselect = false;\n    this.selectedItems = null;\n    this.setSelectedItems = setSelectedItems;\n    this.clearSelectedItems = clearSelectedItems;\n    this.lastPoint = null;\n    this.onUpdateImage = onUpdateImage;\n  }\n  /**\n   * @param {!object} hitProperties Describes the mouse event\n   * @param {!paper.HitResult} hitProperties.hitResult Data about the location of the mouse click\n   * @param {?boolean} hitProperties.multiselect Whether to multiselect on mouse down (e.g. shift key held)\n   * @param {?boolean} hitProperties.doubleClicked Whether this is the second click in a short time\n   */\n  point_tool_createClass(PointTool, [{\n    key: \"onMouseDown\",\n    value: function onMouseDown(hitProperties) {\n      // Remove point\n      if (hitProperties.doubleClicked) {\n        this.deleteOnMouseUp = hitProperties.hitResult;\n      }\n      if (hitProperties.hitResult.segment.selected) {\n        // selected points with no handles get handles if selected again\n        if (hitProperties.multiselect) {\n          this.deselectOnMouseUp = hitProperties.hitResult.segment;\n        } else {\n          this.deselectOnMouseUp = hitProperties.hitResult.segment;\n          this.invertDeselect = true;\n          hitProperties.hitResult.segment.selected = true;\n        }\n      } else {\n        if (!hitProperties.multiselect) {\n          selection_clearSelection(this.clearSelectedItems);\n        }\n        hitProperties.hitResult.segment.selected = true;\n      }\n      this.selectedItems = selection_getSelectedLeafItems();\n    }\n    /**\n     * @param {!object} hitProperties Describes the mouse event\n     * @param {!paper.HitResult} hitProperties.hitResult Data about the location of the mouse click\n     * @param {?boolean} hitProperties.multiselect Whether to multiselect on mouse down (e.g. shift key held)\n     */\n  }, {\n    key: \"addPoint\",\n    value: function addPoint(hitProperties) {\n      var newSegment = hitProperties.hitResult.item.divideAt(hitProperties.hitResult.location); // If we're adding a point in the middle of a straight line, it won't be smooth by default, so smooth it\n      if (!newSegment.hasHandles()) newSegment.smooth();\n      hitProperties.hitResult.segment = newSegment;\n      if (!hitProperties.multiselect) {\n        selection_clearSelection(this.clearSelectedItems);\n      }\n      newSegment.selected = true;\n    }\n  }, {\n    key: \"removePoint\",\n    value: function removePoint(hitResult) {\n      var index = hitResult.segment.index;\n      hitResult.item.removeSegment(index); // Adjust handles of curve before and curve after to account for new curve length\n      var beforeSegment = hitResult.item.segments[index - 1];\n      var afterSegment = hitResult.item.segments[index];\n      var curveLength = beforeSegment ? beforeSegment.curve ? beforeSegment.curve.length : null : null;\n      if (beforeSegment && beforeSegment.handleOut) {\n        if (afterSegment) {\n          beforeSegment.handleOut = beforeSegment.handleOut.multiply(curveLength * HANDLE_RATIO / beforeSegment.handleOut.length);\n        } else {\n          beforeSegment.handleOut = null;\n        }\n      }\n      if (afterSegment && afterSegment.handleIn) {\n        if (beforeSegment) {\n          afterSegment.handleIn = afterSegment.handleIn.multiply(curveLength * HANDLE_RATIO / afterSegment.handleIn.length);\n        } else {\n          afterSegment.handleIn = null;\n        }\n      }\n    }\n  }, {\n    key: \"onMouseDrag\",\n    value: function onMouseDrag(event) {\n      // A click will deselect, but a drag will not\n      this.deselectOnMouseUp = null;\n      this.invertDeselect = false;\n      this.deleteOnMouseUp = null;\n      var point = event.point;\n      var bounds = view_getActionBounds();\n      point.x = Math.max(bounds.left, Math.min(point.x, bounds.right));\n      point.y = Math.max(bounds.top, Math.min(point.y, bounds.bottom));\n      if (!this.lastPoint) this.lastPoint = event.lastPoint;\n      var dragVector = point.subtract(event.downPoint);\n      var delta = point.subtract(this.lastPoint);\n      this.lastPoint = point;\n      var selectedSegments = getSelectedSegments();\n      var _iterator = point_tool_createForOfIteratorHelper(selectedSegments),\n          _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var seg = _step.value;\n          // add the point of the segment before the drag started\n          // for later use in the snap calculation\n          if (!seg.origPoint) {\n            seg.origPoint = seg.point.clone();\n          }\n          if (event.modifiers.shift) {\n            seg.point = seg.origPoint.add(math_snapDeltaToAngle(dragVector, Math.PI / 4));\n          } else {\n            seg.point = seg.point.add(delta);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"onMouseUp\",\n    value: function onMouseUp() {\n      this.lastPoint = null; // resetting the items and segments origin points for the next usage\n      var moved = false;\n      var selectedSegments = getSelectedSegments();\n      var _iterator2 = point_tool_createForOfIteratorHelper(selectedSegments),\n          _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var seg = _step2.value;\n          if (seg.origPoint && !seg.equals(seg.origPoint)) {\n            moved = true;\n          }\n          seg.origPoint = null;\n        } // If no drag occurred between mouse down and mouse up, then we can go through with deselect\n        // and delete\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      if (this.deselectOnMouseUp) {\n        if (this.invertDeselect) {\n          selection_clearSelection(this.clearSelectedItems);\n          this.deselectOnMouseUp.selected = true;\n        } else {\n          this.deselectOnMouseUp.selected = false;\n        }\n        this.deselectOnMouseUp = null;\n        this.invertDeselect = false;\n      }\n      if (this.deleteOnMouseUp) {\n        this.removePoint(this.deleteOnMouseUp);\n      }\n      this.selectedItems = null;\n      this.setSelectedItems();\n      if (moved || this.deleteOnMouseUp) {\n        this.deleteOnMouseUp = null;\n        this.onUpdateImage();\n      }\n    }\n  }]);\n  return PointTool;\n}();\n/* harmony default export */ var point_tool = (point_tool_PointTool);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/helper/selection-tools/handle-tool.js\nfunction handle_tool_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = handle_tool_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction handle_tool_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return handle_tool_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return handle_tool_arrayLikeToArray(o, minLen); }\nfunction handle_tool_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction handle_tool_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction handle_tool_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction handle_tool_createClass(Constructor, protoProps, staticProps) { if (protoProps) handle_tool_defineProperties(Constructor.prototype, protoProps); if (staticProps) handle_tool_defineProperties(Constructor, staticProps); return Constructor; }\n/** Sub tool of the Reshape tool for moving handles, which adjust bezier curves. */\nvar handle_tool_HandleTool = function () {\n  /**\n   * @param {function} setSelectedItems Callback to set the set of selected items in the Redux state\n   * @param {function} clearSelectedItems Callback to clear the set of selected items in the Redux state\n   * @param {!function} onUpdateImage A callback to call when the image visibly changes\n   */\n  function HandleTool(setSelectedItems, clearSelectedItems, onUpdateImage) {\n    handle_tool_classCallCheck(this, HandleTool);\n    this.hitType = null;\n    this.setSelectedItems = setSelectedItems;\n    this.clearSelectedItems = clearSelectedItems;\n    this.onUpdateImage = onUpdateImage;\n    this.selectedItems = [];\n  }\n  /**\n   * @param {!object} hitProperties Describes the mouse event\n   * @param {?boolean} hitProperties.multiselect Whether to multiselect on mouse down (e.g. shift key held)\n   *     select the whole group.\n   */\n  handle_tool_createClass(HandleTool, [{\n    key: \"onMouseDown\",\n    value: function onMouseDown(hitProperties) {\n      if (!hitProperties.multiselect) {\n        selection_clearSelection(this.clearSelectedItems);\n      }\n      hitProperties.hitResult.segment.handleIn.selected = true;\n      hitProperties.hitResult.segment.handleOut.selected = true;\n      this.hitType = hitProperties.hitResult.type;\n    }\n  }, {\n    key: \"onMouseDrag\",\n    value: function onMouseDrag(event) {\n      this.selectedItems = selection_getSelectedLeafItems();\n      var _iterator = handle_tool_createForOfIteratorHelper(this.selectedItems),\n          _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var item = _step.value;\n          var _iterator2 = handle_tool_createForOfIteratorHelper(item.segments),\n              _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var seg = _step2.value;\n              // add the point of the segment before the drag started\n              // for later use in the snap calculation\n              if (!seg.origPoint) {\n                seg.origPoint = seg.point.clone();\n              }\n              if (seg.handleOut.selected && this.hitType === 'handle-out') {\n                // if option is pressed or handles have been split,\n                // they're no longer parallel and move independently\n                if (event.modifiers.option || !seg.handleOut.isColinear(seg.handleIn)) {\n                  seg.handleOut = seg.handleOut.add(event.delta);\n                } else {\n                  seg.handleOut = seg.handleOut.add(event.delta);\n                  seg.handleIn = seg.handleOut.multiply(-seg.handleIn.length / seg.handleOut.length);\n                }\n              } else if (seg.handleIn.selected && this.hitType === 'handle-in') {\n                // if option is pressed or handles have been split,\n                // they're no longer parallel and move independently\n                if (event.modifiers.option || !seg.handleOut.isColinear(seg.handleIn)) {\n                  seg.handleIn = seg.handleIn.add(event.delta);\n                } else {\n                  seg.handleIn = seg.handleIn.add(event.delta);\n                  seg.handleOut = seg.handleIn.multiply(-seg.handleOut.length / seg.handleIn.length);\n                }\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"onMouseUp\",\n    value: function onMouseUp() {\n      // resetting the items and segments origin points for the next usage\n      var moved = false;\n      var _iterator3 = handle_tool_createForOfIteratorHelper(this.selectedItems),\n          _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var item = _step3.value;\n          if (!item.segments) {\n            return;\n          }\n          var _iterator4 = handle_tool_createForOfIteratorHelper(item.segments),\n              _step4;\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var seg = _step4.value;\n              if (seg.origPoint && !seg.equals(seg.origPoint)) {\n                moved = true;\n              }\n              seg.origPoint = null;\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      if (moved) {\n        this.setSelectedItems();\n        this.onUpdateImage();\n      }\n      this.selectedItems = [];\n    }\n  }]);\n  return HandleTool;\n}();\n/* harmony default export */ var handle_tool = (handle_tool_HandleTool);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/helper/selection-tools/reshape-tool.js\nfunction reshape_tool_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { reshape_tool_typeof = function _typeof(obj) { return typeof obj; }; } else { reshape_tool_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return reshape_tool_typeof(obj); }\nfunction reshape_tool_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = reshape_tool_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction reshape_tool_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return reshape_tool_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return reshape_tool_arrayLikeToArray(o, minLen); }\nfunction reshape_tool_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction reshape_tool_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction reshape_tool_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction reshape_tool_createClass(Constructor, protoProps, staticProps) { if (protoProps) reshape_tool_defineProperties(Constructor.prototype, protoProps); if (staticProps) reshape_tool_defineProperties(Constructor, staticProps); return Constructor; }\nfunction reshape_tool_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) reshape_tool_setPrototypeOf(subClass, superClass); }\nfunction reshape_tool_setPrototypeOf(o, p) { reshape_tool_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return reshape_tool_setPrototypeOf(o, p); }\nfunction reshape_tool_createSuper(Derived) { var hasNativeReflectConstruct = reshape_tool_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = reshape_tool_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = reshape_tool_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return reshape_tool_possibleConstructorReturn(this, result); }; }\nfunction reshape_tool_possibleConstructorReturn(self, call) { if (call && (reshape_tool_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return reshape_tool_assertThisInitialized(self); }\nfunction reshape_tool_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction reshape_tool_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction reshape_tool_getPrototypeOf(o) { reshape_tool_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return reshape_tool_getPrototypeOf(o); }\n\n/** Modes of the reshape tool, which can do many things depending on how it's used. */\nvar ReshapeModes = keymirror_default()({\n  FILL: null,\n  POINT: null,\n  HANDLE: null,\n  SELECTION_BOX: null\n});\n/**\n * paper.Tool to handle reshape mode, which allows manipulation of control points and\n * handles of path items. Can be used to select items within groups and points within items.\n * Reshape is made up of 4 tools:\n * - Selection box tool, which is activated by clicking an empty area. Draws a box and selects\n *   points and curves inside it\n * - Move tool, which translates items\n * - Point tool, which translates, adds and removes points\n * - Handle tool, which translates handles, changing the shape of curves\n */\nvar reshape_tool_ReshapeTool = function (_paper$Tool) {\n  reshape_tool_inherits(ReshapeTool, _paper$Tool);\n  var _super = reshape_tool_createSuper(ReshapeTool);\n  reshape_tool_createClass(ReshapeTool, null, [{\n    key: \"TOLERANCE\",\n    /** Distance within which mouse is considered to be hitting an item */\n    get: function get() {\n      return ReshapeTool.HANDLE_RADIUS + ReshapeTool.HANDLE_PADDING;\n    }\n    /**\n     * Units of padding around the visible handle area that will still register clicks as \"touching the handle\"\n     */\n  }, {\n    key: \"HANDLE_PADDING\",\n    get: function get() {\n      return 1;\n    }\n    /**\n     * Handles' radius, including the stroke\n     */\n  }, {\n    key: \"HANDLE_RADIUS\",\n    get: function get() {\n      return 5.25;\n    }\n    /** Clicks registered within this amount of time are registered as double clicks */\n  }, {\n    key: \"DOUBLE_CLICK_MILLIS\",\n    get: function get() {\n      return 250;\n    }\n    /**\n     * @param {function} setHoveredItem Callback to set the hovered item\n     * @param {function} clearHoveredItem Callback to clear the hovered item\n     * @param {function} setSelectedItems Callback to set the set of selected items in the Redux state\n     * @param {function} clearSelectedItems Callback to clear the set of selected items in the Redux state\n     * @param {!function} onUpdateImage A callback to call when the image visibly changes\n     * @param {!function} switchToTextTool A callback to call to switch to the text tool\n     */\n  }]);\n  function ReshapeTool(setHoveredItem, clearHoveredItem, setSelectedItems, clearSelectedItems, onUpdateImage, switchToTextTool) {\n    var _this;\n    reshape_tool_classCallCheck(this, ReshapeTool);\n    _this = _super.call(this);\n    _this.setHoveredItem = setHoveredItem;\n    _this.clearHoveredItem = clearHoveredItem;\n    _this.onUpdateImage = onUpdateImage;\n    _this.prevHoveredItemId = null;\n    _this.lastEvent = null;\n    _this.active = false;\n    _this.mode = ReshapeModes.SELECTION_BOX;\n    _this._modeMap = {};\n    _this._modeMap[ReshapeModes.FILL] = new move_tool(Modes.RESHAPE, setSelectedItems, clearSelectedItems, onUpdateImage, switchToTextTool);\n    _this._modeMap[ReshapeModes.POINT] = new point_tool(setSelectedItems, clearSelectedItems, onUpdateImage);\n    _this._modeMap[ReshapeModes.HANDLE] = new handle_tool(setSelectedItems, clearSelectedItems, onUpdateImage);\n    _this._modeMap[ReshapeModes.SELECTION_BOX] = new selection_box_tool(Modes.RESHAPE, setSelectedItems, clearSelectedItems); // We have to set these functions instead of just declaring them because\n    // paper.js tools hook up the listeners in the setter functions.\n    _this.onMouseDown = _this.handleMouseDown;\n    _this.onMouseMove = _this.handleMouseMove;\n    _this.onMouseDrag = _this.handleMouseDrag;\n    _this.onMouseUp = _this.handleMouseUp;\n    _this.onKeyUp = _this.handleKeyUp;\n    _this.onKeyDown = _this.handleKeyDown; // A handle's size is given in diameter, and each handle has a 2.5-pixel stroke that isn't part of its size:\n    // https://github.com/LLK/paper.js/blob/a187e4c81cc63f3d48c5097b9a9fbddde9f057da/src/item/Item.js#L4480\n    // Size the handles such that clicking on either the stroke or the handle itself will be registered as a drag\n    paper_full_default.a.settings.handleSize = ReshapeTool.HANDLE_RADIUS * 2 - 2.5;\n    return _this;\n  }\n  /**\n   * Returns the hit options for segments to use when conducting hit tests. Segments are only visible\n   * when the shape is selected. Segments take precedence, since they are always over curves and need\n   * to be grabbable. (Segments are the little circles)\n   * @return {object} See paper.Item.hitTest for definition of options\n   */\n  reshape_tool_createClass(ReshapeTool, [{\n    key: \"getSelectedSegmentHitOptions\",\n    value: function getSelectedSegmentHitOptions() {\n      var hitOptions = {\n        segments: true,\n        tolerance: ReshapeTool.TOLERANCE / paper_full_default.a.view.zoom,\n        match: function match(hitResult) {\n          if (hitResult.type !== 'segment') return false;\n          if (hitResult.item.data && hitResult.item.data.noHover) return false;\n          if (!hitResult.item.selected) return false;\n          return true;\n        }\n      };\n      return hitOptions;\n    }\n    /**\n     * Returns the hit options for handles to use when conducting hit tests. Handles need to be done\n     * separately because we want to ignore hidden handles, but we don't want hidden handles to negate\n     * legitimate hits on other things (like if the handle is over part of the fill). (Handles are the diamonds)\n     * @return {object} See paper.Item.hitTest for definition of options\n     */\n  }, {\n    key: \"getHandleHitOptions\",\n    value: function getHandleHitOptions() {\n      var hitOptions = {\n        handles: true,\n        tolerance: ReshapeTool.TOLERANCE / paper_full_default.a.view.zoom,\n        match: function match(hitResult) {\n          if (hitResult.item.data && hitResult.item.data.noHover) return false; // Only hit test against handles that are visible, that is,\n          // their segment is selected\n          if (!hitResult.segment || !hitResult.segment.selected) return false; // If the entire shape is selected, handles are hidden\n          if (hitResult.item.fullySelected) return false;\n          return true;\n        }\n      };\n      return hitOptions;\n    }\n    /**\n     * Returns the hit options for curves of selected objects, which take precedence over\n     * unselected things and fills.\n     * @return {object} See paper.Item.hitTest for definition of options\n     */\n  }, {\n    key: \"getSelectedStrokeHitOptions\",\n    value: function getSelectedStrokeHitOptions() {\n      var hitOptions = {\n        segments: false,\n        stroke: false,\n        curves: true,\n        handles: false,\n        fill: false,\n        guide: false,\n        tolerance: ReshapeTool.TOLERANCE / paper_full_default.a.view.zoom,\n        match: function match(hitResult) {\n          if (hitResult.type !== 'curve') return false;\n          if (!hitResult.item.selected) return false;\n          if (hitResult.item.data && hitResult.item.data.noHover) return false;\n          return true;\n        }\n      };\n      return hitOptions;\n    }\n    /**\n     * Returns the hit options for fills and unselected strokes/curves to use when conducting hit tests.\n     * @param {boolean} preselectedOnly True if we should only return results that are already\n     *     selected.\n     * @return {object} See paper.Item.hitTest for definition of options\n     */\n  }, {\n    key: \"getUnselectedAndFillHitOptions\",\n    value: function getUnselectedAndFillHitOptions() {\n      var hitOptions = {\n        fill: true,\n        stroke: true,\n        curves: true,\n        tolerance: ReshapeTool.TOLERANCE / paper_full_default.a.view.zoom,\n        match: function match(hitResult) {\n          if (hitResult.item.data && hitResult.item.data.noHover) return false;\n          return true;\n        }\n      };\n      return hitOptions;\n    }\n    /**\n     * To be called when the hovered item changes. When the select tool hovers over a\n     * new item, it compares against this to see if a hover item change event needs to\n     * be fired.\n     * @param {paper.Item} prevHoveredItemId ID of the highlight item that indicates the mouse is\n     *     over a given item currently\n     */\n  }, {\n    key: \"setPrevHoveredItemId\",\n    value: function setPrevHoveredItemId(prevHoveredItemId) {\n      this.prevHoveredItemId = prevHoveredItemId;\n    }\n    /**\n     * Given the point at which the mouse is, return the prioritized hit result, or null if nothing was hit.\n     * @param {paper.Point} point Point to hit test on canvas\n     * @return {?paper.HitResult} hitResult\n     */\n  }, {\n    key: \"getHitResult\",\n    value: function getHitResult(point) {\n      // Prefer hits on segments to other types of hits, since segments always overlap curves.\n      var hitResults = paper_full_default.a.project.hitTestAll(point, this.getSelectedSegmentHitOptions());\n      if (!hitResults.length) {\n        hitResults = paper_full_default.a.project.hitTestAll(point, this.getHandleHitOptions());\n      }\n      if (!hitResults.length) {\n        hitResults = paper_full_default.a.project.hitTestAll(point, this.getSelectedStrokeHitOptions());\n      }\n      if (!hitResults.length) {\n        hitResults = paper_full_default.a.project.hitTestAll(point, this.getUnselectedAndFillHitOptions());\n      }\n      if (!hitResults.length) {\n        return null;\n      } // Get highest z-index result\n      var hitResult;\n      var _iterator = reshape_tool_createForOfIteratorHelper(hitResults),\n          _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var result = _step.value;\n          if (!hitResult || math_sortItemsByZIndex(hitResult.item, result.item) < 0) {\n            hitResult = result;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return hitResult;\n    }\n  }, {\n    key: \"handleMouseDown\",\n    value: function handleMouseDown(event) {\n      if (event.event.button > 0) return; // only first mouse button\n      this.active = true;\n      this.clearHoveredItem(); // Check if double clicked\n      var doubleClicked = false;\n      if (this.lastEvent) {\n        if (event.event.timeStamp - this.lastEvent.event.timeStamp < ReshapeTool.DOUBLE_CLICK_MILLIS) {\n          doubleClicked = true;\n        } else {\n          doubleClicked = false;\n        }\n      }\n      this.lastEvent = event;\n      var hitResult = this.getHitResult(event.point);\n      if (!hitResult) {\n        this._modeMap[ReshapeModes.SELECTION_BOX].onMouseDown(event.modifiers.shift);\n        return;\n      }\n      var hitProperties = {\n        hitResult: hitResult,\n        clone: event.modifiers.alt,\n        multiselect: event.modifiers.shift,\n        doubleClicked: doubleClicked,\n        subselect: true\n      }; // If item is not yet selected, don't behave differently depending on if they clicked a segment\n      // (since those were invisible), just select the whole thing as if they clicked the fill.\n      if (!hitResult.item.selected || hitResult.type === 'fill' || hitResult.type === 'stroke' || hitResult.type !== 'segment' && doubleClicked) {\n        this.mode = ReshapeModes.FILL;\n        this._modeMap[this.mode].onMouseDown(hitProperties);\n      } else if (hitResult.type === 'segment') {\n        this.mode = ReshapeModes.POINT;\n        this._modeMap[this.mode].onMouseDown(hitProperties);\n      } else if (hitResult.type === 'curve') {\n        this.mode = ReshapeModes.POINT;\n        this._modeMap[this.mode].addPoint(hitProperties);\n        this.onUpdateImage();\n        this._modeMap[this.mode].onMouseDown(hitProperties);\n      } else if (hitResult.type === 'handle-in' || hitResult.type === 'handle-out') {\n        this.mode = ReshapeModes.HANDLE;\n        this._modeMap[this.mode].onMouseDown(hitProperties);\n      } else {\n        log.warn(\"Unhandled hit result type: \".concat(hitResult.type));\n        this.mode = ReshapeModes.FILL;\n        this._modeMap[this.mode].onMouseDown(hitProperties);\n      }\n    }\n  }, {\n    key: \"handleMouseMove\",\n    value: function handleMouseMove(event) {\n      var hitResult = this.getHitResult(event.point);\n      var hoveredItem;\n      if (hitResult) {\n        var item = hitResult.item;\n        if (item.selected) {\n          hoveredItem = null;\n        } else if (isBoundsItem(item)) {\n          hoveredItem = guides_hoverBounds(item);\n        } else {\n          hoveredItem = guides_hoverItem(item);\n        }\n      }\n      if (!hoveredItem && this.prevHoveredItemId || // There is no longer a hovered item\n      hoveredItem && !this.prevHoveredItemId || // There is now a hovered item\n      hoveredItem && this.prevHoveredItemId && hoveredItem.id !== this.prevHoveredItemId) {\n        // hovered item changed\n        this.setHoveredItem(hoveredItem ? hoveredItem.id : null);\n      }\n    }\n  }, {\n    key: \"handleMouseDrag\",\n    value: function handleMouseDrag(event) {\n      if (event.event.button > 0 || !this.active) return; // only first mouse button\n      this._modeMap[this.mode].onMouseDrag(event);\n    }\n  }, {\n    key: \"handleMouseUp\",\n    value: function handleMouseUp(event) {\n      if (event.event.button > 0 || !this.active) return; // only first mouse button\n      if (this.mode === ReshapeModes.SELECTION_BOX) {\n        this._modeMap[this.mode].onMouseUpVector(event);\n      } else {\n        this._modeMap[this.mode].onMouseUp(event);\n      }\n      this.mode = ReshapeModes.SELECTION_BOX;\n      this.active = false;\n    }\n  }, {\n    key: \"handleKeyDown\",\n    value: function handleKeyDown(event) {\n      if (event.event.target instanceof HTMLInputElement) {\n        // Ignore nudge if a text input field is focused\n        return;\n      }\n      var nudgeAmount = 1 / paper_full_default.a.view.zoom;\n      var selected = selection_getSelectedLeafItems();\n      if (selected.length === 0) return;\n      var translation;\n      if (event.key === 'up') {\n        translation = new paper_full_default.a.Point(0, -nudgeAmount);\n      } else if (event.key === 'down') {\n        translation = new paper_full_default.a.Point(0, nudgeAmount);\n      } else if (event.key === 'left') {\n        translation = new paper_full_default.a.Point(-nudgeAmount, 0);\n      } else if (event.key === 'right') {\n        translation = new paper_full_default.a.Point(nudgeAmount, 0);\n      }\n      if (translation) {\n        var segments = getSelectedSegments(); // If no segments are selected, translate selected paths\n        if (segments.length === 0) {\n          var _iterator2 = reshape_tool_createForOfIteratorHelper(selected),\n              _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var item = _step2.value;\n              item.translate(translation);\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        } else {\n          // Translate segments\n          var _iterator3 = reshape_tool_createForOfIteratorHelper(segments),\n              _step3;\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var seg = _step3.value;\n              seg.point = seg.point.add(translation);\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        }\n      }\n    }\n  }, {\n    key: \"handleKeyUp\",\n    value: function handleKeyUp(event) {\n      var selected = selection_getSelectedLeafItems();\n      if (selected.length === 0) return;\n      if (event.key === 'up' || event.key === 'down' || event.key === 'left' || event.key === 'right') {\n        this.onUpdateImage();\n      }\n    }\n  }, {\n    key: \"deactivateTool\",\n    value: function deactivateTool() {\n      paper_full_default.a.settings.handleSize = 0;\n      this.clearHoveredItem();\n      this.setHoveredItem = null;\n      this.clearHoveredItem = null;\n      this.onUpdateImage = null;\n      this.lastEvent = null;\n    }\n  }]);\n  return ReshapeTool;\n}(paper_full_default.a.Tool);\n/* harmony default export */ var reshape_tool = (reshape_tool_ReshapeTool);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/reshape-mode/reshape.svg\nvar reshape = __webpack_require__(631);\nvar reshape_default = __webpack_require__.n(reshape);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/components/reshape-mode/reshape-mode.jsx\n\nvar reshape_mode_ReshapeModeComponent = function ReshapeModeComponent(props) {\n  return react_default.a.createElement(tool_select_base_tool_select_base, {\n    imgDescriptor: lib_messages.reshape,\n    imgSrc: reshape_default.a,\n    isSelected: props.isSelected,\n    onMouseDown: props.onMouseDown\n  });\n};\nreshape_mode_ReshapeModeComponent.propTypes = {\n  isSelected: prop_types_default.a.bool.isRequired,\n  onMouseDown: prop_types_default.a.func.isRequired\n};\n/* harmony default export */ var reshape_mode = (reshape_mode_ReshapeModeComponent);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/containers/reshape-mode.jsx\nfunction reshape_mode_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { reshape_mode_typeof = function _typeof(obj) { return typeof obj; }; } else { reshape_mode_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return reshape_mode_typeof(obj); }\nfunction reshape_mode_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction reshape_mode_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction reshape_mode_createClass(Constructor, protoProps, staticProps) { if (protoProps) reshape_mode_defineProperties(Constructor.prototype, protoProps); if (staticProps) reshape_mode_defineProperties(Constructor, staticProps); return Constructor; }\nfunction reshape_mode_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) reshape_mode_setPrototypeOf(subClass, superClass); }\nfunction reshape_mode_setPrototypeOf(o, p) { reshape_mode_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return reshape_mode_setPrototypeOf(o, p); }\nfunction reshape_mode_createSuper(Derived) { var hasNativeReflectConstruct = reshape_mode_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = reshape_mode_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = reshape_mode_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return reshape_mode_possibleConstructorReturn(this, result); }; }\nfunction reshape_mode_possibleConstructorReturn(self, call) { if (call && (reshape_mode_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return reshape_mode_assertThisInitialized(self); }\nfunction reshape_mode_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction reshape_mode_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction reshape_mode_getPrototypeOf(o) { reshape_mode_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return reshape_mode_getPrototypeOf(o); }\n\nvar reshape_mode_ReshapeMode = function (_React$Component) {\n  reshape_mode_inherits(ReshapeMode, _React$Component);\n  var _super = reshape_mode_createSuper(ReshapeMode);\n  function ReshapeMode(props) {\n    var _this;\n    reshape_mode_classCallCheck(this, ReshapeMode);\n    _this = _super.call(this, props);\n    lodash_bindall_default()(reshape_mode_assertThisInitialized(_this), ['activateTool', 'deactivateTool']);\n    return _this;\n  }\n  reshape_mode_createClass(ReshapeMode, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this.props.isReshapeModeActive) {\n        this.activateTool(this.props);\n      }\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(nextProps) {\n      if (this.tool && nextProps.hoveredItemId !== this.props.hoveredItemId) {\n        this.tool.setPrevHoveredItemId(nextProps.hoveredItemId);\n      }\n      if (nextProps.isReshapeModeActive && !this.props.isReshapeModeActive) {\n        this.activateTool();\n      } else if (!nextProps.isReshapeModeActive && this.props.isReshapeModeActive) {\n        this.deactivateTool();\n      }\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps) {\n      return nextProps.isReshapeModeActive !== this.props.isReshapeModeActive;\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.tool) {\n        this.deactivateTool();\n      }\n    }\n  }, {\n    key: \"activateTool\",\n    value: function activateTool() {\n      this.tool = new reshape_tool(this.props.setHoveredItem, this.props.clearHoveredItem, this.props.setSelectedItems, this.props.clearSelectedItems, this.props.onUpdateImage, this.props.switchToTextTool);\n      this.tool.setPrevHoveredItemId(this.props.hoveredItemId);\n      this.tool.activate();\n    }\n  }, {\n    key: \"deactivateTool\",\n    value: function deactivateTool() {\n      this.tool.deactivateTool();\n      this.tool.remove();\n      this.tool = null;\n      this.hitResult = null;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return react_default.a.createElement(reshape_mode, {\n        isSelected: this.props.isReshapeModeActive,\n        onMouseDown: this.props.handleMouseDown\n      });\n    }\n  }]);\n  return ReshapeMode;\n}(react_default.a.Component);\nreshape_mode_ReshapeMode.propTypes = {\n  clearHoveredItem: prop_types_default.a.func.isRequired,\n  clearSelectedItems: prop_types_default.a.func.isRequired,\n  handleMouseDown: prop_types_default.a.func.isRequired,\n  hoveredItemId: prop_types_default.a.number,\n  isReshapeModeActive: prop_types_default.a.bool.isRequired,\n  onUpdateImage: prop_types_default.a.func.isRequired,\n  setHoveredItem: prop_types_default.a.func.isRequired,\n  setSelectedItems: prop_types_default.a.func.isRequired,\n  switchToTextTool: prop_types_default.a.func.isRequired\n};\nvar reshape_mode_mapStateToProps = function mapStateToProps(state) {\n  return {\n    isReshapeModeActive: state.scratchPaint.mode === Modes.RESHAPE,\n    hoveredItemId: state.scratchPaint.hoveredItemId\n  };\n};\nvar reshape_mode_mapDispatchToProps = function mapDispatchToProps(dispatch) {\n  return {\n    setHoveredItem: function setHoveredItem(hoveredItemId) {\n      dispatch(hover_setHoveredItem(hoveredItemId));\n    },\n    clearHoveredItem: function clearHoveredItem() {\n      dispatch(hover_clearHoveredItem());\n    },\n    clearSelectedItems: function clearSelectedItems() {\n      dispatch(selected_items_clearSelectedItems());\n    },\n    setSelectedItems: function setSelectedItems() {\n      dispatch(selected_items_setSelectedItems(selection_getSelectedLeafItems(), false\n      /* bitmapMode */\n      ));\n    },\n    handleMouseDown: function handleMouseDown() {\n      dispatch(modes_changeMode(Modes.RESHAPE));\n    },\n    switchToTextTool: function switchToTextTool() {\n      dispatch(modes_changeMode(Modes.TEXT));\n    }\n  };\n};\n/* harmony default export */ var containers_reshape_mode = (Object(es[\"b\" /* connect */])(reshape_mode_mapStateToProps, reshape_mode_mapDispatchToProps)(reshape_mode_ReshapeMode));\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/helper/selection-tools/select-tool.js\nfunction selection_tools_select_tool_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { selection_tools_select_tool_typeof = function _typeof(obj) { return typeof obj; }; } else { selection_tools_select_tool_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return selection_tools_select_tool_typeof(obj); }\nfunction selection_tools_select_tool_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction selection_tools_select_tool_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction selection_tools_select_tool_createClass(Constructor, protoProps, staticProps) { if (protoProps) selection_tools_select_tool_defineProperties(Constructor.prototype, protoProps); if (staticProps) selection_tools_select_tool_defineProperties(Constructor, staticProps); return Constructor; }\nfunction selection_tools_select_tool_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) selection_tools_select_tool_setPrototypeOf(subClass, superClass); }\nfunction selection_tools_select_tool_setPrototypeOf(o, p) { selection_tools_select_tool_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return selection_tools_select_tool_setPrototypeOf(o, p); }\nfunction selection_tools_select_tool_createSuper(Derived) { var hasNativeReflectConstruct = selection_tools_select_tool_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = selection_tools_select_tool_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = selection_tools_select_tool_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return selection_tools_select_tool_possibleConstructorReturn(this, result); }; }\nfunction selection_tools_select_tool_possibleConstructorReturn(self, call) { if (call && (selection_tools_select_tool_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return selection_tools_select_tool_assertThisInitialized(self); }\nfunction selection_tools_select_tool_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction selection_tools_select_tool_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction selection_tools_select_tool_getPrototypeOf(o) { selection_tools_select_tool_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return selection_tools_select_tool_getPrototypeOf(o); }\n\n/**\n * paper.Tool that handles select mode. This is made up of 2 subtools.\n * - The selection box tool is active when the user clicks an empty space and drags.\n *   It selects all items in the rectangle.\n * - The bounding box tool is active if the user clicks on a non-empty space. It handles\n *   reshaping the item that was clicked.\n */\nvar selection_tools_select_tool_SelectTool = function (_paper$Tool) {\n  selection_tools_select_tool_inherits(SelectTool, _paper$Tool);\n  var _super = selection_tools_select_tool_createSuper(SelectTool);\n  selection_tools_select_tool_createClass(SelectTool, null, [{\n    key: \"TOLERANCE\",\n    /** The distance within which mouse events count as a hit against an item */\n    get: function get() {\n      return 2;\n    }\n    /** Clicks registered within this amount of time are registered as double clicks */\n  }, {\n    key: \"DOUBLE_CLICK_MILLIS\",\n    get: function get() {\n      return 250;\n    }\n    /**\n     * @param {function} setHoveredItem Callback to set the hovered item\n     * @param {function} clearHoveredItem Callback to clear the hovered item\n     * @param {function} setSelectedItems Callback to set the set of selected items in the Redux state\n     * @param {function} clearSelectedItems Callback to clear the set of selected items in the Redux state\n     * @param {function} setCursor Callback to set the visible mouse cursor\n     * @param {!function} onUpdateImage A callback to call when the image visibly changes\n     * @param {!function} switchToTextTool A callback to call to switch to the text tool\n     */\n  }]);\n  function SelectTool(setHoveredItem, clearHoveredItem, setSelectedItems, clearSelectedItems, setCursor, onUpdateImage, switchToTextTool) {\n    var _this;\n    selection_tools_select_tool_classCallCheck(this, SelectTool);\n    _this = _super.call(this);\n    _this.setHoveredItem = setHoveredItem;\n    _this.clearHoveredItem = clearHoveredItem;\n    _this.onUpdateImage = onUpdateImage;\n    _this.boundingBoxTool = new bounding_box_tool(Modes.SELECT, setSelectedItems, clearSelectedItems, setCursor, onUpdateImage, switchToTextTool);\n    var nudgeTool = new nudge_tool(Modes.SELECT, _this.boundingBoxTool, onUpdateImage);\n    _this.selectionBoxTool = new selection_box_tool(Modes.SELECT, setSelectedItems, clearSelectedItems);\n    _this.selectionBoxMode = false;\n    _this.prevHoveredItemId = null;\n    _this.active = false; // We have to set these functions instead of just declaring them because\n    // paper.js tools hook up the listeners in the setter functions.\n    _this.onMouseDown = _this.handleMouseDown;\n    _this.onMouseMove = _this.handleMouseMove;\n    _this.onMouseDrag = _this.handleMouseDrag;\n    _this.onMouseUp = _this.handleMouseUp;\n    _this.onKeyUp = nudgeTool.onKeyUp;\n    _this.onKeyDown = nudgeTool.onKeyDown;\n    selection_selectRootItem();\n    setSelectedItems();\n    _this.boundingBoxTool.setSelectionBounds();\n    return _this;\n  }\n  /**\n   * To be called when the hovered item changes. When the select tool hovers over a\n   * new item, it compares against this to see if a hover item change event needs to\n   * be fired.\n   * @param {paper.Item} prevHoveredItemId ID of the highlight item that indicates the mouse is\n   *     over a given item currently\n   */\n  selection_tools_select_tool_createClass(SelectTool, [{\n    key: \"setPrevHoveredItemId\",\n    value: function setPrevHoveredItemId(prevHoveredItemId) {\n      this.prevHoveredItemId = prevHoveredItemId;\n    }\n    /**\n     * Should be called if the selection changes to update the bounds of the bounding box.\n     * @param {Array<paper.Item>} selectedItems Array of selected items.\n     */\n  }, {\n    key: \"onSelectionChanged\",\n    value: function onSelectionChanged(selectedItems) {\n      this.boundingBoxTool.onSelectionChanged(selectedItems);\n    }\n    /**\n     * Returns the hit options to use when conducting hit tests.\n     * @param {boolean} preselectedOnly True if we should only return results that are already\n     *     selected.\n     * @return {object} See paper.Item.hitTest for definition of options\n     */\n  }, {\n    key: \"getHitOptions\",\n    value: function getHitOptions(preselectedOnly) {\n      // Tolerance needs to be scaled when the view is zoomed in in order to represent the same\n      // distance for the user to move the mouse.\n      var hitOptions = {\n        segments: true,\n        stroke: true,\n        curves: true,\n        fill: true,\n        guide: false,\n        tolerance: SelectTool.TOLERANCE / paper_full_default.a.view.zoom,\n        match: function match(hitResult) {\n          // Don't match helper items, unless they are handles.\n          if (!hitResult.item.data || !hitResult.item.data.isHelperItem) return true;\n          return hitResult.item.data.isScaleHandle || hitResult.item.data.isRotHandle;\n        }\n      };\n      if (preselectedOnly) {\n        hitOptions.selected = true;\n      }\n      return hitOptions;\n    }\n  }, {\n    key: \"handleMouseDown\",\n    value: function handleMouseDown(event) {\n      if (event.event.button > 0) return; // only first mouse button\n      this.active = true;\n      this.clearHoveredItem(); // Check if double clicked\n      var doubleClicked = false;\n      if (this.lastEvent) {\n        if (event.event.timeStamp - this.lastEvent.event.timeStamp < SelectTool.DOUBLE_CLICK_MILLIS) {\n          doubleClicked = true;\n        } else {\n          doubleClicked = false;\n        }\n      }\n      this.lastEvent = event; // If bounding box tool does not find an item that was hit, use selection box tool.\n      if (!this.boundingBoxTool.onMouseDown(event, event.modifiers.alt, event.modifiers.shift, doubleClicked, this.getHitOptions(false\n      /* preseelectedOnly */\n      ))) {\n        this.selectionBoxMode = true;\n        this.selectionBoxTool.onMouseDown(event.modifiers.shift);\n      }\n    }\n  }, {\n    key: \"handleMouseMove\",\n    value: function handleMouseMove(event) {\n      var hoveredItem = hover_getHoveredItem(event, this.getHitOptions());\n      if (!hoveredItem && this.prevHoveredItemId || // There is no longer a hovered item\n      hoveredItem && !this.prevHoveredItemId || // There is now a hovered item\n      hoveredItem && this.prevHoveredItemId && hoveredItem.id !== this.prevHoveredItemId) {\n        // hovered item changed\n        this.setHoveredItem(hoveredItem ? hoveredItem.id : null);\n      }\n      if (!this.selectionBoxMode) {\n        this.boundingBoxTool.onMouseMove(event, this.getHitOptions(false));\n      }\n    }\n  }, {\n    key: \"handleMouseDrag\",\n    value: function handleMouseDrag(event) {\n      if (event.event.button > 0 || !this.active) return; // only first mouse button\n      if (this.selectionBoxMode) {\n        this.selectionBoxTool.onMouseDrag(event);\n      } else {\n        this.boundingBoxTool.onMouseDrag(event);\n      }\n    }\n  }, {\n    key: \"handleMouseUp\",\n    value: function handleMouseUp(event) {\n      if (event.event.button > 0 || !this.active) return; // only first mouse button\n      if (this.selectionBoxMode) {\n        this.selectionBoxTool.onMouseUpVector(event);\n      } else {\n        this.boundingBoxTool.onMouseUp(event, this.getHitOptions(false));\n      }\n      this.selectionBoxMode = false;\n      this.active = false;\n    }\n  }, {\n    key: \"deactivateTool\",\n    value: function deactivateTool() {\n      this.clearHoveredItem();\n      this.boundingBoxTool.deactivateTool();\n      this.setHoveredItem = null;\n      this.clearHoveredItem = null;\n      this.onUpdateImage = null;\n      this.boundingBoxTool = null;\n      this.selectionBoxTool = null;\n    }\n  }]);\n  return SelectTool;\n}(paper_full_default.a.Tool);\n/* harmony default export */ var selection_tools_select_tool = (selection_tools_select_tool_SelectTool);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/select-mode/select.svg\nvar select_mode_select = __webpack_require__(632);\nvar select_default = __webpack_require__.n(select_mode_select);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/components/select-mode/select-mode.jsx\n\nvar select_mode_SelectModeComponent = function SelectModeComponent(props) {\n  return react_default.a.createElement(tool_select_base_tool_select_base, {\n    imgDescriptor: lib_messages.select,\n    imgSrc: select_default.a,\n    isSelected: props.isSelected,\n    onMouseDown: props.onMouseDown\n  });\n};\nselect_mode_SelectModeComponent.propTypes = {\n  isSelected: prop_types_default.a.bool.isRequired,\n  onMouseDown: prop_types_default.a.func.isRequired\n};\n/* harmony default export */ var select_mode = (select_mode_SelectModeComponent);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/containers/select-mode.jsx\nfunction select_mode_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { select_mode_typeof = function _typeof(obj) { return typeof obj; }; } else { select_mode_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return select_mode_typeof(obj); }\nfunction select_mode_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction select_mode_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction select_mode_createClass(Constructor, protoProps, staticProps) { if (protoProps) select_mode_defineProperties(Constructor.prototype, protoProps); if (staticProps) select_mode_defineProperties(Constructor, staticProps); return Constructor; }\nfunction select_mode_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) select_mode_setPrototypeOf(subClass, superClass); }\nfunction select_mode_setPrototypeOf(o, p) { select_mode_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return select_mode_setPrototypeOf(o, p); }\nfunction select_mode_createSuper(Derived) { var hasNativeReflectConstruct = select_mode_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = select_mode_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = select_mode_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return select_mode_possibleConstructorReturn(this, result); }; }\nfunction select_mode_possibleConstructorReturn(self, call) { if (call && (select_mode_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return select_mode_assertThisInitialized(self); }\nfunction select_mode_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction select_mode_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction select_mode_getPrototypeOf(o) { select_mode_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return select_mode_getPrototypeOf(o); }\n\nvar select_mode_SelectMode = function (_React$Component) {\n  select_mode_inherits(SelectMode, _React$Component);\n  var _super = select_mode_createSuper(SelectMode);\n  function SelectMode(props) {\n    var _this;\n    select_mode_classCallCheck(this, SelectMode);\n    _this = _super.call(this, props);\n    lodash_bindall_default()(select_mode_assertThisInitialized(_this), ['activateTool', 'deactivateTool']);\n    return _this;\n  }\n  select_mode_createClass(SelectMode, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this.props.isSelectModeActive) {\n        this.activateTool(this.props);\n      }\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(nextProps) {\n      if (this.tool && nextProps.hoveredItemId !== this.props.hoveredItemId) {\n        this.tool.setPrevHoveredItemId(nextProps.hoveredItemId);\n      }\n      if (this.tool && nextProps.selectedItems !== this.props.selectedItems) {\n        this.tool.onSelectionChanged(nextProps.selectedItems);\n      }\n      if (nextProps.isSelectModeActive && !this.props.isSelectModeActive) {\n        this.activateTool();\n      } else if (!nextProps.isSelectModeActive && this.props.isSelectModeActive) {\n        this.deactivateTool();\n      }\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps) {\n      return nextProps.isSelectModeActive !== this.props.isSelectModeActive;\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.tool) {\n        this.deactivateTool();\n      }\n    }\n  }, {\n    key: \"activateTool\",\n    value: function activateTool() {\n      this.tool = new selection_tools_select_tool(this.props.setHoveredItem, this.props.clearHoveredItem, this.props.setSelectedItems, this.props.clearSelectedItems, this.props.setCursor, this.props.onUpdateImage, this.props.switchToTextTool);\n      this.tool.activate();\n    }\n  }, {\n    key: \"deactivateTool\",\n    value: function deactivateTool() {\n      this.tool.deactivateTool();\n      this.tool.remove();\n      this.tool = null;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return react_default.a.createElement(select_mode, {\n        isSelected: this.props.isSelectModeActive,\n        onMouseDown: this.props.handleMouseDown\n      });\n    }\n  }]);\n  return SelectMode;\n}(react_default.a.Component);\nselect_mode_SelectMode.propTypes = {\n  clearHoveredItem: prop_types_default.a.func.isRequired,\n  clearSelectedItems: prop_types_default.a.func.isRequired,\n  handleMouseDown: prop_types_default.a.func.isRequired,\n  hoveredItemId: prop_types_default.a.number,\n  isSelectModeActive: prop_types_default.a.bool.isRequired,\n  onUpdateImage: prop_types_default.a.func.isRequired,\n  selectedItems: prop_types_default.a.arrayOf(prop_types_default.a.instanceOf(paper_full_default.a.Item)),\n  setCursor: prop_types_default.a.func.isRequired,\n  setHoveredItem: prop_types_default.a.func.isRequired,\n  setSelectedItems: prop_types_default.a.func.isRequired,\n  switchToTextTool: prop_types_default.a.func.isRequired\n};\nvar select_mode_mapStateToProps = function mapStateToProps(state) {\n  return {\n    isSelectModeActive: state.scratchPaint.mode === Modes.SELECT,\n    hoveredItemId: state.scratchPaint.hoveredItemId,\n    selectedItems: state.scratchPaint.selectedItems\n  };\n};\nvar select_mode_mapDispatchToProps = function mapDispatchToProps(dispatch) {\n  return {\n    setHoveredItem: function setHoveredItem(hoveredItemId) {\n      dispatch(hover_setHoveredItem(hoveredItemId));\n    },\n    clearHoveredItem: function clearHoveredItem() {\n      dispatch(hover_clearHoveredItem());\n    },\n    clearSelectedItems: function clearSelectedItems() {\n      dispatch(selected_items_clearSelectedItems());\n    },\n    setSelectedItems: function setSelectedItems() {\n      dispatch(selected_items_setSelectedItems(selection_getSelectedLeafItems(), false\n      /* bitmapMode */\n      ));\n    },\n    setCursor: function setCursor(cursorString) {\n      dispatch(cursor_setCursor(cursorString));\n    },\n    handleMouseDown: function handleMouseDown() {\n      dispatch(modes_changeMode(Modes.SELECT));\n    },\n    switchToTextTool: function switchToTextTool() {\n      dispatch(modes_changeMode(Modes.TEXT));\n    }\n  };\n};\n/* harmony default export */ var containers_select_mode = (Object(es[\"b\" /* connect */])(select_mode_mapStateToProps, select_mode_mapDispatchToProps)(select_mode_SelectMode));\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/containers/stroke-color-indicator.jsx\n\nvar stroke_color_indicator_messages = Object(index_es[\"d\" /* defineMessages */])({\n  label: {\n    \"id\": \"paint.paintEditor.stroke\",\n    \"defaultMessage\": \"Outline\"\n  }\n});\nvar StrokeColorIndicator = containers_color_indicator(stroke_color_indicator_messages.label, true);\nvar stroke_color_indicator_mapStateToProps = function mapStateToProps(state) {\n  return {\n    colorIndex: state.scratchPaint.fillMode.colorIndex,\n    disabled: state.scratchPaint.mode === Modes.BRUSH || state.scratchPaint.mode === Modes.TEXT || state.scratchPaint.mode === Modes.FILL,\n    color: state.scratchPaint.color.strokeColor.primary,\n    color2: state.scratchPaint.color.strokeColor.secondary,\n    fillBitmapShapes: state.scratchPaint.fillBitmapShapes,\n    colorModalVisible: state.scratchPaint.modals.strokeColor,\n    format: state.scratchPaint.format,\n    gradientType: state.scratchPaint.color.strokeColor.gradientType,\n    isEyeDropping: state.scratchPaint.color.eyeDropper.active,\n    mode: state.scratchPaint.mode,\n    shouldShowGradientTools: state.scratchPaint.mode in GradientToolsModes,\n    textEditTarget: state.scratchPaint.textEditTarget\n  };\n};\nvar stroke_color_indicator_mapDispatchToProps = function mapDispatchToProps(dispatch) {\n  return {\n    onChangeColorIndex: function onChangeColorIndex(index) {\n      dispatch(changeColorIndex(index));\n    },\n    onChangeColor: function onChangeColor(strokeColor, index) {\n      if (index === 0) {\n        dispatch(changeStrokeColor(strokeColor));\n      } else if (index === 1) {\n        dispatch(changeStrokeColor2(strokeColor));\n      }\n    },\n    onChangeStrokeWidth: function onChangeStrokeWidth(strokeWidth) {\n      dispatch(changeStrokeWidth(strokeWidth));\n    },\n    onOpenColor: function onOpenColor() {\n      dispatch(openStrokeColor());\n    },\n    onCloseColor: function onCloseColor() {\n      dispatch(closeStrokeColor());\n    },\n    onChangeGradientType: function onChangeGradientType(gradientType) {\n      dispatch(changeStrokeGradientType(gradientType));\n    },\n    setSelectedItems: function setSelectedItems(format) {\n      dispatch(selected_items_setSelectedItems(selection_getSelectedLeafItems(), format_isBitmap(format)));\n    }\n  };\n};\n/* harmony default export */ var stroke_color_indicator = (Object(es[\"b\" /* connect */])(stroke_color_indicator_mapStateToProps, stroke_color_indicator_mapDispatchToProps)(StrokeColorIndicator));\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/components/stroke-width-indicator.jsx\n\nvar stroke_width_indicator_LiveInput = live_input_hoc(forms_input);\nvar stroke_width_indicator_StrokeWidthIndicatorComponent = function StrokeWidthIndicatorComponent(props) {\n  return react_default.a.createElement(input_group_input_group, {\n    disabled: props.disabled\n  }, react_default.a.createElement(stroke_width_indicator_LiveInput, {\n    range: true,\n    small: true,\n    disabled: props.disabled,\n    max: MAX_STROKE_WIDTH,\n    min: \"0\",\n    type: \"number\",\n    value: props.strokeWidth ? props.strokeWidth : 0,\n    onSubmit: props.onChangeStrokeWidth\n  }));\n};\nstroke_width_indicator_StrokeWidthIndicatorComponent.propTypes = {\n  disabled: prop_types_default.a.bool.isRequired,\n  onChangeStrokeWidth: prop_types_default.a.func.isRequired,\n  strokeWidth: prop_types_default.a.number\n};\n/* harmony default export */ var stroke_width_indicator = (stroke_width_indicator_StrokeWidthIndicatorComponent);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/containers/stroke-width-indicator.jsx\nfunction stroke_width_indicator_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { stroke_width_indicator_typeof = function _typeof(obj) { return typeof obj; }; } else { stroke_width_indicator_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return stroke_width_indicator_typeof(obj); }\nfunction stroke_width_indicator_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction stroke_width_indicator_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction stroke_width_indicator_createClass(Constructor, protoProps, staticProps) { if (protoProps) stroke_width_indicator_defineProperties(Constructor.prototype, protoProps); if (staticProps) stroke_width_indicator_defineProperties(Constructor, staticProps); return Constructor; }\nfunction stroke_width_indicator_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) stroke_width_indicator_setPrototypeOf(subClass, superClass); }\nfunction stroke_width_indicator_setPrototypeOf(o, p) { stroke_width_indicator_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return stroke_width_indicator_setPrototypeOf(o, p); }\nfunction stroke_width_indicator_createSuper(Derived) { var hasNativeReflectConstruct = stroke_width_indicator_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = stroke_width_indicator_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = stroke_width_indicator_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return stroke_width_indicator_possibleConstructorReturn(this, result); }; }\nfunction stroke_width_indicator_possibleConstructorReturn(self, call) { if (call && (stroke_width_indicator_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return stroke_width_indicator_assertThisInitialized(self); }\nfunction stroke_width_indicator_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction stroke_width_indicator_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction stroke_width_indicator_getPrototypeOf(o) { stroke_width_indicator_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return stroke_width_indicator_getPrototypeOf(o); }\n\nvar stroke_width_indicator_StrokeWidthIndicator = function (_React$Component) {\n  stroke_width_indicator_inherits(StrokeWidthIndicator, _React$Component);\n  var _super = stroke_width_indicator_createSuper(StrokeWidthIndicator);\n  function StrokeWidthIndicator(props) {\n    var _this;\n    stroke_width_indicator_classCallCheck(this, StrokeWidthIndicator);\n    _this = _super.call(this, props);\n    lodash_bindall_default()(stroke_width_indicator_assertThisInitialized(_this), ['handleChangeStrokeWidth']);\n    return _this;\n  }\n  stroke_width_indicator_createClass(StrokeWidthIndicator, [{\n    key: \"handleChangeStrokeWidth\",\n    value: function handleChangeStrokeWidth(newWidth) {\n      var changed = style_path_applyStrokeWidthToSelection(newWidth, this.props.textEditTarget);\n      if ((!this.props.strokeWidth || this.props.strokeWidth === 0) && newWidth > 0) {\n        var currentColorState = style_path_getColorsFromSelection(selection_getSelectedLeafItems(), format_isBitmap(this.props.format)); // Color counts as null if either both colors are null or the primary color is null and it's solid\n        // TODO: consolidate this check in one place\n        var wasNull = currentColorState.strokeColor === null && (currentColorState.strokeColor2 === null || currentColorState.strokeGradientType === gradient_types.SOLID);\n        if (wasNull) {\n          changed = style_path_applyColorToSelection('#000', 0, // colorIndex,\n          true, // isSolidGradient\n          true, // applyToStroke\n          this.props.textEditTarget) || changed; // If there's no previous stroke color, default to solid black\n          this.props.onChangeStrokeGradientType(gradient_types.SOLID);\n          this.props.onChangeStrokeColor('#000');\n        } else if (currentColorState.strokeColor !== MIXED) {\n          // Set color state from the selected item's stroke color\n          this.props.onChangeStrokeGradientType(currentColorState.strokeGradientType);\n          this.props.onChangeStrokeColor(parse_color_default()(currentColorState.strokeColor).hex);\n          this.props.onChangeStrokeColor2(parse_color_default()(currentColorState.strokeColor2).hex);\n        }\n      }\n      this.props.onChangeStrokeWidth(newWidth);\n      if (changed) this.props.onUpdateImage();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return react_default.a.createElement(stroke_width_indicator, {\n        disabled: this.props.disabled,\n        strokeWidth: this.props.strokeWidth,\n        onChangeStrokeWidth: this.handleChangeStrokeWidth\n      });\n    }\n  }]);\n  return StrokeWidthIndicator;\n}(react_default.a.Component);\nvar stroke_width_indicator_mapStateToProps = function mapStateToProps(state) {\n  return {\n    disabled: state.scratchPaint.mode === Modes.BRUSH || state.scratchPaint.mode === Modes.TEXT || state.scratchPaint.mode === Modes.FILL,\n    format: state.scratchPaint.format,\n    strokeWidth: state.scratchPaint.color.strokeWidth,\n    textEditTarget: state.scratchPaint.textEditTarget\n  };\n};\nvar stroke_width_indicator_mapDispatchToProps = function mapDispatchToProps(dispatch) {\n  return {\n    onChangeStrokeColor: function onChangeStrokeColor(strokeColor) {\n      dispatch(changeStrokeColor(strokeColor));\n    },\n    onChangeStrokeColor2: function onChangeStrokeColor2(strokeColor) {\n      dispatch(changeStrokeColor2(strokeColor));\n    },\n    onChangeStrokeGradientType: function onChangeStrokeGradientType(strokeColor) {\n      dispatch(changeStrokeGradientType(strokeColor));\n    },\n    onChangeStrokeWidth: function onChangeStrokeWidth(strokeWidth) {\n      dispatch(changeStrokeWidth(strokeWidth));\n    }\n  };\n};\nstroke_width_indicator_StrokeWidthIndicator.propTypes = {\n  disabled: prop_types_default.a.bool.isRequired,\n  format: prop_types_default.a.oneOf(Object.keys(Formats)),\n  onChangeStrokeColor: prop_types_default.a.func.isRequired,\n  onChangeStrokeColor2: prop_types_default.a.func.isRequired,\n  onChangeStrokeGradientType: prop_types_default.a.func.isRequired,\n  onChangeStrokeWidth: prop_types_default.a.func.isRequired,\n  onUpdateImage: prop_types_default.a.func.isRequired,\n  strokeWidth: prop_types_default.a.number,\n  textEditTarget: prop_types_default.a.number\n};\n/* harmony default export */ var containers_stroke_width_indicator = (Object(es[\"b\" /* connect */])(stroke_width_indicator_mapStateToProps, stroke_width_indicator_mapDispatchToProps)(stroke_width_indicator_StrokeWidthIndicator));\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/helper/tools/text-tool.js\nfunction text_tool_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { text_tool_typeof = function _typeof(obj) { return typeof obj; }; } else { text_tool_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return text_tool_typeof(obj); }\nfunction text_tool_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = text_tool_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction text_tool_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return text_tool_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return text_tool_arrayLikeToArray(o, minLen); }\nfunction text_tool_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction text_tool_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction text_tool_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction text_tool_createClass(Constructor, protoProps, staticProps) { if (protoProps) text_tool_defineProperties(Constructor.prototype, protoProps); if (staticProps) text_tool_defineProperties(Constructor, staticProps); return Constructor; }\nfunction text_tool_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) text_tool_setPrototypeOf(subClass, superClass); }\nfunction text_tool_setPrototypeOf(o, p) { text_tool_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return text_tool_setPrototypeOf(o, p); }\nfunction text_tool_createSuper(Derived) { var hasNativeReflectConstruct = text_tool_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = text_tool_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = text_tool_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return text_tool_possibleConstructorReturn(this, result); }; }\nfunction text_tool_possibleConstructorReturn(self, call) { if (call && (text_tool_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return text_tool_assertThisInitialized(self); }\nfunction text_tool_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction text_tool_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction text_tool_getPrototypeOf(o) { text_tool_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return text_tool_getPrototypeOf(o); }\n\n/**\n * Tool for adding text. Text elements have limited editability; they can't be reshaped,\n * drawn on or erased. This way they can preserve their ability to have the text edited.\n */\nvar text_tool_TextTool = function (_paper$Tool) {\n  text_tool_inherits(TextTool, _paper$Tool);\n  var _super = text_tool_createSuper(TextTool);\n  text_tool_createClass(TextTool, null, [{\n    key: \"TOLERANCE\",\n    get: function get() {\n      return 2;\n    }\n  }, {\n    key: \"TEXT_EDIT_MODE\",\n    get: function get() {\n      return 'TEXT_EDIT_MODE';\n    }\n  }, {\n    key: \"SELECT_MODE\",\n    get: function get() {\n      return 'SELECT_MODE';\n    }\n    /** Clicks registered within this amount of time are registered as double clicks */\n  }, {\n    key: \"DOUBLE_CLICK_MILLIS\",\n    get: function get() {\n      return 250;\n    }\n    /** Typing with no pauses longer than this amount of type will count as 1 action */\n  }, {\n    key: \"TYPING_TIMEOUT_MILLIS\",\n    get: function get() {\n      return 1000;\n    }\n  }, {\n    key: \"TEXT_PADDING\",\n    get: function get() {\n      return 8;\n    }\n    /**\n     * @param {HTMLTextAreaElement} textAreaElement dom element for the editable text field\n     * @param {function} setSelectedItems Callback to set the set of selected items in the Redux state\n     * @param {function} clearSelectedItems Callback to clear the set of selected items in the Redux state\n     * @param {function} setCursor Callback to set the visible mouse cursor\n     * @param {!function} onUpdateImage A callback to call when the image visibly changes\n     * @param {!function} setTextEditTarget Call to set text editing target whenever text editing is active\n     * @param {!function} changeFont Call to change the font in the dropdown\n     * @param {?boolean} isBitmap True if text should be rasterized once it's deselected\n     */\n  }]);\n  function TextTool(textAreaElement, setSelectedItems, clearSelectedItems, setCursor, onUpdateImage, setTextEditTarget, changeFont, isBitmap) {\n    var _this;\n    text_tool_classCallCheck(this, TextTool);\n    _this = _super.call(this);\n    _this.element = textAreaElement;\n    _this.setSelectedItems = setSelectedItems;\n    _this.clearSelectedItems = clearSelectedItems;\n    _this.onUpdateImage = onUpdateImage;\n    _this.setTextEditTarget = setTextEditTarget;\n    _this.changeFont = changeFont;\n    var paintMode = isBitmap ? Modes.BIT_TEXT : Modes.TEXT;\n    _this.boundingBoxTool = new bounding_box_tool(paintMode, setSelectedItems, clearSelectedItems, setCursor, onUpdateImage);\n    _this.nudgeTool = new nudge_tool(paintMode, _this.boundingBoxTool, onUpdateImage);\n    _this.isBitmap = isBitmap; // We have to set these functions instead of just declaring them because\n    // paper.js tools hook up the listeners in the setter functions.\n    _this.onMouseDown = _this.handleMouseDown;\n    _this.onMouseDrag = _this.handleMouseDrag;\n    _this.onMouseUp = _this.handleMouseUp;\n    _this.onMouseMove = _this.handleMouseMove;\n    _this.onKeyUp = _this.handleKeyUp;\n    _this.onKeyDown = _this.handleKeyDown;\n    _this.textBox = null;\n    _this.guide = null;\n    _this.colorState = null;\n    _this.mode = null;\n    _this.active = false;\n    _this.lastTypeEvent = null;\n    _this.lastEvent = null; // If text selected and then activate this tool, switch to text edit mode for that text\n    // If double click on text while in select mode, does mode change to text mode? Text fully selected by default\n    return _this;\n  }\n  text_tool_createClass(TextTool, [{\n    key: \"getBoundingBoxHitOptions\",\n    value: function getBoundingBoxHitOptions() {\n      return {\n        segments: true,\n        stroke: true,\n        curves: true,\n        fill: true,\n        guide: false,\n        match: function match(hitResult) {\n          return hitResult.item.data && (hitResult.item.data.isScaleHandle || hitResult.item.data.isRotHandle) || hitResult.item.selected;\n        },\n        // Allow hits on bounding box and selected only\n        tolerance: TextTool.TOLERANCE / paper_full_default.a.view.zoom\n      };\n    }\n  }, {\n    key: \"getTextEditHitOptions\",\n    value: function getTextEditHitOptions() {\n      return {\n        class: paper_full_default.a.PointText,\n        segments: true,\n        stroke: true,\n        curves: true,\n        fill: true,\n        guide: false,\n        match: function match(hitResult) {\n          return hitResult.item && !(hitResult.item.data && hitResult.item.data.isHelperItem) && !hitResult.item.selected;\n        },\n        // Unselected only\n        tolerance: TextTool.TOLERANCE / paper_full_default.a.view.zoom\n      };\n    }\n    /**\n     * Called when the selection changes to update the bounds of the bounding box.\n     * @param {Array<paper.Item>} selectedItems Array of selected items.\n     */\n  }, {\n    key: \"onSelectionChanged\",\n    value: function onSelectionChanged(selectedItems) {\n      this.boundingBoxTool.onSelectionChanged(selectedItems);\n      if ((!this.textBox || !this.textBox.parent) && selectedItems && selectedItems.length === 1 && selectedItems[0] instanceof paper_full_default.a.PointText) {\n        // Infer that an undo occurred and get back the active text\n        this.textBox = selectedItems[0];\n        this.mode = TextTool.SELECT_MODE;\n      }\n    }\n  }, {\n    key: \"setFont\",\n    value: function setFont(font) {\n      this.font = font;\n      if (this.textBox) {\n        this.textBox.font = font;\n      }\n      var selected = selection_getSelectedLeafItems();\n      var _iterator = text_tool_createForOfIteratorHelper(selected),\n          _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var item = _step.value;\n          if (item instanceof paper_full_default.a.PointText) {\n            item.font = font;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      this.element.style.fontFamily = font;\n      this.setSelectedItems();\n    } // Allow other tools to cancel text edit mode\n  }, {\n    key: \"onTextEditCancelled\",\n    value: function onTextEditCancelled() {\n      if (this.mode !== TextTool.TEXT_EDIT_MODE) {\n        return;\n      }\n      this.endTextEdit();\n      this.beginSelect();\n    }\n    /**\n     * Called when the view matrix changes\n     * @param {paper.Matrix} viewMtx applied to paper.view\n     */\n  }, {\n    key: \"onViewBoundsChanged\",\n    value: function onViewBoundsChanged(viewMtx) {\n      if (this.mode !== TextTool.TEXT_EDIT_MODE) {\n        return;\n      }\n      this.calculateMatrix(viewMtx);\n    }\n  }, {\n    key: \"calculateMatrix\",\n    value: function calculateMatrix(viewMtx) {\n      var textBoxMtx = this.textBox.matrix;\n      var calculated = new paper_full_default.a.Matrix(); // In RTL, the element is moved relative to its parent's right edge instead of its left\n      // edge. We need to correct for this in order for the element to overlap the object in paper.\n      var tx = 0;\n      if (this.rtl && this.element.parentElement) {\n        tx = -this.element.parentElement.clientWidth;\n      } // The transform origin in paper is x at justification side, y at the baseline of the text.\n      // The offset from (0, 0) to the upper left corner is recorded by internalBounds\n      // (so this.textBox.internalBounds.y is negative).\n      // Move the transform origin down to the text baseline to match paper\n      this.element.style.transformOrigin = \"\".concat(-this.textBox.internalBounds.x, \"px \").concat(-this.textBox.internalBounds.y, \"px\"); // Start by translating the element up so that its (0, 0) is now at the text baseline, like in paper\n      calculated.translate(tx, this.textBox.internalBounds.y);\n      calculated.append(viewMtx);\n      calculated.append(textBoxMtx);\n      this.element.style.transform = \"matrix(\".concat(calculated.a, \", \").concat(calculated.b, \", \").concat(calculated.c, \", \").concat(calculated.d, \",\\n             \").concat(calculated.tx, \", \").concat(calculated.ty, \")\");\n    }\n  }, {\n    key: \"setColorState\",\n    value: function setColorState(colorState) {\n      this.colorState = colorState;\n    }\n    /** @param {boolean} isrtl True if paint editor is in right-to-left layout (e.g. Hebrew language) */\n  }, {\n    key: \"setRtl\",\n    value: function setRtl(isrtl) {\n      this.rtl = isrtl;\n    }\n  }, {\n    key: \"handleMouseMove\",\n    value: function handleMouseMove(event) {\n      var hitResults = paper_full_default.a.project.hitTestAll(event.point, this.getTextEditHitOptions());\n      if (hitResults.length) {\n        document.body.style.cursor = 'text';\n      } else {\n        document.body.style.cursor = 'auto';\n      }\n      this.boundingBoxTool.onMouseMove(event, this.getBoundingBoxHitOptions());\n    }\n  }, {\n    key: \"handleMouseDown\",\n    value: function handleMouseDown(event) {\n      if (event.event.button > 0) return; // only first mouse button\n      this.active = true; // Check if double clicked\n      var doubleClicked = this.lastEvent && event.event.timeStamp - this.lastEvent.event.timeStamp < TextTool.DOUBLE_CLICK_MILLIS;\n      this.lastEvent = event;\n      if (doubleClicked && this.mode === TextTool.SELECT_MODE && this.textBox.hitTest(event.point)) {\n        // Double click in select mode moves you to text edit mode\n        this.endSelect();\n        this.beginTextEdit(this.textBox);\n        this.element.select();\n        return;\n      } // In select mode staying in select mode\n      if (this.boundingBoxTool.onMouseDown(event, false\n      /* clone */\n      , false\n      /* multiselect */\n      , false\n      /* doubleClicked */\n      , this.getBoundingBoxHitOptions())) {\n        return;\n      } // We clicked away from the item, so end the current mode\n      var lastMode = this.mode;\n      if (this.mode === TextTool.SELECT_MODE) {\n        this.endSelect();\n        if (this.isBitmap) {\n          this.commitText();\n        }\n      } else if (this.mode === TextTool.TEXT_EDIT_MODE) {\n        this.endTextEdit();\n      }\n      var hitResults = paper_full_default.a.project.hitTestAll(event.point, this.getTextEditHitOptions());\n      if (hitResults.length) {\n        // Clicking a different text item to begin text edit mode on that item\n        this.beginTextEdit(hitResults[0].item);\n      } else if (lastMode === TextTool.TEXT_EDIT_MODE) {\n        // In text mode clicking away to begin select mode\n        this.beginSelect();\n      } else {\n        // In no mode or select mode clicking away to begin text edit mode\n        this.textBox = new paper_full_default.a.PointText({\n          point: event.point,\n          content: '',\n          font: this.font,\n          fontSize: 40,\n          // TODO: style using gradient\n          // https://github.com/LLK/scratch-paint/issues/1164\n          fillColor: this.colorState.fillColor.primary,\n          // Default leading for both the HTML text area and paper.PointText\n          // is 120%, but for some reason they are slightly off from each other.\n          // This value was obtained experimentally.\n          leading: 46.15\n        });\n        this.beginTextEdit(this.textBox);\n      }\n    }\n  }, {\n    key: \"handleMouseDrag\",\n    value: function handleMouseDrag(event) {\n      if (event.event.button > 0 || !this.active) return; // only first mouse button\n      if (this.mode === TextTool.SELECT_MODE) {\n        this.boundingBoxTool.onMouseDrag(event);\n        return;\n      }\n    }\n  }, {\n    key: \"handleMouseUp\",\n    value: function handleMouseUp(event) {\n      if (event.event.button > 0 || !this.active) return; // only first mouse button\n      if (this.mode === TextTool.SELECT_MODE) {\n        this.boundingBoxTool.onMouseUp(event);\n        this.isBoundingBoxMode = null;\n        return;\n      }\n      this.active = false;\n    }\n  }, {\n    key: \"handleKeyUp\",\n    value: function handleKeyUp(event) {\n      if (event.event.target instanceof HTMLInputElement) {\n        // Ignore nudge if a text input field is focused\n        return;\n      }\n      if (this.mode === TextTool.SELECT_MODE) {\n        this.nudgeTool.onKeyUp(event);\n      }\n    }\n  }, {\n    key: \"handleKeyDown\",\n    value: function handleKeyDown(event) {\n      if (event.event.target instanceof HTMLInputElement) {\n        // Ignore nudge if a text input field is focused\n        return;\n      }\n      if (this.mode === TextTool.TEXT_EDIT_MODE && event.key === 'escape') {\n        this.endTextEdit();\n      }\n      if (this.mode === TextTool.SELECT_MODE) {\n        this.nudgeTool.onKeyDown(event);\n      }\n    }\n  }, {\n    key: \"handleTextInput\",\n    value: function handleTextInput(event) {\n      // Save undo state if you paused typing for long enough.\n      if (this.lastTypeEvent && event.timeStamp - this.lastTypeEvent.timeStamp > TextTool.TYPING_TIMEOUT_MILLIS) {\n        // Select the textbox so that it will be selected if the user performs undo.\n        this.textBox.selected = true;\n        this.onUpdateImage();\n        this.textBox.selected = false;\n      }\n      this.lastTypeEvent = event;\n      if (this.mode === TextTool.TEXT_EDIT_MODE) {\n        this.textBox.content = this.element.value;\n      }\n      this.resizeGuide();\n    }\n  }, {\n    key: \"resizeGuide\",\n    value: function resizeGuide() {\n      if (this.guide) this.guide.remove();\n      this.guide = guides_hoverBounds(this.textBox, TextTool.TEXT_PADDING);\n      this.guide.dashArray = [4, 4]; // Prevent line from wrapping\n      this.element.style.width = \"\".concat(this.textBox.internalBounds.width + 1, \"px\");\n      this.element.style.height = \"\".concat(this.textBox.internalBounds.height, \"px\"); // The transform origin needs to be updated in RTL because this.textBox.internalBounds.x\n      // changes as you type\n      if (this.rtl) {\n        this.element.style.transformOrigin = \"\".concat(-this.textBox.internalBounds.x, \"px \").concat(-this.textBox.internalBounds.y, \"px\");\n      }\n    }\n  }, {\n    key: \"beginSelect\",\n    value: function beginSelect() {\n      if (this.textBox) {\n        this.mode = TextTool.SELECT_MODE;\n        this.textBox.selected = true;\n        this.setSelectedItems();\n      }\n    }\n  }, {\n    key: \"endSelect\",\n    value: function endSelect() {\n      selection_clearSelection(this.clearSelectedItems);\n      this.mode = null;\n    }\n    /**\n     * @param {paper.PointText} textBox Text object to begin text edit on\n     */\n  }, {\n    key: \"beginTextEdit\",\n    value: function beginTextEdit(textBox) {\n      this.textBox = textBox;\n      this.mode = TextTool.TEXT_EDIT_MODE;\n      this.setTextEditTarget(this.textBox.id);\n      if (this.font !== this.textBox.font) {\n        this.changeFont(this.textBox.font);\n      }\n      this.element.style.fontSize = \"\".concat(this.textBox.fontSize, \"px\");\n      this.element.style.lineHeight = this.textBox.leading / this.textBox.fontSize;\n      this.element.style.display = 'initial';\n      this.element.value = textBox.content ? textBox.content : '';\n      this.calculateMatrix(paper_full_default.a.view.matrix);\n      if (this.rtl) {\n        // make both the textbox and the textarea element grow to the left\n        this.textBox.justification = 'right';\n      } else {\n        this.textBox.justification = 'left';\n      }\n      this.element.focus({\n        preventScroll: true\n      });\n      this.eventListener = this.handleTextInput.bind(this);\n      this.element.addEventListener('input', this.eventListener);\n      this.resizeGuide();\n    }\n  }, {\n    key: \"endTextEdit\",\n    value: function endTextEdit() {\n      if (this.mode !== TextTool.TEXT_EDIT_MODE) {\n        return;\n      }\n      this.mode = null; // Remove invisible textboxes\n      if (this.textBox && this.textBox.content.trim() === '') {\n        this.textBox.remove();\n        this.textBox = null;\n      } // Remove guide\n      if (this.guide) {\n        this.guide.remove();\n        this.guide = null;\n        this.setTextEditTarget();\n      }\n      this.element.style.display = 'none';\n      if (this.eventListener) {\n        this.element.removeEventListener('input', this.eventListener);\n        this.eventListener = null;\n      }\n      if (this.textBox && this.lastTypeEvent) {\n        // Finished editing a textbox, save undo state\n        // Select the textbox so that it will be selected if the user performs undo.\n        this.textBox.selected = true;\n        this.onUpdateImage();\n        this.textBox.selected = false;\n        this.lastTypeEvent = null;\n      }\n    }\n  }, {\n    key: \"commitText\",\n    value: function commitText() {\n      if (!this.textBox || !this.textBox.parent) return; // @todo get crisp text https://github.com/LLK/scratch-paint/issues/508\n      var textRaster = this.textBox.rasterize(72, false\n      /* insert */\n      , this.textBox.drawnBounds);\n      this.textBox.remove();\n      this.textBox = null;\n      getRaster().drawImage(textRaster.canvas, new paper_full_default.a.Point(Math.floor(textRaster.bounds.x), Math.floor(textRaster.bounds.y)));\n      this.onUpdateImage();\n    }\n  }, {\n    key: \"deactivateTool\",\n    value: function deactivateTool() {\n      if (this.textBox && this.textBox.content.trim() === '') {\n        this.textBox.remove();\n        this.textBox = null;\n      }\n      this.endTextEdit();\n      if (this.isBitmap) {\n        this.commitText();\n      }\n      this.boundingBoxTool.deactivateTool();\n    }\n  }]);\n  return TextTool;\n}(paper_full_default.a.Tool);\n/* harmony default export */ var text_tool = (text_tool_TextTool);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/text-mode/text.svg\nvar text_mode_text = __webpack_require__(633);\nvar text_default = __webpack_require__.n(text_mode_text);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/components/text-mode/text-mode.jsx\n\nvar text_mode_TextModeComponent = function TextModeComponent(props) {\n  return react_default.a.createElement(tool_select_base_tool_select_base, {\n    imgDescriptor: lib_messages.text,\n    imgSrc: text_default.a,\n    isSelected: props.isSelected,\n    onMouseDown: props.onMouseDown\n  });\n};\ntext_mode_TextModeComponent.propTypes = {\n  isSelected: prop_types_default.a.bool.isRequired,\n  onMouseDown: prop_types_default.a.func.isRequired\n};\n/* harmony default export */ var text_mode = (text_mode_TextModeComponent);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/bit-text-mode/text.svg\nvar bit_text_mode_text = __webpack_require__(634);\nvar bit_text_mode_text_default = __webpack_require__.n(bit_text_mode_text);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/components/bit-text-mode/bit-text-mode.jsx\n\nvar bit_text_mode_BitTextComponent = function BitTextComponent(props) {\n  return react_default.a.createElement(tool_select_base_tool_select_base, {\n    imgDescriptor: lib_messages.text,\n    imgSrc: bit_text_mode_text_default.a,\n    isSelected: props.isSelected,\n    onMouseDown: props.onMouseDown\n  });\n};\nbit_text_mode_BitTextComponent.propTypes = {\n  isSelected: prop_types_default.a.bool.isRequired,\n  onMouseDown: prop_types_default.a.func.isRequired\n};\n/* harmony default export */ var bit_text_mode = (bit_text_mode_BitTextComponent);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/containers/text-mode.jsx\nfunction text_mode_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { text_mode_typeof = function _typeof(obj) { return typeof obj; }; } else { text_mode_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return text_mode_typeof(obj); }\nfunction text_mode_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction text_mode_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction text_mode_createClass(Constructor, protoProps, staticProps) { if (protoProps) text_mode_defineProperties(Constructor.prototype, protoProps); if (staticProps) text_mode_defineProperties(Constructor, staticProps); return Constructor; }\nfunction text_mode_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) text_mode_setPrototypeOf(subClass, superClass); }\nfunction text_mode_setPrototypeOf(o, p) { text_mode_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return text_mode_setPrototypeOf(o, p); }\nfunction text_mode_createSuper(Derived) { var hasNativeReflectConstruct = text_mode_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = text_mode_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = text_mode_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return text_mode_possibleConstructorReturn(this, result); }; }\nfunction text_mode_possibleConstructorReturn(self, call) { if (call && (text_mode_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return text_mode_assertThisInitialized(self); }\nfunction text_mode_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction text_mode_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction text_mode_getPrototypeOf(o) { text_mode_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return text_mode_getPrototypeOf(o); }\n\nvar text_mode_TextMode = function (_React$Component) {\n  text_mode_inherits(TextMode, _React$Component);\n  var _super = text_mode_createSuper(TextMode);\n  function TextMode(props) {\n    var _this;\n    text_mode_classCallCheck(this, TextMode);\n    _this = _super.call(this, props);\n    lodash_bindall_default()(text_mode_assertThisInitialized(_this), ['activateTool', 'deactivateTool']);\n    return _this;\n  }\n  text_mode_createClass(TextMode, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this.props.isTextModeActive) {\n        this.activateTool(this.props);\n      }\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(nextProps) {\n      if (this.tool) {\n        if (nextProps.colorState !== this.props.colorState) {\n          this.tool.setColorState(nextProps.colorState);\n        }\n        if (nextProps.selectedItems !== this.props.selectedItems) {\n          this.tool.onSelectionChanged(nextProps.selectedItems);\n        }\n        if (!nextProps.textEditTarget && this.props.textEditTarget) {\n          this.tool.onTextEditCancelled();\n        }\n        if (!nextProps.viewBounds.equals(this.props.viewBounds)) {\n          this.tool.onViewBoundsChanged(nextProps.viewBounds);\n        }\n        if (nextProps.font !== this.props.font) {\n          this.tool.setFont(nextProps.font);\n        }\n        if (nextProps.rtl !== this.props.rtl) {\n          this.tool.setRtl(nextProps.rtl);\n        }\n      }\n      if (nextProps.isTextModeActive && !this.props.isTextModeActive) {\n        this.activateTool(nextProps);\n      } else if (!nextProps.isTextModeActive && this.props.isTextModeActive) {\n        this.deactivateTool();\n      }\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps) {\n      return nextProps.isTextModeActive !== this.props.isTextModeActive;\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.tool) {\n        this.deactivateTool();\n      }\n    }\n  }, {\n    key: \"activateTool\",\n    value: function activateTool(nextProps) {\n      var selected = selection_getSelectedLeafItems();\n      var textBoxToStartEditing = null;\n      if (selected.length === 1 && selected[0] instanceof paper_full_default.a.PointText) {\n        textBoxToStartEditing = selected[0];\n      }\n      selection_clearSelection(this.props.clearSelectedItems);\n      this.props.clearGradient(); // If fill and stroke color are both mixed/transparent/absent, set fill to default and stroke to transparent.\n      // If exactly one of fill or stroke color is set, set the other one to transparent.\n      // This way the tool won't draw an invisible state, or be unclear about what will be drawn.\n      var strokeWidth = nextProps.colorState.strokeWidth;\n      var fillColor = nextProps.colorState.fillColor.primary;\n      var strokeColor = nextProps.colorState.strokeColor.primary;\n      var fillColorPresent = fillColor !== MIXED && fillColor !== null;\n      var strokeColorPresent = nextProps.isBitmap ? false : strokeColor !== MIXED && strokeColor !== null && strokeWidth !== null && strokeWidth !== 0;\n      if (!fillColorPresent && !strokeColorPresent) {\n        this.props.onChangeFillColor(DEFAULT_COLOR);\n        this.props.onChangeStrokeColor(null);\n      } else if (!fillColorPresent && strokeColorPresent) {\n        this.props.onChangeFillColor(null);\n      } else if (fillColorPresent && !strokeColorPresent) {\n        this.props.onChangeStrokeColor(null);\n      }\n      if (!nextProps.font || Object.keys(fonts).map(function (key) {\n        return fonts[key];\n      }).indexOf(nextProps.font) < 0) {\n        this.props.changeFont(fonts.SANS_SERIF);\n      }\n      this.tool = new text_tool(this.props.textArea, this.props.setSelectedItems, this.props.clearSelectedItems, this.props.setCursor, this.props.onUpdateImage, this.props.setTextEditTarget, this.props.changeFont, nextProps.isBitmap);\n      this.tool.setRtl(this.props.rtl);\n      this.tool.setColorState(nextProps.colorState);\n      this.tool.setFont(nextProps.font);\n      this.tool.activate();\n      if (textBoxToStartEditing) {\n        this.tool.beginTextEdit(textBoxToStartEditing);\n        this.props.textArea.select();\n      }\n    }\n  }, {\n    key: \"deactivateTool\",\n    value: function deactivateTool() {\n      this.tool.deactivateTool();\n      this.tool.remove();\n      this.tool = null;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return this.props.isBitmap ? react_default.a.createElement(bit_text_mode, {\n        isSelected: this.props.isTextModeActive,\n        onMouseDown: this.props.handleChangeModeBitText\n      }) : react_default.a.createElement(text_mode, {\n        isSelected: this.props.isTextModeActive,\n        onMouseDown: this.props.handleChangeModeText\n      });\n    }\n  }]);\n  return TextMode;\n}(react_default.a.Component);\ntext_mode_TextMode.propTypes = {\n  changeFont: prop_types_default.a.func.isRequired,\n  clearGradient: prop_types_default.a.func.isRequired,\n  clearSelectedItems: prop_types_default.a.func.isRequired,\n  colorState: prop_types_default.a.shape({\n    fillColor: color_style_proptype,\n    strokeColor: color_style_proptype,\n    strokeWidth: prop_types_default.a.number\n  }).isRequired,\n  font: prop_types_default.a.string,\n  handleChangeModeBitText: prop_types_default.a.func.isRequired,\n  handleChangeModeText: prop_types_default.a.func.isRequired,\n  isBitmap: prop_types_default.a.bool,\n  isTextModeActive: prop_types_default.a.bool.isRequired,\n  onChangeFillColor: prop_types_default.a.func.isRequired,\n  onChangeStrokeColor: prop_types_default.a.func.isRequired,\n  onUpdateImage: prop_types_default.a.func.isRequired,\n  rtl: prop_types_default.a.bool,\n  selectedItems: prop_types_default.a.arrayOf(prop_types_default.a.instanceOf(paper_full_default.a.Item)),\n  setCursor: prop_types_default.a.func.isRequired,\n  setSelectedItems: prop_types_default.a.func.isRequired,\n  setTextEditTarget: prop_types_default.a.func.isRequired,\n  textArea: prop_types_default.a.instanceOf(Element),\n  textEditTarget: prop_types_default.a.number,\n  viewBounds: prop_types_default.a.instanceOf(paper_full_default.a.Matrix).isRequired\n};\nvar text_mode_mapStateToProps = function mapStateToProps(state, ownProps) {\n  return {\n    colorState: state.scratchPaint.color,\n    font: state.scratchPaint.font,\n    isTextModeActive: ownProps.isBitmap ? state.scratchPaint.mode === Modes.BIT_TEXT : state.scratchPaint.mode === Modes.TEXT,\n    rtl: state.scratchPaint.layout.rtl,\n    selectedItems: state.scratchPaint.selectedItems,\n    textEditTarget: state.scratchPaint.textEditTarget,\n    viewBounds: state.scratchPaint.viewBounds\n  };\n};\nvar text_mode_mapDispatchToProps = function mapDispatchToProps(dispatch, ownProps) {\n  return {\n    changeFont: function changeFont(font) {\n      dispatch(font_changeFont(font));\n    },\n    clearSelectedItems: function clearSelectedItems() {\n      dispatch(selected_items_clearSelectedItems());\n    },\n    clearGradient: function clearGradient() {\n      dispatch(fill_style_clearFillGradient());\n    },\n    handleChangeModeBitText: function handleChangeModeBitText() {\n      dispatch(modes_changeMode(Modes.BIT_TEXT));\n    },\n    handleChangeModeText: function handleChangeModeText() {\n      dispatch(modes_changeMode(Modes.TEXT));\n    },\n    setCursor: function setCursor(cursorString) {\n      dispatch(cursor_setCursor(cursorString));\n    },\n    setSelectedItems: function setSelectedItems() {\n      dispatch(selected_items_setSelectedItems(selection_getSelectedLeafItems(), ownProps.isBitmap));\n    },\n    setTextEditTarget: function setTextEditTarget(targetId) {\n      dispatch(text_edit_target_setTextEditTarget(targetId));\n    },\n    onChangeFillColor: function onChangeFillColor(fillColor) {\n      dispatch(changeFillColor(fillColor));\n    },\n    onChangeStrokeColor: function onChangeStrokeColor(strokeColor) {\n      dispatch(changeStrokeColor(strokeColor));\n    }\n  };\n};\n/* harmony default export */ var containers_text_mode = (Object(es[\"b\" /* connect */])(text_mode_mapStateToProps, text_mode_mapDispatchToProps)(text_mode_TextMode));\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/paint-editor/paint-editor.css\nvar paint_editor = __webpack_require__(25);\nvar paint_editor_default = __webpack_require__.n(paint_editor);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/paint-editor/icons/bitmap.svg\nvar icons_bitmap = __webpack_require__(343);\nvar bitmap_default = __webpack_require__.n(icons_bitmap);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/paint-editor/icons/zoom-in.svg\nvar zoom_in = __webpack_require__(635);\nvar zoom_in_default = __webpack_require__.n(zoom_in);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/paint-editor/icons/zoom-out.svg\nvar zoom_out = __webpack_require__(636);\nvar zoom_out_default = __webpack_require__.n(zoom_out);\n// EXTERNAL MODULE: ./node_modules/scratch-paint/src/components/paint-editor/icons/zoom-reset.svg\nvar zoom_reset = __webpack_require__(637);\nvar zoom_reset_default = __webpack_require__.n(zoom_reset);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/components/paint-editor/paint-editor.jsx\n\n\n\nvar paint_editor_messages = Object(index_es[\"d\" /* defineMessages */])({\n  bitmap: {\n    \"id\": \"paint.paintEditor.bitmap\",\n    \"defaultMessage\": \"Convert to Bitmap\"\n  },\n  vector: {\n    \"id\": \"paint.paintEditor.vector\",\n    \"defaultMessage\": \"Convert to Vector\"\n  }\n});\nvar paint_editor_PaintEditorComponent = function PaintEditorComponent(props) {\n  return react_default.a.createElement(\"div\", {\n    className: paint_editor_default.a.editorContainer,\n    dir: props.rtl ? 'rtl' : 'ltr'\n  }, props.canvas !== null ?\n  \n  // eslint-disable-line no-negated-condition\n  react_default.a.createElement(\"div\", {\n    className: paint_editor_default.a.editorContainerTop\n  }, react_default.a.createElement(\"div\", {\n    className: paint_editor_default.a.row\n  }, react_default.a.createElement(containers_fixed_tools, {\n    canRedo: props.canRedo,\n    canUndo: props.canUndo,\n    name: props.name,\n    onRedo: props.onRedo,\n    onUndo: props.onUndo,\n    onUpdateImage: props.onUpdateImage,\n    onUpdateName: props.onUpdateName\n  })), isVector(props.format) ? react_default.a.createElement(\"div\", {\n    className: paint_editor_default.a.row\n  }, react_default.a.createElement(input_group_input_group, {\n    className: classnames_default()(paint_editor_default.a.row, paint_editor_default.a.modDashedBorder, paint_editor_default.a.modLabeledIconHeight)\n  }, react_default.a.createElement(fill_color_indicator, {\n    className: paint_editor_default.a.modMarginAfter,\n    onUpdateImage: props.onUpdateImage\n  }), react_default.a.createElement(stroke_color_indicator, {\n    onUpdateImage: props.onUpdateImage\n  }), react_default.a.createElement(containers_stroke_width_indicator, {\n    onUpdateImage: props.onUpdateImage\n  })), react_default.a.createElement(input_group_input_group, {\n    className: paint_editor_default.a.modModeTools\n  }, react_default.a.createElement(containers_mode_tools, {\n    onUpdateImage: props.onUpdateImage\n  }))) : format_isBitmap(props.format) ? react_default.a.createElement(\"div\", {\n    className: paint_editor_default.a.row\n  }, react_default.a.createElement(input_group_input_group, {\n    className: classnames_default()(paint_editor_default.a.row, paint_editor_default.a.modDashedBorder, paint_editor_default.a.modLabeledIconHeight)\n  }, react_default.a.createElement(fill_color_indicator, {\n    className: paint_editor_default.a.modMarginAfter,\n    onUpdateImage: props.onUpdateImage\n  })), react_default.a.createElement(input_group_input_group, {\n    className: paint_editor_default.a.modModeTools\n  }, react_default.a.createElement(containers_mode_tools, {\n    onUpdateImage: props.onUpdateImage\n  }))) : null) : null, react_default.a.createElement(\"div\", {\n    className: paint_editor_default.a.topAlignRow\n  }, props.canvas !== null && isVector(props.format) ?\n  \n  // eslint-disable-line no-negated-condition\n  react_default.a.createElement(\"div\", {\n    className: paint_editor_default.a.modeSelector\n  }, react_default.a.createElement(containers_select_mode, {\n    onUpdateImage: props.onUpdateImage\n  }), react_default.a.createElement(containers_reshape_mode, {\n    onUpdateImage: props.onUpdateImage\n  }), react_default.a.createElement(containers_brush_mode, {\n    onUpdateImage: props.onUpdateImage\n  }), react_default.a.createElement(containers_eraser_mode, {\n    onUpdateImage: props.onUpdateImage\n  }), react_default.a.createElement(containers_fill_mode, {\n    onUpdateImage: props.onUpdateImage\n  }), react_default.a.createElement(containers_text_mode, {\n    textArea: props.textArea,\n    onUpdateImage: props.onUpdateImage\n  }), react_default.a.createElement(containers_line_mode, {\n    onUpdateImage: props.onUpdateImage\n  }), react_default.a.createElement(containers_oval_mode, {\n    onUpdateImage: props.onUpdateImage\n  }), react_default.a.createElement(containers_rect_mode, {\n    onUpdateImage: props.onUpdateImage\n  })) : null, props.canvas !== null && format_isBitmap(props.format) ?\n  \n  // eslint-disable-line no-negated-condition\n  react_default.a.createElement(\"div\", {\n    className: paint_editor_default.a.modeSelector\n  }, react_default.a.createElement(containers_bit_brush_mode, {\n    onUpdateImage: props.onUpdateImage\n  }), react_default.a.createElement(containers_bit_line_mode, {\n    onUpdateImage: props.onUpdateImage\n  }), react_default.a.createElement(containers_bit_oval_mode, {\n    onUpdateImage: props.onUpdateImage\n  }), react_default.a.createElement(containers_bit_rect_mode, {\n    onUpdateImage: props.onUpdateImage\n  }), react_default.a.createElement(containers_text_mode, {\n    isBitmap: true,\n    textArea: props.textArea,\n    onUpdateImage: props.onUpdateImage\n  }), react_default.a.createElement(containers_bit_fill_mode, {\n    onUpdateImage: props.onUpdateImage\n  }), react_default.a.createElement(containers_bit_eraser_mode, {\n    onUpdateImage: props.onUpdateImage\n  }), react_default.a.createElement(containers_bit_select_mode, {\n    onUpdateImage: props.onUpdateImage\n  })) : null, react_default.a.createElement(\"div\", {\n    className: paint_editor_default.a.controlsContainer\n  }, react_default.a.createElement(containers_scrollable_canvas, {\n    canvas: props.canvas,\n    hideScrollbars: props.isEyeDropping,\n    style: paint_editor_default.a.canvasContainer\n  }, react_default.a.createElement(containers_paper_canvas, {\n    canvasRef: props.setCanvas,\n    image: props.image,\n    imageFormat: props.imageFormat,\n    imageId: props.imageId,\n    rotationCenterX: props.rotationCenterX,\n    rotationCenterY: props.rotationCenterY,\n    zoomLevelId: props.zoomLevelId,\n    onUpdateImage: props.onUpdateImage\n  }), react_default.a.createElement(\"textarea\", {\n    className: paint_editor_default.a.textArea,\n    ref: props.setTextArea,\n    spellCheck: false\n  }), props.isEyeDropping && props.colorInfo !== null && !props.colorInfo.hideLoupe ? react_default.a.createElement(box[\"a\" /* default */], {\n    className: paint_editor_default.a.colorPickerWrapper\n  }, react_default.a.createElement(loupe_loupe, {\n    colorInfo: props.colorInfo,\n    pixelRatio: paper_full_default.a.project.view.pixelRatio\n  })) : null), react_default.a.createElement(\"div\", {\n    className: paint_editor_default.a.canvasControls\n  }, isVector(props.format) ? react_default.a.createElement(components_button_button, {\n    className: paint_editor_default.a.bitmapButton,\n    onClick: props.onSwitchToBitmap\n  }, react_default.a.createElement(\"img\", {\n    className: paint_editor_default.a.bitmapButtonIcon,\n    draggable: false,\n    src: bitmap_default.a\n  }), react_default.a.createElement(\"span\", {\n    className: paint_editor_default.a.buttonText\n  }, props.intl.formatMessage(paint_editor_messages.bitmap))) : format_isBitmap(props.format) ? react_default.a.createElement(components_button_button, {\n    className: paint_editor_default.a.bitmapButton,\n    onClick: props.onSwitchToVector\n  }, react_default.a.createElement(\"img\", {\n    className: paint_editor_default.a.bitmapButtonIcon,\n    draggable: false,\n    src: bitmap_default.a\n  }), react_default.a.createElement(\"span\", {\n    className: paint_editor_default.a.buttonText\n  }, props.intl.formatMessage(paint_editor_messages.vector))) : null, react_default.a.createElement(input_group_input_group, {\n    className: paint_editor_default.a.zoomControls\n  }, react_default.a.createElement(button_group_button_group, null, react_default.a.createElement(components_button_button, {\n    className: paint_editor_default.a.buttonGroupButton,\n    onClick: props.onZoomOut\n  }, react_default.a.createElement(\"img\", {\n    alt: \"Zoom Out\",\n    className: paint_editor_default.a.buttonGroupButtonIcon,\n    draggable: false,\n    src: zoom_out_default.a\n  })), react_default.a.createElement(components_button_button, {\n    className: paint_editor_default.a.buttonGroupButton,\n    onClick: props.onZoomReset\n  }, react_default.a.createElement(\"img\", {\n    alt: \"Zoom Reset\",\n    className: paint_editor_default.a.buttonGroupButtonIcon,\n    draggable: false,\n    src: zoom_reset_default.a\n  })), react_default.a.createElement(components_button_button, {\n    className: paint_editor_default.a.buttonGroupButton,\n    onClick: props.onZoomIn\n  }, react_default.a.createElement(\"img\", {\n    alt: \"Zoom In\",\n    className: paint_editor_default.a.buttonGroupButtonIcon,\n    draggable: false,\n    src: zoom_in_default.a\n  }))))))));\n};\npaint_editor_PaintEditorComponent.propTypes = {\n  canRedo: prop_types_default.a.func.isRequired,\n  canUndo: prop_types_default.a.func.isRequired,\n  canvas: prop_types_default.a.instanceOf(Element),\n  colorInfo: loupe_loupe.propTypes.colorInfo,\n  format: prop_types_default.a.oneOf(Object.keys(Formats)),\n  image: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.instanceOf(HTMLImageElement)]),\n  imageFormat: prop_types_default.a.string,\n  imageId: prop_types_default.a.string,\n  intl: index_es[\"f\" /* intlShape */],\n  isEyeDropping: prop_types_default.a.bool,\n  name: prop_types_default.a.string,\n  onRedo: prop_types_default.a.func.isRequired,\n  onSwitchToBitmap: prop_types_default.a.func.isRequired,\n  onSwitchToVector: prop_types_default.a.func.isRequired,\n  onUndo: prop_types_default.a.func.isRequired,\n  onUpdateImage: prop_types_default.a.func.isRequired,\n  onUpdateName: prop_types_default.a.func.isRequired,\n  onZoomIn: prop_types_default.a.func.isRequired,\n  onZoomOut: prop_types_default.a.func.isRequired,\n  onZoomReset: prop_types_default.a.func.isRequired,\n  rotationCenterX: prop_types_default.a.number,\n  rotationCenterY: prop_types_default.a.number,\n  rtl: prop_types_default.a.bool,\n  setCanvas: prop_types_default.a.func.isRequired,\n  setTextArea: prop_types_default.a.func.isRequired,\n  textArea: prop_types_default.a.instanceOf(Element),\n  zoomLevelId: prop_types_default.a.string\n};\n/* harmony default export */ var paint_editor_paint_editor = (Object(index_es[\"e\" /* injectIntl */])(paint_editor_PaintEditorComponent));\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/hocs/keyboard-shortcuts-hoc.jsx\nfunction keyboard_shortcuts_hoc_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { keyboard_shortcuts_hoc_typeof = function _typeof(obj) { return typeof obj; }; } else { keyboard_shortcuts_hoc_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return keyboard_shortcuts_hoc_typeof(obj); }\nfunction keyboard_shortcuts_hoc_extends() { keyboard_shortcuts_hoc_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return keyboard_shortcuts_hoc_extends.apply(this, arguments); }\nfunction keyboard_shortcuts_hoc_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction keyboard_shortcuts_hoc_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction keyboard_shortcuts_hoc_createClass(Constructor, protoProps, staticProps) { if (protoProps) keyboard_shortcuts_hoc_defineProperties(Constructor.prototype, protoProps); if (staticProps) keyboard_shortcuts_hoc_defineProperties(Constructor, staticProps); return Constructor; }\nfunction keyboard_shortcuts_hoc_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) keyboard_shortcuts_hoc_setPrototypeOf(subClass, superClass); }\nfunction keyboard_shortcuts_hoc_setPrototypeOf(o, p) { keyboard_shortcuts_hoc_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return keyboard_shortcuts_hoc_setPrototypeOf(o, p); }\nfunction keyboard_shortcuts_hoc_createSuper(Derived) { var hasNativeReflectConstruct = keyboard_shortcuts_hoc_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = keyboard_shortcuts_hoc_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = keyboard_shortcuts_hoc_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return keyboard_shortcuts_hoc_possibleConstructorReturn(this, result); }; }\nfunction keyboard_shortcuts_hoc_possibleConstructorReturn(self, call) { if (call && (keyboard_shortcuts_hoc_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return keyboard_shortcuts_hoc_assertThisInitialized(self); }\nfunction keyboard_shortcuts_hoc_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction keyboard_shortcuts_hoc_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction keyboard_shortcuts_hoc_getPrototypeOf(o) { keyboard_shortcuts_hoc_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return keyboard_shortcuts_hoc_getPrototypeOf(o); }\n\nvar keyboard_shortcuts_hoc_KeyboardShortcutsHOC = function KeyboardShortcutsHOC(WrappedComponent) {\n  var KeyboardShortcutsWrapper = function (_React$Component) {\n    keyboard_shortcuts_hoc_inherits(KeyboardShortcutsWrapper, _React$Component);\n    var _super = keyboard_shortcuts_hoc_createSuper(KeyboardShortcutsWrapper);\n    function KeyboardShortcutsWrapper(props) {\n      var _this;\n      keyboard_shortcuts_hoc_classCallCheck(this, KeyboardShortcutsWrapper);\n      _this = _super.call(this, props);\n      lodash_bindall_default()(keyboard_shortcuts_hoc_assertThisInitialized(_this), ['handleKeyPress', 'changeToASelectMode', 'selectAll']);\n      return _this;\n    }\n    keyboard_shortcuts_hoc_createClass(KeyboardShortcutsWrapper, [{\n      key: \"handleKeyPress\",\n      value: function handleKeyPress(event) {\n        if (event.target instanceof HTMLInputElement) {\n          // Ignore keyboard shortcuts if a text input field is focused\n          return;\n        } // Don't activate keyboard shortcuts during text editing\n        if (this.props.textEditing) return;\n        if (event.key === 'Escape') {\n          event.preventDefault();\n          selection_clearSelection(this.props.clearSelectedItems);\n        } else if (event.key === 'Delete' || event.key === 'Backspace') {\n          event.preventDefault();\n          if (selection_deleteSelection(this.props.mode, this.props.onUpdateImage)) {\n            this.props.setSelectedItems(this.props.format);\n          }\n        } else if (event.metaKey || event.ctrlKey) {\n          if (event.shiftKey && event.key.toLowerCase() === 'z') {\n            this.props.onRedo();\n          } else if (event.key === 'z') {\n            this.props.onUndo();\n          } else if (event.shiftKey && event.key.toLowerCase() === 'g') {\n            if (group_shouldShowUngroup()) {\n              group_ungroupSelection(selected_items_clearSelectedItems, selected_items_setSelectedItems, this.props.onUpdateImage);\n            }\n            event.preventDefault();\n          } else if (event.key === 'g') {\n            if (group_shouldShowGroup()) {\n              group_groupSelection(selected_items_clearSelectedItems, selected_items_setSelectedItems, this.props.onUpdateImage);\n            }\n            event.preventDefault();\n          } else if (event.key === 'c') {\n            this.props.onCopyToClipboard();\n          } else if (event.key === 'v') {\n            this.changeToASelectMode();\n            this.props.onPasteFromClipboard();\n          } else if (event.key === 'x') {\n            var selectedItems = selection_getSelectedRootItems();\n            if (selectedItems.length > 0) {\n              this.props.onCopyToClipboard();\n              if (selection_deleteSelection(this.props.mode, this.props.onUpdateImage)) {\n                this.props.setSelectedItems(this.props.format);\n              }\n            }\n            event.preventDefault();\n          } else if (event.key === 'a') {\n            this.changeToASelectMode();\n            event.preventDefault();\n            this.selectAll();\n          }\n        }\n      }\n    }, {\n      key: \"changeToASelectMode\",\n      value: function changeToASelectMode() {\n        if (format_isBitmap(this.props.format)) {\n          if (this.props.mode !== Modes.BIT_SELECT) {\n            this.props.changeMode(Modes.BIT_SELECT);\n          }\n        } else if (this.props.mode !== Modes.SELECT && this.props.mode !== Modes.RESHAPE) {\n          this.props.changeMode(Modes.SELECT);\n        }\n      }\n    }, {\n      key: \"selectAll\",\n      value: function selectAll() {\n        if (format_isBitmap(this.props.format)) {\n          bitmap_selectAllBitmap(this.props.clearSelectedItems);\n          this.props.setSelectedItems(this.props.format);\n        } else if (this.props.mode === Modes.RESHAPE) {\n          if (selectAllSegments()) this.props.setSelectedItems(this.props.format);\n        } else if (selectAllItems()) {\n          this.props.setSelectedItems(this.props.format);\n        }\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var componentProps = lodash_omit_default()(this.props, ['changeMode', 'clearSelectedItems', 'format', 'mode', 'onCopyToClipboard', 'onPasteFromClipboard', 'setSelectedItems', 'textEditing']);\n        return react_default.a.createElement(WrappedComponent, keyboard_shortcuts_hoc_extends({\n          onKeyPress: this.handleKeyPress\n        }, componentProps));\n      }\n    }]);\n    return KeyboardShortcutsWrapper;\n  }(react_default.a.Component);\n  KeyboardShortcutsWrapper.propTypes = {\n    changeMode: prop_types_default.a.func.isRequired,\n    clearSelectedItems: prop_types_default.a.func.isRequired,\n    format: prop_types_default.a.oneOf(Object.keys(Formats)),\n    mode: prop_types_default.a.oneOf(Object.keys(Modes)).isRequired,\n    onCopyToClipboard: prop_types_default.a.func.isRequired,\n    onPasteFromClipboard: prop_types_default.a.func.isRequired,\n    onRedo: prop_types_default.a.func.isRequired,\n    onUndo: prop_types_default.a.func.isRequired,\n    onUpdateImage: prop_types_default.a.func.isRequired,\n    setSelectedItems: prop_types_default.a.func.isRequired,\n    textEditing: prop_types_default.a.bool.isRequired\n  };\n  var mapStateToProps = function mapStateToProps(state) {\n    return {\n      mode: state.scratchPaint.mode,\n      format: state.scratchPaint.format,\n      textEditing: state.scratchPaint.textEditTarget !== null\n    };\n  };\n  var mapDispatchToProps = function mapDispatchToProps(dispatch) {\n    return {\n      changeMode: function changeMode(mode) {\n        dispatch(modes_changeMode(mode));\n      },\n      clearSelectedItems: function clearSelectedItems() {\n        dispatch(selected_items_clearSelectedItems());\n      },\n      setSelectedItems: function setSelectedItems(format) {\n        dispatch(selected_items_setSelectedItems(selection_getSelectedLeafItems(), format_isBitmap(format)));\n      }\n    };\n  };\n  return copy_paste_hoc(Object(es[\"b\" /* connect */])(mapStateToProps, mapDispatchToProps)(KeyboardShortcutsWrapper));\n};\n/* harmony default export */ var keyboard_shortcuts_hoc = (keyboard_shortcuts_hoc_KeyboardShortcutsHOC);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/hocs/selection-hoc.jsx\nfunction selection_hoc_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { selection_hoc_typeof = function _typeof(obj) { return typeof obj; }; } else { selection_hoc_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return selection_hoc_typeof(obj); }\nfunction selection_hoc_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = selection_hoc_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction selection_hoc_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\nfunction selection_hoc_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction selection_hoc_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction selection_hoc_createClass(Constructor, protoProps, staticProps) { if (protoProps) selection_hoc_defineProperties(Constructor.prototype, protoProps); if (staticProps) selection_hoc_defineProperties(Constructor, staticProps); return Constructor; }\nfunction selection_hoc_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) selection_hoc_setPrototypeOf(subClass, superClass); }\nfunction selection_hoc_setPrototypeOf(o, p) { selection_hoc_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return selection_hoc_setPrototypeOf(o, p); }\nfunction selection_hoc_createSuper(Derived) { var hasNativeReflectConstruct = selection_hoc_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = selection_hoc_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = selection_hoc_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return selection_hoc_possibleConstructorReturn(this, result); }; }\nfunction selection_hoc_possibleConstructorReturn(self, call) { if (call && (selection_hoc_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return selection_hoc_assertThisInitialized(self); }\nfunction selection_hoc_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction selection_hoc_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction selection_hoc_getPrototypeOf(o) { selection_hoc_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return selection_hoc_getPrototypeOf(o); }\n\nvar selection_hoc_SelectionHOC = function SelectionHOC(WrappedComponent) {\n  var SelectionComponent = function (_React$Component) {\n    selection_hoc_inherits(SelectionComponent, _React$Component);\n    var _super = selection_hoc_createSuper(SelectionComponent);\n    function SelectionComponent(props) {\n      var _this;\n      selection_hoc_classCallCheck(this, SelectionComponent);\n      _this = _super.call(this, props);\n      lodash_bindall_default()(selection_hoc_assertThisInitialized(_this), ['removeItemById']);\n      return _this;\n    }\n    selection_hoc_createClass(SelectionComponent, [{\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate(prevProps) {\n        // Hovered item has changed\n        if (this.props.hoveredItemId && this.props.hoveredItemId !== prevProps.hoveredItemId || !this.props.hoveredItemId && prevProps.hoveredItemId) {\n          // Remove the old hover item if any\n          this.removeItemById(prevProps.hoveredItemId);\n        }\n      }\n    }, {\n      key: \"removeItemById\",\n      value: function removeItemById(itemId) {\n        if (itemId) {\n          var match = paper_full_default.a.project.getItem({\n            match: function match(item) {\n              return item.id === itemId;\n            }\n          });\n          if (match) {\n            match.remove();\n          }\n        }\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var _this$props = this.props,\n            hoveredItemId = _this$props.hoveredItemId,\n            props = selection_hoc_objectWithoutProperties(_this$props, [\"hoveredItemId\"]);\n        return react_default.a.createElement(WrappedComponent, props);\n      }\n    }]);\n    return SelectionComponent;\n  }(react_default.a.Component);\n  SelectionComponent.propTypes = {\n    hoveredItemId: prop_types_default.a.number\n  };\n  var mapStateToProps = function mapStateToProps(state) {\n    return {\n      hoveredItemId: state.scratchPaint.hoveredItemId\n    };\n  };\n  return Object(es[\"b\" /* connect */])(mapStateToProps)(SelectionComponent);\n};\n/* harmony default export */ var selection_hoc = (selection_hoc_SelectionHOC);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/hocs/undo-hoc.jsx\nfunction undo_hoc_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { undo_hoc_typeof = function _typeof(obj) { return typeof obj; }; } else { undo_hoc_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return undo_hoc_typeof(obj); }\nfunction undo_hoc_extends() { undo_hoc_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return undo_hoc_extends.apply(this, arguments); }\nfunction undo_hoc_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction undo_hoc_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction undo_hoc_createClass(Constructor, protoProps, staticProps) { if (protoProps) undo_hoc_defineProperties(Constructor.prototype, protoProps); if (staticProps) undo_hoc_defineProperties(Constructor, staticProps); return Constructor; }\nfunction undo_hoc_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) undo_hoc_setPrototypeOf(subClass, superClass); }\nfunction undo_hoc_setPrototypeOf(o, p) { undo_hoc_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return undo_hoc_setPrototypeOf(o, p); }\nfunction undo_hoc_createSuper(Derived) { var hasNativeReflectConstruct = undo_hoc_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = undo_hoc_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = undo_hoc_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return undo_hoc_possibleConstructorReturn(this, result); }; }\nfunction undo_hoc_possibleConstructorReturn(self, call) { if (call && (undo_hoc_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return undo_hoc_assertThisInitialized(self); }\nfunction undo_hoc_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction undo_hoc_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction undo_hoc_getPrototypeOf(o) { undo_hoc_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return undo_hoc_getPrototypeOf(o); }\n\nvar undo_hoc_UndoHOC = function UndoHOC(WrappedComponent) {\n  var UndoWrapper = function (_React$Component) {\n    undo_hoc_inherits(UndoWrapper, _React$Component);\n    var _super = undo_hoc_createSuper(UndoWrapper);\n    function UndoWrapper(props) {\n      var _this;\n      undo_hoc_classCallCheck(this, UndoWrapper);\n      _this = _super.call(this, props);\n      lodash_bindall_default()(undo_hoc_assertThisInitialized(_this), ['handleUndo', 'handleRedo', 'handleSetSelectedItems', 'shouldShowUndo', 'shouldShowRedo']);\n      return _this;\n    }\n    undo_hoc_createClass(UndoWrapper, [{\n      key: \"handleUndo\",\n      value: function handleUndo() {\n        undo_performUndo(this.props.undoState, this.props.onUndo, this.handleSetSelectedItems, this.props.onUpdateImage);\n      }\n    }, {\n      key: \"handleRedo\",\n      value: function handleRedo() {\n        undo_performRedo(this.props.undoState, this.props.onRedo, this.handleSetSelectedItems, this.props.onUpdateImage);\n      }\n    }, {\n      key: \"handleSetSelectedItems\",\n      value: function handleSetSelectedItems() {\n        this.props.setSelectedItems(this.props.format);\n      }\n    }, {\n      key: \"shouldShowUndo\",\n      value: function shouldShowUndo() {\n        if(this.props.undoState.pointer>0)\n          scratchStatus(\"BACKUPNEEDED\");\n        return undo_shouldShowUndo(this.props.undoState);\n      }\n    }, {\n      key: \"shouldShowRedo\",\n      value: function shouldShowRedo() {\n        return undo_shouldShowRedo(this.props.undoState);\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var componentProps = lodash_omit_default()(this.props, ['format', 'onUndo', 'onRedo', 'setSelectedItems', 'undoState']);\n        return react_default.a.createElement(WrappedComponent, undo_hoc_extends({\n          shouldShowRedo: this.shouldShowRedo,\n          shouldShowUndo: this.shouldShowUndo,\n          onRedo: this.handleRedo,\n          onUndo: this.handleUndo\n        }, componentProps));\n      }\n    }]);\n    return UndoWrapper;\n  }(react_default.a.Component);\n  UndoWrapper.propTypes = {\n    format: prop_types_default.a.oneOf(Object.keys(Formats)),\n    onRedo: prop_types_default.a.func.isRequired,\n    onUndo: prop_types_default.a.func.isRequired,\n    onUpdateImage: prop_types_default.a.func.isRequired,\n    setSelectedItems: prop_types_default.a.func.isRequired,\n    undoState: prop_types_default.a.shape({\n      stack: prop_types_default.a.arrayOf(prop_types_default.a.object).isRequired,\n      pointer: prop_types_default.a.number.isRequired\n    })\n  };\n  var mapStateToProps = function mapStateToProps(state) {\n    return {\n      format: state.scratchPaint.format,\n      undoState: state.scratchPaint.undo\n    };\n  };\n  var mapDispatchToProps = function mapDispatchToProps(dispatch) {\n    return {\n      setSelectedItems: function setSelectedItems(format) {\n        dispatch(selected_items_setSelectedItems(selection_getSelectedLeafItems(), format_isBitmap(format)));\n      },\n      onUndo: function onUndo(format) {\n        dispatch(undo(format));\n      },\n      onRedo: function onRedo(format) {\n        dispatch(redo(format));\n      }\n    };\n  };\n  return Object(es[\"b\" /* connect */])(mapStateToProps, mapDispatchToProps)(UndoWrapper);\n};\n/* harmony default export */ var undo_hoc = (undo_hoc_UndoHOC);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/hocs/update-image-hoc.jsx\nfunction update_image_hoc_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { update_image_hoc_typeof = function _typeof(obj) { return typeof obj; }; } else { update_image_hoc_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return update_image_hoc_typeof(obj); }\nfunction update_image_hoc_extends() { update_image_hoc_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return update_image_hoc_extends.apply(this, arguments); }\nfunction update_image_hoc_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = update_image_hoc_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction update_image_hoc_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return update_image_hoc_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return update_image_hoc_arrayLikeToArray(o, minLen); }\nfunction update_image_hoc_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction update_image_hoc_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction update_image_hoc_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction update_image_hoc_createClass(Constructor, protoProps, staticProps) { if (protoProps) update_image_hoc_defineProperties(Constructor.prototype, protoProps); if (staticProps) update_image_hoc_defineProperties(Constructor, staticProps); return Constructor; }\nfunction update_image_hoc_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) update_image_hoc_setPrototypeOf(subClass, superClass); }\nfunction update_image_hoc_setPrototypeOf(o, p) { update_image_hoc_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return update_image_hoc_setPrototypeOf(o, p); }\nfunction update_image_hoc_createSuper(Derived) { var hasNativeReflectConstruct = update_image_hoc_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = update_image_hoc_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = update_image_hoc_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return update_image_hoc_possibleConstructorReturn(this, result); }; }\nfunction update_image_hoc_possibleConstructorReturn(self, call) { if (call && (update_image_hoc_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return update_image_hoc_assertThisInitialized(self); }\nfunction update_image_hoc_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction update_image_hoc_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction update_image_hoc_getPrototypeOf(o) { update_image_hoc_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return update_image_hoc_getPrototypeOf(o); }\n\nvar update_image_hoc_UpdateImageHOC = function UpdateImageHOC(WrappedComponent) {\n  var UpdateImageWrapper = function (_React$Component) {\n    update_image_hoc_inherits(UpdateImageWrapper, _React$Component);\n    var _super = update_image_hoc_createSuper(UpdateImageWrapper);\n    function UpdateImageWrapper(props) {\n      var _this;\n      update_image_hoc_classCallCheck(this, UpdateImageWrapper);\n      _this = _super.call(this, props);\n      lodash_bindall_default()(update_image_hoc_assertThisInitialized(_this), ['handleUpdateImage', 'handleUpdateBitmap', 'handleUpdateVector']);\n      return _this;\n    }\n    /**\n     * @param {?boolean} skipSnapshot True if the call to update image should not trigger saving\n     * an undo state. For instance after calling undo.\n     * @param {?Formats} formatOverride Normally the mode is used to determine the format of the image,\n     * but the format used can be overridden here. In particular when converting between formats,\n     * the does not accurately represent the format.\n     */\n    update_image_hoc_createClass(UpdateImageWrapper, [{\n      key: \"handleUpdateImage\",\n      value: function handleUpdateImage(skipSnapshot, formatOverride) {\n        // If in the middle of switching formats, rely on the current mode instead of format.\n        var actualFormat = formatOverride ? formatOverride : BitmapModes[this.props.mode] ? Formats.BITMAP : Formats.VECTOR;\n        if (format_isBitmap(actualFormat)) {\n          this.handleUpdateBitmap(skipSnapshot);\n        } else if (isVector(actualFormat)) {\n          this.handleUpdateVector(skipSnapshot);\n        } // Any time an image update is made, recalculate the bounds of the artwork\n        view_setWorkspaceBounds();\n        this.props.updateViewBounds(paper_full_default.a.view.matrix);\n      }\n    }, {\n      key: \"handleUpdateBitmap\",\n      value: function handleUpdateBitmap(skipSnapshot) {\n        if (!getRaster().loaded) {\n          // In general, callers of updateImage should wait for getRaster().loaded = true before\n          // calling updateImage.\n          // However, this may happen if the user is rapidly undoing/redoing. In this case it's safe\n          // to skip the update.\n          log.warn('Bitmap layer should be loaded before calling updateImage.');\n          return;\n        } // Anything that is selected is on the vector layer waiting to be committed to the bitmap layer.\n        // Plaster the selection onto the raster layer before exporting, if there is a selection.\n        var plasteredRaster = getRaster().getSubRaster(getRaster().bounds); // Clone the raster layer\n        plasteredRaster.remove(); // Don't insert\n        var selectedItems = selection_getSelectedLeafItems();\n        if (selectedItems.length === 1) {\n          var item = selectedItems[0];\n          if (item instanceof paper_full_default.a.Raster) {\n            if (!item.loaded || item.data && item.data.expanded && !item.data.expanded.loaded) {\n              // This may get logged when rapidly undoing/redoing or changing costumes,\n              // in which case the warning is not relevant.\n              log.warn('Bitmap layer should be loaded before calling updateImage.');\n              return;\n            }\n            commitSelectionToBitmap(item, plasteredRaster);\n          } else if (item instanceof paper_full_default.a.Shape && item.type === 'rectangle') {\n            bitmap_commitRectToBitmap(item, plasteredRaster);\n          } else if (item instanceof paper_full_default.a.Shape && item.type === 'ellipse') {\n            bitmap_commitOvalToBitmap(item, plasteredRaster);\n          } else if (item instanceof paper_full_default.a.PointText) {\n            var bounds = item.drawnBounds;\n            var textRaster = item.rasterize(72, false\n            /* insert */\n            , bounds);\n            plasteredRaster.drawImage(textRaster.canvas, new paper_full_default.a.Point(Math.floor(bounds.x), Math.floor(bounds.y)));\n          }\n        }\n        var rect = bitmap_getHitBounds(plasteredRaster); // Use 1x1 instead of 0x0 for getting imageData since paper.js automagically\n        // returns the full artboard in the case of getImageData(0x0).\n        // Bitmaps need a non-zero width/height in order to be saved as PNG.\n        if (rect.width === 0 || rect.height === 0) {\n          rect.width = rect.height = 1;\n        }\n        var imageData = plasteredRaster.getImageData(rect);\n        this.props.onUpdateImage(false\n        /* isVector */\n        , imageData, ART_BOARD_WIDTH / 2 - rect.x, ART_BOARD_HEIGHT / 2 - rect.y);\n        if (!skipSnapshot) {\n          undo_performSnapshot(this.props.undoSnapshot, Formats.BITMAP);\n        }\n      }\n    }, {\n      key: \"handleUpdateVector\",\n      value: function handleUpdateVector(skipSnapshot) {\n        // Remove viewbox (this would make it export at MAX_WORKSPACE_BOUNDS)\n        var workspaceMask;\n        if (paper_full_default.a.project.activeLayer.clipped) {\n          var _iterator = update_image_hoc_createForOfIteratorHelper(paper_full_default.a.project.activeLayer.children),\n              _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var child = _step.value;\n              if (child.isClipMask()) {\n                workspaceMask = child;\n                break;\n              }\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n          paper_full_default.a.project.activeLayer.clipped = false;\n          workspaceMask.remove();\n        }\n        var guideLayers = hideGuideLayers(true\n        /* includeRaster */\n        ); // Export at 0.5x\n        math_scaleWithStrokes(paper_full_default.a.project.activeLayer, .5, new paper_full_default.a.Point());\n        var bounds = paper_full_default.a.project.activeLayer.drawnBounds; // `bounds.x` and `bounds.y` are relative to the top left corner,\n        // but if there is no content in the active layer, they default to 0,\n        // making the \"Scratch space\" rotation center ((SVG_ART_BOARD_WIDTH / 2), (SVG_ART_BOARD_HEIGHT / 2)),\n        // aka the upper left corner. Special-case this to be (0, 0), which is the center of the art board.\n        var centerX = bounds.width === 0 ? 0 : SVG_ART_BOARD_WIDTH / 2 - bounds.x;\n        var centerY = bounds.height === 0 ? 0 : SVG_ART_BOARD_HEIGHT / 2 - bounds.y;\n        this.props.onUpdateImage(true\n        /* isVector */\n        , paper_full_default.a.project.exportSVG({\n          asString: true,\n          bounds: 'content',\n          matrix: new paper_full_default.a.Matrix().translate(-bounds.x, -bounds.y)\n        }), centerX, centerY);\n        math_scaleWithStrokes(paper_full_default.a.project.activeLayer, 2, new paper_full_default.a.Point());\n        paper_full_default.a.project.activeLayer.applyMatrix = true;\n        layer_showGuideLayers(guideLayers); // Add back viewbox\n        if (workspaceMask) {\n          paper_full_default.a.project.activeLayer.addChild(workspaceMask);\n          workspaceMask.clipMask = true;\n        }\n        if (!skipSnapshot) {\n          undo_performSnapshot(this.props.undoSnapshot, Formats.VECTOR);\n        }\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var componentProps = lodash_omit_default()(this.props, ['format', 'onUpdateImage', 'undoSnapshot']);\n        return react_default.a.createElement(WrappedComponent, update_image_hoc_extends({\n          onUpdateImage: this.handleUpdateImage\n        }, componentProps));\n      }\n    }]);\n    return UpdateImageWrapper;\n  }(react_default.a.Component);\n  UpdateImageWrapper.propTypes = {\n    format: prop_types_default.a.oneOf(Object.keys(Formats)),\n    mode: prop_types_default.a.oneOf(Object.keys(Modes)).isRequired,\n    onUpdateImage: prop_types_default.a.func.isRequired,\n    undoSnapshot: prop_types_default.a.func.isRequired,\n    updateViewBounds: prop_types_default.a.func.isRequired\n  };\n  var mapStateToProps = function mapStateToProps(state) {\n    return {\n      format: state.scratchPaint.format,\n      mode: state.scratchPaint.mode,\n      undoState: state.scratchPaint.undo\n    };\n  };\n  var mapDispatchToProps = function mapDispatchToProps(dispatch) {\n    return {\n      setSelectedItems: function setSelectedItems(format) {\n        dispatch(selected_items_setSelectedItems(selection_getSelectedLeafItems(), format_isBitmap(format)));\n      },\n      undoSnapshot: function undoSnapshot(snapshot) {\n        dispatch(undo_undoSnapshot(snapshot));\n      },\n      updateViewBounds: function updateViewBounds(matrix) {\n        dispatch(view_bounds_updateViewBounds(matrix));\n      }\n    };\n  };\n  return Object(es[\"b\" /* connect */])(mapStateToProps, mapDispatchToProps)(UpdateImageWrapper);\n};\n/* harmony default export */ var update_image_hoc = (update_image_hoc_UpdateImageHOC);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/containers/paint-editor.jsx\nfunction paint_editor_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { paint_editor_typeof = function _typeof(obj) { return typeof obj; }; } else { paint_editor_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return paint_editor_typeof(obj); }\nfunction paint_editor_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction paint_editor_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction paint_editor_createClass(Constructor, protoProps, staticProps) { if (protoProps) paint_editor_defineProperties(Constructor.prototype, protoProps); if (staticProps) paint_editor_defineProperties(Constructor, staticProps); return Constructor; }\nfunction paint_editor_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) paint_editor_setPrototypeOf(subClass, superClass); }\nfunction paint_editor_setPrototypeOf(o, p) { paint_editor_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return paint_editor_setPrototypeOf(o, p); }\nfunction paint_editor_createSuper(Derived) { var hasNativeReflectConstruct = paint_editor_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = paint_editor_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = paint_editor_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return paint_editor_possibleConstructorReturn(this, result); }; }\nfunction paint_editor_possibleConstructorReturn(self, call) { if (call && (paint_editor_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return paint_editor_assertThisInitialized(self); }\nfunction paint_editor_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction paint_editor_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction paint_editor_getPrototypeOf(o) { paint_editor_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return paint_editor_getPrototypeOf(o); }\n\n\n/**\n * The top-level paint editor component. See README for more details on usage.\n *\n * <PaintEditor\n *     image={optionalImage}\n *     imageId={optionalId}\n *     imageFormat='svg'\n *     rotationCenterX={optionalCenterPointX}\n *     rotationCenterY={optionalCenterPointY}\n *     rtl={true|false}\n *     onUpdateImage={handleUpdateImageFunction}\n *     zoomLevelId={optionalZoomLevelId}\n * />\n *\n * `image`: may either be nothing, an SVG string or a base64 data URI)\n * SVGs of up to size 480 x 360 will fit into the view window of the paint editor,\n * while bitmaps of size up to 960 x 720 will fit into the paint editor. One unit\n * of an SVG will appear twice as tall and wide as one unit of a bitmap. This quirky\n * import behavior comes from needing to support legacy projects in Scratch.\n *\n * `imageId`: If this parameter changes, then the paint editor will be cleared, the\n * undo stack reset, and the image re-imported.\n *\n * `imageFormat`: 'svg', 'png', or 'jpg'. Other formats are currently not supported.\n *\n * `rotationCenterX`: x coordinate relative to the top left corner of the sprite of\n * the point that should be centered.\n *\n * `rotationCenterY`: y coordinate relative to the top left corner of the sprite of\n * the point that should be centered.\n *\n * `rtl`: True if the paint editor should be laid out right to left (meant for right\n * to left languages)\n *\n * `onUpdateImage`: A handler called with the new image (either an SVG string or an\n * ImageData) each time the drawing is edited.\n *\n * `zoomLevelId`: All costumes with the same zoom level ID will share the same saved\n * zoom level. When a new zoom level ID is encountered, the paint editor will zoom to\n * fit the current costume comfortably. Leave undefined to perform no zoom to fit.\n */\nvar paint_editor_PaintEditor = function (_React$Component) {\n  paint_editor_inherits(PaintEditor, _React$Component);\n  var _super = paint_editor_createSuper(PaintEditor);\n  paint_editor_createClass(PaintEditor, null, [{\n    key: \"ZOOM_INCREMENT\",\n    get: function get() {\n      return 0.5;\n    }\n  }]);\n  function PaintEditor(props) {\n    var _this;\n    paint_editor_classCallCheck(this, PaintEditor);\n    _this = _super.call(this, props);\n    lodash_bindall_default()(paint_editor_assertThisInitialized(_this), ['switchModeForFormat', 'onMouseDown', 'onMouseUp', 'setCanvas', 'setTextArea', 'startEyeDroppingLoop', 'stopEyeDroppingLoop', 'handleSetSelectedItems', 'handleZoomIn', 'handleZoomOut', 'handleZoomReset']);\n    _this.state = {\n      canvas: null,\n      colorInfo: null\n    };\n    _this.props.setLayout(_this.props.rtl ? 'rtl' : 'ltr');\n    return _this;\n  }\n  paint_editor_createClass(PaintEditor, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      document.addEventListener('keydown', this.props.onKeyPress); // document listeners used to detect if a mouse is down outside of the\n      // canvas, and should therefore stop the eye dropper\n      document.addEventListener('mousedown', this.onMouseDown);\n      document.addEventListener('touchstart', this.onMouseDown,{passive:false});\n      document.addEventListener('mouseup', this.onMouseUp);\n      document.addEventListener('touchend', this.onMouseUp);\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(newProps) {\n      if (!format_isBitmap(this.props.format) && format_isBitmap(newProps.format)) {\n        this.switchModeForFormat(Formats.BITMAP);\n      } else if (!isVector(this.props.format) && isVector(newProps.format)) {\n        this.switchModeForFormat(Formats.VECTOR);\n      }\n      if (newProps.rtl !== this.props.rtl) {\n        this.props.setLayout(newProps.rtl ? 'rtl' : 'ltr');\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      if (this.props.isEyeDropping && !prevProps.isEyeDropping) {\n        this.startEyeDroppingLoop();\n      } else if (!this.props.isEyeDropping && prevProps.isEyeDropping) {\n        this.stopEyeDroppingLoop();\n      } else if (this.props.isEyeDropping && this.props.viewBounds !== prevProps.viewBounds) {\n        if (this.props.previousTool) this.props.previousTool.activate();\n        this.props.onDeactivateEyeDropper();\n        this.stopEyeDroppingLoop();\n      }\n      if (this.props.format === Formats.VECTOR && format_isBitmap(prevProps.format)) {\n        bitmap_convertToVector(this.props.clearSelectedItems, this.props.onUpdateImage);\n      } else if (isVector(prevProps.format) && this.props.format === Formats.BITMAP) {\n        bitmap_convertToBitmap(this.props.clearSelectedItems, this.props.onUpdateImage, this.props.fontInlineFn);\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      document.removeEventListener('keydown', this.props.onKeyPress);\n      this.stopEyeDroppingLoop();\n      document.removeEventListener('mousedown', this.onMouseDown);\n      document.removeEventListener('touchstart', this.onMouseDown);\n      document.removeEventListener('mouseup', this.onMouseUp);\n      document.removeEventListener('touchend', this.onMouseUp);\n    }\n  }, {\n    key: \"switchModeForFormat\",\n    value: function switchModeForFormat(newFormat) {\n      if (isVector(newFormat) && this.props.mode in VectorModes || format_isBitmap(newFormat) && this.props.mode in BitmapModes) {\n        // Format didn't change; no mode change needed\n        return;\n      }\n      if (isVector(newFormat)) {\n        switch (this.props.mode) {\n          case Modes.BIT_BRUSH:\n            this.props.changeMode(Modes.BRUSH);\n            break;\n          case Modes.BIT_LINE:\n            this.props.changeMode(Modes.LINE);\n            break;\n          case Modes.BIT_OVAL:\n            this.props.changeMode(Modes.OVAL);\n            break;\n          case Modes.BIT_RECT:\n            this.props.changeMode(Modes.RECT);\n            break;\n          case Modes.BIT_TEXT:\n            this.props.changeMode(Modes.TEXT);\n            break;\n          case Modes.BIT_FILL:\n            this.props.changeMode(Modes.FILL);\n            break;\n          case Modes.BIT_ERASER:\n            this.props.changeMode(Modes.ERASER);\n            break;\n          case Modes.BIT_SELECT:\n            this.props.changeMode(Modes.SELECT);\n            break;\n          default:\n            log.error(\"Mode not handled: \".concat(this.props.mode));\n            this.props.changeMode(Modes.BRUSH);\n        }\n      } else if (format_isBitmap(newFormat)) {\n        switch (this.props.mode) {\n          case Modes.BRUSH:\n            this.props.changeMode(Modes.BIT_BRUSH);\n            break;\n          case Modes.LINE:\n            this.props.changeMode(Modes.BIT_LINE);\n            break;\n          case Modes.OVAL:\n            this.props.changeMode(Modes.BIT_OVAL);\n            break;\n          case Modes.RECT:\n            this.props.changeMode(Modes.BIT_RECT);\n            break;\n          case Modes.TEXT:\n            this.props.changeMode(Modes.BIT_TEXT);\n            break;\n          case Modes.FILL:\n            this.props.changeMode(Modes.BIT_FILL);\n            break;\n          case Modes.ERASER:\n            this.props.changeMode(Modes.BIT_ERASER);\n            break;\n          case Modes.RESHAPE:\n          /* falls through */\n          case Modes.SELECT:\n            this.props.changeMode(Modes.BIT_SELECT);\n            break;\n          default:\n            log.error(\"Mode not handled: \".concat(this.props.mode));\n            this.props.changeMode(Modes.BIT_BRUSH);\n        }\n      }\n    }\n  }, {\n    key: \"handleZoomIn\",\n    value: function handleZoomIn() {\n      // Make the \"next step\" after the outermost zoom level be the default\n      // zoom level (0.5)\n      var zoomIncrement = PaintEditor.ZOOM_INCREMENT;\n      if (paper_full_default.a.view.zoom === OUTERMOST_ZOOM_LEVEL) {\n        zoomIncrement = 0.5 - OUTERMOST_ZOOM_LEVEL;\n      }\n      view_zoomOnSelection(zoomIncrement);\n      this.props.updateViewBounds(paper_full_default.a.view.matrix);\n      this.handleSetSelectedItems();\n    }\n  }, {\n    key: \"handleZoomOut\",\n    value: function handleZoomOut() {\n      view_zoomOnSelection(-PaintEditor.ZOOM_INCREMENT);\n      this.props.updateViewBounds(paper_full_default.a.view.matrix);\n      this.handleSetSelectedItems();\n    }\n  }, {\n    key: \"handleZoomReset\",\n    value: function handleZoomReset() {\n      view_resetZoom();\n      this.props.updateViewBounds(paper_full_default.a.view.matrix);\n      this.handleSetSelectedItems();\n    }\n  }, {\n    key: \"handleSetSelectedItems\",\n    value: function handleSetSelectedItems() {\n      this.props.setSelectedItems(this.props.format);\n    }\n  }, {\n    key: \"setCanvas\",\n    value: function setCanvas(canvas) {\n      this.setState({\n        canvas: canvas\n      });\n      this.canvas = canvas;\n    }\n  }, {\n    key: \"setTextArea\",\n    value: function setTextArea(element) {\n      this.setState({\n        textArea: element\n      });\n    }\n  }, {\n    key: \"onMouseDown\",\n    value: function onMouseDown(event) {\n      if (event.target === paper_full_default.a.view.element && document.activeElement instanceof HTMLInputElement) {\n        document.activeElement.blur();\n      }\n      if (event.target !== paper_full_default.a.view.element && event.target !== this.state.textArea) {\n        // Exit text edit mode if you click anywhere outside of canvas\n        this.props.removeTextEditTarget();\n      }\n    }\n  }, {\n    key: \"onMouseUp\",\n    value: function onMouseUp() {\n      if (this.props.isEyeDropping) {\n        var colorString = this.eyeDropper.colorString;\n        var callback = this.props.changeColorToEyeDropper;\n        this.eyeDropper.remove();\n        if (!this.eyeDropper.hideLoupe) {\n          // If not hide loupe, that means the click is inside the canvas,\n          // so apply the new color\n          callback(colorString);\n        }\n        if (this.props.previousTool) this.props.previousTool.activate();\n        this.props.onDeactivateEyeDropper();\n        this.stopEyeDroppingLoop();\n      }\n    }\n  }, {\n    key: \"startEyeDroppingLoop\",\n    value: function startEyeDroppingLoop() {\n      var _this2 = this;\n      this.eyeDropper = new eye_dropper_EyeDropperTool(this.canvas, paper_full_default.a.project.view.bounds.width, paper_full_default.a.project.view.bounds.height, paper_full_default.a.project.view.pixelRatio, paper_full_default.a.view.zoom, paper_full_default.a.project.view.bounds.x, paper_full_default.a.project.view.bounds.y, format_isBitmap(this.props.format));\n      this.eyeDropper.pickX = -1;\n      this.eyeDropper.pickY = -1;\n      this.eyeDropper.activate();\n      this.intervalId = setInterval(function () {\n        var colorInfo = _this2.eyeDropper.getColorInfo(_this2.eyeDropper.pickX, _this2.eyeDropper.pickY, _this2.eyeDropper.hideLoupe);\n        if (!colorInfo) return;\n        if (_this2.state.colorInfo === null || _this2.state.colorInfo.x !== colorInfo.x || _this2.state.colorInfo.y !== colorInfo.y) {\n          _this2.setState({\n            colorInfo: colorInfo\n          });\n        }\n      }, 30);\n    }\n  }, {\n    key: \"stopEyeDroppingLoop\",\n    value: function stopEyeDroppingLoop() {\n      clearInterval(this.intervalId);\n      this.setState({\n        colorInfo: null\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return react_default.a.createElement(paint_editor_paint_editor, {\n        canRedo: this.props.shouldShowRedo,\n        canUndo: this.props.shouldShowUndo,\n        canvas: this.state.canvas,\n        colorInfo: this.state.colorInfo,\n        format: this.props.format,\n        image: this.props.image,\n        imageFormat: this.props.imageFormat,\n        imageId: this.props.imageId,\n        isEyeDropping: this.props.isEyeDropping,\n        name: this.props.name,\n        rotationCenterX: this.props.rotationCenterX,\n        rotationCenterY: this.props.rotationCenterY,\n        rtl: this.props.rtl,\n        setCanvas: this.setCanvas,\n        setTextArea: this.setTextArea,\n        textArea: this.state.textArea,\n        zoomLevelId: this.props.zoomLevelId,\n        onRedo: this.props.onRedo,\n        onSwitchToBitmap: this.props.handleSwitchToBitmap,\n        onSwitchToVector: this.props.handleSwitchToVector,\n        onUndo: this.props.onUndo,\n        onUpdateImage: this.props.onUpdateImage,\n        onUpdateName: this.props.onUpdateName,\n        onZoomIn: this.handleZoomIn,\n        onZoomOut: this.handleZoomOut,\n        onZoomReset: this.handleZoomReset\n      });\n    }\n  }]);\n  return PaintEditor;\n}(react_default.a.Component);\npaint_editor_PaintEditor.propTypes = {\n  changeColorToEyeDropper: prop_types_default.a.func,\n  changeMode: prop_types_default.a.func.isRequired,\n  clearSelectedItems: prop_types_default.a.func.isRequired,\n  format: prop_types_default.a.oneOf(Object.keys(Formats)),\n  // Internal, up-to-date data format\n  fontInlineFn: prop_types_default.a.func,\n  handleSwitchToBitmap: prop_types_default.a.func.isRequired,\n  handleSwitchToVector: prop_types_default.a.func.isRequired,\n  image: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.instanceOf(HTMLImageElement)]),\n  imageFormat: prop_types_default.a.string,\n  // The incoming image's data format, used during import\n  imageId: prop_types_default.a.string,\n  isEyeDropping: prop_types_default.a.bool,\n  mode: prop_types_default.a.oneOf(Object.keys(Modes)).isRequired,\n  name: prop_types_default.a.string,\n  onDeactivateEyeDropper: prop_types_default.a.func.isRequired,\n  onKeyPress: prop_types_default.a.func.isRequired,\n  onRedo: prop_types_default.a.func.isRequired,\n  onUndo: prop_types_default.a.func.isRequired,\n  onUpdateImage: prop_types_default.a.func.isRequired,\n  onUpdateName: prop_types_default.a.func.isRequired,\n  previousTool: prop_types_default.a.shape({\n    // paper.Tool\n    activate: prop_types_default.a.func.isRequired,\n    remove: prop_types_default.a.func.isRequired\n  }),\n  removeTextEditTarget: prop_types_default.a.func.isRequired,\n  rotationCenterX: prop_types_default.a.number,\n  rotationCenterY: prop_types_default.a.number,\n  rtl: prop_types_default.a.bool,\n  setLayout: prop_types_default.a.func.isRequired,\n  setSelectedItems: prop_types_default.a.func.isRequired,\n  shouldShowRedo: prop_types_default.a.func.isRequired,\n  shouldShowUndo: prop_types_default.a.func.isRequired,\n  updateViewBounds: prop_types_default.a.func.isRequired,\n  viewBounds: prop_types_default.a.instanceOf(paper_full_default.a.Matrix).isRequired,\n  zoomLevelId: prop_types_default.a.string\n};\nvar paint_editor_mapStateToProps = function mapStateToProps(state) {\n  return {\n    changeColorToEyeDropper: state.scratchPaint.color.eyeDropper.callback,\n    format: state.scratchPaint.format,\n    isEyeDropping: state.scratchPaint.color.eyeDropper.active,\n    mode: state.scratchPaint.mode,\n    previousTool: state.scratchPaint.color.eyeDropper.previousTool,\n    viewBounds: state.scratchPaint.viewBounds\n  };\n};\nvar paint_editor_mapDispatchToProps = function mapDispatchToProps(dispatch) {\n  return {\n    changeMode: function changeMode(mode) {\n      dispatch(modes_changeMode(mode));\n    },\n    clearSelectedItems: function clearSelectedItems() {\n      dispatch(selected_items_clearSelectedItems());\n    },\n    handleSwitchToBitmap: function handleSwitchToBitmap() {\n      dispatch(format_changeFormat(Formats.BITMAP));\n    },\n    handleSwitchToVector: function handleSwitchToVector() {\n      dispatch(format_changeFormat(Formats.VECTOR));\n    },\n    removeTextEditTarget: function removeTextEditTarget() {\n      dispatch(text_edit_target_setTextEditTarget());\n    },\n    setLayout: function setLayout(layout) {\n      dispatch(layout_setLayout(layout));\n    },\n    setSelectedItems: function setSelectedItems(format) {\n      dispatch(selected_items_setSelectedItems(selection_getSelectedLeafItems(), format_isBitmap(format)));\n    },\n    onDeactivateEyeDropper: function onDeactivateEyeDropper() {\n      // set redux values to default for eye dropper reducer\n      dispatch(deactivateEyeDropper());\n    },\n    updateViewBounds: function updateViewBounds(matrix) {\n      dispatch(view_bounds_updateViewBounds(matrix));\n    }\n  };\n};\n/* harmony default export */ var containers_paint_editor = (update_image_hoc(selection_hoc(undo_hoc(keyboard_shortcuts_hoc(Object(es[\"b\" /* connect */])(paint_editor_mapStateToProps, paint_editor_mapDispatchToProps)(paint_editor_PaintEditor))))));\n// EXTERNAL MODULE: ./node_modules/redux/es/index.js + 6 modules\nvar redux_es = __webpack_require__(50);\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/reducers/color.js\n\n/* harmony default export */ var reducers_color = (Object(redux_es[\"c\" /* combineReducers */])({\n  eyeDropper: eye_dropper_reducer,\n  fillColor: fill_style_reducer,\n  strokeColor: stroke_style_strokeReducer,\n  strokeWidth: stroke_width_reducer\n}));\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/reducers/fill-mode.js\n/* harmony default export */ var reducers_fill_mode = (Object(redux_es[\"c\" /* combineReducers */])({\n  gradientType: fill_mode_gradient_type_reducer,\n  colorIndex: color_index_reducer\n}));\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/reducers/scratch-paint-reducer.js\n\n/* harmony default export */ var scratch_paint_reducer = (Object(redux_es[\"c\" /* combineReducers */])({\n  mode: modes_reducer,\n  bitBrushSize: bit_brush_size_reducer,\n  bitEraserSize: bit_eraser_size_reducer,\n  brushMode: brush_mode_reducer,\n  color: reducers_color,\n  clipboard: clipboard_reducer,\n  cursor: cursor_reducer,\n  eraserMode: eraser_mode_reducer,\n  fillBitmapShapes: fill_bitmap_shapes_reducer,\n  fillMode: reducers_fill_mode,\n  font: font_reducer,\n  format: format_reducer,\n  hoveredItemId: hover_reducer,\n  layout: layout_reducer,\n  modals: modals_reducer,\n  selectedItems: selected_items_reducer,\n  textEditTarget: text_edit_target_reducer,\n  undo: undo_reducer,\n  viewBounds: view_bounds_reducer,\n  zoomLevels: zoom_levels_reducer\n}));\n// CONCATENATED MODULE: ./node_modules/scratch-paint/src/index.js\n\n })