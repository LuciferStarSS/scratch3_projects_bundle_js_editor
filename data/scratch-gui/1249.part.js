/* 1249 */\n (function(module, exports) {\nmodule.exports = \"precision mediump float;\\n\\n#ifdef DRAW_MODE_silhouette\\nuniform vec4 u_silhouetteColor;\\n#else // DRAW_MODE_silhouette\\n# ifdef ENABLE_color\\nuniform float u_color;\\n# endif // ENABLE_color\\n# ifdef ENABLE_brightness\\nuniform float u_brightness;\\n# endif // ENABLE_brightness\\n#endif // DRAW_MODE_silhouette\\n\\n#ifdef DRAW_MODE_colorMask\\nuniform vec3 u_colorMask;\\nuniform float u_colorMaskTolerance;\\n#endif // DRAW_MODE_colorMask\\n\\n#ifdef ENABLE_fisheye\\nuniform float u_fisheye;\\n#endif // ENABLE_fisheye\\n#ifdef ENABLE_whirl\\nuniform float u_whirl;\\n#endif // ENABLE_whirl\\n#ifdef ENABLE_pixelate\\nuniform float u_pixelate;\\nuniform vec2 u_skinSize;\\n#endif // ENABLE_pixelate\\n#ifdef ENABLE_mosaic\\nuniform float u_mosaic;\\n#endif // ENABLE_mosaic\\n#ifdef ENABLE_ghost\\nuniform float u_ghost;\\n#endif // ENABLE_ghost\\n\\n#ifdef DRAW_MODE_line\\nuniform vec4 u_lineColor;\\nuniform float u_lineThickness;\\nuniform float u_lineLength;\\n#endif // DRAW_MODE_line\\n\\n#ifdef DRAW_MODE_background\\nuniform vec4 u_backgroundColor;\\n#endif // DRAW_MODE_background\\n\\nuniform sampler2D u_skin;\\n\\n#ifndef DRAW_MODE_background\\nvarying vec2 v_texCoord;\\n#endif\\n\\n// Add this to divisors to prevent division by 0, which results in NaNs propagating through calculations.\\n// Smaller values can cause problems on some mobile devices.\\nconst float epsilon = 1e-3;\\n\\n#if !defined(DRAW_MODE_silhouette) && (defined(ENABLE_color))\\n// Branchless color conversions based on code from:\\n// http://www.chilliant.com/rgb2hsv.html by Ian Taylor\\n// Based in part on work by Sam Hocevar and Emil Persson\\n// See also: https://en.wikipedia.org/wiki/HSL_and_HSV#Formal_derivation\\n\\n\\n// Convert an RGB color to Hue, Saturation, and Value.\\n// All components of input and output are expected to be in the [0,1] range.\\nvec3 convertRGB2HSV(vec3 rgb)\\n{\\n\\t// Hue calculation has 3 cases, depending on which RGB component is largest, and one of those cases involves a \\\"mod\\\"\\n\\t// operation. In order to avoid that \\\"mod\\\" we split the M==R case in two: one for G<B and one for B>G. The B>G case\\n\\t// will be calculated in the negative and fed through abs() in the hue calculation at the end.\\n\\t// See also: https://en.wikipedia.org/wiki/HSL_and_HSV#Hue_and_chroma\\n\\tconst vec4 hueOffsets = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\\n\\n\\t// temp1.xy = sort B & G (largest first)\\n\\t// temp1.z = the hue offset we'll use if it turns out that R is the largest component (M==R)\\n\\t// temp1.w = the hue offset we'll use if it turns out that R is not the largest component (M==G or M==B)\\n\\tvec4 temp1 = rgb.b > rgb.g ? vec4(rgb.bg, hueOffsets.wz) : vec4(rgb.gb, hueOffsets.xy);\\n\\n\\t// temp2.x = the largest component of RGB (\\\"M\\\" / \\\"Max\\\")\\n\\t// temp2.yw = the smaller components of RGB, ordered for the hue calculation (not necessarily sorted by magnitude!)\\n\\t// temp2.z = the hue offset we'll use in the hue calculation\\n\\tvec4 temp2 = rgb.r > temp1.x ? vec4(rgb.r, temp1.yzx) : vec4(temp1.xyw, rgb.r);\\n\\n\\t// m = the smallest component of RGB (\\\"min\\\")\\n\\tfloat m = min(temp2.y, temp2.w);\\n\\n\\t// Chroma = M - m\\n\\tfloat C = temp2.x - m;\\n\\n\\t// Value = M\\n\\tfloat V = temp2.x;\\n\\n\\treturn vec3(\\n\\t\\tabs(temp2.z + (temp2.w - temp2.y) / (6.0 * C + epsilon)), // Hue\\n\\t\\tC / (temp2.x + epsilon), // Saturation\\n\\t\\tV); // Value\\n}\\n\\nvec3 convertHue2RGB(float hue)\\n{\\n\\tfloat r = abs(hue * 6.0 - 3.0) - 1.0;\\n\\tfloat g = 2.0 - abs(hue * 6.0 - 2.0);\\n\\tfloat b = 2.0 - abs(hue * 6.0 - 4.0);\\n\\treturn clamp(vec3(r, g, b), 0.0, 1.0);\\n}\\n\\nvec3 convertHSV2RGB(vec3 hsv)\\n{\\n\\tvec3 rgb = convertHue2RGB(hsv.x);\\n\\tfloat c = hsv.z * hsv.y;\\n\\treturn rgb * c + hsv.z - c;\\n}\\n#endif // !defined(DRAW_MODE_silhouette) && (defined(ENABLE_color))\\n\\nconst vec2 kCenter = vec2(0.5, 0.5);\\n\\nvoid main()\\n{\\n\\t#if !(defined(DRAW_MODE_line) || defined(DRAW_MODE_background))\\n\\tvec2 texcoord0 = v_texCoord;\\n\\n\\t#ifdef ENABLE_mosaic\\n\\ttexcoord0 = fract(u_mosaic * texcoord0);\\n\\t#endif // ENABLE_mosaic\\n\\n\\t#ifdef ENABLE_pixelate\\n\\t{\\n\\t\\t// TODO: clean up \\\"pixel\\\" edges\\n\\t\\tvec2 pixelTexelSize = u_skinSize / u_pixelate;\\n\\t\\ttexcoord0 = (floor(texcoord0 * pixelTexelSize) + kCenter) / pixelTexelSize;\\n\\t}\\n\\t#endif // ENABLE_pixelate\\n\\n\\t#ifdef ENABLE_whirl\\n\\t{\\n\\t\\tconst float kRadius = 0.5;\\n\\t\\tvec2 offset = texcoord0 - kCenter;\\n\\t\\tfloat offsetMagnitude = length(offset);\\n\\t\\tfloat whirlFactor = max(1.0 - (offsetMagnitude / kRadius), 0.0);\\n\\t\\tfloat whirlActual = u_whirl * whirlFactor * whirlFactor;\\n\\t\\tfloat sinWhirl = sin(whirlActual);\\n\\t\\tfloat cosWhirl = cos(whirlActual);\\n\\t\\tmat2 rotationMatrix = mat2(\\n\\t\\t\\tcosWhirl, -sinWhirl,\\n\\t\\t\\tsinWhirl, cosWhirl\\n\\t\\t);\\n\\n\\t\\ttexcoord0 = rotationMatrix * offset + kCenter;\\n\\t}\\n\\t#endif // ENABLE_whirl\\n\\n\\t#ifdef ENABLE_fisheye\\n\\t{\\n\\t\\tvec2 vec = (texcoord0 - kCenter) / kCenter;\\n\\t\\tfloat vecLength = length(vec);\\n\\t\\tfloat r = pow(min(vecLength, 1.0), u_fisheye) * max(1.0, vecLength);\\n\\t\\tvec2 unit = vec / vecLength;\\n\\n\\t\\ttexcoord0 = kCenter + r * unit * kCenter;\\n\\t}\\n\\t#endif // ENABLE_fisheye\\n\\n\\tgl_FragColor = texture2D(u_skin, texcoord0);\\n\\n\\t#if defined(ENABLE_color) || defined(ENABLE_brightness)\\n\\t// Divide premultiplied alpha values for proper color processing\\n\\t// Add epsilon to avoid dividing by 0 for fully transparent pixels\\n\\tgl_FragColor.rgb = clamp(gl_FragColor.rgb / (gl_FragColor.a + epsilon), 0.0, 1.0);\\n\\n\\t#ifdef ENABLE_color\\n\\t{\\n\\t\\tvec3 hsv = convertRGB2HSV(gl_FragColor.xyz);\\n\\n\\t\\t// this code forces grayscale values to be slightly saturated\\n\\t\\t// so that some slight change of hue will be visible\\n\\t\\tconst float minLightness = 0.11 / 2.0;\\n\\t\\tconst float minSaturation = 0.09;\\n\\t\\tif (hsv.z < minLightness) hsv = vec3(0.0, 1.0, minLightness);\\n\\t\\telse if (hsv.y < minSaturation) hsv = vec3(0.0, minSaturation, hsv.z);\\n\\n\\t\\thsv.x = mod(hsv.x + u_color, 1.0);\\n\\t\\tif (hsv.x < 0.0) hsv.x += 1.0;\\n\\n\\t\\tgl_FragColor.rgb = convertHSV2RGB(hsv);\\n\\t}\\n\\t#endif // ENABLE_color\\n\\n\\t#ifdef ENABLE_brightness\\n\\tgl_FragColor.rgb = clamp(gl_FragColor.rgb + vec3(u_brightness), vec3(0), vec3(1));\\n\\t#endif // ENABLE_brightness\\n\\n\\t// Re-multiply color values\\n\\tgl_FragColor.rgb *= gl_FragColor.a + epsilon;\\n\\n\\t#endif // defined(ENABLE_color) || defined(ENABLE_brightness)\\n\\n\\t#ifdef ENABLE_ghost\\n\\tgl_FragColor *= u_ghost;\\n\\t#endif // ENABLE_ghost\\n\\n\\t#ifdef DRAW_MODE_silhouette\\n\\t// Discard fully transparent pixels for stencil test\\n\\tif (gl_FragColor.a == 0.0) {\\n\\t\\tdiscard;\\n\\t}\\n\\t// switch to u_silhouetteColor only AFTER the alpha test\\n\\tgl_FragColor = u_silhouetteColor;\\n\\t#else // DRAW_MODE_silhouette\\n\\n\\t#ifdef DRAW_MODE_colorMask\\n\\tvec3 maskDistance = abs(gl_FragColor.rgb - u_colorMask);\\n\\tvec3 colorMaskTolerance = vec3(u_colorMaskTolerance, u_colorMaskTolerance, u_colorMaskTolerance);\\n\\tif (any(greaterThan(maskDistance, colorMaskTolerance)))\\n\\t{\\n\\t\\tdiscard;\\n\\t}\\n\\t#endif // DRAW_MODE_colorMask\\n\\t#endif // DRAW_MODE_silhouette\\n\\n\\t#ifdef DRAW_MODE_straightAlpha\\n\\t// Un-premultiply alpha.\\n\\tgl_FragColor.rgb /= gl_FragColor.a + epsilon;\\n\\t#endif\\n\\n\\t#endif // !(defined(DRAW_MODE_line) || defined(DRAW_MODE_background))\\n\\n\\t#ifdef DRAW_MODE_line\\n\\t// Maaaaagic antialiased-line-with-round-caps shader.\\n\\n\\t// \\\"along-the-lineness\\\". This increases parallel to the line.\\n\\t// It goes from negative before the start point, to 0.5 through the start to the end, then ramps up again\\n\\t// past the end point.\\n\\tfloat d = ((v_texCoord.x - clamp(v_texCoord.x, 0.0, u_lineLength)) * 0.5) + 0.5;\\n\\n\\t// Distance from (0.5, 0.5) to (d, the perpendicular coordinate). When we're in the middle of the line,\\n\\t// d will be 0.5, so the distance will be 0 at points close to the line and will grow at points further from it.\\n\\t// For the \\\"caps\\\", d will ramp down/up, giving us rounding.\\n\\t// See https://www.youtube.com/watch?v=PMltMdi1Wzg for a rough outline of the technique used to round the lines.\\n\\tfloat line = distance(vec2(0.5), vec2(d, v_texCoord.y)) * 2.0;\\n\\t// Expand out the line by its thickness.\\n\\tline -= ((u_lineThickness - 1.0) * 0.5);\\n\\t// Because \\\"distance to the center of the line\\\" decreases the closer we get to the line, but we want more opacity\\n\\t// the closer we are to the line, invert it.\\n\\tgl_FragColor = u_lineColor * clamp(1.0 - line, 0.0, 1.0);\\n\\t#endif // DRAW_MODE_line\\n\\n\\t#ifdef DRAW_MODE_background\\n\\tgl_FragColor = u_backgroundColor;\\n\\t#endif\\n}\\n\"\n })