/* 1187 */\n (function(module, exports, __webpack_require__) {\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n/**\n * @fileoverview\n * The specMap below handles a few pieces of \"translation\" work between\n * the SB2 JSON format and the data we need to run a project\n * in the Scratch 3.0 VM.\n * Notably:\n *  - Map 2.0 and 1.4 opcodes (forward:) into 3.0-format (motion_movesteps).\n *  - Map ordered, unnamed args to unordered, named inputs and fields.\n * Keep this up-to-date as 3.0 blocks are renamed, changed, etc.\n * Originally this was generated largely by a hand-guided scripting process.\n * The relevant data lives here:\n * https://github.com/LLK/scratch-flash/blob/master/src/Specs.as\n * (for the old opcode and argument order).\n * and here:\n * https://github.com/LLK/scratch-blocks/tree/develop/blocks_vertical\n * (for the new opcodes and argument names).\n * and here:\n * https://github.com/LLK/scratch-blocks/blob/develop/tests/\n * (for the shadow blocks created for each block).\n * I started with the `commands` array in Specs.as, and discarded irrelevant\n * properties. By hand, I matched the opcode name to the 3.0 opcode.\n * Finally, I filled in the expected arguments as below.\n */\nvar Variable = __webpack_require__(114);\n/**\n * @typedef {object} SB2SpecMap_blockInfo\n * @property {string} opcode - the Scratch 3.0 block opcode. Use 'extensionID.opcode' for extension opcodes.\n * @property {Array.<SB2SpecMap_argInfo>} argMap - metadata for this block's arguments.\n */\n/**\n * @typedef {object} SB2SpecMap_argInfo\n * @property {string} type - the type of this arg (such as 'input' or 'field')\n * @property {string} inputOp - the scratch-blocks shadow type for this arg\n * @property {string} inputName - the name this argument will take when provided to the block implementation\n */\n/**\n * Mapping of Scratch 2.0 opcode to Scratch 3.0 block metadata.\n * @type {object.<SB2SpecMap_blockInfo>}\n */\nvar specMap = {\n  'forward:': {\n    opcode: 'motion_movesteps',\n    argMap: [{\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'STEPS'\n    }]\n  },\n  'turnRight:': {\n    opcode: 'motion_turnright',\n    argMap: [{\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'DEGREES'\n    }]\n  },\n  'turnLeft:': {\n    opcode: 'motion_turnleft',\n    argMap: [{\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'DEGREES'\n    }]\n  },\n  'heading:': {\n    opcode: 'motion_pointindirection',\n    argMap: [{\n      type: 'input',\n      inputOp: 'math_angle',\n      inputName: 'DIRECTION'\n    }]\n  },\n  'pointTowards:': {\n    opcode: 'motion_pointtowards',\n    argMap: [{\n      type: 'input',\n      inputOp: 'motion_pointtowards_menu',\n      inputName: 'TOWARDS'\n    }]\n  },\n  'gotoX:y:': {\n    opcode: 'motion_gotoxy',\n    argMap: [{\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'X'\n    }, {\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'Y'\n    }]\n  },\n  'gotoSpriteOrMouse:': {\n    opcode: 'motion_goto',\n    argMap: [{\n      type: 'input',\n      inputOp: 'motion_goto_menu',\n      inputName: 'TO'\n    }]\n  },\n  'glideSecs:toX:y:elapsed:from:': {\n    opcode: 'motion_glidesecstoxy',\n    argMap: [{\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'SECS'\n    }, {\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'X'\n    }, {\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'Y'\n    }]\n  },\n  'changeXposBy:': {\n    opcode: 'motion_changexby',\n    argMap: [{\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'DX'\n    }]\n  },\n  'xpos:': {\n    opcode: 'motion_setx',\n    argMap: [{\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'X'\n    }]\n  },\n  'changeYposBy:': {\n    opcode: 'motion_changeyby',\n    argMap: [{\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'DY'\n    }]\n  },\n  'ypos:': {\n    opcode: 'motion_sety',\n    argMap: [{\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'Y'\n    }]\n  },\n  'bounceOffEdge': {\n    opcode: 'motion_ifonedgebounce',\n    argMap: []\n  },\n  'setRotationStyle': {\n    opcode: 'motion_setrotationstyle',\n    argMap: [{\n      type: 'field',\n      fieldName: 'STYLE'\n    }]\n  },\n  'xpos': {\n    opcode: 'motion_xposition',\n    argMap: []\n  },\n  'ypos': {\n    opcode: 'motion_yposition',\n    argMap: []\n  },\n  'heading': {\n    opcode: 'motion_direction',\n    argMap: []\n  },\n  'scrollRight': {\n    opcode: 'motion_scroll_right',\n    argMap: [{\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'DISTANCE'\n    }]\n  },\n  'scrollUp': {\n    opcode: 'motion_scroll_up',\n    argMap: [{\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'DISTANCE'\n    }]\n  },\n  'scrollAlign': {\n    opcode: 'motion_align_scene',\n    argMap: [{\n      type: 'field',\n      fieldName: 'ALIGNMENT'\n    }]\n  },\n  'xScroll': {\n    opcode: 'motion_xscroll',\n    argMap: []\n  },\n  'yScroll': {\n    opcode: 'motion_yscroll',\n    argMap: []\n  },\n  'say:duration:elapsed:from:': {\n    opcode: 'looks_sayforsecs',\n    argMap: [{\n      type: 'input',\n      inputOp: 'text',\n      inputName: 'MESSAGE'\n    }, {\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'SECS'\n    }]\n  },\n  'say:': {\n    opcode: 'looks_say',\n    argMap: [{\n      type: 'input',\n      inputOp: 'text',\n      inputName: 'MESSAGE'\n    }]\n  },\n  'think:duration:elapsed:from:': {\n    opcode: 'looks_thinkforsecs',\n    argMap: [{\n      type: 'input',\n      inputOp: 'text',\n      inputName: 'MESSAGE'\n    }, {\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'SECS'\n    }]\n  },\n  'think:': {\n    opcode: 'looks_think',\n    argMap: [{\n      type: 'input',\n      inputOp: 'text',\n      inputName: 'MESSAGE'\n    }]\n  },\n  'show': {\n    opcode: 'looks_show',\n    argMap: []\n  },\n  'hide': {\n    opcode: 'looks_hide',\n    argMap: []\n  },\n  'hideAll': {\n    opcode: 'looks_hideallsprites',\n    argMap: []\n  },\n  'lookLike:': {\n    opcode: 'looks_switchcostumeto',\n    argMap: [{\n      type: 'input',\n      inputOp: 'looks_costume',\n      inputName: 'COSTUME'\n    }]\n  },\n  'nextCostume': {\n    opcode: 'looks_nextcostume',\n    argMap: []\n  },\n  'startScene': {\n    opcode: 'looks_switchbackdropto',\n    argMap: [{\n      type: 'input',\n      inputOp: 'looks_backdrops',\n      inputName: 'BACKDROP'\n    }]\n  },\n  'changeGraphicEffect:by:': {\n    opcode: 'looks_changeeffectby',\n    argMap: [{\n      type: 'field',\n      fieldName: 'EFFECT'\n    }, {\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'CHANGE'\n    }]\n  },\n  'setGraphicEffect:to:': {\n    opcode: 'looks_seteffectto',\n    argMap: [{\n      type: 'field',\n      fieldName: 'EFFECT'\n    }, {\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'VALUE'\n    }]\n  },\n  'filterReset': {\n    opcode: 'looks_cleargraphiceffects',\n    argMap: []\n  },\n  'changeSizeBy:': {\n    opcode: 'looks_changesizeby',\n    argMap: [{\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'CHANGE'\n    }]\n  },\n  'setSizeTo:': {\n    opcode: 'looks_setsizeto',\n    argMap: [{\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'SIZE'\n    }]\n  },\n  'changeStretchBy:': {\n    opcode: 'looks_changestretchby',\n    argMap: [{\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'CHANGE'\n    }]\n  },\n  'setStretchTo:': {\n    opcode: 'looks_setstretchto',\n    argMap: [{\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'STRETCH'\n    }]\n  },\n  'comeToFront': {\n    opcode: 'looks_gotofrontback',\n    argMap: []\n  },\n  'goBackByLayers:': {\n    opcode: 'looks_goforwardbackwardlayers',\n    argMap: [{\n      type: 'input',\n      inputOp: 'math_integer',\n      inputName: 'NUM'\n    }]\n  },\n  'costumeIndex': {\n    opcode: 'looks_costumenumbername',\n    argMap: []\n  },\n  'costumeName': {\n    opcode: 'looks_costumenumbername',\n    argMap: []\n  },\n  'sceneName': {\n    opcode: 'looks_backdropnumbername',\n    argMap: []\n  },\n  'scale': {\n    opcode: 'looks_size',\n    argMap: []\n  },\n  'startSceneAndWait': {\n    opcode: 'looks_switchbackdroptoandwait',\n    argMap: [{\n      type: 'input',\n      inputOp: 'looks_backdrops',\n      inputName: 'BACKDROP'\n    }]\n  },\n  'nextScene': {\n    opcode: 'looks_nextbackdrop',\n    argMap: []\n  },\n  'backgroundIndex': {\n    opcode: 'looks_backdropnumbername',\n    argMap: []\n  },\n  'playSound:': {\n    opcode: 'sound_play',\n    argMap: [{\n      type: 'input',\n      inputOp: 'sound_sounds_menu',\n      inputName: 'SOUND_MENU'\n    }]\n  },\n  'doPlaySoundAndWait': {\n    opcode: 'sound_playuntildone',\n    argMap: [{\n      type: 'input',\n      inputOp: 'sound_sounds_menu',\n      inputName: 'SOUND_MENU'\n    }]\n  },\n  'stopAllSounds': {\n    opcode: 'sound_stopallsounds',\n    argMap: []\n  },\n  'playDrum': {\n    opcode: 'music_playDrumForBeats',\n    argMap: [{\n      type: 'input',\n      inputOp: 'music_menu_DRUM',\n      inputName: 'DRUM'\n    }, {\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'BEATS'\n    }]\n  },\n  'drum:duration:elapsed:from:': {\n    opcode: 'music_midiPlayDrumForBeats',\n    argMap: [{\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'DRUM'\n    }, {\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'BEATS'\n    }]\n  },\n  'rest:elapsed:from:': {\n    opcode: 'music_restForBeats',\n    argMap: [{\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'BEATS'\n    }]\n  },\n  'noteOn:duration:elapsed:from:': {\n    opcode: 'music_playNoteForBeats',\n    argMap: [{\n      type: 'input',\n      inputOp: 'note',\n      inputName: 'NOTE'\n    }, {\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'BEATS'\n    }]\n  },\n  'instrument:': {\n    opcode: 'music_setInstrument',\n    argMap: [{\n      type: 'input',\n      inputOp: 'music_menu_INSTRUMENT',\n      inputName: 'INSTRUMENT'\n    }]\n  },\n  'midiInstrument:': {\n    opcode: 'music_midiSetInstrument',\n    argMap: [{\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'INSTRUMENT'\n    }]\n  },\n  'changeVolumeBy:': {\n    opcode: 'sound_changevolumeby',\n    argMap: [{\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'VOLUME'\n    }]\n  },\n  'setVolumeTo:': {\n    opcode: 'sound_setvolumeto',\n    argMap: [{\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'VOLUME'\n    }]\n  },\n  'volume': {\n    opcode: 'sound_volume',\n    argMap: []\n  },\n  'changeTempoBy:': {\n    opcode: 'music_changeTempo',\n    argMap: [{\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'TEMPO'\n    }]\n  },\n  'setTempoTo:': {\n    opcode: 'music_setTempo',\n    argMap: [{\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'TEMPO'\n    }]\n  },\n  'tempo': {\n    opcode: 'music_getTempo',\n    argMap: []\n  },\n  'clearPenTrails': {\n    opcode: 'pen_clear',\n    argMap: []\n  },\n  'stampCostume': {\n    opcode: 'pen_stamp',\n    argMap: []\n  },\n  'putPenDown': {\n    opcode: 'pen_penDown',\n    argMap: []\n  },\n  'putPenUp': {\n    opcode: 'pen_penUp',\n    argMap: []\n  },\n  'penColor:': {\n    opcode: 'pen_setPenColorToColor',\n    argMap: [{\n      type: 'input',\n      inputOp: 'colour_picker',\n      inputName: 'COLOR'\n    }]\n  },\n  'changePenHueBy:': {\n    opcode: 'pen_changePenHueBy',\n    argMap: [{\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'HUE'\n    }]\n  },\n  'setPenHueTo:': {\n    opcode: 'pen_setPenHueToNumber',\n    argMap: [{\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'HUE'\n    }]\n  },\n  'changePenShadeBy:': {\n    opcode: 'pen_changePenShadeBy',\n    argMap: [{\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'SHADE'\n    }]\n  },\n  'setPenShadeTo:': {\n    opcode: 'pen_setPenShadeToNumber',\n    argMap: [{\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'SHADE'\n    }]\n  },\n  'changePenSizeBy:': {\n    opcode: 'pen_changePenSizeBy',\n    argMap: [{\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'SIZE'\n    }]\n  },\n  'penSize:': {\n    opcode: 'pen_setPenSizeTo',\n    argMap: [{\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'SIZE'\n    }]\n  },\n  'senseVideoMotion': {\n    opcode: 'videoSensing_videoOn',\n    argMap: [{\n      type: 'input',\n      inputOp: 'videoSensing_menu_ATTRIBUTE',\n      inputName: 'ATTRIBUTE'\n    }, {\n      type: 'input',\n      inputOp: 'videoSensing_menu_SUBJECT',\n      inputName: 'SUBJECT'\n    }]\n  },\n  'whenGreenFlag': {\n    opcode: 'event_whenflagclicked',\n    argMap: []\n  },\n  'whenKeyPressed': {\n    opcode: 'event_whenkeypressed',\n    argMap: [{\n      type: 'field',\n      fieldName: 'KEY_OPTION'\n    }]\n  },\n  'whenClicked': {\n    opcode: 'event_whenthisspriteclicked',\n    argMap: []\n  },\n  'whenSceneStarts': {\n    opcode: 'event_whenbackdropswitchesto',\n    argMap: [{\n      type: 'field',\n      fieldName: 'BACKDROP'\n    }]\n  },\n  'whenSensorGreaterThan': function whenSensorGreaterThan(_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        sensor = _ref2[1];\n    if (sensor === 'video motion') {\n      return {\n        opcode: 'videoSensing_whenMotionGreaterThan',\n        argMap: [// skip the first arg, since we converted to a video specific sensing block\n        {}, {\n          type: 'input',\n          inputOp: 'math_number',\n          inputName: 'REFERENCE'\n        }]\n      };\n    }\n    return {\n      opcode: 'event_whengreaterthan',\n      argMap: [{\n        type: 'field',\n        fieldName: 'WHENGREATERTHANMENU'\n      }, {\n        type: 'input',\n        inputOp: 'math_number',\n        inputName: 'VALUE'\n      }]\n    };\n  },\n  'whenIReceive': {\n    opcode: 'event_whenbroadcastreceived',\n    argMap: [{\n      type: 'field',\n      fieldName: 'BROADCAST_OPTION',\n      variableType: Variable.BROADCAST_MESSAGE_TYPE\n    }]\n  },\n  'broadcast:': {\n    opcode: 'event_broadcast',\n    argMap: [{\n      type: 'input',\n      inputOp: 'event_broadcast_menu',\n      inputName: 'BROADCAST_INPUT',\n      variableType: Variable.BROADCAST_MESSAGE_TYPE\n    }]\n  },\n  'doBroadcastAndWait': {\n    opcode: 'event_broadcastandwait',\n    argMap: [{\n      type: 'input',\n      inputOp: 'event_broadcast_menu',\n      inputName: 'BROADCAST_INPUT',\n      variableType: Variable.BROADCAST_MESSAGE_TYPE\n    }]\n  },\n  'wait:elapsed:from:': {\n    opcode: 'control_wait',\n    argMap: [{\n      type: 'input',\n      inputOp: 'math_positive_number',\n      inputName: 'DURATION'\n    }]\n  },\n  'doRepeat': {\n    opcode: 'control_repeat',\n    argMap: [{\n      type: 'input',\n      inputOp: 'math_whole_number',\n      inputName: 'TIMES'\n    }, {\n      type: 'input',\n      inputOp: 'substack',\n      inputName: 'SUBSTACK'\n    }]\n  },\n  'doForever': {\n    opcode: 'control_forever',\n    argMap: [{\n      type: 'input',\n      inputOp: 'substack',\n      inputName: 'SUBSTACK'\n    }]\n  },\n  'doIf': {\n    opcode: 'control_if',\n    argMap: [{\n      type: 'input',\n      inputOp: 'boolean',\n      inputName: 'CONDITION'\n    }, {\n      type: 'input',\n      inputOp: 'substack',\n      inputName: 'SUBSTACK'\n    }]\n  },\n  'doIfElse': {\n    opcode: 'control_if_else',\n    argMap: [{\n      type: 'input',\n      inputOp: 'boolean',\n      inputName: 'CONDITION'\n    }, {\n      type: 'input',\n      inputOp: 'substack',\n      inputName: 'SUBSTACK'\n    }, {\n      type: 'input',\n      inputOp: 'substack',\n      inputName: 'SUBSTACK2'\n    }]\n  },\n  'doWaitUntil': {\n    opcode: 'control_wait_until',\n    argMap: [{\n      type: 'input',\n      inputOp: 'boolean',\n      inputName: 'CONDITION'\n    }]\n  },\n  'doUntil': {\n    opcode: 'control_repeat_until',\n    argMap: [{\n      type: 'input',\n      inputOp: 'boolean',\n      inputName: 'CONDITION'\n    }, {\n      type: 'input',\n      inputOp: 'substack',\n      inputName: 'SUBSTACK'\n    }]\n  },\n  'doWhile': {\n    opcode: 'control_while',\n    argMap: [{\n      type: 'input',\n      inputOp: 'boolean',\n      inputName: 'CONDITION'\n    }, {\n      type: 'input',\n      inputOp: 'substack',\n      inputName: 'SUBSTACK'\n    }]\n  },\n  'doForLoop': {\n    opcode: 'control_for_each',\n    argMap: [{\n      type: 'field',\n      fieldName: 'VARIABLE'\n    }, {\n      type: 'input',\n      inputOp: 'text',\n      inputName: 'VALUE'\n    }, {\n      type: 'input',\n      inputOp: 'substack',\n      inputName: 'SUBSTACK'\n    }]\n  },\n  'stopScripts': {\n    opcode: 'control_stop',\n    argMap: [{\n      type: 'field',\n      fieldName: 'STOP_OPTION'\n    }]\n  },\n  'whenCloned': {\n    opcode: 'control_start_as_clone',\n    argMap: []\n  },\n  'createCloneOf': {\n    opcode: 'control_create_clone_of',\n    argMap: [{\n      type: 'input',\n      inputOp: 'control_create_clone_of_menu',\n      inputName: 'CLONE_OPTION'\n    }]\n  },\n  'deleteClone': {\n    opcode: 'control_delete_this_clone',\n    argMap: []\n  },\n  'COUNT': {\n    opcode: 'control_get_counter',\n    argMap: []\n  },\n  'INCR_COUNT': {\n    opcode: 'control_incr_counter',\n    argMap: []\n  },\n  'CLR_COUNT': {\n    opcode: 'control_clear_counter',\n    argMap: []\n  },\n  'warpSpeed': {\n    opcode: 'control_all_at_once',\n    argMap: [{\n      type: 'input',\n      inputOp: 'substack',\n      inputName: 'SUBSTACK'\n    }]\n  },\n  'touching:': {\n    opcode: 'sensing_touchingobject',\n    argMap: [{\n      type: 'input',\n      inputOp: 'sensing_touchingobjectmenu',\n      inputName: 'TOUCHINGOBJECTMENU'\n    }]\n  },\n  'touchingColor:': {\n    opcode: 'sensing_touchingcolor',\n    argMap: [{\n      type: 'input',\n      inputOp: 'colour_picker',\n      inputName: 'COLOR'\n    }]\n  },\n  'color:sees:': {\n    opcode: 'sensing_coloristouchingcolor',\n    argMap: [{\n      type: 'input',\n      inputOp: 'colour_picker',\n      inputName: 'COLOR'\n    }, {\n      type: 'input',\n      inputOp: 'colour_picker',\n      inputName: 'COLOR2'\n    }]\n  },\n  'distanceTo:': {\n    opcode: 'sensing_distanceto',\n    argMap: [{\n      type: 'input',\n      inputOp: 'sensing_distancetomenu',\n      inputName: 'DISTANCETOMENU'\n    }]\n  },\n  'doAsk': {\n    opcode: 'sensing_askandwait',\n    argMap: [{\n      type: 'input',\n      inputOp: 'text',\n      inputName: 'QUESTION'\n    }]\n  },\n  'answer': {\n    opcode: 'sensing_answer',\n    argMap: []\n  },\n  'keyPressed:': {\n    opcode: 'sensing_keypressed',\n    argMap: [{\n      type: 'input',\n      inputOp: 'sensing_keyoptions',\n      inputName: 'KEY_OPTION'\n    }]\n  },\n  'mousePressed': {\n    opcode: 'sensing_mousedown',\n    argMap: []\n  },\n  'mouseX': {\n    opcode: 'sensing_mousex',\n    argMap: []\n  },\n  'mouseY': {\n    opcode: 'sensing_mousey',\n    argMap: []\n  },\n  'soundLevel': {\n    opcode: 'sensing_loudness',\n    argMap: []\n  },\n  'isLoud': {\n    opcode: 'sensing_loud',\n    argMap: []\n  },\n  // 'senseVideoMotion': {\n  //     opcode: 'sensing_videoon',\n  //     argMap: [\n  //         {\n  //             type: 'input',\n  //             inputOp: 'sensing_videoonmenuone',\n  //             inputName: 'VIDEOONMENU1'\n  //         },\n  //         {\n  //             type: 'input',\n  //             inputOp: 'sensing_videoonmenutwo',\n  //             inputName: 'VIDEOONMENU2'\n  //         }\n  //     ]\n  // },\n  'setVideoState': {\n    opcode: 'videoSensing_videoToggle',\n    argMap: [{\n      type: 'input',\n      inputOp: 'videoSensing_menu_VIDEO_STATE',\n      inputName: 'VIDEO_STATE'\n    }]\n  },\n  'setVideoTransparency': {\n    opcode: 'videoSensing_setVideoTransparency',\n    argMap: [{\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'TRANSPARENCY'\n    }]\n  },\n  'timer': {\n    opcode: 'sensing_timer',\n    argMap: []\n  },\n  'timerReset': {\n    opcode: 'sensing_resettimer',\n    argMap: []\n  },\n  'getAttribute:of:': {\n    opcode: 'sensing_of',\n    argMap: [{\n      type: 'field',\n      fieldName: 'PROPERTY'\n    }, {\n      type: 'input',\n      inputOp: 'sensing_of_object_menu',\n      inputName: 'OBJECT'\n    }]\n  },\n  'timeAndDate': {\n    opcode: 'sensing_current',\n    argMap: [{\n      type: 'field',\n      fieldName: 'CURRENTMENU'\n    }]\n  },\n  'timestamp': {\n    opcode: 'sensing_dayssince2000',\n    argMap: []\n  },\n  'getUserName': {\n    opcode: 'sensing_username',\n    argMap: []\n  },\n  'getUserId': {\n    opcode: 'sensing_userid',\n    argMap: []\n  },\n  '+': {\n    opcode: 'operator_add',\n    argMap: [{\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'NUM1'\n    }, {\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'NUM2'\n    }]\n  },\n  '-': {\n    opcode: 'operator_subtract',\n    argMap: [{\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'NUM1'\n    }, {\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'NUM2'\n    }]\n  },\n  '*': {\n    opcode: 'operator_multiply',\n    argMap: [{\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'NUM1'\n    }, {\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'NUM2'\n    }]\n  },\n  '/': {\n    opcode: 'operator_divide',\n    argMap: [{\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'NUM1'\n    }, {\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'NUM2'\n    }]\n  },\n  'randomFrom:to:': {\n    opcode: 'operator_random',\n    argMap: [{\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'FROM'\n    }, {\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'TO'\n    }]\n  },\n  '<': {\n    opcode: 'operator_lt',\n    argMap: [{\n      type: 'input',\n      inputOp: 'text',\n      inputName: 'OPERAND1'\n    }, {\n      type: 'input',\n      inputOp: 'text',\n      inputName: 'OPERAND2'\n    }]\n  },\n  '=': {\n    opcode: 'operator_equals',\n    argMap: [{\n      type: 'input',\n      inputOp: 'text',\n      inputName: 'OPERAND1'\n    }, {\n      type: 'input',\n      inputOp: 'text',\n      inputName: 'OPERAND2'\n    }]\n  },\n  '>': {\n    opcode: 'operator_gt',\n    argMap: [{\n      type: 'input',\n      inputOp: 'text',\n      inputName: 'OPERAND1'\n    }, {\n      type: 'input',\n      inputOp: 'text',\n      inputName: 'OPERAND2'\n    }]\n  },\n  '&': {\n    opcode: 'operator_and',\n    argMap: [{\n      type: 'input',\n      inputOp: 'boolean',\n      inputName: 'OPERAND1'\n    }, {\n      type: 'input',\n      inputOp: 'boolean',\n      inputName: 'OPERAND2'\n    }]\n  },\n  '|': {\n    opcode: 'operator_or',\n    argMap: [{\n      type: 'input',\n      inputOp: 'boolean',\n      inputName: 'OPERAND1'\n    }, {\n      type: 'input',\n      inputOp: 'boolean',\n      inputName: 'OPERAND2'\n    }]\n  },\n  'not': {\n    opcode: 'operator_not',\n    argMap: [{\n      type: 'input',\n      inputOp: 'boolean',\n      inputName: 'OPERAND'\n    }]\n  },\n  'concatenate:with:': {\n    opcode: 'operator_join',\n    argMap: [{\n      type: 'input',\n      inputOp: 'text',\n      inputName: 'STRING1'\n    }, {\n      type: 'input',\n      inputOp: 'text',\n      inputName: 'STRING2'\n    }]\n  },\n  'letter:of:': {\n    opcode: 'operator_letter_of',\n    argMap: [{\n      type: 'input',\n      inputOp: 'math_whole_number',\n      inputName: 'LETTER'\n    }, {\n      type: 'input',\n      inputOp: 'text',\n      inputName: 'STRING'\n    }]\n  },\n  'stringLength:': {\n    opcode: 'operator_length',\n    argMap: [{\n      type: 'input',\n      inputOp: 'text',\n      inputName: 'STRING'\n    }]\n  },\n  '%': {\n    opcode: 'operator_mod',\n    argMap: [{\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'NUM1'\n    }, {\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'NUM2'\n    }]\n  },\n  'rounded': {\n    opcode: 'operator_round',\n    argMap: [{\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'NUM'\n    }]\n  },\n  'computeFunction:of:': {\n    opcode: 'operator_mathop',\n    argMap: [{\n      type: 'field',\n      fieldName: 'OPERATOR'\n    }, {\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'NUM'\n    }]\n  },\n  'readVariable': {\n    opcode: 'data_variable',\n    argMap: [{\n      type: 'field',\n      fieldName: 'VARIABLE',\n      variableType: Variable.SCALAR_TYPE\n    }]\n  },\n  // Scratch 2 uses this alternative variable getter opcode only in monitors,\n  // blocks use the `readVariable` opcode above.\n  'getVar:': {\n    opcode: 'data_variable',\n    argMap: [{\n      type: 'field',\n      fieldName: 'VARIABLE',\n      variableType: Variable.SCALAR_TYPE\n    }]\n  },\n  'setVar:to:': {\n    opcode: 'data_setvariableto',\n    argMap: [{\n      type: 'field',\n      fieldName: 'VARIABLE',\n      variableType: Variable.SCALAR_TYPE\n    }, {\n      type: 'input',\n      inputOp: 'text',\n      inputName: 'VALUE'\n    }]\n  },\n  'changeVar:by:': {\n    opcode: 'data_changevariableby',\n    argMap: [{\n      type: 'field',\n      fieldName: 'VARIABLE',\n      variableType: Variable.SCALAR_TYPE\n    }, {\n      type: 'input',\n      inputOp: 'math_number',\n      inputName: 'VALUE'\n    }]\n  },\n  'showVariable:': {\n    opcode: 'data_showvariable',\n    argMap: [{\n      type: 'field',\n      fieldName: 'VARIABLE',\n      variableType: Variable.SCALAR_TYPE\n    }]\n  },\n  'hideVariable:': {\n    opcode: 'data_hidevariable',\n    argMap: [{\n      type: 'field',\n      fieldName: 'VARIABLE',\n      variableType: Variable.SCALAR_TYPE\n    }]\n  },\n  'contentsOfList:': {\n    opcode: 'data_listcontents',\n    argMap: [{\n      type: 'field',\n      fieldName: 'LIST',\n      variableType: Variable.LIST_TYPE\n    }]\n  },\n  'append:toList:': {\n    opcode: 'data_addtolist',\n    argMap: [{\n      type: 'input',\n      inputOp: 'text',\n      inputName: 'ITEM'\n    }, {\n      type: 'field',\n      fieldName: 'LIST',\n      variableType: Variable.LIST_TYPE\n    }]\n  },\n  'deleteLine:ofList:': {\n    opcode: 'data_deleteoflist',\n    argMap: [{\n      type: 'input',\n      inputOp: 'math_integer',\n      inputName: 'INDEX'\n    }, {\n      type: 'field',\n      fieldName: 'LIST',\n      variableType: Variable.LIST_TYPE\n    }]\n  },\n  'insert:at:ofList:': {\n    opcode: 'data_insertatlist',\n    argMap: [{\n      type: 'input',\n      inputOp: 'text',\n      inputName: 'ITEM'\n    }, {\n      type: 'input',\n      inputOp: 'math_integer',\n      inputName: 'INDEX'\n    }, {\n      type: 'field',\n      fieldName: 'LIST',\n      variableType: Variable.LIST_TYPE\n    }]\n  },\n  'setLine:ofList:to:': {\n    opcode: 'data_replaceitemoflist',\n    argMap: [{\n      type: 'input',\n      inputOp: 'math_integer',\n      inputName: 'INDEX'\n    }, {\n      type: 'field',\n      fieldName: 'LIST',\n      variableType: Variable.LIST_TYPE\n    }, {\n      type: 'input',\n      inputOp: 'text',\n      inputName: 'ITEM'\n    }]\n  },\n  'getLine:ofList:': {\n    opcode: 'data_itemoflist',\n    argMap: [{\n      type: 'input',\n      inputOp: 'math_integer',\n      inputName: 'INDEX'\n    }, {\n      type: 'field',\n      fieldName: 'LIST',\n      variableType: Variable.LIST_TYPE\n    }]\n  },\n  'lineCountOfList:': {\n    opcode: 'data_lengthoflist',\n    argMap: [{\n      type: 'field',\n      fieldName: 'LIST',\n      variableType: Variable.LIST_TYPE\n    }]\n  },\n  'list:contains:': {\n    opcode: 'data_listcontainsitem',\n    argMap: [{\n      type: 'field',\n      fieldName: 'LIST',\n      variableType: Variable.LIST_TYPE\n    }, {\n      type: 'input',\n      inputOp: 'text',\n      inputName: 'ITEM'\n    }]\n  },\n  'showList:': {\n    opcode: 'data_showlist',\n    argMap: [{\n      type: 'field',\n      fieldName: 'LIST',\n      variableType: Variable.LIST_TYPE\n    }]\n  },\n  'hideList:': {\n    opcode: 'data_hidelist',\n    argMap: [{\n      type: 'field',\n      fieldName: 'LIST',\n      variableType: Variable.LIST_TYPE\n    }]\n  },\n  'procDef': {\n    opcode: 'procedures_definition',\n    argMap: []\n  },\n  'getParam': {\n    // Doesn't map to single opcode. Import step assigns final correct opcode.\n    opcode: 'argument_reporter_string_number',\n    argMap: [{\n      type: 'field',\n      fieldName: 'VALUE'\n    }]\n  },\n  'call': {\n    opcode: 'procedures_call',\n    argMap: []\n  }\n};\n/**\n * Add to the specMap entries for an opcode from a Scratch 2.0 extension. Two entries will be made with the same\n * metadata; this is done to support projects saved by both older and newer versions of the Scratch 2.0 editor.\n * @param {string} sb2Extension - the Scratch 2.0 name of the extension\n * @param {string} sb2Opcode - the Scratch 2.0 opcode\n * @param {SB2SpecMap_blockInfo} blockInfo - the Scratch 3.0 block info\n */\nvar addExtensionOp = function addExtensionOp(sb2Extension, sb2Opcode, blockInfo) {\n  /**\n   * This string separates the name of an extension and the name of an opcode in more recent Scratch 2.0 projects.\n   * Earlier projects used '.' as a separator, up until we added the 'LEGO WeDo 2.0' extension...\n   * @type {string}\n   */\n  var sep = \"\\x1F\"; // Unicode Unit Separator\n  // make one entry for projects saved by recent versions of the Scratch 2.0 editor\n  specMap[\"\".concat(sb2Extension).concat(sep).concat(sb2Opcode)] = blockInfo; // make a second for projects saved by older versions of the Scratch 2.0 editor\n  specMap[\"\".concat(sb2Extension, \".\").concat(sb2Opcode)] = blockInfo;\n};\nvar weDo2 = 'LEGO WeDo 2.0';\naddExtensionOp(weDo2, 'motorOnFor', {\n  opcode: 'wedo2_motorOnFor',\n  argMap: [{\n    type: 'input',\n    inputOp: 'wedo2_menu_MOTOR_ID',\n    inputName: 'MOTOR_ID'\n  }, {\n    type: 'input',\n    inputOp: 'math_number',\n    inputName: 'DURATION'\n  }]\n});\naddExtensionOp(weDo2, 'motorOn', {\n  opcode: 'wedo2_motorOn',\n  argMap: [{\n    type: 'input',\n    inputOp: 'wedo2_menu_MOTOR_ID',\n    inputName: 'MOTOR_ID'\n  }]\n});\naddExtensionOp(weDo2, 'motorOff', {\n  opcode: 'wedo2_motorOff',\n  argMap: [{\n    type: 'input',\n    inputOp: 'wedo2_menu_MOTOR_ID',\n    inputName: 'MOTOR_ID'\n  }]\n});\naddExtensionOp(weDo2, 'startMotorPower', {\n  opcode: 'wedo2_startMotorPower',\n  argMap: [{\n    type: 'input',\n    inputOp: 'wedo2_menu_MOTOR_ID',\n    inputName: 'MOTOR_ID'\n  }, {\n    type: 'input',\n    inputOp: 'math_number',\n    inputName: 'POWER'\n  }]\n});\naddExtensionOp(weDo2, 'setMotorDirection', {\n  opcode: 'wedo2_setMotorDirection',\n  argMap: [{\n    type: 'input',\n    inputOp: 'wedo2_menu_MOTOR_ID',\n    inputName: 'MOTOR_ID'\n  }, {\n    type: 'input',\n    inputOp: 'wedo2_menu_MOTOR_DIRECTION',\n    inputName: 'MOTOR_DIRECTION'\n  }]\n});\naddExtensionOp(weDo2, 'setLED', {\n  opcode: 'wedo2_setLightHue',\n  argMap: [{\n    type: 'input',\n    inputOp: 'math_number',\n    inputName: 'HUE'\n  }]\n});\naddExtensionOp(weDo2, 'playNote', {\n  opcode: 'wedo2_playNoteFor',\n  argMap: [{\n    type: 'input',\n    inputOp: 'math_number',\n    inputName: 'NOTE'\n  }, {\n    type: 'input',\n    inputOp: 'math_number',\n    inputName: 'DURATION'\n  }]\n});\naddExtensionOp(weDo2, 'whenDistance', {\n  opcode: 'wedo2_whenDistance',\n  argMap: [{\n    type: 'input',\n    inputOp: 'wedo2_menu_OP',\n    inputName: 'OP'\n  }, {\n    type: 'input',\n    inputOp: 'math_number',\n    inputName: 'REFERENCE'\n  }]\n});\naddExtensionOp(weDo2, 'whenTilted', {\n  opcode: 'wedo2_whenTilted',\n  argMap: [{\n    type: 'input',\n    inputOp: 'wedo2_menu_TILT_DIRECTION_ANY',\n    inputName: 'TILT_DIRECTION_ANY'\n  }]\n});\naddExtensionOp(weDo2, 'getDistance', {\n  opcode: 'wedo2_getDistance',\n  argMap: []\n});\naddExtensionOp(weDo2, 'isTilted', {\n  opcode: 'wedo2_isTilted',\n  argMap: [{\n    type: 'input',\n    inputOp: 'wedo2_menu_TILT_DIRECTION_ANY',\n    inputName: 'TILT_DIRECTION_ANY'\n  }]\n});\naddExtensionOp(weDo2, 'getTilt', {\n  opcode: 'wedo2_getTiltAngle',\n  argMap: [{\n    type: 'input',\n    inputOp: 'wedo2_menu_TILT_DIRECTION',\n    inputName: 'TILT_DIRECTION'\n  }]\n});\nmodule.exports = specMap;\n })