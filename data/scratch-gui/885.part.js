/* 885 */\n (function(module, exports, __webpack_require__) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FLUSH = exports.CANCEL = undefined;\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\nexports.default = middleware;\nvar _lodash = __webpack_require__(334);\nvar _lodash2 = _interopRequireDefault(_lodash);\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nvar CANCEL = exports.CANCEL = 'redux-throttle/CANCEL';\nvar FLUSH = exports.FLUSH = 'redux-throttle/FLUSH';\nfunction map(throttled, action, method) {\n  if (action.payload && action.payload.type) {\n    var _ret = function () {\n      var types = action.payload.type;\n      if (!Array.isArray(types)) {\n        types = [types];\n      }\n      Object.keys(throttled).filter(function (t) {\n        return types.includes(t);\n      }).forEach(function (t) {\n        return throttled[t][method]();\n      });\n      return {\n        v: void 0\n      };\n    }();\n    if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n  }\n  Object.keys(throttled).forEach(function (t) {\n    return throttled[t][method]();\n  });\n  return;\n}\nfunction middleware() {\n  var defaultWait = arguments.length <= 0 || arguments[0] === undefined ? 300 : arguments[0];\n  var defaultThrottleOption = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n  var throttled = {};\n  return function (store) {\n    return function (next) {\n      return function (action) {\n        if (action.type === CANCEL) {\n          map(throttled, action, 'cancel');\n          return next(action);\n        }\n        if (action.type === FLUSH) {\n          map(throttled, action, 'flush');\n          return next(action);\n        }\n        var shouldThrottle = (action.meta || {}).throttle;\n        // check if we don't need to throttle the action\n        if (!shouldThrottle) {\n          return next(action);\n        }\n        if (throttled[action.type]) {\n          // if it's a action which was throttled already\n          return throttled[action.type](action);\n        }\n        var wait = defaultWait;\n        var options = defaultThrottleOption;\n        if (!isNaN(shouldThrottle) && shouldThrottle !== true) {\n          wait = shouldThrottle;\n        } else if ((typeof shouldThrottle === 'undefined' ? 'undefined' : _typeof(shouldThrottle)) === 'object') {\n          wait = shouldThrottle.wait || defaultWait;\n          options = _extends({}, defaultThrottleOption, shouldThrottle);\n        }\n        throttled[action.type] = (0, _lodash2.default)(next, wait, options);\n        return throttled[action.type](action);\n      };\n    };\n  };\n}\n })