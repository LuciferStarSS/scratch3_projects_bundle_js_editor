/* 1191 */\n (function(module, exports, __webpack_require__) {\n\"use strict\";\n/*\nCopyright (c) 2014, Yahoo! Inc. All rights reserved.\nCopyrights licensed under the New BSD License.\nSee the accompanying LICENSE file for terms.\n*/\n/* jslint esnext: true */\nexports[\"default\"] = Compiler;\nfunction Compiler(locales, formats, pluralFn) {\n    this.locales  = locales;\n    this.formats  = formats;\n    this.pluralFn = pluralFn;\n}\nCompiler.prototype.compile = function (ast) {\n    this.pluralStack        = [];\n    this.currentPlural      = null;\n    this.pluralNumberFormat = null;\n    return this.compileMessage(ast);\n};\nCompiler.prototype.compileMessage = function (ast) {\n    if (!(ast && ast.type === 'messageFormatPattern')) {\n        throw new Error('Message AST is not of type: \"messageFormatPattern\"');\n    }\n    var elements = ast.elements,\n        pattern  = [];\n    var i, len, element;\n    for (i = 0, len = elements.length; i < len; i += 1) {\n        element = elements[i];\n        switch (element.type) {\n            case 'messageTextElement':\n                pattern.push(this.compileMessageText(element));\n                break;\n            case 'argumentElement':\n                pattern.push(this.compileArgument(element));\n                break;\n            default:\n                throw new Error('Message element does not have a valid type');\n        }\n    }\n    return pattern;\n};\nCompiler.prototype.compileMessageText = function (element) {\n    // When this `element` is part of plural sub-pattern and its value contains\n    // an unescaped '#', use a `PluralOffsetString` helper to properly output\n    // the number with the correct offset in the string.\n    if (this.currentPlural && /(^|[^\\\\])#/g.test(element.value)) {\n        // Create a cache a NumberFormat instance that can be reused for any\n        // PluralOffsetString instance in this message.\n        if (!this.pluralNumberFormat) {\n            this.pluralNumberFormat = new Intl.NumberFormat(this.locales);\n        }\n        return new PluralOffsetString(\n                this.currentPlural.id,\n                this.currentPlural.format.offset,\n                this.pluralNumberFormat,\n                element.value);\n    }\n    // Unescape the escaped '#'s in the message text.\n    return element.value.replace(/\\\\#/g, '#');\n};\nCompiler.prototype.compileArgument = function (element) {\n    var format = element.format;\n    if (!format) {\n        return new StringFormat(element.id);\n    }\n    var formats  = this.formats,\n        locales  = this.locales,\n        pluralFn = this.pluralFn,\n        options;\n    switch (format.type) {\n        case 'numberFormat':\n            options = formats.number[format.style];\n            return {\n                id    : element.id,\n                format: new Intl.NumberFormat(locales, options).format\n            };\n        case 'dateFormat':\n            options = formats.date[format.style];\n            return {\n                id    : element.id,\n                format: new Intl.DateTimeFormat(locales, options).format\n            };\n        case 'timeFormat':\n            options = formats.time[format.style];\n            return {\n                id    : element.id,\n                format: new Intl.DateTimeFormat(locales, options).format\n            };\n        case 'pluralFormat':\n            options = this.compileOptions(element);\n            return new PluralFormat(\n                element.id, format.ordinal, format.offset, options, pluralFn\n            );\n        case 'selectFormat':\n            options = this.compileOptions(element);\n            return new SelectFormat(element.id, options);\n        default:\n            throw new Error('Message element does not have a valid format type');\n    }\n};\nCompiler.prototype.compileOptions = function (element) {\n    var format      = element.format,\n        options     = format.options,\n        optionsHash = {};\n    // Save the current plural element, if any, then set it to a new value when\n    // compiling the options sub-patterns. This conforms the spec's algorithm\n    // for handling `\"#\"` syntax in message text.\n    this.pluralStack.push(this.currentPlural);\n    this.currentPlural = format.type === 'pluralFormat' ? element : null;\n    var i, len, option;\n    for (i = 0, len = options.length; i < len; i += 1) {\n        option = options[i];\n        // Compile the sub-pattern and save it under the options's selector.\n        optionsHash[option.selector] = this.compileMessage(option.value);\n    }\n    // Pop the plural stack to put back the original current plural value.\n    this.currentPlural = this.pluralStack.pop();\n    return optionsHash;\n};\n// -- Compiler Helper Classes --------------------------------------------------\nfunction StringFormat(id) {\n    this.id = id;\n}\nStringFormat.prototype.format = function (value) {\n    if (!value && typeof value !== 'number') {\n        return '';\n    }\n    return typeof value === 'string' ? value : String(value);\n};\nfunction PluralFormat(id, useOrdinal, offset, options, pluralFn) {\n    this.id         = id;\n    this.useOrdinal = useOrdinal;\n    this.offset     = offset;\n    this.options    = options;\n    this.pluralFn   = pluralFn;\n}\nPluralFormat.prototype.getOption = function (value) {\n    var options = this.options;\n    var option = options['=' + value] ||\n            options[this.pluralFn(value - this.offset, this.useOrdinal)];\n    return option || options.other;\n};\nfunction PluralOffsetString(id, offset, numberFormat, string) {\n    this.id           = id;\n    this.offset       = offset;\n    this.numberFormat = numberFormat;\n    this.string       = string;\n}\nPluralOffsetString.prototype.format = function (value) {\n    var number = this.numberFormat.format(value - this.offset);\n    return this.string\n            .replace(/(^|[^\\\\])#/g, '$1' + number)\n            .replace(/\\\\#/g, '#');\n};\nfunction SelectFormat(id, options) {\n    this.id      = id;\n    this.options = options;\n}\nSelectFormat.prototype.getOption = function (value) {\n    var options = this.options;\n    return options[value] || options.other;\n};\n/*# sourceMappingURL=compiler.js.map*/\n })