/* 981 */\n (function(module, exports, __webpack_require__) {\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nvar ArgumentType = __webpack_require__(63);\nvar BlockType = __webpack_require__(45);\nvar Cast = __webpack_require__(48);\nvar formatMessage = __webpack_require__(71);\nvar color = __webpack_require__(180);\nvar BLE = __webpack_require__(221);\nvar Base64Util = __webpack_require__(182);\nvar MathUtil = __webpack_require__(62);\nvar RateLimiter = __webpack_require__(298);\nvar log = __webpack_require__(39);\n/**\n * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.\n * @type {string}\n */\n// eslint-disable-next-line max-len\nvar iconURI = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAACXBIWXMAABYlAAAWJQFJUiTwAAAF8klEQVR4Ae2cbWxTVRjH/7ctbVc2tyEMNpWBk0VIkLcEjSAQgglTE5HEaKqJi1E/mbCP/dJA0kQbvzgTQ0Ki2T7V6AeYGoEPLJmGKPiyzZDwEpYJCHSbQIcbdLvres1zOa13Xbvdu2eTDp9fst329Lnn5XfPPfece7tphmFAmDkuccdDBDIRgUxEIBMRyEQEMhGBTEQgExHIRAQyEYFMRCATEchEBDIRgUxEIBMRyEQEMhGBTEQgExHIxMPNIByNVQBoBUDb7kgo2KTS9wBoUmFNkVCwW6U3A1gP4JJKHwxHY/S+WcW2RkLBVhV7AMAOAIMAGlWstbyOSCh4QMU2Uoy1PBVL+a7IqZu1vOZIKNg20/azBarGvKxebw9HY22RULADwBFLTBcATQnZl4lVEimN4ssteXQrQfstebQpmW1q30xshyqvxRLbofYnYW9ZYgeV8C5LLOWlzbTxM3ouHI7GPgSwWx3Z0syBSBku6IYnlTbM+uQenJQaMnKHDaqAFnDrcCFbl3G1defEjas0a4N/Vz10OybyvapfrSX1sjpo+WIz0ME7QL3djgtHPTAcjb2mepw/b2ZaGh5NL5RnofR8R99dIC5fHusK5JsrCUpm7TSx21XvbcwTNwnbAsPR2GcA3qaG+H0LsHlDPZ7fca/ujZ+cRW9/Em5vCXzlNVhQUjFpf/3OTSRvXkKJz43Xt1bh1S1LUeq/5+njQ9/iVmLIfL1ieRU2b1iFtavztXNu6TrTi8PfnYI67WdPoOp5przV9Y8iuHdb9rOW9uumPI+vDIElddBckztPOqVn5X36Xj1WVQeynx1sOWbK83jc2PviM/dFXIYNax9H55leXLoyYHsfWwI14JCRRx7x5ckBU1oheYQ+1G9u39lVM0Hej7+cR7w/Yb7e9+5LqChfaLvixcK088BwNNZkAOV02ubK6+odwt3RcfOULSSPGEveG48bNj08If3kqXPmdtO6unkpDzYn0u/TLxrzcumJJ80Ut79sygzoFF6/siw75mUYupOEpmnY0/A0pw33FTsCa+hX5oJhZXgkZb5zub2O20CnL7EwkPeCPm+wI7CEBvi5wuOZ36tJW7X3uGXJXAgxk8P4eNpRPEvgskqfuR0Z/BNGejxvDM3/5gs0pboWv+motqybCc+tqUCzz43kaBJ/X+2eMjZ3ClNsjIzo5ioknXZ2b4AlkKYltLJoaY9jOJm/B0KJbtg4c4F/XOmH3+dF9dLKbBo1OD6QQGV56YQ55ODtO0jcHkZ1VSX8/n9nB9S7RkZ1rFy+NG8ZR9s70TeQQKDEh7vJUdt1Y9/OopXFB2/WcbMpyOexE9mlFS21aLlHMmKHfzBl0QT/hV2bzM9oLXv0xG8YGR0zpdLEn6RT2k+/XjDzoLX2G3u3TZBLUyral/Z5qCyAK1f/sl2/or+IWNel1Eji3MWrpjyCZHWqdNrSe6ieSHFERl4mP+q5GehgHGvvRGal5XI5uzU47f3A/R99YTgdF2wXrmkolr9ToZ5NvTjT4yOhoC2T057CJM/r9WDxoqmXa07R9THcuDVcMO8bt4ag6ynULKvkFjWBTLl0ugZKvNlyqLeSQKfYGgOpgXt2b5zVhlzrS+Dr451YvKg0b95txztxvS8xZ+VuXFuLJ5+oNgV+9c3PuHDxGs6cu+w4v//9RJo6x5bN9UgbBo4cPY1U6j+cSD8orFvzGFYuX4KxsRQGbth6FCICc9m5dY05HtN46AQRqPB5PWjY+ZT5RnMwkxGBFh5ZVmle9Z3MrGbjwfqccrC1vajrV7QCaVCfS6qrJj96nQlFK5CujPRT7MgYyEQEMhGBTGwJpAW4kJ9pBbo0zbx70X7y7AOv8HxP3LyB4YTpb2cZBt2iqL3QEwf9zDbX+waLca439QMeC7a+YBmOxugLiM/OTt2yaOoMoO+H6LOcNwf6xusrthsh/7mIh1yFmYhAJiKQiQhkIgKZiEAmIpCJCGQiApmIQCYikIkIZCICmYhAJiKQiQhkIgKZiEAmIpCJCGQiAjkA+AeOwQKMcWZqHgAAAABJRU5ErkJggg==';\n/**\n * A list of WeDo 2.0 BLE service UUIDs.\n * @enum\n */\nvar BLEService = {\n  DEVICE_SERVICE: '00001523-1212-efde-1523-785feabcd123',\n  IO_SERVICE: '00004f0e-1212-efde-1523-785feabcd123'\n};\n/**\n * A list of WeDo 2.0 BLE characteristic UUIDs.\n *\n * Characteristics on DEVICE_SERVICE:\n * - ATTACHED_IO\n *\n * Characteristics on IO_SERVICE:\n * - INPUT_VALUES\n * - INPUT_COMMAND\n * - OUTPUT_COMMAND\n *\n * @enum\n */\nvar BLECharacteristic = {\n  ATTACHED_IO: '00001527-1212-efde-1523-785feabcd123',\n  LOW_VOLTAGE_ALERT: '00001528-1212-efde-1523-785feabcd123',\n  INPUT_VALUES: '00001560-1212-efde-1523-785feabcd123',\n  INPUT_COMMAND: '00001563-1212-efde-1523-785feabcd123',\n  OUTPUT_COMMAND: '00001565-1212-efde-1523-785feabcd123'\n};\n/**\n * A time interval to wait (in milliseconds) in between battery check calls.\n * @type {number}\n */\nvar BLEBatteryCheckInterval = 5000;\n/**\n * A time interval to wait (in milliseconds) while a block that sends a BLE message is running.\n * @type {number}\n */\nvar BLESendInterval = 100;\n/**\n * A maximum number of BLE message sends per second, to be enforced by the rate limiter.\n * @type {number}\n */\nvar BLESendRateMax = 20;\n/**\n * Enum for WeDo 2.0 sensor and output types.\n * @readonly\n * @enum {number}\n */\nvar WeDo2Device = {\n  MOTOR: 1,\n  PIEZO: 22,\n  LED: 23,\n  TILT: 34,\n  DISTANCE: 35\n};\n/**\n * Enum for connection/port ids assigned to internal WeDo 2.0 output devices.\n * @readonly\n * @enum {number}\n */\n// TODO: Check for these more accurately at startup?\nvar WeDo2ConnectID = {\n  LED: 6,\n  PIEZO: 5\n};\n/**\n * Enum for ids for various output commands on the WeDo 2.0.\n * @readonly\n * @enum {number}\n */\nvar WeDo2Command = {\n  MOTOR_POWER: 1,\n  PLAY_TONE: 2,\n  STOP_TONE: 3,\n  WRITE_RGB: 4,\n  SET_VOLUME: 255\n};\n/**\n * Enum for modes for input sensors on the WeDo 2.0.\n * @enum {number}\n */\nvar WeDo2Mode = {\n  TILT: 0,\n  // angle\n  DISTANCE: 0,\n  // detect\n  LED: 1 // RGB\n};\n/**\n * Enum for units for input sensors on the WeDo 2.0.\n *\n * 0 = raw\n * 1 = percent\n *\n * @enum {number}\n */\nvar WeDo2Unit = {\n  TILT: 0,\n  DISTANCE: 1,\n  LED: 0\n};\n/**\n * Manage power, direction, and timers for one WeDo 2.0 motor.\n */\nvar WeDo2Motor = function () {\n  /**\n   * Construct a WeDo 2.0 Motor instance.\n   * @param {WeDo2} parent - the WeDo 2.0 peripheral which owns this motor.\n   * @param {int} index - the zero-based index of this motor on its parent peripheral.\n   */\n  function WeDo2Motor(parent, index) {\n    _classCallCheck(this, WeDo2Motor);\n    /**\n     * The WeDo 2.0 peripheral which owns this motor.\n     * @type {WeDo2}\n     * @private\n     */\n    this._parent = parent;\n    /**\n     * The zero-based index of this motor on its parent peripheral.\n     * @type {int}\n     * @private\n     */\n    this._index = index;\n    /**\n     * This motor's current direction: 1 for \"this way\" or -1 for \"that way\"\n     * @type {number}\n     * @private\n     */\n    this._direction = 1;\n    /**\n     * This motor's current power level, in the range [0,100].\n     * @type {number}\n     * @private\n     */\n    this._power = 100;\n    /**\n     * Is this motor currently moving?\n     * @type {boolean}\n     * @private\n     */\n    this._isOn = false;\n    /**\n     * If the motor has been turned on or is actively braking for a specific duration, this is the timeout ID for\n     * the end-of-action handler. Cancel this when changing plans.\n     * @type {Object}\n     * @private\n     */\n    this._pendingTimeoutId = null;\n    /**\n     * The starting time for the pending timeout.\n     * @type {Object}\n     * @private\n     */\n    this._pendingTimeoutStartTime = null;\n    /**\n     * The delay/duration of the pending timeout.\n     * @type {Object}\n     * @private\n     */\n    this._pendingTimeoutDelay = null;\n    this.startBraking = this.startBraking.bind(this);\n    this.turnOff = this.turnOff.bind(this);\n  }\n  /**\n   * @return {number} - the duration of active braking after a call to startBraking(). Afterward, turn the motor off.\n   * @constructor\n   */\n  _createClass(WeDo2Motor, [{\n    key: \"turnOn\",\n    /**\n     * Turn this motor on indefinitely.\n     */\n    value: function turnOn() {\n      if (this._power === 0) return;\n      var cmd = this._parent.generateOutputCommand(this._index + 1, WeDo2Command.MOTOR_POWER, [this._power * this._direction] // power in range 0-100\n      );\n      this._parent.send(BLECharacteristic.OUTPUT_COMMAND, cmd);\n      this._isOn = true;\n      this._clearTimeout();\n    }\n    /**\n     * Turn this motor on for a specific duration.\n     * @param {number} milliseconds - run the motor for this long.\n     */\n  }, {\n    key: \"turnOnFor\",\n    value: function turnOnFor(milliseconds) {\n      if (this._power === 0) return;\n      milliseconds = Math.max(0, milliseconds);\n      this.turnOn();\n      this._setNewTimeout(this.startBraking, milliseconds);\n    }\n    /**\n     * Start active braking on this motor. After a short time, the motor will turn off.\n     */\n  }, {\n    key: \"startBraking\",\n    value: function startBraking() {\n      if (this._power === 0) return;\n      var cmd = this._parent.generateOutputCommand(this._index + 1, WeDo2Command.MOTOR_POWER, [127] // 127 = break\n      );\n      this._parent.send(BLECharacteristic.OUTPUT_COMMAND, cmd);\n      this._isOn = false;\n      this._setNewTimeout(this.turnOff, WeDo2Motor.BRAKE_TIME_MS);\n    }\n    /**\n     * Turn this motor off.\n     * @param {boolean} [useLimiter=true] - if true, use the rate limiter\n     */\n  }, {\n    key: \"turnOff\",\n    value: function turnOff() {\n      var useLimiter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      if (this._power === 0) return;\n      var cmd = this._parent.generateOutputCommand(this._index + 1, WeDo2Command.MOTOR_POWER, [0] // 0 = stop\n      );\n      this._parent.send(BLECharacteristic.OUTPUT_COMMAND, cmd, useLimiter);\n      this._isOn = false;\n    }\n    /**\n     * Clear the motor action timeout, if any. Safe to call even when there is no pending timeout.\n     * @private\n     */\n  }, {\n    key: \"_clearTimeout\",\n    value: function _clearTimeout() {\n      if (this._pendingTimeoutId !== null) {\n        clearTimeout(this._pendingTimeoutId);\n        this._pendingTimeoutId = null;\n        this._pendingTimeoutStartTime = null;\n        this._pendingTimeoutDelay = null;\n      }\n    }\n    /**\n     * Set a new motor action timeout, after clearing an existing one if necessary.\n     * @param {Function} callback - to be called at the end of the timeout.\n     * @param {int} delay - wait this many milliseconds before calling the callback.\n     * @private\n     */\n  }, {\n    key: \"_setNewTimeout\",\n    value: function _setNewTimeout(callback, delay) {\n      var _this = this;\n      this._clearTimeout();\n      var timeoutID = setTimeout(function () {\n        if (_this._pendingTimeoutId === timeoutID) {\n          _this._pendingTimeoutId = null;\n          _this._pendingTimeoutStartTime = null;\n          _this._pendingTimeoutDelay = null;\n        }\n        callback();\n      }, delay);\n      this._pendingTimeoutId = timeoutID;\n      this._pendingTimeoutStartTime = Date.now();\n      this._pendingTimeoutDelay = delay;\n    }\n  }, {\n    key: \"direction\",\n    /**\n     * @return {int} - this motor's current direction: 1 for \"this way\" or -1 for \"that way\"\n     */\n    get: function get() {\n      return this._direction;\n    }\n    /**\n     * @param {int} value - this motor's new direction: 1 for \"this way\" or -1 for \"that way\"\n     */\n    ,\n    set: function set(value) {\n      if (value < 0) {\n        this._direction = -1;\n      } else {\n        this._direction = 1;\n      }\n    }\n    /**\n     * @return {int} - this motor's current power level, in the range [0,100].\n     */\n  }, {\n    key: \"power\",\n    get: function get() {\n      return this._power;\n    }\n    /**\n     * @param {int} value - this motor's new power level, in the range [0,100].\n     */\n    ,\n    set: function set(value) {\n      var p = Math.max(0, Math.min(value, 100)); // Lego Wedo 2.0 hub only turns motors at power range [30 - 100], so\n      // map value from [0 - 100] to [30 - 100].\n      if (p === 0) {\n        this._power = 0;\n      } else {\n        var delta = 100 / p;\n        this._power = 30 + 70 / delta;\n      }\n    }\n    /**\n     * @return {boolean} - true if this motor is currently moving, false if this motor is off or braking.\n     */\n  }, {\n    key: \"isOn\",\n    get: function get() {\n      return this._isOn;\n    }\n    /**\n     * @return {boolean} - time, in milliseconds, of when the pending timeout began.\n     */\n  }, {\n    key: \"pendingTimeoutStartTime\",\n    get: function get() {\n      return this._pendingTimeoutStartTime;\n    }\n    /**\n     * @return {boolean} - delay, in milliseconds, of the pending timeout.\n     */\n  }, {\n    key: \"pendingTimeoutDelay\",\n    get: function get() {\n      return this._pendingTimeoutDelay;\n    }\n  }], [{\n    key: \"BRAKE_TIME_MS\",\n    get: function get() {\n      return 1000;\n    }\n  }]);\n  return WeDo2Motor;\n}();\n/**\n * Manage communication with a WeDo 2.0 peripheral over a Bluetooth Low Energy client socket.\n */\nvar WeDo2 = function () {\n  function WeDo2(runtime, extensionId) {\n    _classCallCheck(this, WeDo2);\n    /**\n     * The Scratch 3.0 runtime used to trigger the green flag button.\n     * @type {Runtime}\n     * @private\n     */\n    this._runtime = runtime;\n    this._runtime.on('PROJECT_STOP_ALL', this.stopAll.bind(this));\n    /**\n     * The id of the extension this peripheral belongs to.\n     */\n    this._extensionId = extensionId;\n    /**\n     * A list of the ids of the motors or sensors in ports 1 and 2.\n     * @type {string[]}\n     * @private\n     */\n    this._ports = ['none', 'none'];\n    /**\n     * The motors which this WeDo 2.0 could possibly have.\n     * @type {WeDo2Motor[]}\n     * @private\n     */\n    this._motors = [null, null];\n    /**\n     * The most recently received value for each sensor.\n     * @type {Object.<string, number>}\n     * @private\n     */\n    this._sensors = {\n      tiltX: 0,\n      tiltY: 0,\n      distance: 0\n    };\n    /**\n     * The Bluetooth connection socket for reading/writing peripheral data.\n     * @type {BLE}\n     * @private\n     */\n    this._ble = null;\n    this._runtime.registerPeripheralExtension(extensionId, this);\n    /**\n     * A rate limiter utility, to help limit the rate at which we send BLE messages\n     * over the socket to Scratch Link to a maximum number of sends per second.\n     * @type {RateLimiter}\n     * @private\n     */\n    this._rateLimiter = new RateLimiter(BLESendRateMax);\n    /**\n     * An interval id for the battery check interval.\n     * @type {number}\n     * @private\n     */\n    this._batteryLevelIntervalId = null;\n    this.reset = this.reset.bind(this);\n    this._onConnect = this._onConnect.bind(this);\n    this._onMessage = this._onMessage.bind(this);\n    this._checkBatteryLevel = this._checkBatteryLevel.bind(this);\n  }\n  /**\n   * @return {number} - the latest value received for the tilt sensor's tilt about the X axis.\n   */\n  _createClass(WeDo2, [{\n    key: \"motor\",\n    /**\n     * Access a particular motor on this peripheral.\n     * @param {int} index - the zero-based index of the desired motor.\n     * @return {WeDo2Motor} - the WeDo2Motor instance, if any, at that index.\n     */\n    value: function motor(index) {\n      return this._motors[index];\n    }\n    /**\n     * Stop all the motors that are currently running.\n     */\n  }, {\n    key: \"stopAllMotors\",\n    value: function stopAllMotors() {\n      this._motors.forEach(function (motor) {\n        if (motor) {\n          // Send the motor off command without using the rate limiter.\n          // This allows the stop button to stop motors even if we are\n          // otherwise flooded with commands.\n          motor.turnOff(false);\n        }\n      });\n    }\n    /**\n     * Set the WeDo 2.0 peripheral's LED to a specific color.\n     * @param {int} inputRGB - a 24-bit RGB color in 0xRRGGBB format.\n     * @return {Promise} - a promise of the completion of the set led send operation.\n     */\n  }, {\n    key: \"setLED\",\n    value: function setLED(inputRGB) {\n      var rgb = [inputRGB >> 16 & 0x000000FF, inputRGB >> 8 & 0x000000FF, inputRGB & 0x000000FF];\n      var cmd = this.generateOutputCommand(WeDo2ConnectID.LED, WeDo2Command.WRITE_RGB, rgb);\n      return this.send(BLECharacteristic.OUTPUT_COMMAND, cmd);\n    }\n    /**\n     * Sets the input mode of the LED to RGB.\n     * @return {Promise} - a promise returned by the send operation.\n     */\n  }, {\n    key: \"setLEDMode\",\n    value: function setLEDMode() {\n      var cmd = this.generateInputCommand(WeDo2ConnectID.LED, WeDo2Device.LED, WeDo2Mode.LED, 0, WeDo2Unit.LED, false);\n      return this.send(BLECharacteristic.INPUT_COMMAND, cmd);\n    }\n    /**\n     * Switch off the LED on the WeDo 2.0.\n     * @return {Promise} - a promise of the completion of the stop led send operation.\n     */\n  }, {\n    key: \"stopLED\",\n    value: function stopLED() {\n      var cmd = this.generateOutputCommand(WeDo2ConnectID.LED, WeDo2Command.WRITE_RGB, [0, 0, 0]);\n      return this.send(BLECharacteristic.OUTPUT_COMMAND, cmd);\n    }\n    /**\n     * Play a tone from the WeDo 2.0 peripheral for a specific amount of time.\n     * @param {int} tone - the pitch of the tone, in Hz.\n     * @param {int} milliseconds - the duration of the note, in milliseconds.\n     * @return {Promise} - a promise of the completion of the play tone send operation.\n     */\n  }, {\n    key: \"playTone\",\n    value: function playTone(tone, milliseconds) {\n      var cmd = this.generateOutputCommand(WeDo2ConnectID.PIEZO, WeDo2Command.PLAY_TONE, [tone, tone >> 8, milliseconds, milliseconds >> 8]);\n      return this.send(BLECharacteristic.OUTPUT_COMMAND, cmd);\n    }\n    /**\n     * Stop the tone playing from the WeDo 2.0 peripheral, if any.\n     * @return {Promise} - a promise that the command sent.\n     */\n  }, {\n    key: \"stopTone\",\n    value: function stopTone() {\n      var cmd = this.generateOutputCommand(WeDo2ConnectID.PIEZO, WeDo2Command.STOP_TONE); // Send this command without using the rate limiter, because it is\n      // only triggered by the stop button.\n      return this.send(BLECharacteristic.OUTPUT_COMMAND, cmd, false);\n    }\n    /**\n     * Stop the tone playing and motors on the WeDo 2.0 peripheral.\n     */\n  }, {\n    key: \"stopAll\",\n    value: function stopAll() {\n      if (!this.isConnected()) return;\n      this.stopTone();\n      this.stopAllMotors();\n    }\n    /**\n     * Called by the runtime when user wants to scan for a WeDo 2.0 peripheral.\n     */\n  }, {\n    key: \"scan\",\n    value: function scan() {\n      if (this._ble) {\n        this._ble.disconnect();\n      }\n      this._ble = new BLE(this._runtime, this._extensionId, {\n        filters: [{\n          services: [BLEService.DEVICE_SERVICE]\n        }],\n        optionalServices: [BLEService.IO_SERVICE]\n      }, this._onConnect, this.reset);\n    }\n    /**\n     * Called by the runtime when user wants to connect to a certain WeDo 2.0 peripheral.\n     * @param {number} id - the id of the peripheral to connect to.\n     */\n  }, {\n    key: \"connect\",\n    value: function connect(id) {\n      if (this._ble) {\n        this._ble.connectPeripheral(id);\n      }\n    }\n    /**\n     * Disconnects from the current BLE socket.\n     */\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      if (this._ble) {\n        this._ble.disconnect();\n      }\n      this.reset();\n    }\n    /**\n     * Reset all the state and timeout/interval ids.\n     */\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this._ports = ['none', 'none'];\n      this._motors = [null, null];\n      this._sensors = {\n        tiltX: 0,\n        tiltY: 0,\n        distance: 0\n      };\n      if (this._batteryLevelIntervalId) {\n        window.clearInterval(this._batteryLevelIntervalId);\n        this._batteryLevelIntervalId = null;\n      }\n    }\n    /**\n     * Called by the runtime to detect whether the WeDo 2.0 peripheral is connected.\n     * @return {boolean} - the connected state.\n     */\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      var connected = false;\n      if (this._ble) {\n        connected = this._ble.isConnected();\n      }\n      return connected;\n    }\n    /**\n     * Write a message to the WeDo 2.0 peripheral BLE socket.\n     * @param {number} uuid - the UUID of the characteristic to write to\n     * @param {Array} message - the message to write.\n     * @param {boolean} [useLimiter=true] - if true, use the rate limiter\n     * @return {Promise} - a promise result of the write operation\n     */\n  }, {\n    key: \"send\",\n    value: function send(uuid, message) {\n      var useLimiter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      if (!this.isConnected()) return Promise.resolve();\n      if (useLimiter) {\n        if (!this._rateLimiter.okayToSend()) return Promise.resolve();\n      }\n      return this._ble.write(BLEService.IO_SERVICE, uuid, Base64Util.uint8ArrayToBase64(message), 'base64');\n    }\n    /**\n     * Generate a WeDo 2.0 'Output Command' in the byte array format\n     * (CONNECT ID, COMMAND ID, NUMBER OF BYTES, VALUES ...).\n     *\n     * This sends a command to the WeDo 2.0 to actuate the specified outputs.\n     *\n     * @param  {number} connectID - the port (Connect ID) to send a command to.\n     * @param  {number} commandID - the id of the byte command.\n     * @param  {array}  values    - the list of values to write to the command.\n     * @return {array}            - a generated output command.\n     */\n  }, {\n    key: \"generateOutputCommand\",\n    value: function generateOutputCommand(connectID, commandID) {\n      var values = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var command = [connectID, commandID];\n      if (values) {\n        command = command.concat(values.length).concat(values);\n      }\n      return command;\n    }\n    /**\n     * Generate a WeDo 2.0 'Input Command' in the byte array format\n     * (COMMAND ID, COMMAND TYPE, CONNECT ID, TYPE ID, MODE, DELTA INTERVAL (4 BYTES),\n     * UNIT, NOTIFICATIONS ENABLED).\n     *\n     * This sends a command to the WeDo 2.0 that sets that input format\n     * of the specified inputs and sets value change notifications.\n     *\n     * @param  {number}  connectID           - the port (Connect ID) to send a command to.\n     * @param  {number}  type                - the type of input sensor.\n     * @param  {number}  mode                - the mode of the input sensor.\n     * @param  {number}  delta               - the delta change needed to trigger notification.\n     * @param  {array}   units               - the unit of the input sensor value.\n     * @param  {boolean} enableNotifications - whether to enable notifications.\n     * @return {array}                       - a generated input command.\n     */\n  }, {\n    key: \"generateInputCommand\",\n    value: function generateInputCommand(connectID, type, mode, delta, units, enableNotifications) {\n      var command = [1, // Command ID = 1 = \"Sensor Format\"\n      2, // Command Type = 2 = \"Write\"\n      connectID, type, mode, delta, 0, // Delta Interval Byte 2\n      0, // Delta Interval Byte 3\n      0, // Delta Interval Byte 4\n      units, enableNotifications ? 1 : 0];\n      return command;\n    }\n    /**\n     * Sets LED mode and initial color and starts reading data from peripheral after BLE has connected.\n     * @private\n     */\n  }, {\n    key: \"_onConnect\",\n    value: function _onConnect() {\n      this.setLEDMode();\n      this.setLED(0x0000FF);\n      this._ble.startNotifications(BLEService.DEVICE_SERVICE, BLECharacteristic.ATTACHED_IO, this._onMessage);\n      this._batteryLevelIntervalId = window.setInterval(this._checkBatteryLevel, BLEBatteryCheckInterval);\n    }\n    /**\n     * Process the sensor data from the incoming BLE characteristic.\n     * @param {object} base64 - the incoming BLE data.\n     * @private\n     */\n  }, {\n    key: \"_onMessage\",\n    value: function _onMessage(base64) {\n      var data = Base64Util.base64ToUint8Array(base64); // log.info(data);\n      /**\n       * If first byte of data is '1' or '2', then either clear the\n       * sensor present in ports 1 or 2 or set their format.\n       *\n       * If first byte of data is anything else, read incoming sensor value.\n       */\n      switch (data[0]) {\n        case 1:\n        case 2:\n          {\n            var connectID = data[0];\n            if (data[1] === 0) {\n              // clear sensor or motor\n              this._clearPort(connectID);\n            } else {\n              // register sensor or motor\n              this._registerSensorOrMotor(connectID, data[3]);\n            }\n            break;\n          }\n        default:\n          {\n            // read incoming sensor value\n            var _connectID = data[1];\n            var type = this._ports[_connectID - 1];\n            if (type === WeDo2Device.DISTANCE) {\n              this._sensors.distance = data[2];\n            }\n            if (type === WeDo2Device.TILT) {\n              this._sensors.tiltX = data[2];\n              this._sensors.tiltY = data[3];\n            }\n            break;\n          }\n      }\n    }\n    /**\n     * Check the battery level on the WeDo 2.0. If the WeDo 2.0 has disconnected\n     * for some reason, the BLE socket will get an error back and automatically\n     * close the socket.\n     */\n  }, {\n    key: \"_checkBatteryLevel\",\n    value: function _checkBatteryLevel() {\n      this._ble.read(BLEService.DEVICE_SERVICE, BLECharacteristic.LOW_VOLTAGE_ALERT, false);\n    }\n    /**\n     * Register a new sensor or motor connected at a port.  Store the type of\n     * sensor or motor internally, and then register for notifications on input\n     * values if it is a sensor.\n     * @param {number} connectID - the port to register a sensor or motor on.\n     * @param {number} type - the type ID of the sensor or motor\n     * @private\n     */\n  }, {\n    key: \"_registerSensorOrMotor\",\n    value: function _registerSensorOrMotor(connectID, type) {\n      // Record which port is connected to what type of device\n      this._ports[connectID - 1] = type; // Record motor port\n      if (type === WeDo2Device.MOTOR) {\n        this._motors[connectID - 1] = new WeDo2Motor(this, connectID - 1);\n      } else {\n        // Set input format for tilt or distance sensor\n        var typeString = type === WeDo2Device.DISTANCE ? 'DISTANCE' : 'TILT';\n        var cmd = this.generateInputCommand(connectID, type, WeDo2Mode[typeString], 1, WeDo2Unit[typeString], true);\n        this.send(BLECharacteristic.INPUT_COMMAND, cmd);\n        this._ble.startNotifications(BLEService.IO_SERVICE, BLECharacteristic.INPUT_VALUES, this._onMessage);\n      }\n    }\n    /**\n     * Clear the sensor or motor present at port 1 or 2.\n     * @param {number} connectID - the port to clear.\n     * @private\n     */\n  }, {\n    key: \"_clearPort\",\n    value: function _clearPort(connectID) {\n      var type = this._ports[connectID - 1];\n      if (type === WeDo2Device.TILT) {\n        this._sensors.tiltX = this._sensors.tiltY = 0;\n      }\n      if (type === WeDo2Device.DISTANCE) {\n        this._sensors.distance = 0;\n      }\n      this._ports[connectID - 1] = 'none';\n      this._motors[connectID - 1] = null;\n    }\n  }, {\n    key: \"tiltX\",\n    get: function get() {\n      return this._sensors.tiltX;\n    }\n    /**\n     * @return {number} - the latest value received for the tilt sensor's tilt about the Y axis.\n     */\n  }, {\n    key: \"tiltY\",\n    get: function get() {\n      return this._sensors.tiltY;\n    }\n    /**\n     * @return {number} - the latest value received from the distance sensor.\n     */\n  }, {\n    key: \"distance\",\n    get: function get() {\n      return this._sensors.distance;\n    }\n  }]);\n  return WeDo2;\n}();\n/**\n * Enum for motor specification.\n * @readonly\n * @enum {string}\n */\nvar WeDo2MotorLabel = {\n  DEFAULT: 'motor',\n  A: 'motor A',\n  B: 'motor B',\n  ALL: 'all motors'\n};\n/**\n * Enum for motor direction specification.\n * @readonly\n * @enum {string}\n */\nvar WeDo2MotorDirection = {\n  FORWARD: 'this way',\n  BACKWARD: 'that way',\n  REVERSE: 'reverse'\n};\n/**\n * Enum for tilt sensor direction.\n * @readonly\n * @enum {string}\n */\nvar WeDo2TiltDirection = {\n  UP: 'up',\n  DOWN: 'down',\n  LEFT: 'left',\n  RIGHT: 'right',\n  ANY: 'any'\n};\n/**\n * Scratch 3.0 blocks to interact with a LEGO WeDo 2.0 peripheral.\n */\nvar Scratch3WeDo2Blocks = function () {\n  _createClass(Scratch3WeDo2Blocks, null, [{\n    key: \"EXTENSION_ID\",\n    /**\n     * @return {string} - the ID of this extension.\n     */\n    get: function get() {\n      return 'wedo2';\n    }\n    /**\n     * @return {number} - the tilt sensor counts as \"tilted\" if its tilt angle meets or exceeds this threshold.\n     */\n  }, {\n    key: \"TILT_THRESHOLD\",\n    get: function get() {\n      return 15;\n    }\n    /**\n     * Construct a set of WeDo 2.0 blocks.\n     * @param {Runtime} runtime - the Scratch 3.0 runtime.\n     */\n  }]);\n  function Scratch3WeDo2Blocks(runtime) {\n    _classCallCheck(this, Scratch3WeDo2Blocks);\n    /**\n     * The Scratch 3.0 runtime.\n     * @type {Runtime}\n     */\n    this.runtime = runtime; // Create a new WeDo 2.0 peripheral instance\n    this._peripheral = new WeDo2(this.runtime, Scratch3WeDo2Blocks.EXTENSION_ID);\n  }\n  /**\n   * @returns {object} metadata for this extension and its blocks.\n   */\n  _createClass(Scratch3WeDo2Blocks, [{\n    key: \"getInfo\",\n    value: function getInfo() {\n      return {\n        id: Scratch3WeDo2Blocks.EXTENSION_ID,\n        name: 'WeDo 2.0',\n        blockIconURI: iconURI,\n        showStatusButton: true,\n        blocks: [{\n          opcode: 'motorOnFor',\n          text: formatMessage({\n            id: 'wedo2.motorOnFor',\n            default: 'turn [MOTOR_ID] on for [DURATION] seconds',\n            description: 'turn a motor on for some time'\n          }),\n          blockType: BlockType.COMMAND,\n          arguments: {\n            MOTOR_ID: {\n              type: ArgumentType.STRING,\n              menu: 'MOTOR_ID',\n              defaultValue: WeDo2MotorLabel.DEFAULT\n            },\n            DURATION: {\n              type: ArgumentType.NUMBER,\n              defaultValue: 1\n            }\n          }\n        }, {\n          opcode: 'motorOn',\n          text: formatMessage({\n            id: 'wedo2.motorOn',\n            default: 'turn [MOTOR_ID] on',\n            description: 'turn a motor on indefinitely'\n          }),\n          blockType: BlockType.COMMAND,\n          arguments: {\n            MOTOR_ID: {\n              type: ArgumentType.STRING,\n              menu: 'MOTOR_ID',\n              defaultValue: WeDo2MotorLabel.DEFAULT\n            }\n          }\n        }, {\n          opcode: 'motorOff',\n          text: formatMessage({\n            id: 'wedo2.motorOff',\n            default: 'turn [MOTOR_ID] off',\n            description: 'turn a motor off'\n          }),\n          blockType: BlockType.COMMAND,\n          arguments: {\n            MOTOR_ID: {\n              type: ArgumentType.STRING,\n              menu: 'MOTOR_ID',\n              defaultValue: WeDo2MotorLabel.DEFAULT\n            }\n          }\n        }, {\n          opcode: 'startMotorPower',\n          text: formatMessage({\n            id: 'wedo2.startMotorPower',\n            default: 'set [MOTOR_ID] power to [POWER]',\n            description: 'set the motor\\'s power and turn it on'\n          }),\n          blockType: BlockType.COMMAND,\n          arguments: {\n            MOTOR_ID: {\n              type: ArgumentType.STRING,\n              menu: 'MOTOR_ID',\n              defaultValue: WeDo2MotorLabel.DEFAULT\n            },\n            POWER: {\n              type: ArgumentType.NUMBER,\n              defaultValue: 100\n            }\n          }\n        }, {\n          opcode: 'setMotorDirection',\n          text: formatMessage({\n            id: 'wedo2.setMotorDirection',\n            default: 'set [MOTOR_ID] direction to [MOTOR_DIRECTION]',\n            description: 'set the motor\\'s turn direction'\n          }),\n          blockType: BlockType.COMMAND,\n          arguments: {\n            MOTOR_ID: {\n              type: ArgumentType.STRING,\n              menu: 'MOTOR_ID',\n              defaultValue: WeDo2MotorLabel.DEFAULT\n            },\n            MOTOR_DIRECTION: {\n              type: ArgumentType.STRING,\n              menu: 'MOTOR_DIRECTION',\n              defaultValue: WeDo2MotorDirection.FORWARD\n            }\n          }\n        }, {\n          opcode: 'setLightHue',\n          text: formatMessage({\n            id: 'wedo2.setLightHue',\n            default: 'set light color to [HUE]',\n            description: 'set the LED color'\n          }),\n          blockType: BlockType.COMMAND,\n          arguments: {\n            HUE: {\n              type: ArgumentType.NUMBER,\n              defaultValue: 50\n            }\n          }\n        }, {\n          opcode: 'playNoteFor',\n          text: formatMessage({\n            id: 'wedo2.playNoteFor',\n            default: 'play note [NOTE] for [DURATION] seconds',\n            description: 'play a certain note for some time'\n          }),\n          blockType: BlockType.COMMAND,\n          arguments: {\n            NOTE: {\n              type: ArgumentType.NUMBER,\n              // TODO: ArgumentType.MIDI_NOTE?\n              defaultValue: 60\n            },\n            DURATION: {\n              type: ArgumentType.NUMBER,\n              defaultValue: 0.5\n            }\n          },\n          hideFromPalette: true\n        }, {\n          opcode: 'whenDistance',\n          text: formatMessage({\n            id: 'wedo2.whenDistance',\n            default: 'when distance [OP] [REFERENCE]',\n            description: 'check for when distance is < or > than reference'\n          }),\n          blockType: BlockType.HAT,\n          arguments: {\n            OP: {\n              type: ArgumentType.STRING,\n              menu: 'OP',\n              defaultValue: '<'\n            },\n            REFERENCE: {\n              type: ArgumentType.NUMBER,\n              defaultValue: 50\n            }\n          }\n        }, {\n          opcode: 'whenTilted',\n          text: formatMessage({\n            id: 'wedo2.whenTilted',\n            default: 'when tilted [TILT_DIRECTION_ANY]',\n            description: 'check when tilted in a certain direction'\n          }),\n          func: 'isTilted',\n          blockType: BlockType.HAT,\n          arguments: {\n            TILT_DIRECTION_ANY: {\n              type: ArgumentType.STRING,\n              menu: 'TILT_DIRECTION_ANY',\n              defaultValue: WeDo2TiltDirection.ANY\n            }\n          }\n        }, {\n          opcode: 'getDistance',\n          text: formatMessage({\n            id: 'wedo2.getDistance',\n            default: 'distance',\n            description: 'the value returned by the distance sensor'\n          }),\n          blockType: BlockType.REPORTER\n        }, {\n          opcode: 'isTilted',\n          text: formatMessage({\n            id: 'wedo2.isTilted',\n            default: 'tilted [TILT_DIRECTION_ANY]?',\n            description: 'whether the tilt sensor is tilted'\n          }),\n          blockType: BlockType.BOOLEAN,\n          arguments: {\n            TILT_DIRECTION_ANY: {\n              type: ArgumentType.STRING,\n              menu: 'TILT_DIRECTION_ANY',\n              defaultValue: WeDo2TiltDirection.ANY\n            }\n          }\n        }, {\n          opcode: 'getTiltAngle',\n          text: formatMessage({\n            id: 'wedo2.getTiltAngle',\n            default: 'tilt angle [TILT_DIRECTION]',\n            description: 'the angle returned by the tilt sensor'\n          }),\n          blockType: BlockType.REPORTER,\n          arguments: {\n            TILT_DIRECTION: {\n              type: ArgumentType.STRING,\n              menu: 'TILT_DIRECTION',\n              defaultValue: WeDo2TiltDirection.UP\n            }\n          }\n        }],\n        menus: {\n          MOTOR_ID: {\n            acceptReporters: true,\n            items: [{\n              text: formatMessage({\n                id: 'wedo2.motorId.default',\n                default: 'motor',\n                description: 'label for motor element in motor menu for LEGO WeDo 2 extension'\n              }),\n              value: WeDo2MotorLabel.DEFAULT\n            }, {\n              text: formatMessage({\n                id: 'wedo2.motorId.a',\n                default: 'motor A',\n                description: 'label for motor A element in motor menu for LEGO WeDo 2 extension'\n              }),\n              value: WeDo2MotorLabel.A\n            }, {\n              text: formatMessage({\n                id: 'wedo2.motorId.b',\n                default: 'motor B',\n                description: 'label for motor B element in motor menu for LEGO WeDo 2 extension'\n              }),\n              value: WeDo2MotorLabel.B\n            }, {\n              text: formatMessage({\n                id: 'wedo2.motorId.all',\n                default: 'all motors',\n                description: 'label for all motors element in motor menu for LEGO WeDo 2 extension'\n              }),\n              value: WeDo2MotorLabel.ALL\n            }]\n          },\n          MOTOR_DIRECTION: {\n            acceptReporters: true,\n            items: [{\n              text: formatMessage({\n                id: 'wedo2.motorDirection.forward',\n                default: 'this way',\n                description: 'label for forward element in motor direction menu for LEGO WeDo 2 extension'\n              }),\n              value: WeDo2MotorDirection.FORWARD\n            }, {\n              text: formatMessage({\n                id: 'wedo2.motorDirection.backward',\n                default: 'that way',\n                description: 'label for backward element in motor direction menu for LEGO WeDo 2 extension'\n              }),\n              value: WeDo2MotorDirection.BACKWARD\n            }, {\n              text: formatMessage({\n                id: 'wedo2.motorDirection.reverse',\n                default: 'reverse',\n                description: 'label for reverse element in motor direction menu for LEGO WeDo 2 extension'\n              }),\n              value: WeDo2MotorDirection.REVERSE\n            }]\n          },\n          TILT_DIRECTION: {\n            acceptReporters: true,\n            items: [{\n              text: formatMessage({\n                id: 'wedo2.tiltDirection.up',\n                default: 'up',\n                description: 'label for up element in tilt direction menu for LEGO WeDo 2 extension'\n              }),\n              value: WeDo2TiltDirection.UP\n            }, {\n              text: formatMessage({\n                id: 'wedo2.tiltDirection.down',\n                default: 'down',\n                description: 'label for down element in tilt direction menu for LEGO WeDo 2 extension'\n              }),\n              value: WeDo2TiltDirection.DOWN\n            }, {\n              text: formatMessage({\n                id: 'wedo2.tiltDirection.left',\n                default: 'left',\n                description: 'label for left element in tilt direction menu for LEGO WeDo 2 extension'\n              }),\n              value: WeDo2TiltDirection.LEFT\n            }, {\n              text: formatMessage({\n                id: 'wedo2.tiltDirection.right',\n                default: 'right',\n                description: 'label for right element in tilt direction menu for LEGO WeDo 2 extension'\n              }),\n              value: WeDo2TiltDirection.RIGHT\n            }]\n          },\n          TILT_DIRECTION_ANY: {\n            acceptReporters: true,\n            items: [{\n              text: formatMessage({\n                id: 'wedo2.tiltDirection.up',\n                default: 'up'\n              }),\n              value: WeDo2TiltDirection.UP\n            }, {\n              text: formatMessage({\n                id: 'wedo2.tiltDirection.down',\n                default: 'down'\n              }),\n              value: WeDo2TiltDirection.DOWN\n            }, {\n              text: formatMessage({\n                id: 'wedo2.tiltDirection.left',\n                default: 'left'\n              }),\n              value: WeDo2TiltDirection.LEFT\n            }, {\n              text: formatMessage({\n                id: 'wedo2.tiltDirection.right',\n                default: 'right'\n              }),\n              value: WeDo2TiltDirection.RIGHT\n            }, {\n              text: formatMessage({\n                id: 'wedo2.tiltDirection.any',\n                default: 'any',\n                description: 'label for any element in tilt direction menu for LEGO WeDo 2 extension'\n              }),\n              value: WeDo2TiltDirection.ANY\n            }]\n          },\n          OP: {\n            acceptReporters: true,\n            items: ['<', '>']\n          }\n        }\n      };\n    }\n    /**\n     * Turn specified motor(s) on for a specified duration.\n     * @param {object} args - the block's arguments.\n     * @property {MotorID} MOTOR_ID - the motor(s) to activate.\n     * @property {int} DURATION - the amount of time to run the motors.\n     * @return {Promise} - a promise which will resolve at the end of the duration.\n     */\n  }, {\n    key: \"motorOnFor\",\n    value: function motorOnFor(args) {\n      var _this2 = this;\n      // TODO: cast args.MOTOR_ID?\n      var durationMS = Cast.toNumber(args.DURATION) * 1000;\n      durationMS = MathUtil.clamp(durationMS, 0, 15000);\n      return new Promise(function (resolve) {\n        _this2._forEachMotor(args.MOTOR_ID, function (motorIndex) {\n          var motor = _this2._peripheral.motor(motorIndex);\n          if (motor) {\n            motor.turnOnFor(durationMS);\n          }\n        }); // Run for some time even when no motor is connected\n        setTimeout(resolve, durationMS);\n      });\n    }\n    /**\n     * Turn specified motor(s) on indefinitely.\n     * @param {object} args - the block's arguments.\n     * @property {MotorID} MOTOR_ID - the motor(s) to activate.\n     * @return {Promise} - a Promise that resolves after some delay.\n     */\n  }, {\n    key: \"motorOn\",\n    value: function motorOn(args) {\n      var _this3 = this;\n      // TODO: cast args.MOTOR_ID?\n      this._forEachMotor(args.MOTOR_ID, function (motorIndex) {\n        var motor = _this3._peripheral.motor(motorIndex);\n        if (motor) {\n          motor.turnOn();\n        }\n      });\n      return new Promise(function (resolve) {\n        window.setTimeout(function () {\n          resolve();\n        }, BLESendInterval);\n      });\n    }\n    /**\n     * Turn specified motor(s) off.\n     * @param {object} args - the block's arguments.\n     * @property {MotorID} MOTOR_ID - the motor(s) to deactivate.\n     * @return {Promise} - a Promise that resolves after some delay.\n     */\n  }, {\n    key: \"motorOff\",\n    value: function motorOff(args) {\n      var _this4 = this;\n      // TODO: cast args.MOTOR_ID?\n      this._forEachMotor(args.MOTOR_ID, function (motorIndex) {\n        var motor = _this4._peripheral.motor(motorIndex);\n        if (motor) {\n          motor.turnOff();\n        }\n      });\n      return new Promise(function (resolve) {\n        window.setTimeout(function () {\n          resolve();\n        }, BLESendInterval);\n      });\n    }\n    /**\n     * Turn specified motor(s) off.\n     * @param {object} args - the block's arguments.\n     * @property {MotorID} MOTOR_ID - the motor(s) to be affected.\n     * @property {int} POWER - the new power level for the motor(s).\n     * @return {Promise} - a Promise that resolves after some delay.\n     */\n  }, {\n    key: \"startMotorPower\",\n    value: function startMotorPower(args) {\n      var _this5 = this;\n      // TODO: cast args.MOTOR_ID?\n      this._forEachMotor(args.MOTOR_ID, function (motorIndex) {\n        var motor = _this5._peripheral.motor(motorIndex);\n        if (motor) {\n          motor.power = MathUtil.clamp(Cast.toNumber(args.POWER), 0, 100);\n          motor.turnOn();\n        }\n      });\n      return new Promise(function (resolve) {\n        window.setTimeout(function () {\n          resolve();\n        }, BLESendInterval);\n      });\n    }\n    /**\n     * Set the direction of rotation for specified motor(s).\n     * If the direction is 'reverse' the motor(s) will be reversed individually.\n     * @param {object} args - the block's arguments.\n     * @property {MotorID} MOTOR_ID - the motor(s) to be affected.\n     * @property {MotorDirection} MOTOR_DIRECTION - the new direction for the motor(s).\n     * @return {Promise} - a Promise that resolves after some delay.\n     */\n  }, {\n    key: \"setMotorDirection\",\n    value: function setMotorDirection(args) {\n      var _this6 = this;\n      // TODO: cast args.MOTOR_ID?\n      this._forEachMotor(args.MOTOR_ID, function (motorIndex) {\n        var motor = _this6._peripheral.motor(motorIndex);\n        if (motor) {\n          switch (args.MOTOR_DIRECTION) {\n            case WeDo2MotorDirection.FORWARD:\n              motor.direction = 1;\n              break;\n            case WeDo2MotorDirection.BACKWARD:\n              motor.direction = -1;\n              break;\n            case WeDo2MotorDirection.REVERSE:\n              motor.direction = -motor.direction;\n              break;\n            default:\n              log.warn(\"Unknown motor direction in setMotorDirection: \".concat(args.DIRECTION));\n              break;\n          } // keep the motor on if it's running, and update the pending timeout if needed\n          if (motor.isOn) {\n            if (motor.pendingTimeoutDelay) {\n              motor.turnOnFor(motor.pendingTimeoutStartTime + motor.pendingTimeoutDelay - Date.now());\n            } else {\n              motor.turnOn();\n            }\n          }\n        }\n      });\n      return new Promise(function (resolve) {\n        window.setTimeout(function () {\n          resolve();\n        }, BLESendInterval);\n      });\n    }\n    /**\n     * Set the LED's hue.\n     * @param {object} args - the block's arguments.\n     * @property {number} HUE - the hue to set, in the range [0,100].\n     * @return {Promise} - a Promise that resolves after some delay.\n     */\n  }, {\n    key: \"setLightHue\",\n    value: function setLightHue(args) {\n      // Convert from [0,100] to [0,360]\n      var inputHue = Cast.toNumber(args.HUE);\n      inputHue = MathUtil.wrapClamp(inputHue, 0, 100);\n      var hue = inputHue * 360 / 100;\n      var rgbObject = color.hsvToRgb({\n        h: hue,\n        s: 1,\n        v: 1\n      });\n      var rgbDecimal = color.rgbToDecimal(rgbObject);\n      this._peripheral.setLED(rgbDecimal);\n      return new Promise(function (resolve) {\n        window.setTimeout(function () {\n          resolve();\n        }, BLESendInterval);\n      });\n    }\n    /**\n     * Make the WeDo 2.0 peripheral play a MIDI note for the specified duration.\n     * @param {object} args - the block's arguments.\n     * @property {number} NOTE - the MIDI note to play.\n     * @property {number} DURATION - the duration of the note, in seconds.\n     * @return {Promise} - a promise which will resolve at the end of the duration.\n     */\n  }, {\n    key: \"playNoteFor\",\n    value: function playNoteFor(args) {\n      var _this7 = this;\n      var durationMS = Cast.toNumber(args.DURATION) * 1000;\n      durationMS = MathUtil.clamp(durationMS, 0, 3000);\n      var note = MathUtil.clamp(Cast.toNumber(args.NOTE), 25, 125); // valid WeDo 2.0 sounds\n      if (durationMS === 0) return; // WeDo 2.0 plays duration '0' forever\n      return new Promise(function (resolve) {\n        var tone = _this7._noteToTone(note);\n        _this7._peripheral.playTone(tone, durationMS); // Run for some time even when no piezo is connected\n        setTimeout(resolve, durationMS);\n      });\n    }\n    /**\n     * Compare the distance sensor's value to a reference.\n     * @param {object} args - the block's arguments.\n     * @property {string} OP - the comparison operation: '<' or '>'.\n     * @property {number} REFERENCE - the value to compare against.\n     * @return {boolean} - the result of the comparison, or false on error.\n     */\n  }, {\n    key: \"whenDistance\",\n    value: function whenDistance(args) {\n      switch (args.OP) {\n        case '<':\n          return this._peripheral.distance < Cast.toNumber(args.REFERENCE);\n        case '>':\n          return this._peripheral.distance > Cast.toNumber(args.REFERENCE);\n        default:\n          log.warn(\"Unknown comparison operator in whenDistance: \".concat(args.OP));\n          return false;\n      }\n    }\n    /**\n     * Test whether the tilt sensor is currently tilted.\n     * @param {object} args - the block's arguments.\n     * @property {TiltDirection} TILT_DIRECTION_ANY - the tilt direction to test (up, down, left, right, or any).\n     * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.\n     */\n  }, {\n    key: \"whenTilted\",\n    value: function whenTilted(args) {\n      return this._isTilted(args.TILT_DIRECTION_ANY);\n    }\n    /**\n     * @return {number} - the distance sensor's value, scaled to the [0,100] range.\n     */\n  }, {\n    key: \"getDistance\",\n    value: function getDistance() {\n      return this._peripheral.distance;\n    }\n    /**\n     * Test whether the tilt sensor is currently tilted.\n     * @param {object} args - the block's arguments.\n     * @property {TiltDirection} TILT_DIRECTION_ANY - the tilt direction to test (up, down, left, right, or any).\n     * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.\n     */\n  }, {\n    key: \"isTilted\",\n    value: function isTilted(args) {\n      return this._isTilted(args.TILT_DIRECTION_ANY);\n    }\n    /**\n     * @param {object} args - the block's arguments.\n     * @property {TiltDirection} TILT_DIRECTION - the direction (up, down, left, right) to check.\n     * @return {number} - the tilt sensor's angle in the specified direction.\n     * Note that getTiltAngle(up) = -getTiltAngle(down) and getTiltAngle(left) = -getTiltAngle(right).\n     */\n  }, {\n    key: \"getTiltAngle\",\n    value: function getTiltAngle(args) {\n      return this._getTiltAngle(args.TILT_DIRECTION);\n    }\n    /**\n     * Test whether the tilt sensor is currently tilted.\n     * @param {TiltDirection} direction - the tilt direction to test (up, down, left, right, or any).\n     * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.\n     * @private\n     */\n  }, {\n    key: \"_isTilted\",\n    value: function _isTilted(direction) {\n      switch (direction) {\n        case WeDo2TiltDirection.ANY:\n          return this._getTiltAngle(WeDo2TiltDirection.UP) >= Scratch3WeDo2Blocks.TILT_THRESHOLD || this._getTiltAngle(WeDo2TiltDirection.DOWN) >= Scratch3WeDo2Blocks.TILT_THRESHOLD || this._getTiltAngle(WeDo2TiltDirection.LEFT) >= Scratch3WeDo2Blocks.TILT_THRESHOLD || this._getTiltAngle(WeDo2TiltDirection.RIGHT) >= Scratch3WeDo2Blocks.TILT_THRESHOLD;\n        default:\n          return this._getTiltAngle(direction) >= Scratch3WeDo2Blocks.TILT_THRESHOLD;\n      }\n    }\n    /**\n     * @param {TiltDirection} direction - the direction (up, down, left, right) to check.\n     * @return {number} - the tilt sensor's angle in the specified direction.\n     * Note that getTiltAngle(up) = -getTiltAngle(down) and getTiltAngle(left) = -getTiltAngle(right).\n     * @private\n     */\n  }, {\n    key: \"_getTiltAngle\",\n    value: function _getTiltAngle(direction) {\n      switch (direction) {\n        case WeDo2TiltDirection.UP:\n          return this._peripheral.tiltY > 45 ? 256 - this._peripheral.tiltY : -this._peripheral.tiltY;\n        case WeDo2TiltDirection.DOWN:\n          return this._peripheral.tiltY > 45 ? this._peripheral.tiltY - 256 : this._peripheral.tiltY;\n        case WeDo2TiltDirection.LEFT:\n          return this._peripheral.tiltX > 45 ? 256 - this._peripheral.tiltX : -this._peripheral.tiltX;\n        case WeDo2TiltDirection.RIGHT:\n          return this._peripheral.tiltX > 45 ? this._peripheral.tiltX - 256 : this._peripheral.tiltX;\n        default:\n          log.warn(\"Unknown tilt direction in _getTiltAngle: \".concat(direction));\n      }\n    }\n    /**\n     * Call a callback for each motor indexed by the provided motor ID.\n     * @param {MotorID} motorID - the ID specifier.\n     * @param {Function} callback - the function to call with the numeric motor index for each motor.\n     * @private\n     */\n  }, {\n    key: \"_forEachMotor\",\n    value: function _forEachMotor(motorID, callback) {\n      var motors;\n      switch (motorID) {\n        case WeDo2MotorLabel.A:\n          motors = [0];\n          break;\n        case WeDo2MotorLabel.B:\n          motors = [1];\n          break;\n        case WeDo2MotorLabel.ALL:\n        case WeDo2MotorLabel.DEFAULT:\n          motors = [0, 1];\n          break;\n        default:\n          log.warn(\"Invalid motor ID: \".concat(motorID));\n          motors = [];\n          break;\n      }\n      var _iterator = _createForOfIteratorHelper(motors),\n          _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var index = _step.value;\n          callback(index);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    /**\n     * @param {number} midiNote - the MIDI note value to convert.\n     * @return {number} - the frequency, in Hz, corresponding to that MIDI note value.\n     * @private\n     */\n  }, {\n    key: \"_noteToTone\",\n    value: function _noteToTone(midiNote) {\n      // Note that MIDI note 69 is A4, 440 Hz\n      return 440 * Math.pow(2, (midiNote - 69) / 12);\n    }\n  }]);\n  return Scratch3WeDo2Blocks;\n}();\nmodule.exports = Scratch3WeDo2Blocks;\n })