/* 225 */\n (function(module, exports, __webpack_require__) {\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nvar StringUtil = __webpack_require__(102);\nvar log = __webpack_require__(39);\nvar loadVector_ = function loadVector_(costume, runtime, rotationCenter, optVersion) {\n  return new Promise(function (resolve) {\n    var svgString = costume.asset.decodeText(); // SVG Renderer load fixes \"quirks\" associated with Scratch 2 projects\n    if (optVersion && optVersion === 2 && !runtime.v2SvgAdapter) {\n      log.error('No V2 SVG adapter present; SVGs may not render correctly.');\n    } else if (optVersion && optVersion === 2 && runtime.v2SvgAdapter) {\n      runtime.v2SvgAdapter.loadString(svgString, true\n      /* fromVersion2 */\n      );\n      svgString = runtime.v2SvgAdapter.toString(); // Put back into storage\n      var storage = runtime.storage;\n      costume.asset.encodeTextData(svgString, storage.DataFormat.SVG, true);\n      costume.assetId = costume.asset.assetId;\n      costume.md5 = \"\".concat(costume.assetId, \".\").concat(costume.dataFormat);\n    } // createSVGSkin does the right thing if rotationCenter isn't provided, so it's okay if it's\n    // undefined here\n    costume.skinId = runtime.renderer.createSVGSkin(svgString, rotationCenter);\n    costume.size = runtime.renderer.getSkinSize(costume.skinId); // Now we should have a rotationCenter even if we didn't before\n    if (!rotationCenter) {\n      rotationCenter = runtime.renderer.getSkinRotationCenter(costume.skinId);\n      costume.rotationCenterX = rotationCenter[0];\n      costume.rotationCenterY = rotationCenter[1];\n      costume.bitmapResolution = 1;\n    }\n    resolve(costume);\n  });\n};\nvar canvasPool = function () {\n  /**\n   * A pool of canvas objects that can be reused to reduce memory\n   * allocations. And time spent in those allocations and the later garbage\n   * collection.\n   */\n  var CanvasPool = function () {\n    function CanvasPool() {\n      _classCallCheck(this, CanvasPool);\n      this.pool = [];\n      this.clearSoon = null;\n    }\n    /**\n     * After a short wait period clear the pool to let the VM collect\n     * garbage.\n     */\n    _createClass(CanvasPool, [{\n      key: \"clear\",\n      value: function clear() {\n        var _this = this;\n        if (!this.clearSoon) {\n          this.clearSoon = new Promise(function (resolve) {\n            return setTimeout(resolve, 1000);\n          }).then(function () {\n            _this.pool.length = 0;\n            _this.clearSoon = null;\n          });\n        }\n      }\n      /**\n       * Return a canvas. Create the canvas if the pool is empty.\n       * @returns {HTMLCanvasElement} A canvas element.\n       */\n    }, {\n      key: \"create\",\n      value: function create() {\n        return this.pool.pop() || document.createElement('canvas');\n      }\n      /**\n       * Release the canvas to be reused.\n       * @param {HTMLCanvasElement} canvas A canvas element.\n       */\n    }, {\n      key: \"release\",\n      value: function release(canvas) {\n        this.clear();\n        this.pool.push(canvas);\n      }\n    }]);\n    return CanvasPool;\n  }();\n  return new CanvasPool();\n}();\n/**\n * Return a promise to fetch a bitmap from storage and return it as a canvas\n * If the costume has bitmapResolution 1, it will be converted to bitmapResolution 2 here (the standard for Scratch 3)\n * If the costume has a text layer asset, which is a text part from Scratch 1.4, then this function\n * will merge the two image assets. See the issue LLK/scratch-vm#672 for more information.\n * @param {!object} costume - the Scratch costume object.\n * @param {!Runtime} runtime - Scratch runtime, used to access the v2BitmapAdapter\n * @param {?object} rotationCenter - optionally passed in coordinates for the center of rotation for the image. If\n *     none is given, the rotation center of the costume will be set to the middle of the costume later on.\n * @property {number} costume.bitmapResolution - the resolution scale for a bitmap costume.\n * @returns {?Promise} - a promise which will resolve to an object {canvas, rotationCenter, assetMatchesBase},\n *     or reject on error.\n *     assetMatchesBase is true if the asset matches the base layer; false if it required adjustment\n */\nvar fetchBitmapCanvas_ = function fetchBitmapCanvas_(costume, runtime, rotationCenter) {\n  if (!costume || !costume.asset) {\n    return Promise.reject('Costume load failed. Assets were missing.');\n  }\n  if (!runtime.v2BitmapAdapter) {\n    return Promise.reject('No V2 Bitmap adapter present.');\n  }\n  return Promise.all([costume.asset, costume.textLayerAsset].map(function (asset) {\n    if (!asset) {\n      return null;\n    }\n    if (typeof createImageBitmap !== 'undefined') {\n      return createImageBitmap(new Blob([asset.data], {\n        type: asset.assetType.contentType\n      }));\n    }\n    return new Promise(function (resolve, reject) {\n      var image = new Image();\n      image.onload = function () {\n        resolve(image);\n        image.onload = null;\n        image.onerror = null;\n      };\n      image.onerror = function () {\n        reject('Costume load failed. Asset could not be read.');\n        image.onload = null;\n        image.onerror = null;\n      };\n      image.src = asset.encodeDataURI();\n    });\n  })).then(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        baseImageElement = _ref2[0],\n        textImageElement = _ref2[1];\n    var mergeCanvas = canvasPool.create();\n    var scale = costume.bitmapResolution === 1 ? 2 : 1;\n    mergeCanvas.width = baseImageElement.width;\n    mergeCanvas.height = baseImageElement.height;\n    var ctx = mergeCanvas.getContext('2d',{willReadFrequently:true});\n    ctx.drawImage(baseImageElement, 0, 0);\n    if (textImageElement) {\n      ctx.drawImage(textImageElement, 0, 0);\n    } // Track the canvas we merged the bitmaps onto separately from the\n    // canvas that we receive from resize if scale is not 1. We know\n    // resize treats mergeCanvas as read only data. We don't know when\n    // resize may use or modify the canvas. So we'll only release the\n    // mergeCanvas back into the canvas pool. Reusing the canvas from\n    // resize may cause errors.\n    var canvas = mergeCanvas;\n    if (scale !== 1) {\n      canvas = runtime.v2BitmapAdapter.resize(mergeCanvas, canvas.width * scale, canvas.height * scale);\n    } // By scaling, we've converted it to bitmap resolution 2\n    if (rotationCenter) {\n      rotationCenter[0] = rotationCenter[0] * scale;\n      rotationCenter[1] = rotationCenter[1] * scale;\n      costume.rotationCenterX = rotationCenter[0];\n      costume.rotationCenterY = rotationCenter[1];\n    }\n    costume.bitmapResolution = 2; // Clean up the costume object\n    delete costume.textLayerMD5;\n    delete costume.textLayerAsset;\n    return {\n      canvas: canvas,\n      mergeCanvas: mergeCanvas,\n      rotationCenter: rotationCenter,\n      // True if the asset matches the base layer; false if it required adjustment\n      assetMatchesBase: scale === 1 && !textImageElement\n    };\n  }).catch(function () {\n    // Clean up the text layer properties if it fails to load\n    delete costume.textLayerMD5;\n    delete costume.textLayerAsset;\n  });\n};\nvar loadBitmap_ = function loadBitmap_(costume, runtime, _rotationCenter) {\n  return fetchBitmapCanvas_(costume, runtime, _rotationCenter).then(function (fetched) {\n    var updateCostumeAsset = function updateCostumeAsset(dataURI) {\n      if (!runtime.v2BitmapAdapter) {\n        // TODO: This might be a bad practice since the returned\n        // promise isn't acted on. If this is something we should be\n        // creating a rejected promise for we should also catch it\n        // somewhere and act on that error (like logging).\n        //\n        // Return a rejection to stop executing updateCostumeAsset.\n        return Promise.reject('No V2 Bitmap adapter present.');\n      }\n      var storage = runtime.storage;\n      costume.asset = storage.createAsset(storage.AssetType.ImageBitmap, storage.DataFormat.PNG, runtime.v2BitmapAdapter.convertDataURIToBinary(dataURI), null, true // generate md5\n      );\n      costume.dataFormat = storage.DataFormat.PNG;\n      costume.assetId = costume.asset.assetId;\n      costume.md5 = \"\".concat(costume.assetId, \".\").concat(costume.dataFormat);\n    };\n    if (!fetched.assetMatchesBase) {\n      updateCostumeAsset(fetched.canvas.toDataURL());\n    }\n    return fetched;\n  }).then(function (_ref3) {\n    var canvas = _ref3.canvas,\n        mergeCanvas = _ref3.mergeCanvas,\n        rotationCenter = _ref3.rotationCenter;\n    // createBitmapSkin does the right thing if costume.rotationCenter is undefined.\n    // That will be the case if you upload a bitmap asset or create one by taking a photo.\n    var center;\n    if (rotationCenter) {\n      // fetchBitmapCanvas will ensure that the costume's bitmap resolution is 2 and its rotation center is\n      // scaled to match, so it's okay to always divide by 2.\n      center = [rotationCenter[0] / 2, rotationCenter[1] / 2];\n    } // TODO: costume.bitmapResolution will always be 2 at this point because of fetchBitmapCanvas_, so we don't\n    // need to pass it in here.\n    costume.skinId = runtime.renderer.createBitmapSkin(canvas, costume.bitmapResolution, center);\n    canvasPool.release(mergeCanvas);\n    var renderSize = runtime.renderer.getSkinSize(costume.skinId);\n    costume.size = [renderSize[0] * 2, renderSize[1] * 2]; // Actual size, since all bitmaps are resolution 2\n    if (!rotationCenter) {\n      rotationCenter = runtime.renderer.getSkinRotationCenter(costume.skinId); // Actual rotation center, since all bitmaps are resolution 2\n      costume.rotationCenterX = rotationCenter[0] * 2;\n      costume.rotationCenterY = rotationCenter[1] * 2;\n      costume.bitmapResolution = 2;\n    }\n    return costume;\n  });\n};\n/**\n * Initialize a costume from an asset asynchronously.\n * Do not call this unless there is a renderer attached.\n * @param {!object} costume - the Scratch costume object.\n * @property {int} skinId - the ID of the costume's render skin, once installed.\n * @property {number} rotationCenterX - the X component of the costume's origin.\n * @property {number} rotationCenterY - the Y component of the costume's origin.\n * @property {number} [bitmapResolution] - the resolution scale for a bitmap costume.\n * @property {!Asset} costume.asset - the asset of the costume loaded from storage.\n * @param {!Runtime} runtime - Scratch runtime, used to access the storage module.\n * @param {?int} optVersion - Version of Scratch that the costume comes from. If this is set\n *     to 2, scratch 3 will perform an upgrade step to handle quirks in SVGs from Scratch 2.0.\n * @returns {?Promise} - a promise which will resolve after skinId is set, or null on error.\n */\nvar loadCostumeFromAsset = function loadCostumeFromAsset(costume, runtime, optVersion) {\n  costume.assetId = costume.asset.assetId;\n  var renderer = runtime.renderer;\n  if (!renderer) {\n    log.error('No rendering module present; cannot load costume: ', costume.name);\n    return Promise.resolve(costume);\n  }\n  var AssetType = runtime.storage.AssetType;\n  var rotationCenter; // Use provided rotation center and resolution if they are defined. Bitmap resolution\n  // should only ever be 1 or 2.\n  if (typeof costume.rotationCenterX === 'number' && !isNaN(costume.rotationCenterX) && typeof costume.rotationCenterY === 'number' && !isNaN(costume.rotationCenterY)) {\n    rotationCenter = [costume.rotationCenterX, costume.rotationCenterY];\n  }\n  if (costume.asset.assetType.runtimeFormat === AssetType.ImageVector.runtimeFormat) {\n    return loadVector_(costume, runtime, rotationCenter, optVersion).catch(function (error) {\n      log.warn(\"Error loading vector image: \".concat(error.name, \": \").concat(error.message)); // Use default asset if original fails to load\n      costume.assetId = runtime.storage.defaultAssetId.ImageVector;\n      costume.asset = runtime.storage.get(costume.assetId);\n      costume.md5 = \"\".concat(costume.assetId, \".\").concat(AssetType.ImageVector.runtimeFormat);\n      return loadVector_(costume, runtime);\n    });\n  }\n  return loadBitmap_(costume, runtime, rotationCenter, optVersion);\n};\n/**\n * Load a costume's asset into memory asynchronously.\n * Do not call this unless there is a renderer attached.\n * @param {!string} md5ext - the MD5 and extension of the costume to be loaded.\n * @param {!object} costume - the Scratch costume object.\n * @property {int} skinId - the ID of the costume's render skin, once installed.\n * @property {number} rotationCenterX - the X component of the costume's origin.\n * @property {number} rotationCenterY - the Y component of the costume's origin.\n * @property {number} [bitmapResolution] - the resolution scale for a bitmap costume.\n * @param {!Runtime} runtime - Scratch runtime, used to access the storage module.\n * @param {?int} optVersion - Version of Scratch that the costume comes from. If this is set\n *     to 2, scratch 3 will perform an upgrade step to handle quirks in SVGs from Scratch 2.0.\n * @returns {?Promise} - a promise which will resolve after skinId is set, or null on error.\n */\nvar loadCostume = function loadCostume(md5ext, costume, runtime, optVersion) {\n  var idParts = StringUtil.splitFirst(md5ext, '.');\n  var md5 = idParts[0];\n  var ext = idParts[1].toLowerCase();\n  costume.dataFormat = ext;\n  if (costume.asset) {\n    // Costume comes with asset. It could be coming from camera, image upload, drag and drop, or file\n    return loadCostumeFromAsset(costume, runtime, optVersion);\n  } // Need to load the costume from storage. The server should have a reference to this md5.\n  if (!runtime.storage) {\n    log.error('No storage module present; cannot load costume asset: ', md5ext);\n    return Promise.resolve(costume);\n  }\n  if (!runtime.storage.defaultAssetId) {\n    log.error(\"No default assets found\");\n    return Promise.resolve(costume);\n  }\n  var AssetType = runtime.storage.AssetType;\n  var assetType = ext === 'svg' ? AssetType.ImageVector : AssetType.ImageBitmap;\n  var costumePromise = runtime.storage.load(assetType, md5, ext);\n  if (!costumePromise) {\n    log.error(\"Couldn't fetch costume asset: \".concat(md5ext));\n    return;\n  }\n  var textLayerPromise;\n  if (costume.textLayerMD5) {\n    textLayerPromise = runtime.storage.load(AssetType.ImageBitmap, costume.textLayerMD5, 'png');\n  } else {\n    textLayerPromise = Promise.resolve(null);\n  }\n  return Promise.all([costumePromise, textLayerPromise]).then(function (assetArray) {\n    costume.asset = assetArray[0];\n    if (assetArray[1]) {\n      costume.textLayerAsset = assetArray[1];\n    }\n    return loadCostumeFromAsset(costume, runtime, optVersion);\n  });\n};\nmodule.exports = {\n  loadCostume: loadCostume,\n  loadCostumeFromAsset: loadCostumeFromAsset\n};\n })