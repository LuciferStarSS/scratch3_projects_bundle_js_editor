/* 1250 */\n (function(module, exports, __webpack_require__) {\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nvar twgl = __webpack_require__(103);\nvar RenderConstants = __webpack_require__(230);\nvar Skin = __webpack_require__(187);\nvar ShaderManager = __webpack_require__(188);\n/**\n * Attributes to use when drawing with the pen\n * @typedef {object} PenSkin#PenAttributes\n * @property {number} [diameter] - The size (diameter) of the pen.\n * @property {Array<number>} [color4f] - The pen color as an array of [r,g,b,a], each component in the range [0,1].\n */\n/**\n * The pen attributes to use when unspecified.\n * @type {PenSkin#PenAttributes}\n * @memberof PenSkin\n * @private\n * @const\n */\nvar DefaultPenAttributes = {\n  color4f: [0, 0, 1, 1],\n  diameter: 1\n};\n/**\n * Reused memory location for storing a premultiplied pen color.\n * @type {FloatArray}\n */\nvar __premultipliedColor = [0, 0, 0, 0];\nvar PenSkin = function (_Skin) {\n  _inherits(PenSkin, _Skin);\n  var _super = _createSuper(PenSkin);\n  /**\n   * Create a Skin which implements a Scratch pen layer.\n   * @param {int} id - The unique ID for this Skin.\n   * @param {RenderWebGL} renderer - The renderer which will use this Skin.\n   * @extends Skin\n   * @listens RenderWebGL#event:NativeSizeChanged\n   */\n  function PenSkin(id, renderer) {\n    var _this;\n    _classCallCheck(this, PenSkin);\n    _this = _super.call(this, id);\n    /**\n     * @private\n     * @type {RenderWebGL}\n     */\n    _this._renderer = renderer;\n    /** @type {Array<number>} */\n    _this._size = null;\n    /** @type {WebGLFramebuffer} */\n    _this._framebuffer = null;\n    /** @type {boolean} */\n    _this._silhouetteDirty = false;\n    /** @type {Uint8Array} */\n    _this._silhouettePixels = null;\n    /** @type {ImageData} */\n    _this._silhouetteImageData = null;\n    /** @type {object} */\n    _this._lineOnBufferDrawRegionId = {\n      enter: function enter() {\n        return _this._enterDrawLineOnBuffer();\n      },\n      exit: function exit() {\n        return _this._exitDrawLineOnBuffer();\n      }\n    };\n    /** @type {object} */\n    _this._usePenBufferDrawRegionId = {\n      enter: function enter() {\n        return _this._enterUsePenBuffer();\n      },\n      exit: function exit() {\n        return _this._exitUsePenBuffer();\n      }\n    };\n    /** @type {twgl.BufferInfo} */\n    _this._lineBufferInfo = twgl.createBufferInfoFromArrays(_this._renderer.gl, {\n      a_position: {\n        numComponents: 2,\n        data: [1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1]\n      }\n    });\n    var NO_EFFECTS = 0;\n    /** @type {twgl.ProgramInfo} */\n    _this._lineShader = _this._renderer._shaderManager.getShader(ShaderManager.DRAW_MODE.line, NO_EFFECTS);\n    _this.onNativeSizeChanged = _this.onNativeSizeChanged.bind(_assertThisInitialized(_this));\n    _this._renderer.on(RenderConstants.Events.NativeSizeChanged, _this.onNativeSizeChanged);\n    _this._setCanvasSize(renderer.getNativeSize());\n    return _this;\n  }\n  /**\n   * Dispose of this object. Do not use it after calling this method.\n   */\n  _createClass(PenSkin, [{\n    key: \"dispose\",\n    value: function dispose() {\n      this._renderer.removeListener(RenderConstants.Events.NativeSizeChanged, this.onNativeSizeChanged);\n      this._renderer.gl.deleteTexture(this._texture);\n      this._texture = null;\n      _get(_getPrototypeOf(PenSkin.prototype), \"dispose\", this).call(this);\n    }\n    /**\n     * @return {Array<number>} the \"native\" size, in texels, of this skin. [width, height]\n     */\n  }, {\n    key: \"useNearest\",\n    value: function useNearest(scale) {\n      // Use nearest-neighbor interpolation when scaling up the pen skin-- this matches Scratch 2.0.\n      // When scaling it down, use linear interpolation to avoid giving pen lines a \"dashed\" appearance.\n      return Math.max(scale[0], scale[1]) >= 100;\n    }\n    /**\n     * @param {Array<number>} scale The X and Y scaling factors to be used, as percentages of this skin's \"native\" size.\n     * @return {WebGLTexture} The GL texture representation of this skin when drawing at the given size.\n     */\n    // eslint-disable-next-line no-unused-vars\n  }, {\n    key: \"getTexture\",\n    value: function getTexture(scale) {\n      return this._texture;\n    }\n    /**\n     * Clear the pen layer.\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._renderer.enterDrawRegion(this._usePenBufferDrawRegionId);\n      /* Reset framebuffer to transparent black */\n      var gl = this._renderer.gl;\n      gl.clearColor(0, 0, 0, 0);\n      gl.clear(gl.COLOR_BUFFER_BIT);\n      this._silhouetteDirty = true;\n    }\n    /**\n     * Draw a point on the pen layer.\n     * @param {PenAttributes} penAttributes - how the point should be drawn.\n     * @param {number} x - the X coordinate of the point to draw.\n     * @param {number} y - the Y coordinate of the point to draw.\n     */\n  }, {\n    key: \"drawPoint\",\n    value: function drawPoint(penAttributes, x, y) {\n      this.drawLine(penAttributes, x, y, x, y);\n    }\n    /**\n     * Draw a line on the pen layer.\n     * @param {PenAttributes} penAttributes - how the line should be drawn.\n     * @param {number} x0 - the X coordinate of the beginning of the line.\n     * @param {number} y0 - the Y coordinate of the beginning of the line.\n     * @param {number} x1 - the X coordinate of the end of the line.\n     * @param {number} y1 - the Y coordinate of the end of the line.\n     */\n  }, {\n    key: \"drawLine\",\n    value: function drawLine(penAttributes, x0, y0, x1, y1) {\n      // For compatibility with Scratch 2.0, offset pen lines of width 1 and 3 so they're pixel-aligned.\n      // See https://github.com/LLK/scratch-render/pull/314\n      var diameter = penAttributes.diameter || DefaultPenAttributes.diameter;\n      var offset = diameter === 1 || diameter === 3 ? 0.5 : 0;\n      this._drawLineOnBuffer(penAttributes, x0 + offset, y0 + offset, x1 + offset, y1 + offset);\n      this._silhouetteDirty = true;\n    }\n    /**\n     * Prepare to draw lines in the _lineOnBufferDrawRegionId region.\n     */\n  }, {\n    key: \"_enterDrawLineOnBuffer\",\n    value: function _enterDrawLineOnBuffer() {\n      var gl = this._renderer.gl;\n      twgl.bindFramebufferInfo(gl, this._framebuffer);\n      gl.viewport(0, 0, this._size[0], this._size[1]);\n      var currentShader = this._lineShader;\n      gl.useProgram(currentShader.program);\n      twgl.setBuffersAndAttributes(gl, currentShader, this._lineBufferInfo);\n      var uniforms = {\n        u_skin: this._texture,\n        u_stageSize: this._size\n      };\n      twgl.setUniforms(currentShader, uniforms);\n    }\n    /**\n     * Return to a base state from _lineOnBufferDrawRegionId.\n     */\n  }, {\n    key: \"_exitDrawLineOnBuffer\",\n    value: function _exitDrawLineOnBuffer() {\n      var gl = this._renderer.gl;\n      twgl.bindFramebufferInfo(gl, null);\n    }\n    /**\n     * Prepare to do things with this PenSkin's framebuffer\n     */\n  }, {\n    key: \"_enterUsePenBuffer\",\n    value: function _enterUsePenBuffer() {\n      twgl.bindFramebufferInfo(this._renderer.gl, this._framebuffer);\n    }\n    /**\n     * Return to a base state\n     */\n  }, {\n    key: \"_exitUsePenBuffer\",\n    value: function _exitUsePenBuffer() {\n      twgl.bindFramebufferInfo(this._renderer.gl, null);\n    }\n    /**\n     * Draw a line on the framebuffer.\n     * Note that the point coordinates are in the following coordinate space:\n     * +y is down, (0, 0) is the center, and the coords range from (-width / 2, -height / 2) to (height / 2, width / 2).\n     * @param {PenAttributes} penAttributes - how the line should be drawn.\n     * @param {number} x0 - the X coordinate of the beginning of the line.\n     * @param {number} y0 - the Y coordinate of the beginning of the line.\n     * @param {number} x1 - the X coordinate of the end of the line.\n     * @param {number} y1 - the Y coordinate of the end of the line.\n     */\n  }, {\n    key: \"_drawLineOnBuffer\",\n    value: function _drawLineOnBuffer(penAttributes, x0, y0, x1, y1) {\n      var gl = this._renderer.gl;\n      var currentShader = this._lineShader;\n      this._renderer.enterDrawRegion(this._lineOnBufferDrawRegionId); // Premultiply pen color by pen transparency\n      var penColor = penAttributes.color4f || DefaultPenAttributes.color4f;\n      __premultipliedColor[0] = penColor[0] * penColor[3];\n      __premultipliedColor[1] = penColor[1] * penColor[3];\n      __premultipliedColor[2] = penColor[2] * penColor[3];\n      __premultipliedColor[3] = penColor[3]; // Fun fact: Doing this calculation in the shader has the potential to overflow the floating-point range.\n      // 'mediump' precision is only required to have a range up to 2^14 (16384), so any lines longer than 2^7 (128)\n      // can overflow that, because you're squaring the operands, and they could end up as \"infinity\".\n      // Even GLSL's `length` function won't save us here:\n      // https://asawicki.info/news_1596_watch_out_for_reduced_precision_normalizelength_in_opengl_es\n      var lineDiffX = x1 - x0;\n      var lineDiffY = y1 - y0;\n      var lineLength = Math.sqrt(lineDiffX * lineDiffX + lineDiffY * lineDiffY);\n      var uniforms = {\n        u_lineColor: __premultipliedColor,\n        u_lineThickness: penAttributes.diameter || DefaultPenAttributes.diameter,\n        u_lineLength: lineLength,\n        u_penPoints: [x0, -y0, lineDiffX, -lineDiffY]\n      };\n      twgl.setUniforms(currentShader, uniforms);\n      twgl.drawBufferInfo(gl, this._lineBufferInfo, gl.TRIANGLES);\n      this._silhouetteDirty = true;\n    }\n    /**\n     * React to a change in the renderer's native size.\n     * @param {object} event - The change event.\n     */\n  }, {\n    key: \"onNativeSizeChanged\",\n    value: function onNativeSizeChanged(event) {\n      this._setCanvasSize(event.newSize);\n    }\n    /**\n     * Set the size of the pen canvas.\n     * @param {Array<int>} canvasSize - the new width and height for the canvas.\n     * @private\n     */\n  }, {\n    key: \"_setCanvasSize\",\n    value: function _setCanvasSize(canvasSize) {\n      var _canvasSize = _slicedToArray(canvasSize, 2),\n          width = _canvasSize[0],\n          height = _canvasSize[1];\n      this._size = canvasSize;\n      this._rotationCenter[0] = width / 2;\n      this._rotationCenter[1] = height / 2;\n      var gl = this._renderer.gl;\n      this._texture = twgl.createTexture(gl, {\n        mag: gl.NEAREST,\n        min: gl.NEAREST,\n        wrap: gl.CLAMP_TO_EDGE,\n        width: width,\n        height: height\n      });\n      var attachments = [{\n        format: gl.RGBA,\n        attachment: this._texture\n      }];\n      if (this._framebuffer) {\n        twgl.resizeFramebufferInfo(gl, this._framebuffer, attachments, width, height);\n      } else {\n        this._framebuffer = twgl.createFramebufferInfo(gl, attachments, width, height);\n      }\n      gl.clearColor(0, 0, 0, 0);\n      gl.clear(gl.COLOR_BUFFER_BIT);\n      this._silhouettePixels = new Uint8Array(Math.floor(width * height * 4));\n      this._silhouetteImageData = new ImageData(width, height);\n      this._silhouetteDirty = true;\n    }\n    /**\n     * If there have been pen operations that have dirtied the canvas, update\n     * now before someone wants to use our silhouette.\n     */\n  }, {\n    key: \"updateSilhouette\",\n    value: function updateSilhouette() {\n      if (this._silhouetteDirty) {\n        this._renderer.enterDrawRegion(this._usePenBufferDrawRegionId); // Sample the framebuffer's pixels into the silhouette instance\n        var gl = this._renderer.gl;\n        gl.readPixels(0, 0, this._size[0], this._size[1], gl.RGBA, gl.UNSIGNED_BYTE, this._silhouettePixels);\n        this._silhouetteImageData.data.set(this._silhouettePixels);\n        this._silhouette.update(this._silhouetteImageData, true\n        /* isPremultiplied */\n        );\n        this._silhouetteDirty = false;\n      }\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this._size;\n    }\n  }]);\n  return PenSkin;\n}(Skin);\nmodule.exports = PenSkin;\n })