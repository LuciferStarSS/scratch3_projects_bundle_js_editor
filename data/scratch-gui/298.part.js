/* 298 */\n (function(module, exports, __webpack_require__) {\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nvar Timer = __webpack_require__(136);\nvar RateLimiter = function () {\n  /**\n   * A utility for limiting the rate of repetitive send operations, such as\n   * bluetooth messages being sent to hardware devices. It uses the token bucket\n   * strategy: a counter accumulates tokens at a steady rate, and each send costs\n   * a token. If no tokens remain, it's not okay to send.\n   * @param {number} maxRate the maximum number of sends allowed per second\n   * @constructor\n   */\n  function RateLimiter(maxRate) {\n    _classCallCheck(this, RateLimiter);\n    /**\n     * The maximum number of tokens.\n     * @type {number}\n     */\n    this._maxTokens = maxRate;\n    /**\n     * The interval in milliseconds for refilling one token. It is calculated\n     * so that the tokens will be filled to maximum in one second.\n     * @type {number}\n     */\n    this._refillInterval = 1000 / maxRate;\n    /**\n     * The current number of tokens in the bucket.\n     * @type {number}\n     */\n    this._count = this._maxTokens;\n    this._timer = new Timer();\n    this._timer.start();\n    /**\n     * The last time in milliseconds when the token count was updated.\n     * @type {number}\n     */\n    this._lastUpdateTime = this._timer.timeElapsed();\n  }\n  /**\n   * Check if it is okay to send a message, by updating the token count,\n   * taking a token and then checking if we are still under the rate limit.\n   * @return {boolean} true if we are under the rate limit\n   */\n  _createClass(RateLimiter, [{\n    key: \"okayToSend\",\n    value: function okayToSend() {\n      // Calculate the number of tokens to refill the bucket with, based on the\n      // amount of time since the last refill.\n      var now = this._timer.timeElapsed();\n      var timeSinceRefill = now - this._lastUpdateTime;\n      var refillCount = Math.floor(timeSinceRefill / this._refillInterval); // If we're adding at least one token, reset _lastUpdateTime to now.\n      // Otherwise, don't reset it so that we can continue measuring time until\n      // the next refill.\n      if (refillCount > 0) {\n        this._lastUpdateTime = now;\n      } // Refill the tokens up to the maximum\n      this._count = Math.min(this._maxTokens, this._count + refillCount); // If we have at least one token, use one, and it's okay to send.\n      if (this._count > 0) {\n        this._count--;\n        return true;\n      }\n      return false;\n    }\n  }]);\n  return RateLimiter;\n}();\nmodule.exports = RateLimiter;\n })