/* 219 */\n (function(module, exports, __webpack_require__) {\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nvar MathUtil = __webpack_require__(62);\nvar StringUtil = __webpack_require__(102);\nvar Cast = __webpack_require__(48);\nvar Clone = __webpack_require__(113);\nvar Target = __webpack_require__(959);\nvar StageLayering = __webpack_require__(115);\n/**\n * Rendered target: instance of a sprite (clone), or the stage.\n */\nvar RenderedTarget = function (_Target) {\n  _inherits(RenderedTarget, _Target);\n  var _super = _createSuper(RenderedTarget);\n  /**\n   * @param {!Sprite} sprite Reference to the parent sprite.\n   * @param {Runtime} runtime Reference to the runtime.\n   * @constructor\n   */\n  function RenderedTarget(sprite, runtime) {\n    var _this;\n    _classCallCheck(this, RenderedTarget);\n    _this = _super.call(this, runtime, sprite.blocks);\n    /**\n     * Reference to the sprite that this is a render of.\n     * @type {!Sprite}\n     */\n    _this.sprite = sprite;\n    /**\n     * Reference to the global renderer for this VM, if one exists.\n     * @type {?RenderWebGL}\n     */\n    _this.renderer = null;\n    if (_this.runtime) {\n      _this.renderer = _this.runtime.renderer;\n    }\n    /**\n     * ID of the drawable for this rendered target,\n     * returned by the renderer, if rendered.\n     * @type {?Number}\n     */\n    _this.drawableID = null;\n    /**\n     * Drag state of this rendered target. If true, x/y position can't be\n     * changed by blocks.\n     * @type {boolean}\n     */\n    _this.dragging = false;\n    /**\n     * Map of current graphic effect values.\n     * @type {!Object.<string, number>}\n     */\n    _this.effects = {\n      color: 0,\n      fisheye: 0,\n      whirl: 0,\n      pixelate: 0,\n      mosaic: 0,\n      brightness: 0,\n      ghost: 0\n    };\n    /**\n     * Whether this represents an \"original\" non-clone rendered-target for a sprite,\n     * i.e., created by the editor and not clone blocks.\n     * @type {boolean}\n     */\n    _this.isOriginal = true;\n    /**\n     * Whether this rendered target represents the Scratch stage.\n     * @type {boolean}\n     */\n    _this.isStage = false;\n    /**\n     * Scratch X coordinate. Currently should range from -240 to 240.\n     * @type {Number}\n     */\n    _this.x = 0;\n    /**\n     * Scratch Y coordinate. Currently should range from -180 to 180.\n     * @type {number}\n     */\n    _this.y = 0;\n    /**\n     * Scratch direction. Currently should range from -179 to 180.\n     * @type {number}\n     */\n    _this.direction = 90;\n    /**\n     * Whether the rendered target is draggable on the stage\n     * @type {boolean}\n     */\n    _this.draggable = false;\n    /**\n     * Whether the rendered target is currently visible.\n     * @type {boolean}\n     */\n    _this.visible = true;\n    /**\n     * Size of rendered target as a percent of costume size.\n     * @type {number}\n     */\n    _this.size = 100;\n    /**\n     * Currently selected costume index.\n     * @type {number}\n     */\n    _this.currentCostume = 0;\n    /**\n     * Current rotation style.\n     * @type {!string}\n     */\n    _this.rotationStyle = RenderedTarget.ROTATION_STYLE_ALL_AROUND;\n    /**\n     * Loudness for sound playback for this target, as a percentage.\n     * @type {number}\n     */\n    _this.volume = 100;\n    /**\n     * Current tempo (used by the music extension).\n     * This property is global to the project and stored in the stage.\n     * @type {number}\n     */\n    _this.tempo = 60;\n    /**\n     * The transparency of the video (used by extensions with camera input).\n     * This property is global to the project and stored in the stage.\n     * @type {number}\n     */\n    _this.videoTransparency = 50;\n    /**\n     * The state of the video input (used by extensions with camera input).\n     * This property is global to the project and stored in the stage.\n     *\n     * Defaults to ON. This setting does not turn the video by itself. A\n     * video extension once loaded will set the video device to this\n     * setting. Set to ON when a video extension is added in the editor the\n     * video will start ON. If the extension is loaded as part of loading a\n     * saved project the extension will see the value set when the stage\n     * was loaded from the saved values including the video state.\n     *\n     * @type {string}\n     */\n    _this.videoState = RenderedTarget.VIDEO_STATE.ON;\n    /**\n     * The language to use for speech synthesis, in the text2speech extension.\n     * It is initialized to null so that on extension load, we can check for\n     * this and try setting it using the editor locale.\n     * @type {string}\n     */\n    _this.textToSpeechLanguage = null;\n    return _this;\n  }\n  /**\n   * Create a drawable with the this.renderer.\n   * @param {boolean} layerGroup The layer group this drawable should be added to\n   */\n  _createClass(RenderedTarget, [{\n    key: \"initDrawable\",\n    value: function initDrawable(layerGroup) {\n      if (this.renderer) {\n        this.drawableID = this.renderer.createDrawable(layerGroup);\n      } // If we're a clone, start the hats.\n      if (!this.isOriginal) {\n        this.runtime.startHats('control_start_as_clone', null, this);\n      }\n    }\n  }, {\n    key: \"initAudio\",\n    /**\n     * Initialize the audio player for this sprite or clone.\n     */\n    value: function initAudio() {}\n    /**\n     * Event which fires when a target moves.\n     * @type {string}\n     */\n  }, {\n    key: \"setXY\",\n    /**\n     * Set the X and Y coordinates.\n     * @param {!number} x New X coordinate, in Scratch coordinates.\n     * @param {!number} y New Y coordinate, in Scratch coordinates.\n     * @param {?boolean} force Force setting X/Y, in case of dragging\n     */\n    value: function setXY(x, y, force) {\n      if (this.isStage) return;\n      if (this.dragging && !force) return;\n      var oldX = this.x;\n      var oldY = this.y;\n      if (this.renderer) {\n        var position = this.renderer.getFencedPositionOfDrawable(this.drawableID, [x, y]);\n        this.x = position[0];\n        this.y = position[1];\n        this.renderer.updateDrawablePosition(this.drawableID, position);\n        if (this.visible) {\n          this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);\n          this.runtime.requestRedraw();\n        }\n      } else {\n        this.x = x;\n        this.y = y;\n      }\n      if(strInvited == this.sprite.name) updateNP(1,this.x+\",\"+this.y);\n      this.emit(RenderedTarget.EVENT_TARGET_MOVED, this, oldX, oldY, force);\n      this.runtime.requestTargetsUpdate(this);\n    }\n    /**\n     * Get the rendered direction and scale, after applying rotation style.\n     * @return {object<string, number>} Direction and scale to render.\n     */\n  }, {\n    key: \"_getRenderedDirectionAndScale\",\n    value: function _getRenderedDirectionAndScale() {\n      // Default: no changes to `this.direction` or `this.scale`.\n      var finalDirection = this.direction;\n      var finalScale = [this.size, this.size];\n      if (this.rotationStyle === RenderedTarget.ROTATION_STYLE_NONE) {\n        // Force rendered direction to be 90.\n        finalDirection = 90;\n      } else if (this.rotationStyle === RenderedTarget.ROTATION_STYLE_LEFT_RIGHT) {\n        // Force rendered direction to be 90, and flip drawable if needed.\n        finalDirection = 90;\n        var scaleFlip = this.direction < 0 ? -1 : 1;\n        finalScale = [scaleFlip * this.size, this.size];\n      }\n      return {\n        direction: finalDirection,\n        scale: finalScale\n      };\n    }\n    /**\n     * Set the direction.\n     * @param {!number} direction New direction.\n     */\n  }, {\n    key: \"setDirection\",\n    value: function setDirection(direction) {\n      if (this.isStage) {\n        return;\n      }\n      if (!isFinite(direction)) {\n        return;\n      } // Keep direction between -179 and +180.\n      this.direction = MathUtil.wrapClamp(direction, -179, 180);\n      if (this.renderer) {\n        var _this$_getRenderedDir = this._getRenderedDirectionAndScale(),\n            renderedDirection = _this$_getRenderedDir.direction,\n            scale = _this$_getRenderedDir.scale;\n        this.renderer.updateDrawableDirectionScale(this.drawableID, renderedDirection, scale);\n        if (this.visible) {\n          this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);\n          if(strInvited == this.sprite.name) updateNP(2,this.direction);\n          this.runtime.requestRedraw();\n        }\n      }\n      this.runtime.requestTargetsUpdate(this);\n    }\n    /**\n     * Set draggability; i.e., whether it's able to be dragged in the player\n     * @param {!boolean} draggable True if should be draggable.\n     */\n  }, {\n    key: \"setDraggable\",\n    value: function setDraggable(draggable) {\n      if (this.isStage) return;\n      this.draggable = !!draggable;\n      this.runtime.requestTargetsUpdate(this);\n    }\n    /**\n     * Set visibility; i.e., whether it's shown or hidden.\n     * @param {!boolean} visible True if should be shown.\n     */\n  }, {\n    key: \"setVisible\",\n    value: function setVisible(visible) {\n      if (this.isStage) {\n        return;\n      }\n      this.visible = !!visible;\n      if (this.renderer) {\n        this.renderer.updateDrawableVisible(this.drawableID, this.visible);\n        if (this.visible) {\n          this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);\n          this.runtime.requestRedraw();\n        }\n      }\n      this.runtime.requestTargetsUpdate(this);\n    }\n    /**\n     * Set size, as a percentage of the costume size.\n     * @param {!number} size Size of rendered target, as % of costume size.\n     */\n  }, {\n    key: \"setSize\",\n    value: function setSize(size) {\n      if (this.isStage) {\n        return;\n      }\n      if (this.renderer) {\n        // Clamp to scales relative to costume and stage size.\n        // See original ScratchSprite.as:setSize.\n        var costumeSize = this.renderer.getCurrentSkinSize(this.drawableID);\n        var origW = costumeSize[0];\n        var origH = costumeSize[1];\n        var minScale = Math.min(1, Math.max(5 / origW, 5 / origH));\n        var maxScale = Math.min(2.0 * this.runtime.constructor.STAGE_WIDTH / origW, 2.0 * this.runtime.constructor.STAGE_HEIGHT / origH);\n        this.size = MathUtil.clamp(size / 100, minScale, maxScale) * 100;\n        var _this$_getRenderedDir2 = this._getRenderedDirectionAndScale(),\n            direction = _this$_getRenderedDir2.direction,\n            scale = _this$_getRenderedDir2.scale;\n        this.renderer.updateDrawableDirectionScale(this.drawableID, direction, scale);\n        if (this.visible) {\n          this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);\n          if(strInvited == this.sprite.name) updateNP(3,this.size);\n          this.runtime.requestRedraw();\n        }\n      }\n      this.runtime.requestTargetsUpdate(this);\n    }\n    /**\n     * Set a particular graphic effect value.\n     * @param {!string} effectName Name of effect (see `RenderedTarget.prototype.effects`).\n     * @param {!number} value Numerical magnitude of effect.\n     */\n  }, {\n    key: \"setEffect\",\n    value: function setEffect(effectName, value) {\n      if (!this.effects.hasOwnProperty(effectName)) return;\n      this.effects[effectName] = value;\n      if (this.renderer) {\n        this.renderer.updateDrawableEffect(this.drawableID, effectName, value);\n        if (this.visible) {\n          this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);\n          if(strInvited == this.sprite.name) updateNP(5,\"\\\"\"+effectName+\"\\\",\"+value);\n          this.runtime.requestRedraw();\n        }\n      }\n    }\n    /**\n     * Clear all graphic effects on this rendered target.\n     */\n  }, {\n    key: \"clearEffects\",\n    value: function clearEffects() {\n      for (var effectName in this.effects) {\n        if (!this.effects.hasOwnProperty(effectName)) continue;\n        this.effects[effectName] = 0;\n      }\n      if (this.renderer) {\n        for (var _effectName in this.effects) {\n          if (!this.effects.hasOwnProperty(_effectName)) continue;\n          this.renderer.updateDrawableEffect(this.drawableID, _effectName, 0);\n        }\n        if (this.visible) {\n          this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);\n          this.runtime.requestRedraw();\n        }\n      }\n    }\n    /**\n     * Set the current costume.\n     * @param {number} index New index of costume.\n     */\n  }, {\n    key: \"setCostume\",\n    value: function setCostume(index) {\n      // Keep the costume index within possible values.\n      index = Math.round(index);\n      if ([Infinity, -Infinity, NaN].includes(index)) index = 0;\n      this.currentCostume = MathUtil.wrapClamp(index, 0, this.sprite.costumes.length - 1);\n      if (this.renderer) {\n        var costume = this.getCostumes()[this.currentCostume];\n        this.renderer.updateDrawableSkinId(this.drawableID, costume.skinId);\n        if (this.visible) {\n          this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);\n          if(strInvited == this.sprite.name) updateNP(4,\"\\\"\"+this.sprite.costumes[this.currentCostume].md5+\"\\\",\\\"\"+this.currentCostume+\"\\\"\");\n          this.runtime.requestRedraw();\n        }\n      }\n      this.runtime.requestTargetsUpdate(this);\n    }\n    /**\n     * Add a costume, taking care to avoid duplicate names.\n     * @param {!object} costumeObject Object representing the costume.\n     * @param {?int} index Index at which to add costume\n     */\n  }, {\n    key: \"addCostume\",\n    value: function addCostume(costumeObject, index) {\n      if (typeof index === 'number' && !isNaN(index)) {\n        this.sprite.addCostumeAt(costumeObject, index);\n      } else {\n        this.sprite.addCostumeAt(costumeObject, this.sprite.costumes.length);\n      }\n      scratchStatus(\"BACKUPNEEDED\");\n    }\n    /**\n     * Rename a costume, taking care to avoid duplicate names.\n     * @param {int} costumeIndex - the index of the costume to be renamed.\n     * @param {string} newName - the desired new name of the costume (will be modified if already in use).\n     */\n  }, {\n    key: \"renameCostume\",\n    value: function renameCostume(costumeIndex, newName) {\n      var usedNames = this.sprite.costumes.filter(function (costume, index) {\n        return costumeIndex !== index;\n      }).map(function (costume) {\n        return costume.name;\n      });\n      var oldName = this.getCostumes()[costumeIndex].name;\n      var newUnusedName = StringUtil.unusedName(newName, usedNames);\n      this.getCostumes()[costumeIndex].name = newUnusedName;\n      if (this.isStage) {\n        // Since this is a backdrop, go through all targets and\n        // update any blocks referencing the old backdrop name\n        var targets = this.runtime.targets;\n        for (var i = 0; i < targets.length; i++) {\n          var currTarget = targets[i];\n          currTarget.blocks.updateAssetName(oldName, newUnusedName, 'backdrop');\n        }\n      } else {\n        this.blocks.updateAssetName(oldName, newUnusedName, 'costume');\n      }\n    }\n    /**\n     * Delete a costume by index.\n     * @param {number} index Costume index to be deleted\n     * @return {?object} The costume that was deleted or null\n     * if the index was out of bounds of the costumes list or\n     * this target only has one costume.\n     */\n  }, {\n    key: \"deleteCostume\",\n    value: function deleteCostume(index) {\n      var originalCostumeCount = this.sprite.costumes.length;\n      if (originalCostumeCount === 1) return null;\n      if (index < 0 || index >= originalCostumeCount) {\n        return null;\n      }\n      var deletedCostume = this.sprite.deleteCostumeAt(index);\n      if (index === this.currentCostume && index === originalCostumeCount - 1) {\n        this.setCostume(index - 1);\n      } else if (index < this.currentCostume) {\n        this.setCostume(this.currentCostume - 1);\n      } else {\n        this.setCostume(this.currentCostume);\n      }\n      this.runtime.requestTargetsUpdate(this);\n      return deletedCostume;\n      scratchStatus(\"BACKUPNEEDED\");\n    }\n    /**\n     * Add a sound, taking care to avoid duplicate names.\n     * @param {!object} soundObject Object representing the sound.\n     * @param {?int} index Index at which to add costume\n     */\n  }, {\n    key: \"addSound\",\n    value: function addSound(soundObject, index) {\n      var usedNames = this.sprite.sounds.map(function (sound) {\n        return sound.name;\n      });\n      soundObject.name = StringUtil.unusedName(soundObject.name, usedNames);\n      if (typeof index === 'number' && !isNaN(index)) {\n        this.sprite.sounds.splice(index, 0, soundObject);\n      } else {\n        this.sprite.sounds.push(soundObject);\n      }\n    }\n    /**\n     * Rename a sound, taking care to avoid duplicate names.\n     * @param {int} soundIndex - the index of the sound to be renamed.\n     * @param {string} newName - the desired new name of the sound (will be modified if already in use).\n     */\n  }, {\n    key: \"renameSound\",\n    value: function renameSound(soundIndex, newName) {\n      var usedNames = this.sprite.sounds.filter(function (sound, index) {\n        return soundIndex !== index;\n      }).map(function (sound) {\n        return sound.name;\n      });\n      var oldName = this.sprite.sounds[soundIndex].name;\n      var newUnusedName = StringUtil.unusedName(newName, usedNames);\n      this.sprite.sounds[soundIndex].name = newUnusedName;\n      this.blocks.updateAssetName(oldName, newUnusedName, 'sound');\n    }\n    /**\n     * Delete a sound by index.\n     * @param {number} index Sound index to be deleted\n     * @return {object} The deleted sound object, or null if no sound was deleted.\n     */\n  }, {\n    key: \"deleteSound\",\n    value: function deleteSound(index) {\n      // Make sure the sound index is not out of bounds\n      if (index < 0 || index >= this.sprite.sounds.length) {\n        return null;\n      } // Delete the sound at the given index\n      var deletedSound = this.sprite.sounds.splice(index, 1)[0];\n      this.runtime.requestTargetsUpdate(this);\n      return deletedSound;\n    }\n    /**\n     * Update the rotation style.\n     * @param {!string} rotationStyle New rotation style.\n     */\n  }, {\n    key: \"setRotationStyle\",\n    value: function setRotationStyle(rotationStyle) {\n      if (rotationStyle === RenderedTarget.ROTATION_STYLE_NONE) {\n        this.rotationStyle = RenderedTarget.ROTATION_STYLE_NONE;\n      } else if (rotationStyle === RenderedTarget.ROTATION_STYLE_ALL_AROUND) {\n        this.rotationStyle = RenderedTarget.ROTATION_STYLE_ALL_AROUND;\n      } else if (rotationStyle === RenderedTarget.ROTATION_STYLE_LEFT_RIGHT) {\n        this.rotationStyle = RenderedTarget.ROTATION_STYLE_LEFT_RIGHT;\n      }\n      if (this.renderer) {\n        var _this$_getRenderedDir3 = this._getRenderedDirectionAndScale(),\n            direction = _this$_getRenderedDir3.direction,\n            scale = _this$_getRenderedDir3.scale;\n        this.renderer.updateDrawableDirectionScale(this.drawableID, direction, scale);\n        if (this.visible) {\n          this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);\n          this.runtime.requestRedraw();\n        }\n      }\n      this.runtime.requestTargetsUpdate(this);\n    }\n    /**\n     * Get a costume index of this rendered target, by name of the costume.\n     * @param {?string} costumeName Name of a costume.\n     * @return {number} Index of the named costume, or -1 if not present.\n     */\n  }, {\n    key: \"getCostumeIndexByName\",\n    value: function getCostumeIndexByName(costumeName) {\n      for (var i = 0; i < this.sprite.costumes.length; i++) {\n        if (this.getCostumes()[i].name === costumeName) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    /**\n     * Get a costume of this rendered target by id.\n     * @return {object} current costume\n     */\n  }, {\n    key: \"getCurrentCostume\",\n    value: function getCurrentCostume() {\n      return this.getCostumes()[this.currentCostume];\n    }\n    /**\n     * Get full costume list\n     * @return {object[]} list of costumes\n     */\n  }, {\n    key: \"getCostumes\",\n    value: function getCostumes() {\n      return this.sprite.costumes;\n    }\n    /**\n     * Reorder costume list by moving costume at costumeIndex to newIndex.\n     * @param {!number} costumeIndex Index of the costume to move.\n     * @param {!number} newIndex New index for that costume.\n     * @returns {boolean} If a change occurred (i.e. if the indices do not match)\n     */\n  }, {\n    key: \"reorderCostume\",\n    value: function reorderCostume(costumeIndex, newIndex) {\n      newIndex = MathUtil.clamp(newIndex, 0, this.sprite.costumes.length - 1);\n      costumeIndex = MathUtil.clamp(costumeIndex, 0, this.sprite.costumes.length - 1);\n      if (newIndex === costumeIndex) return false;\n      var currentCostume = this.getCurrentCostume();\n      var costume = this.sprite.costumes[costumeIndex]; // Use the sprite method for deleting costumes because setCostume is handled manually\n      this.sprite.deleteCostumeAt(costumeIndex);\n      this.addCostume(costume, newIndex);\n      this.currentCostume = this.getCostumeIndexByName(currentCostume.name);\n      return true;\n    }\n    /**\n     * Reorder sound list by moving sound at soundIndex to newIndex.\n     * @param {!number} soundIndex Index of the sound to move.\n     * @param {!number} newIndex New index for that sound.\n     * @returns {boolean} If a change occurred (i.e. if the indices do not match)\n     */\n  }, {\n    key: \"reorderSound\",\n    value: function reorderSound(soundIndex, newIndex) {\n      newIndex = MathUtil.clamp(newIndex, 0, this.sprite.sounds.length - 1);\n      soundIndex = MathUtil.clamp(soundIndex, 0, this.sprite.sounds.length - 1);\n      if (newIndex === soundIndex) return false;\n      var sound = this.sprite.sounds[soundIndex];\n      this.deleteSound(soundIndex);\n      this.addSound(sound, newIndex);\n      return true;\n    }\n    /**\n     * Get full sound list\n     * @return {object[]} list of sounds\n     */\n  }, {\n    key: \"getSounds\",\n    value: function getSounds() {\n      return this.sprite.sounds;\n    }\n    /**\n     * Update all drawable properties for this rendered target.\n     * Use when a batch has changed, e.g., when the drawable is first created.\n     */\n  }, {\n    key: \"updateAllDrawableProperties\",\n    value: function updateAllDrawableProperties() {\n      if (this.renderer) {\n        var _this$_getRenderedDir4 = this._getRenderedDirectionAndScale(),\n            direction = _this$_getRenderedDir4.direction,\n            scale = _this$_getRenderedDir4.scale;\n        this.renderer.updateDrawablePosition(this.drawableID, [this.x, this.y]);\n        this.renderer.updateDrawableDirectionScale(this.drawableID, direction, scale);\n        this.renderer.updateDrawableVisible(this.drawableID, this.visible);\n        var costume = this.getCostumes()[this.currentCostume];\n        this.renderer.updateDrawableSkinId(this.drawableID, costume.skinId);\n        for (var effectName in this.effects) {\n          if (!this.effects.hasOwnProperty(effectName)) continue;\n          this.renderer.updateDrawableEffect(this.drawableID, effectName, this.effects[effectName]);\n        }\n        if (this.visible) {\n          this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);\n          this.runtime.requestRedraw();\n        }\n      }\n      this.runtime.requestTargetsUpdate(this);\n    }\n    /**\n     * Return the human-readable name for this rendered target, e.g., the sprite's name.\n     * @override\n     * @returns {string} Human-readable name.\n     */\n  }, {\n    key: \"getName\",\n    value: function getName() {\n      return this.sprite.name;\n    }\n    /**\n     * Return whether this rendered target is a sprite (not a clone, not the stage).\n     * @return {boolean} True if not a clone and not the stage.\n     */\n  }, {\n    key: \"isSprite\",\n    value: function isSprite() {\n      return !this.isStage && this.isOriginal;\n    }\n    /**\n     * Return the rendered target's tight bounding box.\n     * Includes top, left, bottom, right attributes in Scratch coordinates.\n     * @return {?object} Tight bounding box, or null.\n     */\n  }, {\n    key: \"getBounds\",\n    value: function getBounds() {\n      if (this.renderer) {\n        return this.runtime.renderer.getBounds(this.drawableID);\n      }\n      return null;\n    }\n    /**\n     * Return the bounding box around a slice of the top 8px of the rendered target.\n     * Includes top, left, bottom, right attributes in Scratch coordinates.\n     * @return {?object} Tight bounding box, or null.\n     */\n  }, {\n    key: \"getBoundsForBubble\",\n    value: function getBoundsForBubble() {\n      if (this.renderer) {\n        return this.runtime.renderer.getBoundsForBubble(this.drawableID);\n      }\n      return null;\n    }\n    /**\n     * Return whether this target is touching the mouse, an edge, or a sprite.\n     * @param {string} requestedObject an id for mouse or edge, or a sprite name.\n     * @return {boolean} True if the sprite is touching the object.\n     */\n  }, {\n    key: \"isTouchingObject\",\n    value: function isTouchingObject(requestedObject) {\n      if (requestedObject === '_mouse_') {\n        if (!this.runtime.ioDevices.mouse) return false;\n        var mouseX = this.runtime.ioDevices.mouse.getClientX();\n        var mouseY = this.runtime.ioDevices.mouse.getClientY();\n        return this.isTouchingPoint(mouseX, mouseY);\n      } else if (requestedObject === '_edge_') {\n        return this.isTouchingEdge();\n      }\n      return this.isTouchingSprite(requestedObject);\n    }\n    /**\n     * Return whether touching a point.\n     * @param {number} x X coordinate of test point.\n     * @param {number} y Y coordinate of test point.\n     * @return {boolean} True iff the rendered target is touching the point.\n     */\n  }, {\n    key: \"isTouchingPoint\",\n    value: function isTouchingPoint(x, y) {\n      if (this.renderer) {\n        return this.renderer.drawableTouching(this.drawableID, x, y);\n      }\n      return false;\n    }\n    /**\n     * Return whether touching a stage edge.\n     * @return {boolean} True iff the rendered target is touching the stage edge.\n     */\n  }, {\n    key: \"isTouchingEdge\",\n    value: function isTouchingEdge() {\n      if (this.renderer) {\n        var stageWidth = this.runtime.constructor.STAGE_WIDTH;\n        var stageHeight = this.runtime.constructor.STAGE_HEIGHT;\n        var bounds = this.getBounds();\n        if (bounds.left < -stageWidth / 2 || bounds.right > stageWidth / 2 || bounds.top > stageHeight / 2 || bounds.bottom < -stageHeight / 2) {\n          return true;\n        }\n      }\n      return false;\n    }\n    /**\n     * Return whether touching any of a named sprite's clones.\n     * @param {string} spriteName Name of the sprite.\n     * @return {boolean} True iff touching a clone of the sprite.\n     */\n  }, {\n    key: \"isTouchingSprite\",\n    value: function isTouchingSprite(spriteName) {\n      spriteName = Cast.toString(spriteName);\n      var firstClone = this.runtime.getSpriteTargetByName(spriteName);\n      if (!firstClone || !this.renderer) {\n        return false;\n      } // Filter out dragging targets. This means a sprite that is being dragged\n      // can detect other sprites using touching <sprite>, but cannot be detected\n      // by other sprites while it is being dragged. This matches Scratch 2.0 behavior.\n      var drawableCandidates = firstClone.sprite.clones.filter(function (clone) {\n        return !clone.dragging;\n      }).map(function (clone) {\n        return clone.drawableID;\n      });\n      return this.renderer.isTouchingDrawables(this.drawableID, drawableCandidates);\n    }\n    /**\n     * Return whether touching a color.\n     * @param {Array.<number>} rgb [r,g,b], values between 0-255.\n     * @return {Promise.<boolean>} True iff the rendered target is touching the color.\n     */\n  }, {\n    key: \"isTouchingColor\",\n    value: function isTouchingColor(rgb) {\n      if (this.renderer) {\n        return this.renderer.isTouchingColor(this.drawableID, rgb);\n      }\n      return false;\n    }\n    /**\n     * Return whether rendered target's color is touching a color.\n     * @param {object} targetRgb {Array.<number>} [r,g,b], values between 0-255.\n     * @param {object} maskRgb {Array.<number>} [r,g,b], values between 0-255.\n     * @return {Promise.<boolean>} True iff the color is touching the color.\n     */\n  }, {\n    key: \"colorIsTouchingColor\",\n    value: function colorIsTouchingColor(targetRgb, maskRgb) {\n      if (this.renderer) {\n        return this.renderer.isTouchingColor(this.drawableID, targetRgb, maskRgb);\n      }\n      return false;\n    }\n  }, {\n    key: \"getLayerOrder\",\n    value: function getLayerOrder() {\n      if (this.renderer) {\n        return this.renderer.getDrawableOrder(this.drawableID);\n      }\n      return null;\n    }\n    /**\n     * Move to the front layer.\n     */\n  }, {\n    key: \"goToFront\",\n    value: function goToFront() {\n      // This should only ever be used for sprites\n      if (this.renderer) {\n        // Let the renderer re-order the sprite based on its knowledge\n        // of what layers are present\n        this.renderer.setDrawableOrder(this.drawableID, Infinity, StageLayering.SPRITE_LAYER);\n      }\n      this.runtime.setExecutablePosition(this, Infinity);\n    }\n    /**\n     * Move to the back layer.\n     */\n  }, {\n    key: \"goToBack\",\n    value: function goToBack() {\n      // This should only ever be used for sprites\n      if (this.renderer) {\n        // Let the renderer re-order the sprite based on its knowledge\n        // of what layers are present\n        this.renderer.setDrawableOrder(this.drawableID, -Infinity, StageLayering.SPRITE_LAYER, false);\n      }\n      this.runtime.setExecutablePosition(this, -Infinity);\n    }\n    /**\n     * Move forward a number of layers.\n     * @param {number} nLayers How many layers to go forward.\n     */\n  }, {\n    key: \"goForwardLayers\",\n    value: function goForwardLayers(nLayers) {\n      if (this.renderer) {\n        this.renderer.setDrawableOrder(this.drawableID, nLayers, StageLayering.SPRITE_LAYER, true);\n      }\n      this.runtime.moveExecutable(this, nLayers);\n    }\n    /**\n     * Move backward a number of layers.\n     * @param {number} nLayers How many layers to go backward.\n     */\n  }, {\n    key: \"goBackwardLayers\",\n    value: function goBackwardLayers(nLayers) {\n      if (this.renderer) {\n        this.renderer.setDrawableOrder(this.drawableID, -nLayers, StageLayering.SPRITE_LAYER, true);\n      }\n      this.runtime.moveExecutable(this, -nLayers);\n    }\n    /**\n     * Move behind some other rendered target.\n     * @param {!RenderedTarget} other Other rendered target to move behind.\n     */\n  }, {\n    key: \"goBehindOther\",\n    value: function goBehindOther(other) {\n      if (this.renderer) {\n        var otherLayer = this.renderer.setDrawableOrder(other.drawableID, 0, StageLayering.SPRITE_LAYER, true);\n        this.renderer.setDrawableOrder(this.drawableID, otherLayer, StageLayering.SPRITE_LAYER);\n      }\n      var executionPosition = this.runtime.executableTargets.indexOf(other);\n      this.runtime.setExecutablePosition(this, executionPosition);\n    }\n    /**\n     * Keep a desired position within a fence.\n     * @param {number} newX New desired X position.\n     * @param {number} newY New desired Y position.\n     * @param {object=} optFence Optional fence with left, right, top bottom.\n     * @return {Array.<number>} Fenced X and Y coordinates.\n     */\n  }, {\n    key: \"keepInFence\",\n    value: function keepInFence(newX, newY, optFence) {\n      var fence = optFence;\n      if (!fence) {\n        fence = {\n          left: -this.runtime.constructor.STAGE_WIDTH / 2,\n          right: this.runtime.constructor.STAGE_WIDTH / 2,\n          top: this.runtime.constructor.STAGE_HEIGHT / 2,\n          bottom: -this.runtime.constructor.STAGE_HEIGHT / 2\n        };\n      }\n      var bounds = this.getBounds();\n      if (!bounds) return; // Adjust the known bounds to the target position.\n      bounds.left += newX - this.x;\n      bounds.right += newX - this.x;\n      bounds.top += newY - this.y;\n      bounds.bottom += newY - this.y; // Find how far we need to move the target position.\n      var dx = 0;\n      var dy = 0;\n      if (bounds.left < fence.left) {\n        dx += fence.left - bounds.left;\n      }\n      if (bounds.right > fence.right) {\n        dx += fence.right - bounds.right;\n      }\n      if (bounds.top > fence.top) {\n        dy += fence.top - bounds.top;\n      }\n      if (bounds.bottom < fence.bottom) {\n        dy += fence.bottom - bounds.bottom;\n      }\n      return [newX + dx, newY + dy];\n    }\n    /**\n     * Make a clone, copying any run-time properties.\n     * If we've hit the global clone limit, returns null.\n     * @return {RenderedTarget} New clone.\n     */\n  }, {\n    key: \"makeClone\",\n    value: function makeClone() {\n      if (!this.runtime.clonesAvailable() || this.isStage) {\n        return null; // Hit max clone limit, or this is the stage.\n      }\n      this.runtime.changeCloneCounter(1);\n      var newClone = this.sprite.createClone(); // Copy all properties.\n      newClone.x = this.x;\n      newClone.y = this.y;\n      newClone.direction = this.direction;\n      newClone.draggable = this.draggable;\n      newClone.visible = this.visible;\n      newClone.size = this.size;\n      newClone.currentCostume = this.currentCostume;\n      newClone.rotationStyle = this.rotationStyle;\n      newClone.effects = Clone.simple(this.effects);\n      newClone.variables = this.duplicateVariables();\n      newClone._edgeActivatedHatValues = Clone.simple(this._edgeActivatedHatValues);\n      newClone.initDrawable(StageLayering.SPRITE_LAYER);\n      newClone.updateAllDrawableProperties();\n      return newClone;\n    }\n    /**\n     * Make a duplicate using a duplicate sprite.\n     * @return {RenderedTarget} New clone.\n     */\n  }, {\n    key: \"duplicate\",\n    value: function duplicate() {\n      var _this2 = this;\n      return this.sprite.duplicate().then(function (newSprite) {\n        var newTarget = newSprite.createClone(); // Copy all properties.\n        // @todo refactor with clone methods\n        newTarget.x = (Math.random() - 0.5) * 400 / 2;\n        newTarget.y = (Math.random() - 0.5) * 300 / 2;\n        newTarget.direction = _this2.direction;\n        newTarget.draggable = _this2.draggable;\n        newTarget.visible = _this2.visible;\n        newTarget.size = _this2.size;\n        newTarget.currentCostume = _this2.currentCostume;\n        newTarget.rotationStyle = _this2.rotationStyle;\n        newTarget.effects = JSON.parse(JSON.stringify(_this2.effects));\n        newTarget.variables = _this2.duplicateVariables(newTarget.blocks);\n        newTarget.updateAllDrawableProperties();\n      scratchStatus(\"BACKUPNEEDED\");\n        return newTarget;\n      });\n    }\n    /**\n     * Called when the project receives a \"green flag.\"\n     * For a rendered target, this clears graphic effects.\n     */\n  }, {\n    key: \"onGreenFlag\",\n    value: function onGreenFlag() {\n      this.clearEffects();\n    }\n    /**\n     * Called when the project receives a \"stop all\"\n     * Stop all sounds and clear graphic effects.\n     */\n  }, {\n    key: \"onStopAll\",\n    value: function onStopAll() {\n      this.clearEffects();\n    }\n    /**\n     * Post/edit sprite info.\n     * @param {object} data An object with sprite info data to set.\n     */\n  }, {\n    key: \"postSpriteInfo\",\n    value: function postSpriteInfo(data) {\n      var force = data.hasOwnProperty('force') ? data.force : null;\n      var isXChanged = data.hasOwnProperty('x');\n      var isYChanged = data.hasOwnProperty('y');\n      if (isXChanged || isYChanged) {\n        this.setXY(isXChanged ? data.x : this.x, isYChanged ? data.y : this.y, force);\n      }\n      if (data.hasOwnProperty('direction')) {\n        this.setDirection(data.direction);\n      }\n      if (data.hasOwnProperty('draggable')) {\n        this.setDraggable(data.draggable);\n      }\n      if (data.hasOwnProperty('rotationStyle')) {\n        this.setRotationStyle(data.rotationStyle);\n      }\n      if (data.hasOwnProperty('visible')) {\n        this.setVisible(data.visible);\n      }\n      if (data.hasOwnProperty('size')) {\n        this.setSize(data.size);\n      }\n    }\n    /**\n     * Put the sprite into the drag state. While in effect, setXY must be forced\n     */\n  }, {\n    key: \"startDrag\",\n    value: function startDrag() {\n      this.dragging = true;\n    }\n    /**\n     * Remove the sprite from the drag state.\n     */\n  }, {\n    key: \"stopDrag\",\n    value: function stopDrag() {\n      this.dragging = false;\n    }\n    /**\n     * Serialize sprite info, used when emitting events about the sprite\n     * @returns {object} Sprite data as a simple object\n     */\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var costumes = this.getCostumes();\n      return {\n        id: this.id,\n        name: this.getName(),\n        isStage: this.isStage,\n        x: this.x,\n        y: this.y,\n        size: this.size,\n        direction: this.direction,\n        draggable: this.draggable,\n        currentCostume: this.currentCostume,\n        costume: costumes[this.currentCostume],\n        costumeCount: costumes.length,\n        visible: this.visible,\n        rotationStyle: this.rotationStyle,\n        comments: this.comments,\n        blocks: this.blocks._blocks,\n        variables: this.variables,\n        costumes: costumes,\n        sounds: this.getSounds(),\n        textToSpeechLanguage: this.textToSpeechLanguage,\n        tempo: this.tempo,\n        volume: this.volume,\n        videoTransparency: this.videoTransparency,\n        videoState: this.videoState\n      };\n    }\n    /**\n     * Dispose, destroying any run-time properties.\n     */\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.runtime.changeCloneCounter(-1);\n      this.runtime.stopForTarget(this);\n      this.runtime.removeExecutable(this);\n      this.sprite.removeClone(this);\n      if (this.renderer && this.drawableID !== null) {\n        this.renderer.destroyDrawable(this.drawableID, this.isStage ? StageLayering.BACKGROUND_LAYER : StageLayering.SPRITE_LAYER);\n        if (this.visible) {\n          this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);\n          this.runtime.requestRedraw();\n        }\n      }\n    }\n  }, {\n    key: \"audioPlayer\",\n    get: function get() {\n      var _this3 = this;\n      /* eslint-disable no-console */\n    //console.warn('get audioPlayer deprecated, please update to use .sprite.soundBank methods');\n    //console.warn(new Error('stack for debug').stack);\n      /* eslint-enable no-console */\n      var bank = this.sprite.soundBank;\n      var audioPlayerProxy = {\n        playSound: function playSound(soundId) {\n          return bank.play(_this3, soundId);\n        }\n      };\n      Object.defineProperty(this, 'audioPlayer', {\n        configurable: false,\n        enumerable: true,\n        writable: false,\n        value: audioPlayerProxy\n      });\n      return audioPlayerProxy;\n    }\n  }], [{\n    key: \"EVENT_TARGET_MOVED\",\n    get: function get() {\n      return 'TARGET_MOVED';\n    }\n    /**\n     * Event which fires when a target changes visually, for updating say bubbles.\n     * @type {string}\n     */\n  }, {\n    key: \"EVENT_TARGET_VISUAL_CHANGE\",\n    get: function get() {\n      return 'EVENT_TARGET_VISUAL_CHANGE';\n    }\n    /**\n     * Rotation style for \"all around\"/spinning.\n     * @type {string}\n     */\n  }, {\n    key: \"ROTATION_STYLE_ALL_AROUND\",\n    get: function get() {\n      return 'all around';\n    }\n    /**\n     * Rotation style for \"left-right\"/flipping.\n     * @type {string}\n     */\n  }, {\n    key: \"ROTATION_STYLE_LEFT_RIGHT\",\n    get: function get() {\n      return 'left-right';\n    }\n    /**\n     * Rotation style for \"no rotation.\"\n     * @type {string}\n     */\n  }, {\n    key: \"ROTATION_STYLE_NONE\",\n    get: function get() {\n      return \"don't rotate\";\n    }\n    /**\n     * Available states for video input.\n     * @enum {string}\n     */\n  }, {\n    key: \"VIDEO_STATE\",\n    get: function get() {\n      return {\n        OFF: 'off',\n        ON: 'on',\n        ON_FLIPPED: 'on-flipped'\n      };\n    }\n  }]);\n  return RenderedTarget;\n}(Target);\nmodule.exports = RenderedTarget;\n })