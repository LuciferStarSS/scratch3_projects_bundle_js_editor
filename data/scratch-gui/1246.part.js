/* 1246 */\n (function(module, exports) {\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n/**\n * @fileoverview\n * A representation of a Skin's silhouette that can test if a point on the skin\n * renders a pixel where it is drawn.\n */\n/**\n * <canvas> element used to update Silhouette data from skin bitmap data.\n * @type {CanvasElement}\n */\nvar __SilhouetteUpdateCanvas; // Optimized Math.min and Math.max for integers;\n// taken from https://web.archive.org/web/20190716181049/http://guihaire.com/code/?p=549\nvar intMin = function intMin(i, j) {\n  return j ^ (i ^ j) & i - j >> 31;\n};\nvar intMax = function intMax(i, j) {\n  return i ^ (i ^ j) & i - j >> 31;\n};\n/**\n * Internal helper function (in hopes that compiler can inline).  Get a pixel\n * from silhouette data, or 0 if outside it's bounds.\n * @private\n * @param {Silhouette} silhouette - has data width and height\n * @param {number} x - x\n * @param {number} y - y\n * @return {number} Alpha value for x/y position\n */\nvar getPoint = function getPoint(_ref, x, y) {\n  var width = _ref._width,\n      height = _ref._height,\n      data = _ref._colorData;\n  // 0 if outside bounds, otherwise read from data.\n  if (x >= width || y >= height || x < 0 || y < 0) {\n    return 0;\n  }\n  return data[(y * width + x) * 4 + 3];\n};\n/**\n * Memory buffers for doing 4 corner sampling for linear interpolation\n */\nvar __cornerWork = [new Uint8ClampedArray(4), new Uint8ClampedArray(4), new Uint8ClampedArray(4), new Uint8ClampedArray(4)];\n/**\n * Get the color from a given silhouette at an x/y local texture position.\n * Multiply color values by alpha for proper blending.\n * @param {Silhouette} $0 The silhouette to sample.\n * @param {number} x X position of texture [0, width).\n * @param {number} y Y position of texture [0, height).\n * @param {Uint8ClampedArray} dst A color 4b space.\n * @return {Uint8ClampedArray} The dst vector.\n */\nvar getColor4b = function getColor4b(_ref2, x, y, dst) {\n  var width = _ref2._width,\n      height = _ref2._height,\n      data = _ref2._colorData;\n  // Clamp coords to edge, matching GL_CLAMP_TO_EDGE.\n  // (See github.com/LLK/scratch-render/blob/954cfff02b08069a082cbedd415c1fecd9b1e4fb/src/BitmapSkin.js#L88)\n  x = intMax(0, intMin(x, width - 1));\n  y = intMax(0, intMin(y, height - 1)); // 0 if outside bounds, otherwise read from data.\n  if (x >= width || y >= height || x < 0 || y < 0) {\n    return dst.fill(0);\n  }\n  var offset = (y * width + x) * 4; // premultiply alpha\n  var alpha = data[offset + 3] / 255;\n  dst[0] = data[offset] * alpha;\n  dst[1] = data[offset + 1] * alpha;\n  dst[2] = data[offset + 2] * alpha;\n  dst[3] = data[offset + 3];\n  return dst;\n};\n/**\n * Get the color from a given silhouette at an x/y local texture position.\n * Do not multiply color values by alpha, as it has already been done.\n * @param {Silhouette} $0 The silhouette to sample.\n * @param {number} x X position of texture [0, width).\n * @param {number} y Y position of texture [0, height).\n * @param {Uint8ClampedArray} dst A color 4b space.\n * @return {Uint8ClampedArray} The dst vector.\n */\nvar getPremultipliedColor4b = function getPremultipliedColor4b(_ref3, x, y, dst) {\n  var width = _ref3._width,\n      height = _ref3._height,\n      data = _ref3._colorData;\n  // Clamp coords to edge, matching GL_CLAMP_TO_EDGE.\n  x = intMax(0, intMin(x, width - 1));\n  y = intMax(0, intMin(y, height - 1));\n  var offset = (y * width + x) * 4;\n  dst[0] = data[offset];\n  dst[1] = data[offset + 1];\n  dst[2] = data[offset + 2];\n  dst[3] = data[offset + 3];\n  return dst;\n};\nvar Silhouette = function () {\n  function Silhouette() {\n    _classCallCheck(this, Silhouette);\n    /**\n     * The width of the data representing the current skin data.\n     * @type {number}\n     */\n    this._width = 0;\n    /**\n     * The height of the data representing the current skin date.\n     * @type {number}\n     */\n    this._height = 0;\n    /**\n     * The data representing a skin's silhouette shape.\n     * @type {Uint8ClampedArray}\n     */\n    this._colorData = null; // By default, silhouettes are assumed not to contain premultiplied image data,\n    // so when we get a color, we want to multiply it by its alpha channel.\n    // Point `_getColor` to the version of the function that multiplies.\n    this._getColor = getColor4b;\n    this.colorAtNearest = this.colorAtLinear = function (_, dst) {\n      return dst.fill(0);\n    };\n  }\n  /**\n   * Update this silhouette with the bitmapData for a skin.\n   * @param {ImageData|HTMLCanvasElement|HTMLImageElement} bitmapData An image, canvas or other element that the skin\n   * @param {boolean} isPremultiplied True if the source bitmap data comes premultiplied (e.g. from readPixels).\n   * rendering can be queried from.\n   */\n  _createClass(Silhouette, [{\n    key: \"update\",\n    value: function update(bitmapData) {\n      var isPremultiplied = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var imageData;\n      if (bitmapData instanceof ImageData) {\n        // If handed ImageData directly, use it directly.\n        imageData = bitmapData;\n        this._width = bitmapData.width;\n        this._height = bitmapData.height;\n      } else {\n        // Draw about anything else to our update canvas and poll image data\n        // from that.\n        var canvas = Silhouette._updateCanvas();\n        var width = this._width = canvas.width = bitmapData.width;\n        var height = this._height = canvas.height = bitmapData.height;\n        var ctx = canvas.getContext('2d',{willReadFrequently:true});\n        if (!(width && height)) {\n          return;\n        }\n        ctx.clearRect(0, 0, width, height);\n        ctx.drawImage(bitmapData, 0, 0, width, height);\n        imageData = ctx.getImageData(0, 0, width, height);\n      }\n      if (isPremultiplied) {\n        this._getColor = getPremultipliedColor4b;\n      } else {\n        this._getColor = getColor4b;\n      }\n      this._colorData = imageData.data; // delete our custom overriden \"uninitalized\" color functions\n      // let the prototype work for itself\n      delete this.colorAtNearest;\n      delete this.colorAtLinear;\n    }\n    /**\n     * Sample a color from the silhouette at a given local position using\n     * \"nearest neighbor\"\n     * @param {twgl.v3} vec [x,y] texture space (0-1)\n     * @param {Uint8ClampedArray} dst The memory buffer to store the value in. (4 bytes)\n     * @returns {Uint8ClampedArray} dst\n     */\n  }, {\n    key: \"colorAtNearest\",\n    value: function colorAtNearest(vec, dst) {\n      return this._getColor(this, Math.floor(vec[0] * (this._width - 1)), Math.floor(vec[1] * (this._height - 1)), dst);\n    }\n    /**\n     * Sample a color from the silhouette at a given local position using\n     * \"linear interpolation\"\n     * @param {twgl.v3} vec [x,y] texture space (0-1)\n     * @param {Uint8ClampedArray} dst The memory buffer to store the value in. (4 bytes)\n     * @returns {Uint8ClampedArray} dst\n     */\n  }, {\n    key: \"colorAtLinear\",\n    value: function colorAtLinear(vec, dst) {\n      var x = vec[0] * (this._width - 1);\n      var y = vec[1] * (this._height - 1);\n      var x1D = x % 1;\n      var y1D = y % 1;\n      var x0D = 1 - x1D;\n      var y0D = 1 - y1D;\n      var xFloor = Math.floor(x);\n      var yFloor = Math.floor(y);\n      var x0y0 = this._getColor(this, xFloor, yFloor, __cornerWork[0]);\n      var x1y0 = this._getColor(this, xFloor + 1, yFloor, __cornerWork[1]);\n      var x0y1 = this._getColor(this, xFloor, yFloor + 1, __cornerWork[2]);\n      var x1y1 = this._getColor(this, xFloor + 1, yFloor + 1, __cornerWork[3]);\n      dst[0] = x0y0[0] * x0D * y0D + x0y1[0] * x0D * y1D + x1y0[0] * x1D * y0D + x1y1[0] * x1D * y1D;\n      dst[1] = x0y0[1] * x0D * y0D + x0y1[1] * x0D * y1D + x1y0[1] * x1D * y0D + x1y1[1] * x1D * y1D;\n      dst[2] = x0y0[2] * x0D * y0D + x0y1[2] * x0D * y1D + x1y0[2] * x1D * y0D + x1y1[2] * x1D * y1D;\n      dst[3] = x0y0[3] * x0D * y0D + x0y1[3] * x0D * y1D + x1y0[3] * x1D * y0D + x1y1[3] * x1D * y1D;\n      return dst;\n    }\n    /**\n     * Test if texture coordinate touches the silhouette using nearest neighbor.\n     * @param {twgl.v3} vec A texture coordinate.\n     * @return {boolean} If the nearest pixel has an alpha value.\n     */\n  }, {\n    key: \"isTouchingNearest\",\n    value: function isTouchingNearest(vec) {\n      if (!this._colorData) return;\n      return getPoint(this, Math.floor(vec[0] * (this._width - 1)), Math.floor(vec[1] * (this._height - 1))) > 0;\n    }\n    /**\n     * Test to see if any of the 4 pixels used in the linear interpolate touch\n     * the silhouette.\n     * @param {twgl.v3} vec A texture coordinate.\n     * @return {boolean} Any of the pixels have some alpha.\n     */\n  }, {\n    key: \"isTouchingLinear\",\n    value: function isTouchingLinear(vec) {\n      if (!this._colorData) return;\n      var x = Math.floor(vec[0] * (this._width - 1));\n      var y = Math.floor(vec[1] * (this._height - 1));\n      return getPoint(this, x, y) > 0 || getPoint(this, x + 1, y) > 0 || getPoint(this, x, y + 1) > 0 || getPoint(this, x + 1, y + 1) > 0;\n    }\n    /**\n     * Get the canvas element reused by Silhouettes to update their data with.\n     * @private\n     * @return {CanvasElement} A canvas to draw bitmap data to.\n     */\n  }], [{\n    key: \"_updateCanvas\",\n    value: function _updateCanvas() {\n      if (typeof __SilhouetteUpdateCanvas === 'undefined') {\n        __SilhouetteUpdateCanvas = document.createElement('canvas');\n      }\n      return __SilhouetteUpdateCanvas;\n    }\n  }]);\n  return Silhouette;\n}();\nmodule.exports = Silhouette;\n })