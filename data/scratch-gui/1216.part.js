/* 1216 */\n (function(module, exports, __webpack_require__) {\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nvar log = __webpack_require__(308);\nvar Asset = __webpack_require__(309);\nvar Helper = __webpack_require__(484);\nvar ProxyTool = __webpack_require__(1217);\nvar ensureRequestConfig = function ensureRequestConfig(reqConfig) {\n  if (typeof reqConfig === 'string') {\n    return {\n      url: reqConfig\n    };\n  }\n  return reqConfig;\n};\n/**\n * @typedef {function} UrlFunction - A function which computes a URL from asset information.\n * @param {Asset} - The asset for which the URL should be computed.\n * @returns {(string|object)} - A string representing the URL for the asset request OR an object with configuration for\n *                              the underlying `nets` call (necessary for configuring e.g. authentication)\n */\nvar WebHelper = function (_Helper) {\n  _inherits(WebHelper, _Helper);\n  var _super = _createSuper(WebHelper);\n  function WebHelper(parent) {\n    var _this;\n    _classCallCheck(this, WebHelper);\n    _this = _super.call(this, parent);\n    /**\n     * @type {Array.<StoreRecord>}\n     * @typedef {object} StoreRecord\n     * @property {Array.<string>} types - The types of asset provided by this store, from AssetType's name field.\n     * @property {UrlFunction} getFunction - A function which computes a URL from an Asset.\n     * @property {UrlFunction} createFunction - A function which computes a URL from an Asset.\n     * @property {UrlFunction} updateFunction - A function which computes a URL from an Asset.\n     */\n    _this.stores = [];\n    /**\n     * Set of tools to best load many assets in parallel. If one tool\n     * cannot be used, it will use the next.\n     * @type {ProxyTool}\n     */\n    _this.assetTool = new ProxyTool();\n    /**\n     * Set of tools to best load project data in parallel with assets. This\n     * tool set prefers tools that are immediately ready. Some tools have\n     * to initialize before they can load files.\n     * @type {ProxyTool}\n     */\n    _this.projectTool = new ProxyTool(ProxyTool.TOOL_FILTER.READY);\n    return _this;\n  }\n  /**\n   * Register a web-based source for assets. Sources will be checked in order of registration.\n   * @deprecated Please use addStore\n   * @param {Array.<AssetType>} types - The types of asset provided by this source.\n   * @param {UrlFunction} urlFunction - A function which computes a URL from an Asset.\n   */\n  _createClass(WebHelper, [{\n    key: \"addSource\",\n    value: function addSource(types, urlFunction) {\n      log.warn('Deprecation: WebHelper.addSource has been replaced with WebHelper.addStore.');\n      this.addStore(types, urlFunction);\n    }\n    /**\n     * Register a web-based store for assets. Sources will be checked in order of registration.\n     * @param {Array.<AssetType>} types - The types of asset provided by this store.\n     * @param {UrlFunction} getFunction - A function which computes a GET URL for an Asset\n     * @param {UrlFunction} createFunction - A function which computes a POST URL for an Asset\n     * @param {UrlFunction} updateFunction - A function which computes a PUT URL for an Asset\n     */\n  }, {\n    key: \"addStore\",\n    value: function addStore(types, getFunction, createFunction, updateFunction) {\n      this.stores.push({\n        types: types.map(function (assetType) {\n          return assetType.name;\n        }),\n        get: getFunction,\n        create: createFunction,\n        update: updateFunction\n      });\n    }\n    /**\n     * Fetch an asset but don't process dependencies.\n     * @param {AssetType} assetType - The type of asset to fetch.\n     * @param {string} assetId - The ID of the asset to fetch: a project ID, MD5, etc.\n     * @param {DataFormat} dataFormat - The file format / file extension of the asset to fetch: PNG, JPG, etc.\n     * @return {Promise.<Asset>} A promise for the contents of the asset.\n     */\n  }, {\n    key: \"load\",\n    value: function load(assetType, assetId, dataFormat) {\n      /** @type {Array.<{url:string, result:*}>} List of URLs attempted & errors encountered. */\n      var errors = [];\n      var stores = this.stores.slice().filter(function (store) {\n        return store.types.indexOf(assetType.name) >= 0;\n      });\n      var asset = new Asset(assetType, assetId, dataFormat);\n      var tool = this.assetTool;\n      if (assetType.name === 'Project') {\n        tool = this.projectTool;\n      }\n      var storeIndex = 0;\n      var tryNextSource = function tryNextSource() {\n        var store = stores[storeIndex++];\n        /** @type {UrlFunction} */\n        var reqConfigFunction = store.get;\n        if (reqConfigFunction) {\n          var reqConfig = ensureRequestConfig(reqConfigFunction(asset));\n          if (reqConfig === false) {\n            return tryNextSource();\n          }\n          return tool.get(reqConfig).then(function (body) {\n            return asset.setData(body, dataFormat);\n          }).catch(tryNextSource);\n        } else if (errors.length > 0) {\n          return Promise.reject(errors);\n        } // no stores matching asset\n        return Promise.resolve(null);\n      };\n      return tryNextSource().then(function () {\n        return asset;\n      });\n    }\n    /**\n     * Create or update an asset with provided data. The create function is called if no asset id is provided\n     * @param {AssetType} assetType - The type of asset to create or update.\n     * @param {?DataFormat} dataFormat - DataFormat of the data for the stored asset.\n     * @param {Buffer} data - The data for the cached asset.\n     * @param {?string} assetId - The ID of the asset to fetch: a project ID, MD5, etc.\n     * @return {Promise.<object>} A promise for the response from the create or update request\n     */\n  }, {\n    key: \"store\",\n    value: function store(assetType, dataFormat, data, assetId) {\n      var asset = new Asset(assetType, assetId, dataFormat); // If we have an asset id, we should update, otherwise create to get an id\n      var create = assetId === '' || assetId === null || typeof assetId === 'undefined'; // Use the first store with the appropriate asset type and url function\n      var store = this.stores.filter(function (s) {\n        return (// Only use stores for the incoming asset type\n          s.types.indexOf(assetType.name) !== -1 && ( // Only use stores that have a create function if this is a create request\n          // or an update function if this is an update request\n          create && s.create || s.update)\n        );\n      })[0];\n      var method = create ? 'post' : 'put';\n      if (!store) return Promise.reject('No appropriate stores');\n      var tool = this.assetTool;\n      if (assetType.name === 'Project') {\n        tool = this.projectTool;\n      }\n      var reqConfig = ensureRequestConfig(create ? store.create(asset) : store.update(asset));\n      var reqBodyConfig = Object.assign({\n        body: data,\n        method: method\n      }, reqConfig);\n      return tool.send(reqBodyConfig).then(function (body) {\n        // xhr makes it difficult to both send FormData and\n        // automatically parse a JSON response. So try to parse\n        // everything as JSON.\n        if (typeof body === 'string') {\n          try {\n            body = JSON.parse(body);\n          } catch (parseError) {\n            // If it's not parseable, then we can't add the id even\n            // if we want to, so stop here\n            return body;\n          }\n        }\n        return Object.assign({\n          id: body['content-name'] || assetId\n        }, body);\n      });\n    }\n  }]);\n  return WebHelper;\n}(Helper);\nmodule.exports = WebHelper;\n })