/* 487 */\n (function(module, exports, __webpack_require__) {\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n/**\n * @fileoverview\n * A utility to transform a texture coordinate to another texture coordinate\n * representing how the shaders apply effects.\n */\nvar twgl = __webpack_require__(103);\nvar ShaderManager = __webpack_require__(188);\n/**\n * A texture coordinate is between 0 and 1. 0.5 is the center position.\n * @const {number}\n */\nvar CENTER_X = 0.5;\n/**\n * A texture coordinate is between 0 and 1. 0.5 is the center position.\n * @const {number}\n */\nvar CENTER_Y = 0.5;\n/**\n * Reused memory location for storing an HSV color value.\n * @type {Array<number>}\n */\nvar __hsv = [0, 0, 0];\n/**\n * Converts an RGB color value to HSV. Conversion formula\n * adapted from http://lolengine.net/blog/2013/01/13/fast-rgb-to-hsv.\n * Assumes r, g, and b are in the range [0, 255] and\n * returns h, s, and v in the range [0, 1].\n *\n * @param   {Array<number>} rgb   The RGB color value\n * @param   {number}        rgb.r The red color value\n * @param   {number}        rgb.g The green color value\n * @param   {number}        rgb.b The blue color value\n * @param   {Array<number>} dst   The array to store the RGB values in\n * @return  {Array<number>}       The `dst` array passed in\n */\nvar rgbToHsv = function rgbToHsv(_ref, dst) {\n  var _ref2 = _slicedToArray(_ref, 3),\n      r = _ref2[0],\n      g = _ref2[1],\n      b = _ref2[2];\n  var K = 0.0;\n  r /= 255;\n  g /= 255;\n  b /= 255;\n  var tmp = 0;\n  if (g < b) {\n    tmp = g;\n    g = b;\n    b = tmp;\n    K = -1;\n  }\n  if (r < g) {\n    tmp = r;\n    r = g;\n    g = tmp;\n    K = -2 / 6 - K;\n  }\n  var chroma = r - Math.min(g, b);\n  var h = Math.abs(K + (g - b) / (6 * chroma + Number.EPSILON));\n  var s = chroma / (r + Number.EPSILON);\n  var v = r;\n  dst[0] = h;\n  dst[1] = s;\n  dst[2] = v;\n  return dst;\n};\n/**\n * Converts an HSV color value to RGB. Conversion formula\n * adapted from https://gist.github.com/mjackson/5311256.\n * Assumes h, s, and v are contained in the set [0, 1] and\n * returns r, g, and b in the set [0, 255].\n *\n * @param   {Array<number>}                hsv The HSV color value\n * @param   {number}                       hsv.h     The hue\n * @param   {number}                       hsv.s     The saturation\n * @param   {number}                       hsv.v     The value\n * @param   {Uint8Array|Uint8ClampedArray} dst The array to store the RGB values in\n * @return  {Uint8Array|Uint8ClampedArray}     The `dst` array passed in\n */\nvar hsvToRgb = function hsvToRgb(_ref3, dst) {\n  var _ref4 = _slicedToArray(_ref3, 3),\n      h = _ref4[0],\n      s = _ref4[1],\n      v = _ref4[2];\n  if (s === 0) {\n    dst[0] = dst[1] = dst[2] = v * 255 + 0.5;\n    return dst;\n  } // keep hue in [0,1) so the `switch(i)` below only needs 6 cases (0-5)\n  h %= 1;\n  var i = h * 6 | 0;\n  var f = h * 6 - i;\n  var p = v * (1 - s);\n  var q = v * (1 - s * f);\n  var t = v * (1 - s * (1 - f));\n  var r = 0;\n  var g = 0;\n  var b = 0;\n  switch (i) {\n    case 0:\n      r = v;\n      g = t;\n      b = p;\n      break;\n    case 1:\n      r = q;\n      g = v;\n      b = p;\n      break;\n    case 2:\n      r = p;\n      g = v;\n      b = t;\n      break;\n    case 3:\n      r = p;\n      g = q;\n      b = v;\n      break;\n    case 4:\n      r = t;\n      g = p;\n      b = v;\n      break;\n    case 5:\n      r = v;\n      g = p;\n      b = q;\n      break;\n  } // Add 0.5 in order to round. Setting integer TypedArray elements implicitly floors.\n  dst[0] = r * 255 + 0.5;\n  dst[1] = g * 255 + 0.5;\n  dst[2] = b * 255 + 0.5;\n  return dst;\n};\nvar EffectTransform = function () {\n  function EffectTransform() {\n    _classCallCheck(this, EffectTransform);\n  }\n  _createClass(EffectTransform, null, [{\n    key: \"transformColor\",\n    /**\n     * Transform a color in-place given the drawable's effect uniforms.  Will apply\n     * Ghost and Color and Brightness effects.\n     * @param {Drawable} drawable The drawable to get uniforms from.\n     * @param {Uint8ClampedArray} inOutColor The color to transform.\n     * @param {number} [effectMask] A bitmask for which effects to use. Optional.\n     * @returns {Uint8ClampedArray} dst filled with the transformed color\n     */\n    value: function transformColor(drawable, inOutColor, effectMask) {\n      // If the color is fully transparent, don't bother attempting any transformations.\n      if (inOutColor[3] === 0) {\n        return inOutColor;\n      }\n      var effects = drawable.enabledEffects;\n      if (typeof effectMask === 'number') effects &= effectMask;\n      var uniforms = drawable.getUniforms();\n      var enableColor = (effects & ShaderManager.EFFECT_INFO.color.mask) !== 0;\n      var enableBrightness = (effects & ShaderManager.EFFECT_INFO.brightness.mask) !== 0;\n      if (enableColor || enableBrightness) {\n        // gl_FragColor.rgb /= gl_FragColor.a + epsilon;\n        // Here, we're dividing by the (previously pre-multiplied) alpha to ensure HSV is properly calculated\n        // for partially transparent pixels.\n        // epsilon is present in the shader because dividing by 0 (fully transparent pixels) messes up calculations.\n        // We're doing this with a Uint8ClampedArray here, so dividing by 0 just gives 255. We're later multiplying\n        // by 0 again, so it won't affect results.\n        var alpha = inOutColor[3] / 255;\n        inOutColor[0] /= alpha;\n        inOutColor[1] /= alpha;\n        inOutColor[2] /= alpha;\n        if (enableColor) {\n          // vec3 hsv = convertRGB2HSV(gl_FragColor.xyz);\n          var hsv = rgbToHsv(inOutColor, __hsv); // this code forces grayscale values to be slightly saturated\n          // so that some slight change of hue will be visible\n          // const float minLightness = 0.11 / 2.0;\n          var minV = 0.11 / 2.0; // const float minSaturation = 0.09;\n          var minS = 0.09; // if (hsv.z < minLightness) hsv = vec3(0.0, 1.0, minLightness);\n          if (hsv[2] < minV) {\n            hsv[0] = 0;\n            hsv[1] = 1;\n            hsv[2] = minV; // else if (hsv.y < minSaturation) hsv = vec3(0.0, minSaturation, hsv.z);\n          } else if (hsv[1] < minS) {\n            hsv[0] = 0;\n            hsv[1] = minS;\n          } // hsv.x = mod(hsv.x + u_color, 1.0);\n          // if (hsv.x < 0.0) hsv.x += 1.0;\n          hsv[0] = uniforms.u_color + hsv[0] + 1; // gl_FragColor.rgb = convertHSV2RGB(hsl);\n          hsvToRgb(hsv, inOutColor);\n        }\n        if (enableBrightness) {\n          var brightness = uniforms.u_brightness * 255; // gl_FragColor.rgb = clamp(gl_FragColor.rgb + vec3(u_brightness), vec3(0), vec3(1));\n          // We don't need to clamp because the Uint8ClampedArray does that for us\n          inOutColor[0] += brightness;\n          inOutColor[1] += brightness;\n          inOutColor[2] += brightness;\n        } // gl_FragColor.rgb *= gl_FragColor.a + epsilon;\n        // Now we're doing the reverse, premultiplying by the alpha once again.\n        inOutColor[0] *= alpha;\n        inOutColor[1] *= alpha;\n        inOutColor[2] *= alpha;\n      }\n      if ((effects & ShaderManager.EFFECT_INFO.ghost.mask) !== 0) {\n        // gl_FragColor *= u_ghost\n        inOutColor[0] *= uniforms.u_ghost;\n        inOutColor[1] *= uniforms.u_ghost;\n        inOutColor[2] *= uniforms.u_ghost;\n        inOutColor[3] *= uniforms.u_ghost;\n      }\n      return inOutColor;\n    }\n    /**\n     * Transform a texture coordinate to one that would be select after applying shader effects.\n     * @param {Drawable} drawable The drawable whose effects to emulate.\n     * @param {twgl.v3} vec The texture coordinate to transform.\n     * @param {twgl.v3} dst A place to store the output coordinate.\n     * @return {twgl.v3} dst - The coordinate after being transform by effects.\n     */\n  }, {\n    key: \"transformPoint\",\n    value: function transformPoint(drawable, vec, dst) {\n      twgl.v3.copy(vec, dst);\n      var effects = drawable.enabledEffects;\n      var uniforms = drawable.getUniforms();\n      if ((effects & ShaderManager.EFFECT_INFO.mosaic.mask) !== 0) {\n        // texcoord0 = fract(u_mosaic * texcoord0);\n        dst[0] = uniforms.u_mosaic * dst[0] % 1;\n        dst[1] = uniforms.u_mosaic * dst[1] % 1;\n      }\n      if ((effects & ShaderManager.EFFECT_INFO.pixelate.mask) !== 0) {\n        var skinUniforms = drawable.skin.getUniforms(); // vec2 pixelTexelSize = u_skinSize / u_pixelate;\n        var texelX = skinUniforms.u_skinSize[0] / uniforms.u_pixelate;\n        var texelY = skinUniforms.u_skinSize[1] / uniforms.u_pixelate; // texcoord0 = (floor(texcoord0 * pixelTexelSize) + kCenter) /\n        //   pixelTexelSize;\n        dst[0] = (Math.floor(dst[0] * texelX) + CENTER_X) / texelX;\n        dst[1] = (Math.floor(dst[1] * texelY) + CENTER_Y) / texelY;\n      }\n      if ((effects & ShaderManager.EFFECT_INFO.whirl.mask) !== 0) {\n        // const float kRadius = 0.5;\n        var RADIUS = 0.5; // vec2 offset = texcoord0 - kCenter;\n        var offsetX = dst[0] - CENTER_X;\n        var offsetY = dst[1] - CENTER_Y; // float offsetMagnitude = length(offset);\n        var offsetMagnitude = Math.sqrt(Math.pow(offsetX, 2) + Math.pow(offsetY, 2)); // float whirlFactor = max(1.0 - (offsetMagnitude / kRadius), 0.0);\n        var whirlFactor = Math.max(1.0 - offsetMagnitude / RADIUS, 0.0); // float whirlActual = u_whirl * whirlFactor * whirlFactor;\n        var whirlActual = uniforms.u_whirl * whirlFactor * whirlFactor; // float sinWhirl = sin(whirlActual);\n        var sinWhirl = Math.sin(whirlActual); // float cosWhirl = cos(whirlActual);\n        var cosWhirl = Math.cos(whirlActual); // mat2 rotationMatrix = mat2(\n        //     cosWhirl, -sinWhirl,\n        //     sinWhirl, cosWhirl\n        // );\n        var rot1 = cosWhirl;\n        var rot2 = -sinWhirl;\n        var rot3 = sinWhirl;\n        var rot4 = cosWhirl; // texcoord0 = rotationMatrix * offset + kCenter;\n        dst[0] = rot1 * offsetX + rot3 * offsetY + CENTER_X;\n        dst[1] = rot2 * offsetX + rot4 * offsetY + CENTER_Y;\n      }\n      if ((effects & ShaderManager.EFFECT_INFO.fisheye.mask) !== 0) {\n        // vec2 vec = (texcoord0 - kCenter) / kCenter;\n        var vX = (dst[0] - CENTER_X) / CENTER_X;\n        var vY = (dst[1] - CENTER_Y) / CENTER_Y; // float vecLength = length(vec);\n        var vLength = Math.sqrt(vX * vX + vY * vY); // float r = pow(min(vecLength, 1.0), u_fisheye) * max(1.0, vecLength);\n        var r = Math.pow(Math.min(vLength, 1), uniforms.u_fisheye) * Math.max(1, vLength); // vec2 unit = vec / vecLength;\n        var unitX = vX / vLength;\n        var unitY = vY / vLength; // texcoord0 = kCenter + r * unit * kCenter;\n        dst[0] = CENTER_X + r * unitX * CENTER_X;\n        dst[1] = CENTER_Y + r * unitY * CENTER_Y;\n      }\n      return dst;\n    }\n  }]);\n  return EffectTransform;\n}();\nmodule.exports = EffectTransform;\n })