/* 1087 */\n (function(module, exports, __webpack_require__) {\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nvar Cast = __webpack_require__(48);\nvar Clone = __webpack_require__(113);\nvar RenderedTarget = __webpack_require__(219);\nvar uid = __webpack_require__(94);\nvar StageLayering = __webpack_require__(115);\nvar getMonitorIdForBlockWithArgs = __webpack_require__(296);\nvar MathUtil = __webpack_require__(62);\n/**\n * @typedef {object} BubbleState - the bubble state associated with a particular target.\n * @property {Boolean} onSpriteRight - tracks whether the bubble is right or left of the sprite.\n * @property {?int} drawableId - the ID of the associated bubble Drawable, null if none.\n * @property {string} text - the text of the bubble.\n * @property {string} type - the type of the bubble, \"say\" or \"think\"\n * @property {?string} usageId - ID indicating the most recent usage of the say/think bubble.\n *      Used for comparison when determining whether to clear a say/think bubble.\n */\nvar Scratch3LooksBlocks = function () {\n  function Scratch3LooksBlocks(runtime) {\n    _classCallCheck(this, Scratch3LooksBlocks);\n    /**\n     * The runtime instantiating this block package.\n     * @type {Runtime}\n     */\n    this.runtime = runtime;\n    this._onTargetChanged = this._onTargetChanged.bind(this);\n    this._onResetBubbles = this._onResetBubbles.bind(this);\n    this._onTargetWillExit = this._onTargetWillExit.bind(this);\n    this._updateBubble = this._updateBubble.bind(this); // Reset all bubbles on start/stop\n    this.runtime.on('PROJECT_STOP_ALL', this._onResetBubbles);\n    this.runtime.on('targetWasRemoved', this._onTargetWillExit); // Enable other blocks to use bubbles like ask/answer\n    this.runtime.on(Scratch3LooksBlocks.SAY_OR_THINK, this._updateBubble);\n  }\n  /**\n   * The default bubble state, to be used when a target has no existing bubble state.\n   * @type {BubbleState}\n   */\n  _createClass(Scratch3LooksBlocks, [{\n    key: \"_getBubbleState\",\n    /**\n     * @param {Target} target - collect bubble state for this target. Probably, but not necessarily, a RenderedTarget.\n     * @returns {BubbleState} the mutable bubble state associated with that target. This will be created if necessary.\n     * @private\n     */\n    value: function _getBubbleState(target) {\n      var bubbleState = target.getCustomState(Scratch3LooksBlocks.STATE_KEY);\n      if (!bubbleState) {\n        bubbleState = Clone.simple(Scratch3LooksBlocks.DEFAULT_BUBBLE_STATE);\n        target.setCustomState(Scratch3LooksBlocks.STATE_KEY, bubbleState);\n      }\n      return bubbleState;\n    }\n    /**\n     * Handle a target which has moved.\n     * @param {RenderedTarget} target - the target which has moved.\n     * @private\n     */\n  }, {\n    key: \"_onTargetChanged\",\n    value: function _onTargetChanged(target) {\n      var bubbleState = this._getBubbleState(target);\n      if (bubbleState.drawableId) {\n        this._positionBubble(target);\n      }\n    }\n    /**\n     * Handle a target which is exiting.\n     * @param {RenderedTarget} target - the target.\n     * @private\n     */\n  }, {\n    key: \"_onTargetWillExit\",\n    value: function _onTargetWillExit(target) {\n      var bubbleState = this._getBubbleState(target);\n      if (bubbleState.drawableId && bubbleState.skinId) {\n        this.runtime.renderer.destroyDrawable(bubbleState.drawableId, StageLayering.SPRITE_LAYER);\n        this.runtime.renderer.destroySkin(bubbleState.skinId);\n        bubbleState.drawableId = null;\n        bubbleState.skinId = null;\n        this.runtime.requestRedraw();\n      }\n      target.removeListener(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this._onTargetChanged);\n    }\n    /**\n     * Handle project start/stop by clearing all visible bubbles.\n     * @private\n     */\n  }, {\n    key: \"_onResetBubbles\",\n    value: function _onResetBubbles() {\n      for (var n = 0; n < this.runtime.targets.length; n++) {\n        var bubbleState = this._getBubbleState(this.runtime.targets[n]);\n        bubbleState.text = '';\n        this._onTargetWillExit(this.runtime.targets[n]);\n      }\n      clearTimeout(this._bubbleTimeout);\n    }\n    /**\n     * Position the bubble of a target. If it doesn't fit on the specified side, flip and rerender.\n     * @param {!Target} target Target whose bubble needs positioning.\n     * @private\n     */\n  }, {\n    key: \"_positionBubble\",\n    value: function _positionBubble(target) {\n      if (!target.visible) return;\n      var bubbleState = this._getBubbleState(target);\n      var _this$runtime$rendere = this.runtime.renderer.getCurrentSkinSize(bubbleState.drawableId),\n          _this$runtime$rendere2 = _slicedToArray(_this$runtime$rendere, 2),\n          bubbleWidth = _this$runtime$rendere2[0],\n          bubbleHeight = _this$runtime$rendere2[1];\n      var targetBounds;\n      try {\n        targetBounds = target.getBoundsForBubble();\n      } catch (error_) {\n        // Bounds calculation could fail (e.g. on empty costumes), in that case\n        // use the x/y position of the target.\n        targetBounds = {\n          left: target.x,\n          right: target.x,\n          top: target.y,\n          bottom: target.y\n        };\n      }\n      var stageSize = this.runtime.renderer.getNativeSize();\n      var stageBounds = {\n        left: -stageSize[0] / 2,\n        right: stageSize[0] / 2,\n        top: stageSize[1] / 2,\n        bottom: -stageSize[1] / 2\n      };\n      if (bubbleState.onSpriteRight && bubbleWidth + targetBounds.right > stageBounds.right && targetBounds.left - bubbleWidth > stageBounds.left) {\n        // Only flip if it would fit\n        bubbleState.onSpriteRight = false;\n        this._renderBubble(target);\n      } else if (!bubbleState.onSpriteRight && targetBounds.left - bubbleWidth < stageBounds.left && bubbleWidth + targetBounds.right < stageBounds.right) {\n        // Only flip if it would fit\n        bubbleState.onSpriteRight = true;\n        this._renderBubble(target);\n      } else {\n        this.runtime.renderer.updateDrawablePosition(bubbleState.drawableId, [bubbleState.onSpriteRight ? Math.max(stageBounds.left, // Bubble should not extend past left edge of stage\n        Math.min(stageBounds.right - bubbleWidth, targetBounds.right)) : Math.min(stageBounds.right - bubbleWidth, // Bubble should not extend past right edge of stage\n        Math.max(stageBounds.left, targetBounds.left - bubbleWidth)), // Bubble should not extend past the top of the stage\n        Math.min(stageBounds.top, targetBounds.bottom + bubbleHeight)]);\n        this.runtime.requestRedraw();\n      }\n    }\n    /**\n     * Create a visible bubble for a target. If a bubble exists for the target,\n     * just set it to visible and update the type/text. Otherwise create a new\n     * bubble and update the relevant custom state.\n     * @param {!Target} target Target who needs a bubble.\n     * @return {undefined} Early return if text is empty string.\n     * @private\n     */\n  }, {\n    key: \"_renderBubble\",\n    value: function _renderBubble(target) {\n      if (!this.runtime.renderer) return;\n      var bubbleState = this._getBubbleState(target);\n      var type = bubbleState.type,\n          text = bubbleState.text,\n          onSpriteRight = bubbleState.onSpriteRight; // Remove the bubble if target is not visible, or text is being set to blank.\n      if (!target.visible || text === '') {\n        this._onTargetWillExit(target);\n        return;\n      }\n      if (bubbleState.skinId) {\n        this.runtime.renderer.updateTextSkin(bubbleState.skinId, type, text, onSpriteRight, [0, 0]);\n      } else {\n        target.addListener(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this._onTargetChanged);\n        bubbleState.drawableId = this.runtime.renderer.createDrawable(StageLayering.SPRITE_LAYER);\n        bubbleState.skinId = this.runtime.renderer.createTextSkin(type, text, bubbleState.onSpriteRight, [0, 0]);\n        this.runtime.renderer.updateDrawableSkinId(bubbleState.drawableId, bubbleState.skinId);\n      }\n      this._positionBubble(target);\n    }\n    /**\n     * Properly format text for a text bubble.\n     * @param {string} text The text to be formatted\n     * @return {string} The formatted text\n     * @private\n     */\n  }, {\n    key: \"_formatBubbleText\",\n    value: function _formatBubbleText(text) {\n      if (text === '') return text; // Non-integers should be rounded to 2 decimal places (no more, no less), unless they're small enough that\n      // rounding would display them as 0.00. This matches 2.0's behavior:\n      // https://github.com/LLK/scratch-flash/blob/2e4a402ceb205a042887f54b26eebe1c2e6da6c0/src/scratch/ScratchSprite.as#L579-L585\n      if (typeof text === 'number' && Math.abs(text) >= 0.01 && text % 1 !== 0) {\n        text = text.toFixed(2);\n      } // Limit the length of the string.\n      text = String(text).substr(0, Scratch3LooksBlocks.SAY_BUBBLE_LIMIT);\n      return text;\n    }\n    /**\n     * The entry point for say/think blocks. Clears existing bubble if the text is empty.\n     * Set the bubble custom state and then call _renderBubble.\n     * @param {!Target} target Target that say/think blocks are being called on.\n     * @param {!string} type Either \"say\" or \"think\"\n     * @param {!string} text The text for the bubble, empty string clears the bubble.\n     * @private\n     */\n  }, {\n    key: \"_updateBubble\",\n    value: function _updateBubble(target, type, text) {\n      var bubbleState = this._getBubbleState(target);\n      bubbleState.type = type;\n      bubbleState.text = this._formatBubbleText(text);\n      bubbleState.usageId = uid();\n      this._renderBubble(target);\n    }\n    /**\n     * Retrieve the block primitives implemented by this package.\n     * @return {object.<string, Function>} Mapping of opcode to Function.\n     */\n  }, {\n    key: \"getPrimitives\",\n    value: function getPrimitives() {\n      return {\n        looks_say: this.say,\n        looks_sayforsecs: this.sayforsecs,\n        looks_think: this.think,\n        looks_thinkforsecs: this.thinkforsecs,\n        looks_show: this.show,\n        looks_hide: this.hide,\n        looks_hideallsprites: function looks_hideallsprites() {},\n        // legacy no-op block\n        looks_switchcostumeto: this.switchCostume,\n        looks_switchbackdropto: this.switchBackdrop,\n        looks_switchbackdroptoandwait: this.switchBackdropAndWait,\n        looks_nextcostume: this.nextCostume,\n        looks_nextbackdrop: this.nextBackdrop,\n        looks_changeeffectby: this.changeEffect,\n        looks_seteffectto: this.setEffect,\n        looks_cleargraphiceffects: this.clearEffects,\n        looks_changesizeby: this.changeSize,\n        looks_setsizeto: this.setSize,\n        looks_changestretchby: function looks_changestretchby() {},\n        // legacy no-op blocks\n        looks_setstretchto: function looks_setstretchto() {},\n        looks_gotofrontback: this.goToFrontBack,\n        looks_goforwardbackwardlayers: this.goForwardBackwardLayers,\n        looks_size: this.getSize,\n        looks_costumenumbername: this.getCostumeNumberName,\n        looks_backdropnumbername: this.getBackdropNumberName\n      };\n    }\n  }, {\n    key: \"getMonitored\",\n    value: function getMonitored() {\n      return {\n        looks_size: {\n          isSpriteSpecific: true,\n          getId: function getId(targetId) {\n            return \"\".concat(targetId, \"_size\");\n          }\n        },\n        looks_costumenumbername: {\n          isSpriteSpecific: true,\n          getId: function getId(targetId, fields) {\n            return getMonitorIdForBlockWithArgs(\"\".concat(targetId, \"_costumenumbername\"), fields);\n          }\n        },\n        looks_backdropnumbername: {\n          getId: function getId(_, fields) {\n            return getMonitorIdForBlockWithArgs('backdropnumbername', fields);\n          }\n        }\n      };\n    }\n  }, {\n    key: \"say\",\n    value: function say(args, util) {\n      // @TODO in 2.0 calling say/think resets the right/left bias of the bubble\n      this.runtime.emit(Scratch3LooksBlocks.SAY_OR_THINK, util.target, 'say', args.MESSAGE);\n    }\n  }, {\n    key: \"sayforsecs\",\n    value: function sayforsecs(args, util) {\n      var _this = this;\n      this.say(args, util);\n      var target = util.target;\n      var usageId = this._getBubbleState(target).usageId;\n      return new Promise(function (resolve) {\n        _this._bubbleTimeout = setTimeout(function () {\n          _this._bubbleTimeout = null; // Clear say bubble if it hasn't been changed and proceed.\n          if (_this._getBubbleState(target).usageId === usageId) {\n            _this._updateBubble(target, 'say', '');\n          }\n          resolve();\n        }, 1000 * args.SECS);\n      });\n    }\n  }, {\n    key: \"think\",\n    value: function think(args, util) {\n      this.runtime.emit(Scratch3LooksBlocks.SAY_OR_THINK, util.target, 'think', args.MESSAGE);\n    }\n  }, {\n    key: \"thinkforsecs\",\n    value: function thinkforsecs(args, util) {\n      var _this2 = this;\n      this.think(args, util);\n      var target = util.target;\n      var usageId = this._getBubbleState(target).usageId;\n      return new Promise(function (resolve) {\n        _this2._bubbleTimeout = setTimeout(function () {\n          _this2._bubbleTimeout = null; // Clear think bubble if it hasn't been changed and proceed.\n          if (_this2._getBubbleState(target).usageId === usageId) {\n            _this2._updateBubble(target, 'think', '');\n          }\n          resolve();\n        }, 1000 * args.SECS);\n      });\n    }\n  }, {\n    key: \"show\",\n    value: function show(args, util) {\n      util.target.setVisible(true);\n      this._renderBubble(util.target);\n    }\n  }, {\n    key: \"hide\",\n    value: function hide(args, util) {\n      util.target.setVisible(false);\n      this._renderBubble(util.target);\n    }\n    /**\n     * Utility function to set the costume of a target.\n     * Matches the behavior of Scratch 2.0 for different types of arguments.\n     * @param {!Target} target Target to set costume to.\n     * @param {Any} requestedCostume Costume requested, e.g., 0, 'name', etc.\n     * @param {boolean=} optZeroIndex Set to zero-index the requestedCostume.\n     * @return {Array.<!Thread>} Any threads started by this switch.\n     */\n  }, {\n    key: \"_setCostume\",\n    value: function _setCostume(target, requestedCostume, optZeroIndex) {\n      if (typeof requestedCostume === 'number') {\n        // Numbers should be treated as costume indices, always\n        target.setCostume(optZeroIndex ? requestedCostume : requestedCostume - 1);\n      } else {\n        // Strings should be treated as costume names, where possible\n        var costumeIndex = target.getCostumeIndexByName(requestedCostume.toString());\n        if (costumeIndex !== -1) {\n          target.setCostume(costumeIndex);\n        } else if (requestedCostume === 'next costume') {\n          target.setCostume(target.currentCostume + 1);\n        } else if (requestedCostume === 'previous costume') {\n          target.setCostume(target.currentCostume - 1); // Try to cast the string to a number (and treat it as a costume index)\n          // Pure whitespace should not be treated as a number\n          // Note: isNaN will cast the string to a number before checking if it's NaN\n        } else if (!(isNaN(requestedCostume) || Cast.isWhiteSpace(requestedCostume))) {\n          target.setCostume(optZeroIndex ? Number(requestedCostume) : Number(requestedCostume) - 1);\n        }\n      } // Per 2.0, 'switch costume' can't start threads even in the Stage.\n      return [];\n    }\n    /**\n     * Utility function to set the backdrop of a target.\n     * Matches the behavior of Scratch 2.0 for different types of arguments.\n     * @param {!Target} stage Target to set backdrop to.\n     * @param {Any} requestedBackdrop Backdrop requested, e.g., 0, 'name', etc.\n     * @param {boolean=} optZeroIndex Set to zero-index the requestedBackdrop.\n     * @return {Array.<!Thread>} Any threads started by this switch.\n     */\n  }, {\n    key: \"_setBackdrop\",\n    value: function _setBackdrop(stage, requestedBackdrop, optZeroIndex) {\n      if (typeof requestedBackdrop === 'number') {\n        // Numbers should be treated as backdrop indices, always\n        stage.setCostume(optZeroIndex ? requestedBackdrop : requestedBackdrop - 1);\n      } else {\n        // Strings should be treated as backdrop names where possible\n        var costumeIndex = stage.getCostumeIndexByName(requestedBackdrop.toString());\n        if (costumeIndex !== -1) {\n          stage.setCostume(costumeIndex);\n        } else if (requestedBackdrop === 'next backdrop') {\n          stage.setCostume(stage.currentCostume + 1);\n        } else if (requestedBackdrop === 'previous backdrop') {\n          stage.setCostume(stage.currentCostume - 1);\n        } else if (requestedBackdrop === 'random backdrop') {\n          var numCostumes = stage.getCostumes().length;\n          if (numCostumes > 1) {\n            // Don't pick the current backdrop, so that the block\n            // will always have an observable effect.\n            var lowerBound = 0;\n            var upperBound = numCostumes - 1;\n            var costumeToExclude = stage.currentCostume;\n            var nextCostume = MathUtil.inclusiveRandIntWithout(lowerBound, upperBound, costumeToExclude);\n            stage.setCostume(nextCostume);\n          } // Try to cast the string to a number (and treat it as a costume index)\n          // Pure whitespace should not be treated as a number\n          // Note: isNaN will cast the string to a number before checking if it's NaN\n        } else if (!(isNaN(requestedBackdrop) || Cast.isWhiteSpace(requestedBackdrop))) {\n          stage.setCostume(optZeroIndex ? Number(requestedBackdrop) : Number(requestedBackdrop) - 1);\n        }\n      }\n      var newName = stage.getCostumes()[stage.currentCostume].name;\n      return this.runtime.startHats('event_whenbackdropswitchesto', {\n        BACKDROP: newName\n      });\n    }\n  }, {\n    key: \"switchCostume\",\n    value: function switchCostume(args, util) {\n      this._setCostume(util.target, args.COSTUME);\n    }\n  }, {\n    key: \"nextCostume\",\n    value: function nextCostume(args, util) {\n      this._setCostume(util.target, util.target.currentCostume + 1, true);\n    }\n  }, {\n    key: \"switchBackdrop\",\n    value: function switchBackdrop(args) {\n      this._setBackdrop(this.runtime.getTargetForStage(), args.BACKDROP);\n    }\n  }, {\n    key: \"switchBackdropAndWait\",\n    value: function switchBackdropAndWait(args, util) {\n      // Have we run before, starting threads?\n      if (!util.stackFrame.startedThreads) {\n        // No - switch the backdrop.\n        util.stackFrame.startedThreads = this._setBackdrop(this.runtime.getTargetForStage(), args.BACKDROP);\n        if (util.stackFrame.startedThreads.length === 0) {\n          // Nothing was started.\n          return;\n        }\n      } // We've run before; check if the wait is still going on.\n      var instance = this; // Scratch 2 considers threads to be waiting if they are still in\n      // runtime.threads. Threads that have run all their blocks, or are\n      // marked done but still in runtime.threads are still considered to\n      // be waiting.\n      var waiting = util.stackFrame.startedThreads.some(function (thread) {\n        return instance.runtime.threads.indexOf(thread) !== -1;\n      });\n      if (waiting) {\n        // If all threads are waiting for the next tick or later yield\n        // for a tick as well. Otherwise yield until the next loop of\n        // the threads.\n        if (util.stackFrame.startedThreads.every(function (thread) {\n          return instance.runtime.isWaitingThread(thread);\n        })) {\n          util.yieldTick();\n        } else {\n          util.yield();\n        }\n      }\n    }\n  }, {\n    key: \"nextBackdrop\",\n    value: function nextBackdrop() {\n      var stage = this.runtime.getTargetForStage();\n      this._setBackdrop(stage, stage.currentCostume + 1, true);\n    }\n  }, {\n    key: \"clampEffect\",\n    value: function clampEffect(effect, value) {\n      var clampedValue = value;\n      switch (effect) {\n        case 'ghost':\n          clampedValue = MathUtil.clamp(value, Scratch3LooksBlocks.EFFECT_GHOST_LIMIT.min, Scratch3LooksBlocks.EFFECT_GHOST_LIMIT.max);\n          break;\n        case 'brightness':\n          clampedValue = MathUtil.clamp(value, Scratch3LooksBlocks.EFFECT_BRIGHTNESS_LIMIT.min, Scratch3LooksBlocks.EFFECT_BRIGHTNESS_LIMIT.max);\n          break;\n      }\n      return clampedValue;\n    }\n  }, {\n    key: \"changeEffect\",\n    value: function changeEffect(args, util) {\n      var effect = Cast.toString(args.EFFECT).toLowerCase();\n      var change = Cast.toNumber(args.CHANGE);\n      if (!util.target.effects.hasOwnProperty(effect)) return;\n      var newValue = change + util.target.effects[effect];\n      newValue = this.clampEffect(effect, newValue);\n      util.target.setEffect(effect, newValue);\n    }\n  }, {\n    key: \"setEffect\",\n    value: function setEffect(args, util) {\n      var effect = Cast.toString(args.EFFECT).toLowerCase();\n      var value = Cast.toNumber(args.VALUE);\n      value = this.clampEffect(effect, value);\n      util.target.setEffect(effect, value);\n    }\n  }, {\n    key: \"clearEffects\",\n    value: function clearEffects(args, util) {\n      util.target.clearEffects();\n    }\n  }, {\n    key: \"changeSize\",\n    value: function changeSize(args, util) {\n      var change = Cast.toNumber(args.CHANGE);\n      util.target.setSize(util.target.size + change);\n    }\n  }, {\n    key: \"setSize\",\n    value: function setSize(args, util) {\n      var size = Cast.toNumber(args.SIZE);\n      util.target.setSize(size);\n    }\n  }, {\n    key: \"goToFrontBack\",\n    value: function goToFrontBack(args, util) {\n      if (!util.target.isStage) {\n        if (args.FRONT_BACK === 'front') {\n          util.target.goToFront();\n        } else {\n          util.target.goToBack();\n        }\n      }\n    }\n  }, {\n    key: \"goForwardBackwardLayers\",\n    value: function goForwardBackwardLayers(args, util) {\n      if (!util.target.isStage) {\n        if (args.FORWARD_BACKWARD === 'forward') {\n          util.target.goForwardLayers(Cast.toNumber(args.NUM));\n        } else {\n          util.target.goBackwardLayers(Cast.toNumber(args.NUM));\n        }\n      }\n    }\n  }, {\n    key: \"getSize\",\n    value: function getSize(args, util) {\n      return Math.round(util.target.size);\n    }\n  }, {\n    key: \"getBackdropNumberName\",\n    value: function getBackdropNumberName(args) {\n      var stage = this.runtime.getTargetForStage();\n      if (args.NUMBER_NAME === 'number') {\n        return stage.currentCostume + 1;\n      } // Else return name\n      return stage.getCostumes()[stage.currentCostume].name;\n    }\n  }, {\n    key: \"getCostumeNumberName\",\n    value: function getCostumeNumberName(args, util) {\n      if (args.NUMBER_NAME === 'number') {\n        return util.target.currentCostume + 1;\n      } // Else return name\n      return util.target.getCostumes()[util.target.currentCostume].name;\n    }\n  }], [{\n    key: \"DEFAULT_BUBBLE_STATE\",\n    get: function get() {\n      return {\n        drawableId: null,\n        onSpriteRight: true,\n        skinId: null,\n        text: '',\n        type: 'say',\n        usageId: null\n      };\n    }\n    /**\n     * The key to load & store a target's bubble-related state.\n     * @type {string}\n     */\n  }, {\n    key: \"STATE_KEY\",\n    get: function get() {\n      return 'Scratch.looks';\n    }\n    /**\n     * Event name for a text bubble being created or updated.\n     * @const {string}\n     */\n  }, {\n    key: \"SAY_OR_THINK\",\n    get: function get() {\n      // There are currently many places in the codebase which explicitly refer to this event by the string 'SAY',\n      // so keep this as the string 'SAY' for now rather than changing it to 'SAY_OR_THINK' and breaking things.\n      return 'SAY';\n    }\n    /**\n     * Limit for say bubble string.\n     * @const {string}\n     */\n  }, {\n    key: \"SAY_BUBBLE_LIMIT\",\n    get: function get() {\n      return 330;\n    }\n    /**\n     * Limit for ghost effect\n     * @const {object}\n     */\n  }, {\n    key: \"EFFECT_GHOST_LIMIT\",\n    get: function get() {\n      return {\n        min: 0,\n        max: 100\n      };\n    }\n    /**\n     * Limit for brightness effect\n     * @const {object}\n     */\n  }, {\n    key: \"EFFECT_BRIGHTNESS_LIMIT\",\n    get: function get() {\n      return {\n        min: -100,\n        max: 100\n      };\n    }\n  }]);\n  return Scratch3LooksBlocks;\n}();\nmodule.exports = Scratch3LooksBlocks;\n })