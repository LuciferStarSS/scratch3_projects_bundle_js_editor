/* 309 */\n (function(module, exports, __webpack_require__) {\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n// Use JS implemented TextDecoder and TextEncoder if it is not provided by the\n// browser.\nvar _TextDecoder;\nvar _TextEncoder;\nif (typeof TextDecoder === 'undefined' || typeof TextEncoder === 'undefined') {\n  // Wait to require text-encoding until we _know_ its needed. This will save\n  // evaluating ~500kb of encoding indices that we do not need to evaluate if\n  // the browser provides TextDecoder and TextEncoder.\n  // eslint-disable-next-line global-require\n  var encoding = __webpack_require__(160);\n  _TextDecoder = encoding.TextDecoder;\n  _TextEncoder = encoding.TextEncoder;\n} else {\n  /* global TextDecoder TextEncoder */\n  _TextDecoder = TextDecoder;\n  _TextEncoder = TextEncoder;\n}\nvar md5 = __webpack_require__(161);\nvar memoizedToString = function () {\n  /**\n   * The maximum length of a chunk before encoding it into base64.\n   *\n   * 32766 is a multiple of 3 so btoa does not need to use padding characters\n   * except for the final chunk where that is fine. 32766 is also close to\n   * 32768 so it is close to a size an memory allocator would prefer.\n   * @const {number}\n   */\n  var BTOA_CHUNK_MAX_LENGTH = 32766;\n  /**\n   * An array cache of bytes to characters.\n   * @const {?Array.<string>}\n   */\n  var fromCharCode = null;\n  var strings = {};\n  return function (assetId, data) {\n    if (!strings.hasOwnProperty(assetId)) {\n      if (typeof btoa === 'undefined') {\n        // Use a library that does not need btoa to run.\n        /* eslint-disable-next-line global-require */\n        var base64js = __webpack_require__(1212);\n        strings[assetId] = base64js.fromByteArray(data);\n      } else {\n        // Native btoa is faster than javascript translation. Use js to\n        // create a \"binary\" string and btoa to encode it.\n        if (fromCharCode === null) {\n          // Cache the first 256 characters for input byte values.\n          fromCharCode = new Array(256);\n          for (var i = 0; i < 256; i++) {\n            fromCharCode[i] = String.fromCharCode(i);\n          }\n        }\n        var length = data.length;\n        var s = ''; // Iterate over chunks of the binary data.\n        for (var _i = 0, e = 0; _i < length; _i = e) {\n          // Create small chunks to cause more small allocations and\n          // less large allocations.\n          e = Math.min(e + BTOA_CHUNK_MAX_LENGTH, length);\n          var s_ = '';\n          for (var j = _i; j < e; j += 1) {\n            s_ += fromCharCode[data[j]];\n          } // Encode the latest chunk so the we create one big output\n          // string instead of creating a big input string and then\n          // one big output string.\n          /* global btoa */\n          s += btoa(s_);\n        }\n        strings[assetId] = s;\n      }\n    }\n    return strings[assetId];\n  };\n}();\nvar Asset = function () {\n  /**\n   * Construct an Asset.\n   * @param {AssetType} assetType - The type of this asset (sound, image, etc.)\n   * @param {string} assetId - The ID of this asset.\n   * @param {DataFormat} [dataFormat] - The format of the data (WAV, PNG, etc.); required iff `data` is present.\n   * @param {Buffer} [data] - The in-memory data for this asset; optional.\n   * @param {bool} [generateId] - Whether to create id from an md5 hash of data\n   */\n  function Asset(assetType, assetId, dataFormat, data, generateId) {\n    _classCallCheck(this, Asset);\n    /** @type {AssetType} */\n    this.assetType = assetType;\n    /** @type {string} */\n    this.assetId = assetId;\n    this.setData(data, dataFormat || assetType.runtimeFormat, generateId);\n    /** @type {Asset[]} */\n    this.dependencies = [];\n  }\n  _createClass(Asset, [{\n    key: \"setData\",\n    value: function setData(data, dataFormat, generateId) {\n      if (data && !dataFormat) {\n        throw new Error('Data provided without specifying its format');\n      }\n      /** @type {DataFormat} */\n      this.dataFormat = dataFormat;\n      /** @type {Buffer} */\n      this.data = data;\n      if (generateId) this.assetId = md5(data); // Mark as clean only if set is being called without generateId\n      // If a new id is being generated, mark this asset as not clean\n      this.clean = !generateId;\n    }\n    /**\n     * @returns {string} - This asset's data, decoded as text.\n     */\n  }, {\n    key: \"decodeText\",\n    value: function decodeText() {\n      var decoder = new _TextDecoder();\n      return decoder.decode(this.data);\n    }\n    /**\n     * Same as `setData` but encodes text first.\n     * @param {string} data - the text data to encode and store.\n     * @param {DataFormat} dataFormat - the format of the data (DataFormat.SVG for example).\n     * @param {bool} generateId - after setting data, set the id to an md5 of the data?\n     */\n  }, {\n    key: \"encodeTextData\",\n    value: function encodeTextData(data, dataFormat, generateId) {\n      var encoder = new _TextEncoder();\n      this.setData(encoder.encode(data), dataFormat, generateId);\n    }\n    /**\n     * @param {string} [contentType] - Optionally override the content type to be included in the data URI.\n     * @returns {string} - A data URI representing the asset's data.\n     */\n  }, {\n    key: \"encodeDataURI\",\n    value: function encodeDataURI(contentType) {\n      contentType = contentType || this.assetType.contentType;\n      return \"data:\".concat(contentType, \";base64,\").concat(memoizedToString(this.assetId, this.data));\n    }\n  }]);\n  return Asset;\n}();\nmodule.exports = Asset;\n })