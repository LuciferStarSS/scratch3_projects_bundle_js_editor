/* 944 */\n (function(module, exports, __webpack_require__) {\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nvar log = __webpack_require__(39);\n/**\n * @typedef {object} DispatchCallMessage - a message to the dispatch system representing a service method call\n * @property {*} responseId - send a response message with this response ID. See {@link DispatchResponseMessage}\n * @property {string} service - the name of the service to be called\n * @property {string} method - the name of the method to be called\n * @property {Array|undefined} args - the arguments to be passed to the method\n */\n/**\n * @typedef {object} DispatchResponseMessage - a message to the dispatch system representing the results of a call\n * @property {*} responseId - a copy of the response ID from the call which generated this response\n * @property {*|undefined} error - if this is truthy, then it contains results from a failed call (such as an exception)\n * @property {*|undefined} result - if error is not truthy, then this contains the return value of the call (if any)\n */\n/**\n * @typedef {DispatchCallMessage|DispatchResponseMessage} DispatchMessage\n * Any message to the dispatch system.\n */\n/**\n * The SharedDispatch class is responsible for dispatch features shared by\n * {@link CentralDispatch} and {@link WorkerDispatch}.\n */\nvar SharedDispatch = function () {\n  function SharedDispatch() {\n    _classCallCheck(this, SharedDispatch);\n    /**\n     * List of callback registrations for promises waiting for a response from a call to a service on another\n     * worker. A callback registration is an array of [resolve,reject] Promise functions.\n     * Calls to local services don't enter this list.\n     * @type {Array.<Function[]>}\n     */\n    this.callbacks = [];\n    /**\n     * The next response ID to be used.\n     * @type {int}\n     */\n    this.nextResponseId = 0;\n  }\n  /**\n   * Call a particular method on a particular service, regardless of whether that service is provided locally or on\n   * a worker. If the service is provided by a worker, the `args` will be copied using the Structured Clone\n   * algorithm, except for any items which are also in the `transfer` list. Ownership of those items will be\n   * transferred to the worker, and they should not be used after this call.\n   * @example\n   *      dispatcher.call('vm', 'setData', 'cat', 42);\n   *      // this finds the worker for the 'vm' service, then on that worker calls:\n   *      vm.setData('cat', 42);\n   * @param {string} service - the name of the service.\n   * @param {string} method - the name of the method.\n   * @param {*} [args] - the arguments to be copied to the method, if any.\n   * @returns {Promise} - a promise for the return value of the service method.\n   */\n  _createClass(SharedDispatch, [{\n    key: \"call\",\n    value: function call(service, method) {\n      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        args[_key - 2] = arguments[_key];\n      }\n      return this.transferCall.apply(this, [service, method, null].concat(args));\n    }\n    /**\n     * Call a particular method on a particular service, regardless of whether that service is provided locally or on\n     * a worker. If the service is provided by a worker, the `args` will be copied using the Structured Clone\n     * algorithm, except for any items which are also in the `transfer` list. Ownership of those items will be\n     * transferred to the worker, and they should not be used after this call.\n     * @example\n     *      dispatcher.transferCall('vm', 'setData', [myArrayBuffer], 'cat', myArrayBuffer);\n     *      // this finds the worker for the 'vm' service, transfers `myArrayBuffer` to it, then on that worker calls:\n     *      vm.setData('cat', myArrayBuffer);\n     * @param {string} service - the name of the service.\n     * @param {string} method - the name of the method.\n     * @param {Array} [transfer] - objects to be transferred instead of copied. Must be present in `args` to be useful.\n     * @param {*} [args] - the arguments to be copied to the method, if any.\n     * @returns {Promise} - a promise for the return value of the service method.\n     */\n  }, {\n    key: \"transferCall\",\n    value: function transferCall(service, method, transfer) {\n      try {\n        var _this$_getServiceProv = this._getServiceProvider(service),\n            provider = _this$_getServiceProv.provider,\n            isRemote = _this$_getServiceProv.isRemote;\n        if (provider) {\n          for (var _len2 = arguments.length, args = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n            args[_key2 - 3] = arguments[_key2];\n          }\n          if (isRemote) {\n            return this._remoteTransferCall.apply(this, [provider, service, method, transfer].concat(args));\n          }\n          var result = provider[method].apply(provider, args);\n          return Promise.resolve(result);\n        }\n        return Promise.reject(new Error(\"Service not found: \".concat(service)));\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }\n    /**\n     * Check if a particular service lives on another worker.\n     * @param {string} service - the service to check.\n     * @returns {boolean} - true if the service is remote (calls must cross a Worker boundary), false otherwise.\n     * @private\n     */\n  }, {\n    key: \"_isRemoteService\",\n    value: function _isRemoteService(service) {\n      return this._getServiceProvider(service).isRemote;\n    }\n    /**\n     * Like {@link call}, but force the call to be posted through a particular communication channel.\n     * @param {object} provider - send the call through this object's `postMessage` function.\n     * @param {string} service - the name of the service.\n     * @param {string} method - the name of the method.\n     * @param {*} [args] - the arguments to be copied to the method, if any.\n     * @returns {Promise} - a promise for the return value of the service method.\n     */\n  }, {\n    key: \"_remoteCall\",\n    value: function _remoteCall(provider, service, method) {\n      for (var _len3 = arguments.length, args = new Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {\n        args[_key3 - 3] = arguments[_key3];\n      }\n      return this._remoteTransferCall.apply(this, [provider, service, method, null].concat(args));\n    }\n    /**\n     * Like {@link transferCall}, but force the call to be posted through a particular communication channel.\n     * @param {object} provider - send the call through this object's `postMessage` function.\n     * @param {string} service - the name of the service.\n     * @param {string} method - the name of the method.\n     * @param {Array} [transfer] - objects to be transferred instead of copied. Must be present in `args` to be useful.\n     * @param {*} [args] - the arguments to be copied to the method, if any.\n     * @returns {Promise} - a promise for the return value of the service method.\n     */\n  }, {\n    key: \"_remoteTransferCall\",\n    value: function _remoteTransferCall(provider, service, method, transfer) {\n      var _this = this;\n      for (var _len4 = arguments.length, args = new Array(_len4 > 4 ? _len4 - 4 : 0), _key4 = 4; _key4 < _len4; _key4++) {\n        args[_key4 - 4] = arguments[_key4];\n      }\n      return new Promise(function (resolve, reject) {\n        var responseId = _this._storeCallbacks(resolve, reject);\n        /** @TODO: remove this hack! this is just here so we don't try to send `util` to a worker */\n        if (args.length > 0 && typeof args[args.length - 1].yield === 'function') {\n          args.pop();\n        }\n        if (transfer) {\n          provider.postMessage({\n            service: service,\n            method: method,\n            responseId: responseId,\n            args: args\n          }, transfer);\n        } else {\n          provider.postMessage({\n            service: service,\n            method: method,\n            responseId: responseId,\n            args: args\n          });\n        }\n      });\n    }\n    /**\n     * Store callback functions pending a response message.\n     * @param {Function} resolve - function to call if the service method returns.\n     * @param {Function} reject - function to call if the service method throws.\n     * @returns {*} - a unique response ID for this set of callbacks. See {@link _deliverResponse}.\n     * @protected\n     */\n  }, {\n    key: \"_storeCallbacks\",\n    value: function _storeCallbacks(resolve, reject) {\n      var responseId = this.nextResponseId++;\n      this.callbacks[responseId] = [resolve, reject];\n      return responseId;\n    }\n    /**\n     * Deliver call response from a worker. This should only be called as the result of a message from a worker.\n     * @param {int} responseId - the response ID of the callback set to call.\n     * @param {DispatchResponseMessage} message - the message containing the response value(s).\n     * @protected\n     */\n  }, {\n    key: \"_deliverResponse\",\n    value: function _deliverResponse(responseId, message) {\n      try {\n        var _this$callbacks$respo = _slicedToArray(this.callbacks[responseId], 2),\n            resolve = _this$callbacks$respo[0],\n            reject = _this$callbacks$respo[1];\n        delete this.callbacks[responseId];\n        if (message.error) {\n          reject(message.error);\n        } else {\n          resolve(message.result);\n        }\n      } catch (e) {\n        log.error(\"Dispatch callback failed: \".concat(JSON.stringify(e)));\n      }\n    }\n    /**\n     * Handle a message event received from a connected worker.\n     * @param {Worker} worker - the worker which sent the message, or the global object if running in a worker.\n     * @param {MessageEvent} event - the message event to be handled.\n     * @protected\n     */\n  }, {\n    key: \"_onMessage\",\n    value: function _onMessage(worker, event) {\n      /** @type {DispatchMessage} */\n      var message = event.data;\n      message.args = message.args || [];\n      var promise;\n      if (message.service) {\n        if (message.service === 'dispatch') {\n          promise = this._onDispatchMessage(worker, message);\n        } else {\n          promise = this.call.apply(this, [message.service, message.method].concat(_toConsumableArray(message.args)));\n        }\n      } else if (typeof message.responseId === 'undefined') {\n        log.error(\"Dispatch caught malformed message from a worker: \".concat(JSON.stringify(event)));\n      } else {\n        this._deliverResponse(message.responseId, message);\n      }\n      if (promise) {\n        if (typeof message.responseId === 'undefined') {\n          log.error(\"Dispatch message missing required response ID: \".concat(JSON.stringify(event)));\n        } else {\n          promise.then(function (result) {\n            return worker.postMessage({\n              responseId: message.responseId,\n              result: result\n            });\n          }, function (error) {\n            return worker.postMessage({\n              responseId: message.responseId,\n              error: error\n            });\n          });\n        }\n      }\n    }\n    /**\n     * Fetch the service provider object for a particular service name.\n     * @abstract\n     * @param {string} service - the name of the service to look up\n     * @returns {{provider:(object|Worker), isRemote:boolean}} - the means to contact the service, if found\n     * @protected\n     */\n  }, {\n    key: \"_getServiceProvider\",\n    value: function _getServiceProvider(service) {\n      throw new Error(\"Could not get provider for \".concat(service, \": _getServiceProvider not implemented\"));\n    }\n    /**\n     * Handle a call message sent to the dispatch service itself\n     * @abstract\n     * @param {Worker} worker - the worker which sent the message.\n     * @param {DispatchCallMessage} message - the message to be handled.\n     * @returns {Promise|undefined} - a promise for the results of this operation, if appropriate\n     * @private\n     */\n  }, {\n    key: \"_onDispatchMessage\",\n    value: function _onDispatchMessage(worker, message) {\n      throw new Error(\"Unimplemented dispatch message handler cannot handle \".concat(message.method, \" method\"));\n    }\n  }]);\n  return SharedDispatch;\n}();\nmodule.exports = SharedDispatch;\n })