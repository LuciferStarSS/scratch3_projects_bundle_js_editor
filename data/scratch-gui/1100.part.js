/* 1100 */\n (function(module, exports, __webpack_require__) {\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nvar ArgumentType = __webpack_require__(63);\nvar BlockType = __webpack_require__(45);\nvar log = __webpack_require__(39);\nvar formatMessage = __webpack_require__(71);\nvar MathUtil = __webpack_require__(62);\nvar BLE = __webpack_require__(221);\nvar godirect = __webpack_require__(1101);\nvar ScratchLinkDeviceAdapter = __webpack_require__(1102);\n/**\n * Icon png to be displayed at the left edge of each extension block, encoded as a data URI.\n * @type {string}\n */\n// eslint-disable-next-line max-len\nvar blockIconURI = 'data:image/png;base64,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';\n/**\n * Icon png to be displayed in the blocks category menu, encoded as a data URI.\n * @type {string}\n */\n// eslint-disable-next-line max-len\nvar menuIconURI = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAABGdBTUEAALGPC/xhBQAAA9dJREFUWAnNmE2IFEcUgF/9dE/v7LoaM9kkK4JBRA0EFBIPRm85hBAvEXHXwyo5eFE87GFcReMkObgJiQnkkJzEg9n8HIJixKNe1IMKihgiCbviwV11V3d0d3pmuqsqr5ppcEnb3TNVggVFVVe9eu+r97qqq4tASqp8/fsboQgmU0TMugi571K29bPy9ovPU8Sf16HbpQj3EkYFBcJcr5Am2nZfs94AIWVfqMQeHNwhICUBZ4ypUIA/X2sbIm2AW8AJK0lkEP6TJpfqwXgg4QxmF/fB7Gtvxk1G5ZKHU1CqTgPJoSUXYJYeohSUJu+qrqdVUGh2/pVX4VFffx77WaqBZkrkEFj271+qWH0sXcU3FBzyQe/Mg7B//LbKMTRTxNiDbsMHHjTJlyM7HEJIBHXs2KXFj+oTNSdoQOCYLS5jD9IwBMm5H8NplwwPb/QV4yEIcycaAza9IuA76B38fuz1OF5RXUkmHCdu6rg0BpSMgV/sAe7DdzGFrvvdi0D3mSZjQA0wt7REQsY+iWF0XbfFzyal8SLRxuteD+Du4h4Z/flbqaBHibAQtZmQtcZaAZSMwtTylaR/4vaw1ju5YhWG10pwwAqghmp2FeHO2+t11WqyM80W0m7vAOhsM1kD7CGz8L57Jsq6bitZC/GcWgLf1H6KuHT92cTDAFy/BgXMXm0OCpgV50Bo9kK3BqiBboabQMMU/WoL5im4jToeq/AIgXsiRx5KKCjcwPEsiAv/BQMu9EwyDHXd/3kqCOSzDk6t5/YglQKKeJwq+PNRmJI8kwSTaj1HZy5AhSHqnXkIvU9mMUwEw4Q5wTM57LUtkg8QPw/cdcBJ+PhvKJ0Gj80nGq6JXrg6/XFiX97GXIBpyqTieKpKViOl+WEhWXMaUavvvdIZ8Giy5+Lh3bwKm/t+Be3JazMfxc1tldY26rastiHcsQevTG9pw0znovkAcRWHzSDKnZtaOJLSfMFLB5RqtRBS4LbCurqLCy0YPkU3C0IIPEimMqR2ei7ZX2+KQdRi/WahNT/GmfOD4Vyzhx/66pcjp85dUvcmp6J8+txldXh07PPskdkS+V6EbD0vTOKlB0x9B/O6BS8ULly9PgE6x4kDPR/XX5pyYKj8xcCucsUmkNUQE0JvKKm2VioVK5HRE7UKOHbi6B94RzP+93jtpC0vWgXUF0hr3ipuw8uadwd3jXxoA9IK4Pah8t6BneV9GgjD28Svw1mlxFobgFbeFTz13cKbth93fDryp2CEq0a4hTA+aAPQ/ESJFDdvXLzzzrqNjlTqOP6uDeFf0uhvJ0ZP2QD8D6ZzU6u8YIbBAAAAAElFTkSuQmCC';\n/**\n * Enum for Vernier godirect protocol.\n * @readonly\n * @enum {string}\n */\nvar BLEUUID = {\n  service: 'd91714ef-28b9-4f91-ba16-f0d9a604f112',\n  commandChar: 'f4bf14a6-c7d5-4b6d-8aa8-df1a7c83adcb',\n  responseChar: 'b41e6675-a329-40e0-aa01-44d2f444babe'\n};\n/**\n * A time interval to wait (in milliseconds) before reporting to the BLE socket\n * that data has stopped coming from the peripheral.\n */\nvar BLETimeout = 4500;\n/**\n * A string to report to the BLE socket when the GdxFor has stopped receiving data.\n * @type {string}\n */\nvar BLEDataStoppedError = 'Force and Acceleration extension stopped receiving data';\n/**\n * Sensor ID numbers for the GDX-FOR.\n */\nvar GDXFOR_SENSOR = {\n  FORCE: 1,\n  ACCELERATION_X: 2,\n  ACCELERATION_Y: 3,\n  ACCELERATION_Z: 4,\n  SPIN_SPEED_X: 5,\n  SPIN_SPEED_Y: 6,\n  SPIN_SPEED_Z: 7\n};\n/**\n * The update rate, in milliseconds, for sensor data input from the peripheral.\n */\nvar GDXFOR_UPDATE_RATE = 80;\n/**\n * Threshold for pushing and pulling force, for the whenForcePushedOrPulled hat block.\n * @type {number}\n */\nvar FORCE_THRESHOLD = 5;\n/**\n * Threshold for acceleration magnitude, for the \"shaken\" gesture.\n * @type {number}\n */\nvar SHAKEN_THRESHOLD = 30;\n/**\n * Threshold for acceleration magnitude, to check if we are facing up.\n * @type {number}\n */\nvar FACING_THRESHOLD = 9;\n/**\n * An offset for the facing threshold, used to check that we are no longer facing up.\n * @type {number}\n */\nvar FACING_THRESHOLD_OFFSET = 5;\n/**\n * Threshold for acceleration magnitude, below which we are in freefall.\n * @type {number}\n */\nvar FREEFALL_THRESHOLD = 0.5;\n/**\n * Factor used to account for influence of rotation during freefall.\n * @type {number}\n */\nvar FREEFALL_ROTATION_FACTOR = 0.3;\n/**\n * Threshold in degrees for reporting that the sensor is tilted.\n * @type {number}\n */\nvar TILT_THRESHOLD = 15;\n/**\n * Acceleration due to gravity, in m/s^2.\n * @type {number}\n */\nvar GRAVITY = 9.8;\n/**\n * Manage communication with a GDX-FOR peripheral over a Scratch Link client socket.\n */\nvar GdxFor = function () {\n  /**\n   * Construct a GDX-FOR communication object.\n   * @param {Runtime} runtime - the Scratch 3.0 runtime\n   * @param {string} extensionId - the id of the extension\n   */\n  function GdxFor(runtime, extensionId) {\n    _classCallCheck(this, GdxFor);\n    /**\n     * The Scratch 3.0 runtime used to trigger the green flag button.\n     * @type {Runtime}\n     * @private\n     */\n    this._runtime = runtime;\n    /**\n     * The BluetoothLowEnergy connection socket for reading/writing peripheral data.\n     * @type {BLE}\n     * @private\n     */\n    this._ble = null;\n    /**\n     * An @vernier/godirect Device\n     * @type {Device}\n     * @private\n     */\n    this._device = null;\n    this._runtime.registerPeripheralExtension(extensionId, this);\n    /**\n     * The id of the extension this peripheral belongs to.\n     */\n    this._extensionId = extensionId;\n    /**\n     * The most recently received value for each sensor.\n     * @type {Object.<string, number>}\n     * @private\n     */\n    this._sensors = {\n      force: 0,\n      accelerationX: 0,\n      accelerationY: 0,\n      accelerationZ: 0,\n      spinSpeedX: 0,\n      spinSpeedY: 0,\n      spinSpeedZ: 0\n    };\n    /**\n     * Interval ID for data reading timeout.\n     * @type {number}\n     * @private\n     */\n    this._timeoutID = null;\n    this.reset = this.reset.bind(this);\n    this._onConnect = this._onConnect.bind(this);\n  }\n  /**\n   * Called by the runtime when user wants to scan for a peripheral.\n   */\n  _createClass(GdxFor, [{\n    key: \"scan\",\n    value: function scan() {\n      if (this._ble) {\n        this._ble.disconnect();\n      }\n      this._ble = new BLE(this._runtime, this._extensionId, {\n        filters: [{\n          namePrefix: 'GDX-FOR'\n        }],\n        optionalServices: [BLEUUID.service]\n      }, this._onConnect, this.reset);\n    }\n    /**\n     * Called by the runtime when user wants to connect to a certain peripheral.\n     * @param {number} id - the id of the peripheral to connect to.\n     */\n  }, {\n    key: \"connect\",\n    value: function connect(id) {\n      if (this._ble) {\n        this._ble.connectPeripheral(id);\n      }\n    }\n    /**\n     * Called by the runtime when a user exits the connection popup.\n     * Disconnect from the GDX FOR.\n     */\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      if (this._ble) {\n        this._ble.disconnect();\n      }\n      this.reset();\n    }\n    /**\n     * Reset all the state and timeout/interval ids.\n     */\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this._sensors = {\n        force: 0,\n        accelerationX: 0,\n        accelerationY: 0,\n        accelerationZ: 0,\n        spinSpeedX: 0,\n        spinSpeedY: 0,\n        spinSpeedZ: 0\n      };\n      if (this._timeoutID) {\n        window.clearInterval(this._timeoutID);\n        this._timeoutID = null;\n      }\n    }\n    /**\n     * Return true if connected to the goforce device.\n     * @return {boolean} - whether the goforce is connected.\n     */\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      var connected = false;\n      if (this._ble) {\n        connected = this._ble.isConnected();\n      }\n      return connected;\n    }\n    /**\n     * Starts reading data from peripheral after BLE has connected to it.\n     * @private\n     */\n  }, {\n    key: \"_onConnect\",\n    value: function _onConnect() {\n      var _this = this;\n      var adapter = new ScratchLinkDeviceAdapter(this._ble, BLEUUID);\n      godirect.createDevice(adapter, {\n        open: true,\n        startMeasurements: false\n      }).then(function (device) {\n        // Setup device\n        _this._device = device;\n        _this._device.keepValues = false; // todo: possibly remove after updating Vernier godirect module\n        // Enable sensors\n        _this._device.sensors.forEach(function (sensor) {\n          sensor.setEnabled(true);\n        }); // Set sensor value-update behavior\n        _this._device.on('measurements-started', function () {\n          var enabledSensors = _this._device.sensors.filter(function (s) {\n            return s.enabled;\n          });\n          enabledSensors.forEach(function (sensor) {\n            sensor.on('value-changed', function (s) {\n              _this._onSensorValueChanged(s);\n            });\n          });\n          _this._timeoutID = window.setInterval(function () {\n            return _this._ble.handleDisconnectError(BLEDataStoppedError);\n          }, BLETimeout);\n        }); // Start device\n        _this._device.start(GDXFOR_UPDATE_RATE);\n      });\n    }\n    /**\n     * Handler for sensor value changes from the goforce device.\n     * @param {object} sensor - goforce device sensor whose value has changed\n     * @private\n     */\n  }, {\n    key: \"_onSensorValueChanged\",\n    value: function _onSensorValueChanged(sensor) {\n      var _this2 = this;\n      switch (sensor.number) {\n        case GDXFOR_SENSOR.FORCE:\n          // Normalize the force, which can be measured between -50 and 50 N,\n          // to be a value between -100 and 100.\n          this._sensors.force = MathUtil.clamp(sensor.value * 2, -100, 100);\n          break;\n        case GDXFOR_SENSOR.ACCELERATION_X:\n          this._sensors.accelerationX = sensor.value;\n          break;\n        case GDXFOR_SENSOR.ACCELERATION_Y:\n          this._sensors.accelerationY = sensor.value;\n          break;\n        case GDXFOR_SENSOR.ACCELERATION_Z:\n          this._sensors.accelerationZ = sensor.value;\n          break;\n        case GDXFOR_SENSOR.SPIN_SPEED_X:\n          this._sensors.spinSpeedX = this._spinSpeedFromGyro(sensor.value);\n          break;\n        case GDXFOR_SENSOR.SPIN_SPEED_Y:\n          this._sensors.spinSpeedY = this._spinSpeedFromGyro(sensor.value);\n          break;\n        case GDXFOR_SENSOR.SPIN_SPEED_Z:\n          this._sensors.spinSpeedZ = this._spinSpeedFromGyro(sensor.value);\n          break;\n      } // cancel disconnect timeout and start a new one\n      window.clearInterval(this._timeoutID);\n      this._timeoutID = window.setInterval(function () {\n        return _this2._ble.handleDisconnectError(BLEDataStoppedError);\n      }, BLETimeout);\n    }\n  }, {\n    key: \"_spinSpeedFromGyro\",\n    value: function _spinSpeedFromGyro(val) {\n      var framesPerSec = 1000 / this._runtime.currentStepTime;\n      val = MathUtil.radToDeg(val);\n      val = val / framesPerSec; // convert to from degrees per sec to degrees per frame\n      val = val * -1;\n      return val;\n    }\n  }, {\n    key: \"getForce\",\n    value: function getForce() {\n      return this._sensors.force;\n    }\n  }, {\n    key: \"getTiltFrontBack\",\n    value: function getTiltFrontBack() {\n      var back = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var x = this.getAccelerationX();\n      var y = this.getAccelerationY();\n      var z = this.getAccelerationZ(); // Compute the yz unit vector\n      var y2 = y * y;\n      var z2 = z * z;\n      var value = y2 + z2;\n      value = Math.sqrt(value); // For sufficiently small zy vector values we are essentially at 90 degrees.\n      // The following snaps to 90 and avoids divide-by-zero errors.\n      // The snap factor was derived through observation -- just enough to\n      // still allow single degree steps up to 90 (..., 87, 88, 89, 90).\n      if (value < 0.35) {\n        value = x < 0 ? 90 : -90;\n      } else {\n        value = x / value;\n        value = Math.atan(value);\n        value = MathUtil.radToDeg(value) * -1;\n      } // Back is the inverse of front\n      if (back) value *= -1;\n      return value;\n    }\n  }, {\n    key: \"getTiltLeftRight\",\n    value: function getTiltLeftRight() {\n      var right = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var x = this.getAccelerationX();\n      var y = this.getAccelerationY();\n      var z = this.getAccelerationZ(); // Compute the yz unit vector\n      var x2 = x * x;\n      var z2 = z * z;\n      var value = x2 + z2;\n      value = Math.sqrt(value); // For sufficiently small zy vector values we are essentially at 90 degrees.\n      // The following snaps to 90 and avoids divide-by-zero errors.\n      // The snap factor was derived through observation -- just enough to\n      // still allow single degree steps up to 90 (..., 87, 88, 89, 90).\n      if (value < 0.35) {\n        value = y < 0 ? 90 : -90;\n      } else {\n        value = y / value;\n        value = Math.atan(value);\n        value = MathUtil.radToDeg(value) * -1;\n      } // Right is the inverse of left\n      if (right) value *= -1;\n      return value;\n    }\n  }, {\n    key: \"getAccelerationX\",\n    value: function getAccelerationX() {\n      return this._sensors.accelerationX;\n    }\n  }, {\n    key: \"getAccelerationY\",\n    value: function getAccelerationY() {\n      return this._sensors.accelerationY;\n    }\n  }, {\n    key: \"getAccelerationZ\",\n    value: function getAccelerationZ() {\n      return this._sensors.accelerationZ;\n    }\n  }, {\n    key: \"getSpinSpeedX\",\n    value: function getSpinSpeedX() {\n      return this._sensors.spinSpeedX;\n    }\n  }, {\n    key: \"getSpinSpeedY\",\n    value: function getSpinSpeedY() {\n      return this._sensors.spinSpeedY;\n    }\n  }, {\n    key: \"getSpinSpeedZ\",\n    value: function getSpinSpeedZ() {\n      return this._sensors.spinSpeedZ;\n    }\n  }]);\n  return GdxFor;\n}();\n/**\n * Enum for pushed and pulled menu options.\n * @readonly\n * @enum {string}\n */\nvar PushPullValues = {\n  PUSHED: 'pushed',\n  PULLED: 'pulled'\n};\n/**\n * Enum for motion gesture menu options.\n * @readonly\n * @enum {string}\n */\nvar GestureValues = {\n  SHAKEN: 'shaken',\n  STARTED_FALLING: 'started falling',\n  TURNED_FACE_UP: 'turned face up',\n  TURNED_FACE_DOWN: 'turned face down'\n};\n/**\n * Enum for tilt axis menu options.\n * @readonly\n * @enum {string}\n */\nvar TiltAxisValues = {\n  FRONT: 'front',\n  BACK: 'back',\n  LEFT: 'left',\n  RIGHT: 'right',\n  ANY: 'any'\n};\n/**\n * Enum for axis menu options.\n * @readonly\n * @enum {string}\n */\nvar AxisValues = {\n  X: 'x',\n  Y: 'y',\n  Z: 'z'\n};\n/**\n * Scratch 3.0 blocks to interact with a GDX-FOR peripheral.\n */\nvar Scratch3GdxForBlocks = function () {\n  _createClass(Scratch3GdxForBlocks, [{\n    key: \"AXIS_MENU\",\n    get: function get() {\n      return [{\n        text: 'x',\n        value: AxisValues.X\n      }, {\n        text: 'y',\n        value: AxisValues.Y\n      }, {\n        text: 'z',\n        value: AxisValues.Z\n      }];\n    }\n  }, {\n    key: \"TILT_MENU\",\n    get: function get() {\n      return [{\n        text: formatMessage({\n          id: 'gdxfor.tiltDirectionMenu.front',\n          default: 'front',\n          description: 'label for front element in tilt direction picker for gdxfor extension'\n        }),\n        value: TiltAxisValues.FRONT\n      }, {\n        text: formatMessage({\n          id: 'gdxfor.tiltDirectionMenu.back',\n          default: 'back',\n          description: 'label for back element in tilt direction picker for gdxfor extension'\n        }),\n        value: TiltAxisValues.BACK\n      }, {\n        text: formatMessage({\n          id: 'gdxfor.tiltDirectionMenu.left',\n          default: 'left',\n          description: 'label for left element in tilt direction picker for gdxfor extension'\n        }),\n        value: TiltAxisValues.LEFT\n      }, {\n        text: formatMessage({\n          id: 'gdxfor.tiltDirectionMenu.right',\n          default: 'right',\n          description: 'label for right element in tilt direction picker for gdxfor extension'\n        }),\n        value: TiltAxisValues.RIGHT\n      }];\n    }\n  }, {\n    key: \"TILT_MENU_ANY\",\n    get: function get() {\n      return [].concat(_toConsumableArray(this.TILT_MENU), [{\n        text: formatMessage({\n          id: 'gdxfor.tiltDirectionMenu.any',\n          default: 'any',\n          description: 'label for any direction element in tilt direction picker for gdxfor extension'\n        }),\n        value: TiltAxisValues.ANY\n      }]);\n    }\n  }, {\n    key: \"PUSH_PULL_MENU\",\n    get: function get() {\n      return [{\n        text: formatMessage({\n          id: 'gdxfor.pushed',\n          default: 'pushed',\n          description: 'the force sensor was pushed inward'\n        }),\n        value: PushPullValues.PUSHED\n      }, {\n        text: formatMessage({\n          id: 'gdxfor.pulled',\n          default: 'pulled',\n          description: 'the force sensor was pulled outward'\n        }),\n        value: PushPullValues.PULLED\n      }];\n    }\n  }, {\n    key: \"GESTURE_MENU\",\n    get: function get() {\n      return [{\n        text: formatMessage({\n          id: 'gdxfor.shaken',\n          default: 'shaken',\n          description: 'the sensor was shaken'\n        }),\n        value: GestureValues.SHAKEN\n      }, {\n        text: formatMessage({\n          id: 'gdxfor.startedFalling',\n          default: 'started falling',\n          description: 'the sensor started free falling'\n        }),\n        value: GestureValues.STARTED_FALLING\n      }, {\n        text: formatMessage({\n          id: 'gdxfor.turnedFaceUp',\n          default: 'turned face up',\n          description: 'the sensor was turned to face up'\n        }),\n        value: GestureValues.TURNED_FACE_UP\n      }, {\n        text: formatMessage({\n          id: 'gdxfor.turnedFaceDown',\n          default: 'turned face down',\n          description: 'the sensor was turned to face down'\n        }),\n        value: GestureValues.TURNED_FACE_DOWN\n      }];\n    }\n    /**\n     * Construct a set of GDX-FOR blocks.\n     * @param {Runtime} runtime - the Scratch 3.0 runtime.\n     */\n  }], [{\n    key: \"EXTENSION_NAME\",\n    /**\n     * @return {string} - the name of this extension.\n     */\n    get: function get() {\n      return 'Force and Acceleration';\n    }\n    /**\n     * @return {string} - the ID of this extension.\n     */\n  }, {\n    key: \"EXTENSION_ID\",\n    get: function get() {\n      return 'gdxfor';\n    }\n  }]);\n  function Scratch3GdxForBlocks(runtime) {\n    _classCallCheck(this, Scratch3GdxForBlocks);\n    /**\n     * The Scratch 3.0 runtime.\n     * @type {Runtime}\n     */\n    this.runtime = runtime; // Create a new GdxFor peripheral instance\n    this._peripheral = new GdxFor(this.runtime, Scratch3GdxForBlocks.EXTENSION_ID);\n  }\n  /**\n   * @returns {object} metadata for this extension and its blocks.\n   */\n  _createClass(Scratch3GdxForBlocks, [{\n    key: \"getInfo\",\n    value: function getInfo() {\n      return {\n        id: Scratch3GdxForBlocks.EXTENSION_ID,\n        name: Scratch3GdxForBlocks.EXTENSION_NAME,\n        blockIconURI: blockIconURI,\n        menuIconURI: menuIconURI,\n        showStatusButton: true,\n        blocks: [{\n          opcode: 'whenGesture',\n          text: formatMessage({\n            id: 'gdxfor.whenGesture',\n            default: 'when [GESTURE]',\n            description: 'when the sensor detects a gesture'\n          }),\n          blockType: BlockType.HAT,\n          arguments: {\n            GESTURE: {\n              type: ArgumentType.STRING,\n              menu: 'gestureOptions',\n              defaultValue: GestureValues.SHAKEN\n            }\n          }\n        }, {\n          opcode: 'whenForcePushedOrPulled',\n          text: formatMessage({\n            id: 'gdxfor.whenForcePushedOrPulled',\n            default: 'when force sensor [PUSH_PULL]',\n            description: 'when the force sensor is pushed or pulled'\n          }),\n          blockType: BlockType.HAT,\n          arguments: {\n            PUSH_PULL: {\n              type: ArgumentType.STRING,\n              menu: 'pushPullOptions',\n              defaultValue: PushPullValues.PUSHED\n            }\n          }\n        }, {\n          opcode: 'getForce',\n          text: formatMessage({\n            id: 'gdxfor.getForce',\n            default: 'force',\n            description: 'gets force'\n          }),\n          blockType: BlockType.REPORTER\n        }, '---', {\n          opcode: 'whenTilted',\n          text: formatMessage({\n            id: 'gdxfor.whenTilted',\n            default: 'when tilted [TILT]',\n            description: 'when the sensor detects tilt'\n          }),\n          blockType: BlockType.HAT,\n          arguments: {\n            TILT: {\n              type: ArgumentType.STRING,\n              menu: 'tiltAnyOptions',\n              defaultValue: TiltAxisValues.ANY\n            }\n          }\n        }, {\n          opcode: 'isTilted',\n          text: formatMessage({\n            id: 'gdxfor.isTilted',\n            default: 'tilted [TILT]?',\n            description: 'is the device tilted?'\n          }),\n          blockType: BlockType.BOOLEAN,\n          arguments: {\n            TILT: {\n              type: ArgumentType.STRING,\n              menu: 'tiltAnyOptions',\n              defaultValue: TiltAxisValues.ANY\n            }\n          }\n        }, {\n          opcode: 'getTilt',\n          text: formatMessage({\n            id: 'gdxfor.getTilt',\n            default: 'tilt angle [TILT]',\n            description: 'gets tilt'\n          }),\n          blockType: BlockType.REPORTER,\n          arguments: {\n            TILT: {\n              type: ArgumentType.STRING,\n              menu: 'tiltOptions',\n              defaultValue: TiltAxisValues.FRONT\n            }\n          }\n        }, '---', {\n          opcode: 'isFreeFalling',\n          text: formatMessage({\n            id: 'gdxfor.isFreeFalling',\n            default: 'falling?',\n            description: 'is the device in free fall?'\n          }),\n          blockType: BlockType.BOOLEAN\n        }, {\n          opcode: 'getSpinSpeed',\n          text: formatMessage({\n            id: 'gdxfor.getSpin',\n            default: 'spin speed [DIRECTION]',\n            description: 'gets spin speed'\n          }),\n          blockType: BlockType.REPORTER,\n          arguments: {\n            DIRECTION: {\n              type: ArgumentType.STRING,\n              menu: 'axisOptions',\n              defaultValue: AxisValues.Z\n            }\n          }\n        }, {\n          opcode: 'getAcceleration',\n          text: formatMessage({\n            id: 'gdxfor.getAcceleration',\n            default: 'acceleration [DIRECTION]',\n            description: 'gets acceleration'\n          }),\n          blockType: BlockType.REPORTER,\n          arguments: {\n            DIRECTION: {\n              type: ArgumentType.STRING,\n              menu: 'axisOptions',\n              defaultValue: AxisValues.X\n            }\n          }\n        }],\n        menus: {\n          pushPullOptions: {\n            acceptReporters: true,\n            items: this.PUSH_PULL_MENU\n          },\n          gestureOptions: {\n            acceptReporters: true,\n            items: this.GESTURE_MENU\n          },\n          axisOptions: {\n            acceptReporters: true,\n            items: this.AXIS_MENU\n          },\n          tiltOptions: {\n            acceptReporters: true,\n            items: this.TILT_MENU\n          },\n          tiltAnyOptions: {\n            acceptReporters: true,\n            items: this.TILT_MENU_ANY\n          }\n        }\n      };\n    }\n  }, {\n    key: \"whenForcePushedOrPulled\",\n    value: function whenForcePushedOrPulled(args) {\n      switch (args.PUSH_PULL) {\n        case PushPullValues.PUSHED:\n          return this._peripheral.getForce() < FORCE_THRESHOLD * -1;\n        case PushPullValues.PULLED:\n          return this._peripheral.getForce() > FORCE_THRESHOLD;\n        default:\n          log.warn(\"unknown push/pull value in whenForcePushedOrPulled: \".concat(args.PUSH_PULL));\n          return false;\n      }\n    }\n  }, {\n    key: \"getForce\",\n    value: function getForce() {\n      return Math.round(this._peripheral.getForce());\n    }\n  }, {\n    key: \"whenGesture\",\n    value: function whenGesture(args) {\n      switch (args.GESTURE) {\n        case GestureValues.SHAKEN:\n          return this.gestureMagnitude() > SHAKEN_THRESHOLD;\n        case GestureValues.STARTED_FALLING:\n          return this.isFreeFalling();\n        case GestureValues.TURNED_FACE_UP:\n          return this._isFacing(GestureValues.TURNED_FACE_UP);\n        case GestureValues.TURNED_FACE_DOWN:\n          return this._isFacing(GestureValues.TURNED_FACE_DOWN);\n        default:\n          log.warn(\"unknown gesture value in whenGesture: \".concat(args.GESTURE));\n          return false;\n      }\n    }\n  }, {\n    key: \"_isFacing\",\n    value: function _isFacing(direction) {\n      if (typeof this._facingUp === 'undefined') {\n        this._facingUp = false;\n      }\n      if (typeof this._facingDown === 'undefined') {\n        this._facingDown = false;\n      } // If the sensor is already facing up or down, reduce the threshold.\n      // This prevents small fluctations in acceleration while it is being\n      // turned from causing the hat block to trigger multiple times.\n      var threshold = FACING_THRESHOLD;\n      if (this._facingUp || this._facingDown) {\n        threshold -= FACING_THRESHOLD_OFFSET;\n      }\n      this._facingUp = this._peripheral.getAccelerationZ() > threshold;\n      this._facingDown = this._peripheral.getAccelerationZ() < threshold * -1;\n      switch (direction) {\n        case GestureValues.TURNED_FACE_UP:\n          return this._facingUp;\n        case GestureValues.TURNED_FACE_DOWN:\n          return this._facingDown;\n        default:\n          return false;\n      }\n    }\n  }, {\n    key: \"whenTilted\",\n    value: function whenTilted(args) {\n      return this._isTilted(args.TILT);\n    }\n  }, {\n    key: \"isTilted\",\n    value: function isTilted(args) {\n      return this._isTilted(args.TILT);\n    }\n  }, {\n    key: \"getTilt\",\n    value: function getTilt(args) {\n      return this._getTiltAngle(args.TILT);\n    }\n  }, {\n    key: \"_isTilted\",\n    value: function _isTilted(direction) {\n      switch (direction) {\n        case TiltAxisValues.ANY:\n          return this._getTiltAngle(TiltAxisValues.FRONT) > TILT_THRESHOLD || this._getTiltAngle(TiltAxisValues.BACK) > TILT_THRESHOLD || this._getTiltAngle(TiltAxisValues.LEFT) > TILT_THRESHOLD || this._getTiltAngle(TiltAxisValues.RIGHT) > TILT_THRESHOLD;\n        default:\n          return this._getTiltAngle(direction) > TILT_THRESHOLD;\n      }\n    }\n  }, {\n    key: \"_getTiltAngle\",\n    value: function _getTiltAngle(direction) {\n      // Tilt values are calculated using acceleration due to gravity,\n      // so we need to return 0 when the peripheral is not connected.\n      if (!this._peripheral.isConnected()) {\n        return 0;\n      }\n      switch (direction) {\n        case TiltAxisValues.FRONT:\n          return Math.round(this._peripheral.getTiltFrontBack(true));\n        case TiltAxisValues.BACK:\n          return Math.round(this._peripheral.getTiltFrontBack(false));\n        case TiltAxisValues.LEFT:\n          return Math.round(this._peripheral.getTiltLeftRight(true));\n        case TiltAxisValues.RIGHT:\n          return Math.round(this._peripheral.getTiltLeftRight(false));\n        default:\n          log.warn(\"Unknown direction in getTilt: \".concat(direction));\n      }\n    }\n  }, {\n    key: \"getSpinSpeed\",\n    value: function getSpinSpeed(args) {\n      switch (args.DIRECTION) {\n        case AxisValues.X:\n          return Math.round(this._peripheral.getSpinSpeedX());\n        case AxisValues.Y:\n          return Math.round(this._peripheral.getSpinSpeedY());\n        case AxisValues.Z:\n          return Math.round(this._peripheral.getSpinSpeedZ());\n        default:\n          log.warn(\"Unknown direction in getSpinSpeed: \".concat(args.DIRECTION));\n      }\n    }\n  }, {\n    key: \"getAcceleration\",\n    value: function getAcceleration(args) {\n      switch (args.DIRECTION) {\n        case AxisValues.X:\n          return Math.round(this._peripheral.getAccelerationX());\n        case AxisValues.Y:\n          return Math.round(this._peripheral.getAccelerationY());\n        case AxisValues.Z:\n          return Math.round(this._peripheral.getAccelerationZ());\n        default:\n          log.warn(\"Unknown direction in getAcceleration: \".concat(args.DIRECTION));\n      }\n    }\n    /**\n     * @param {number} x - x axis vector\n     * @param {number} y - y axis vector\n     * @param {number} z - z axis vector\n     * @return {number} - the magnitude of a three dimension vector.\n     */\n  }, {\n    key: \"magnitude\",\n    value: function magnitude(x, y, z) {\n      return Math.sqrt(x * x + y * y + z * z);\n    }\n  }, {\n    key: \"accelMagnitude\",\n    value: function accelMagnitude() {\n      return this.magnitude(this._peripheral.getAccelerationX(), this._peripheral.getAccelerationY(), this._peripheral.getAccelerationZ());\n    }\n  }, {\n    key: \"gestureMagnitude\",\n    value: function gestureMagnitude() {\n      return this.accelMagnitude() - GRAVITY;\n    }\n  }, {\n    key: \"spinMagnitude\",\n    value: function spinMagnitude() {\n      return this.magnitude(this._peripheral.getSpinSpeedX(), this._peripheral.getSpinSpeedY(), this._peripheral.getSpinSpeedZ());\n    }\n  }, {\n    key: \"isFreeFalling\",\n    value: function isFreeFalling() {\n      // When the peripheral is not connected, the acceleration magnitude\n      // is 0 instead of ~9.8, which ends up calculating as a positive\n      // free fall; so we need to return 'false' here to prevent returning 'true'.\n      if (!this._peripheral.isConnected()) {\n        return false;\n      }\n      var accelMag = this.accelMagnitude();\n      var spinMag = this.spinMagnitude(); // We want to account for rotation during freefall,\n      // so we tack on a an estimated \"rotational effect\"\n      // The FREEFALL_ROTATION_FACTOR const is used to both scale the\n      // gyro measurements and convert them to radians/second.\n      // So, we compare our accel magnitude against:\n      // FREEFALL_THRESHOLD + (some_scaled_magnitude_of_rotation).\n      var ffThresh = FREEFALL_THRESHOLD + FREEFALL_ROTATION_FACTOR * spinMag;\n      return accelMag < ffThresh;\n    }\n  }]);\n  return Scratch3GdxForBlocks;\n}();\nmodule.exports = Scratch3GdxForBlocks;\n })