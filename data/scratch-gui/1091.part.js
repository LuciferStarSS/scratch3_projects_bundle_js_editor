/* 1091 */\n (function(module, exports, __webpack_require__) {\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nvar Cast = __webpack_require__(48);\nvar Timer = __webpack_require__(136);\nvar getMonitorIdForBlockWithArgs = __webpack_require__(296);\nvar Scratch3SensingBlocks = function () {\n  function Scratch3SensingBlocks(runtime) {\n    _classCallCheck(this, Scratch3SensingBlocks);\n    /**\n     * The runtime instantiating this block package.\n     * @type {Runtime}\n     */\n    this.runtime = runtime;\n    /**\n     * The \"answer\" block value.\n     * @type {string}\n     */\n    this._answer = '';\n    /**\n     * The timer utility.\n     * @type {Timer}\n     */\n    this._timer = new Timer();\n    /**\n     * The stored microphone loudness measurement.\n     * @type {number}\n     */\n    this._cachedLoudness = -1;\n    /**\n     * The time of the most recent microphone loudness measurement.\n     * @type {number}\n     */\n    this._cachedLoudnessTimestamp = 0;\n    /**\n     * The list of queued questions and respective `resolve` callbacks.\n     * @type {!Array}\n     */\n    this._questionList = [];\n    this.runtime.on('ANSWER', this._onAnswer.bind(this));\n    this.runtime.on('PROJECT_START', this._resetAnswer.bind(this));\n    this.runtime.on('PROJECT_STOP_ALL', this._clearAllQuestions.bind(this));\n    this.runtime.on('STOP_FOR_TARGET', this._clearTargetQuestions.bind(this));\n    this.runtime.on('RUNTIME_DISPOSED', this._resetAnswer.bind(this));\n  }\n  /**\n   * Retrieve the block primitives implemented by this package.\n   * @return {object.<string, Function>} Mapping of opcode to Function.\n   */\n  _createClass(Scratch3SensingBlocks, [{\n    key: \"getPrimitives\",\n    value: function getPrimitives() {\n      return {\n        sensing_touchingobject: this.touchingObject,\n        sensing_touchingcolor: this.touchingColor,\n        sensing_coloristouchingcolor: this.colorTouchingColor,\n        sensing_distanceto: this.distanceTo,\n        sensing_timer: this.getTimer,\n        sensing_resettimer: this.resetTimer,\n        sensing_of: this.getAttributeOf,\n        sensing_mousex: this.getMouseX,\n        sensing_mousey: this.getMouseY,\n        sensing_setdragmode: this.setDragMode,\n        sensing_mousedown: this.getMouseDown,\n        sensing_keypressed: this.getKeyPressed,\n        sensing_current: this.current,\n        sensing_dayssince2000: this.daysSince2000,\n        sensing_loudness: this.getLoudness,\n        sensing_loud: this.isLoud,\n        sensing_askandwait: this.askAndWait,\n        sensing_answer: this.getAnswer,\n        sensing_username: this.getUsername,\n        sensing_userid: function sensing_userid() {} // legacy no-op block\n      };\n    }\n  }, {\n    key: \"getMonitored\",\n    value: function getMonitored() {\n      return {\n        sensing_answer: {\n          getId: function getId() {\n            return 'answer';\n          }\n        },\n        sensing_loudness: {\n          getId: function getId() {\n            return 'loudness';\n          }\n        },\n        sensing_timer: {\n          getId: function getId() {\n            return 'timer';\n          }\n        },\n        sensing_current: {\n          // This is different from the default toolbox xml id in order to support\n          // importing multiple monitors from the same opcode from sb2 files,\n          // something that is not currently supported in scratch 3.\n          getId: function getId(_, fields) {\n            return getMonitorIdForBlockWithArgs('current', fields);\n          } // _${param}`\n        }\n      };\n    }\n  }, {\n    key: \"_onAnswer\",\n    value: function _onAnswer(answer) {\n      this._answer = answer;\n      var questionObj = this._questionList.shift();\n      if (questionObj) {\n        var _questionObj = _slicedToArray(questionObj, 5),\n            _question = _questionObj[0],\n            resolve = _questionObj[1],\n            target = _questionObj[2],\n            wasVisible = _questionObj[3],\n            wasStage = _questionObj[4]; // If the target was visible when asked, hide the say bubble unless the target was the stage.\n        if (wasVisible && !wasStage) {\n          this.runtime.emit('SAY', target, 'say', '');\n        }\n        resolve();\n        this._askNextQuestion();\n      }\n    }\n  }, {\n    key: \"_resetAnswer\",\n    value: function _resetAnswer() {\n      this._answer = '';\n    }\n  }, {\n    key: \"_enqueueAsk\",\n    value: function _enqueueAsk(question, resolve, target, wasVisible, wasStage) {\n      this._questionList.push([question, resolve, target, wasVisible, wasStage]);\n    }\n  }, {\n    key: \"_askNextQuestion\",\n    value: function _askNextQuestion() {\n      if (this._questionList.length > 0) {\n        var _this$_questionList$ = _slicedToArray(this._questionList[0], 5),\n            question = _this$_questionList$[0],\n            _resolve = _this$_questionList$[1],\n            target = _this$_questionList$[2],\n            wasVisible = _this$_questionList$[3],\n            wasStage = _this$_questionList$[4]; // If the target is visible, emit a blank question and use the\n        // say event to trigger a bubble unless the target was the stage.\n        if (wasVisible && !wasStage) {\n          this.runtime.emit('SAY', target, 'say', question);\n          this.runtime.emit('QUESTION', '');\n        } else {\n          this.runtime.emit('QUESTION', question);\n        }\n      }\n    }\n  }, {\n    key: \"_clearAllQuestions\",\n    value: function _clearAllQuestions() {\n      this._questionList = [];\n      this.runtime.emit('QUESTION', null);\n    }\n  }, {\n    key: \"_clearTargetQuestions\",\n    value: function _clearTargetQuestions(stopTarget) {\n      var currentlyAsking = this._questionList.length > 0 && this._questionList[0][2] === stopTarget;\n      this._questionList = this._questionList.filter(function (question) {\n        return question[2] !== stopTarget;\n      });\n      if (currentlyAsking) {\n        this.runtime.emit('SAY', stopTarget, 'say', '');\n        if (this._questionList.length > 0) {\n          this._askNextQuestion();\n        } else {\n          this.runtime.emit('QUESTION', null);\n        }\n      }\n    }\n  }, {\n    key: \"askAndWait\",\n    value: function askAndWait(args, util) {\n      var _this = this;\n      var _target = util.target;\n      return new Promise(function (resolve) {\n        var isQuestionAsked = _this._questionList.length > 0;\n        _this._enqueueAsk(String(args.QUESTION), resolve, _target, _target.visible, _target.isStage);\n        if (!isQuestionAsked) {\n          _this._askNextQuestion();\n        }\n      });\n    }\n  }, {\n    key: \"getAnswer\",\n    value: function getAnswer() {\n      return this._answer;\n    }\n  }, {\n    key: \"touchingObject\",\n    value: function touchingObject(args, util) {\n      return util.target.isTouchingObject(args.TOUCHINGOBJECTMENU);\n    }\n  }, {\n    key: \"touchingColor\",\n    value: function touchingColor(args, util) {\n      var color = Cast.toRgbColorList(args.COLOR);\n      return util.target.isTouchingColor(color);\n    }\n  }, {\n    key: \"colorTouchingColor\",\n    value: function colorTouchingColor(args, util) {\n      var maskColor = Cast.toRgbColorList(args.COLOR);\n      var targetColor = Cast.toRgbColorList(args.COLOR2);\n      return util.target.colorIsTouchingColor(targetColor, maskColor);\n    }\n  }, {\n    key: \"distanceTo\",\n    value: function distanceTo(args, util) {\n      if (util.target.isStage) return 10000;\n      var targetX = 0;\n      var targetY = 0;\n      if (args.DISTANCETOMENU === '_mouse_') {\n        targetX = util.ioQuery('mouse', 'getScratchX');\n        targetY = util.ioQuery('mouse', 'getScratchY');\n      } else {\n        args.DISTANCETOMENU = Cast.toString(args.DISTANCETOMENU);\n        var distTarget = this.runtime.getSpriteTargetByName(args.DISTANCETOMENU);\n        if (!distTarget) return 10000;\n        targetX = distTarget.x;\n        targetY = distTarget.y;\n      }\n      var dx = util.target.x - targetX;\n      var dy = util.target.y - targetY;\n      return Math.sqrt(dx * dx + dy * dy);\n    }\n  }, {\n    key: \"setDragMode\",\n    value: function setDragMode(args, util) {\n      util.target.setDraggable(args.DRAG_MODE === 'draggable');\n    }\n  }, {\n    key: \"getTimer\",\n    value: function getTimer(args, util) {\n      return util.ioQuery('clock', 'projectTimer');\n    }\n  }, {\n    key: \"resetTimer\",\n    value: function resetTimer(args, util) {\n      util.ioQuery('clock', 'resetProjectTimer');\n    }\n  }, {\n    key: \"getMouseX\",\n    value: function getMouseX(args, util) {\n      return util.ioQuery('mouse', 'getScratchX');\n    }\n  }, {\n    key: \"getMouseY\",\n    value: function getMouseY(args, util) {\n      return util.ioQuery('mouse', 'getScratchY');\n    }\n  }, {\n    key: \"getMouseDown\",\n    value: function getMouseDown(args, util) {\n      return util.ioQuery('mouse', 'getIsDown');\n    }\n  }, {\n    key: \"current\",\n    value: function current(args) {\n      var menuOption = Cast.toString(args.CURRENTMENU).toLowerCase();\n      var date = new Date();\n      switch (menuOption) {\n        case 'year':\n          return date.getFullYear();\n        case 'month':\n          return date.getMonth() + 1;\n        // getMonth is zero-based\n        case 'date':\n          return date.getDate();\n        case 'dayofweek':\n          return date.getDay() + 1;\n        // getDay is zero-based, Sun=0\n        case 'hour':\n          return date.getHours();\n        case 'minute':\n          return date.getMinutes();\n        case 'second':\n          return date.getSeconds();\n      }\n      return 0;\n    }\n  }, {\n    key: \"getKeyPressed\",\n    value: function getKeyPressed(args, util) {\n      return util.ioQuery('keyboard', 'getKeyIsDown', [args.KEY_OPTION]);\n    }\n  }, {\n    key: \"daysSince2000\",\n    value: function daysSince2000() {\n      var msPerDay = 24 * 60 * 60 * 1000;\n      var start = new Date(2000, 0, 1); // Months are 0-indexed.\n      var today = new Date();\n      var dstAdjust = today.getTimezoneOffset() - start.getTimezoneOffset();\n      var mSecsSinceStart = today.valueOf() - start.valueOf();\n      mSecsSinceStart += (today.getTimezoneOffset() - dstAdjust) * 60 * 1000;\n      return mSecsSinceStart / msPerDay;\n    }\n  }, {\n    key: \"getLoudness\",\n    value: function getLoudness() {\n      if (typeof this.runtime.audioEngine === 'undefined') return -1;\n      if (this.runtime.currentStepTime === null) return -1; // Only measure loudness once per step\n      var timeSinceLoudness = this._timer.time() - this._cachedLoudnessTimestamp;\n      if (timeSinceLoudness < this.runtime.currentStepTime) {\n        return this._cachedLoudness;\n      }\n      this._cachedLoudnessTimestamp = this._timer.time();\n      this._cachedLoudness = this.runtime.audioEngine.getLoudness();\n      return this._cachedLoudness;\n    }\n  }, {\n    key: \"isLoud\",\n    value: function isLoud() {\n      return this.getLoudness() > 10;\n    }\n  }, {\n    key: \"getAttributeOf\",\n    value: function getAttributeOf(args) {\n      var attrTarget;\n      if (args.OBJECT === '_stage_') {\n        attrTarget = this.runtime.getTargetForStage();\n      } else {\n        args.OBJECT = Cast.toString(args.OBJECT);\n        attrTarget = this.runtime.getSpriteTargetByName(args.OBJECT);\n      } // attrTarget can be undefined if the target does not exist\n      // (e.g. single sprite uploaded from larger project referencing\n      // another sprite that wasn't uploaded)\n      if (!attrTarget) return 0; // Generic attributes\n      if (attrTarget.isStage) {\n        switch (args.PROPERTY) {\n          // Scratch 1.4 support\n          case 'background #':\n            return attrTarget.currentCostume + 1;\n          case 'backdrop #':\n            return attrTarget.currentCostume + 1;\n          case 'backdrop name':\n            return attrTarget.getCostumes()[attrTarget.currentCostume].name;\n          case 'volume':\n            return attrTarget.volume;\n        }\n      } else {\n        switch (args.PROPERTY) {\n          case 'x position':\n            return attrTarget.x;\n          case 'y position':\n            return attrTarget.y;\n          case 'direction':\n            return attrTarget.direction;\n          case 'costume #':\n            return attrTarget.currentCostume + 1;\n          case 'costume name':\n            return attrTarget.getCostumes()[attrTarget.currentCostume].name;\n          case 'size':\n            return attrTarget.size;\n          case 'volume':\n            return attrTarget.volume;\n        }\n      } // Target variables.\n      var varName = args.PROPERTY;\n      var variable = attrTarget.lookupVariableByNameAndType(varName, '', true);\n      if (variable) {\n        return variable.value;\n      } // Otherwise, 0\n      return 0;\n    }\n  }, {\n    key: \"getUsername\",\n    value: function getUsername(args, util) {\n      return util.ioQuery('userData', 'getUsername');\n    }\n  }]);\n  return Scratch3SensingBlocks;\n}();\nmodule.exports = Scratch3SensingBlocks;\n })