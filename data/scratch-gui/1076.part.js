/* 1076 */\n (function(module, exports, __webpack_require__) {\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nvar Thread = __webpack_require__(224);\nvar Timer = __webpack_require__(136);\n/**\n * @fileoverview\n * Interface provided to block primitive functions for interacting with the\n * runtime, thread, target, and convenient methods.\n */\nvar BlockUtility = function () {\n  function BlockUtility() {\n    var _this = this;\n    var sequencer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var thread = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    _classCallCheck(this, BlockUtility);\n    /**\n     * A sequencer block primitives use to branch or start procedures with\n     * @type {?Sequencer}\n     */\n    this.sequencer = sequencer;\n    /**\n     * The block primitives thread with the block's target, stackFrame and\n     * modifiable status.\n     * @type {?Thread}\n     */\n    this.thread = thread;\n    this._nowObj = {\n      now: function now() {\n        return _this.sequencer.runtime.currentMSecs;\n      }\n    };\n  }\n  /**\n   * The target the primitive is working on.\n   * @type {Target}\n   */\n  _createClass(BlockUtility, [{\n    key: \"stackTimerFinished\",\n    /**\n     * Check the stack timer and return a boolean based on whether it has finished or not.\n     * @return {boolean} - true if the stack timer has finished.\n     */\n    value: function stackTimerFinished() {\n      var timeElapsed = this.stackFrame.timer.timeElapsed();\n      if (timeElapsed < this.stackFrame.duration) {\n        return false;\n      }\n      return true;\n    }\n    /**\n     * Check if the stack timer needs initialization.\n     * @return {boolean} - true if the stack timer needs to be initialized.\n     */\n  }, {\n    key: \"stackTimerNeedsInit\",\n    value: function stackTimerNeedsInit() {\n      return !this.stackFrame.timer;\n    }\n    /**\n     * Create and start a stack timer\n     * @param {number} duration - a duration in milliseconds to set the timer for.\n     */\n  }, {\n    key: \"startStackTimer\",\n    value: function startStackTimer(duration) {\n      if (this.nowObj) {\n        this.stackFrame.timer = new Timer(this.nowObj);\n      } else {\n        this.stackFrame.timer = new Timer();\n      }\n      this.stackFrame.timer.start();\n      this.stackFrame.duration = duration;\n    }\n    /**\n     * Set the thread to yield.\n     */\n  }, {\n    key: \"yield\",\n    value: function _yield() {\n      this.thread.status = Thread.STATUS_YIELD;\n    }\n    /**\n     * Set the thread to yield until the next tick of the runtime.\n     */\n  }, {\n    key: \"yieldTick\",\n    value: function yieldTick() {\n      this.thread.status = Thread.STATUS_YIELD_TICK;\n    }\n    /**\n     * Start a branch in the current block.\n     * @param {number} branchNum Which branch to step to (i.e., 1, 2).\n     * @param {boolean} isLoop Whether this block is a loop.\n     */\n  }, {\n    key: \"startBranch\",\n    value: function startBranch(branchNum, isLoop) {\n      this.sequencer.stepToBranch(this.thread, branchNum, isLoop);\n    }\n    /**\n     * Stop all threads.\n     */\n  }, {\n    key: \"stopAll\",\n    value: function stopAll() {\n      this.sequencer.runtime.stopAll();\n    }\n    /**\n     * Stop threads other on this target other than the thread holding the\n     * executed block.\n     */\n  }, {\n    key: \"stopOtherTargetThreads\",\n    value: function stopOtherTargetThreads() {\n      this.sequencer.runtime.stopForTarget(this.thread.target, this.thread);\n    }\n    /**\n     * Stop this thread.\n     */\n  }, {\n    key: \"stopThisScript\",\n    value: function stopThisScript() {\n      this.thread.stopThisScript();\n    }\n    /**\n     * Start a specified procedure on this thread.\n     * @param {string} procedureCode Procedure code for procedure to start.\n     */\n  }, {\n    key: \"startProcedure\",\n    value: function startProcedure(procedureCode) {\n      this.sequencer.stepToProcedure(this.thread, procedureCode);\n    }\n    /**\n     * Get names and ids of parameters for the given procedure.\n     * @param {string} procedureCode Procedure code for procedure to query.\n     * @return {Array.<string>} List of param names for a procedure.\n     */\n  }, {\n    key: \"getProcedureParamNamesAndIds\",\n    value: function getProcedureParamNamesAndIds(procedureCode) {\n      return this.thread.target.blocks.getProcedureParamNamesAndIds(procedureCode);\n    }\n    /**\n     * Get names, ids, and defaults of parameters for the given procedure.\n     * @param {string} procedureCode Procedure code for procedure to query.\n     * @return {Array.<string>} List of param names for a procedure.\n     */\n  }, {\n    key: \"getProcedureParamNamesIdsAndDefaults\",\n    value: function getProcedureParamNamesIdsAndDefaults(procedureCode) {\n      return this.thread.target.blocks.getProcedureParamNamesIdsAndDefaults(procedureCode);\n    }\n    /**\n     * Initialize procedure parameters in the thread before pushing parameters.\n     */\n  }, {\n    key: \"initParams\",\n    value: function initParams() {\n      this.thread.initParams();\n    }\n    /**\n     * Store a procedure parameter value by its name.\n     * @param {string} paramName The procedure's parameter name.\n     * @param {*} paramValue The procedure's parameter value.\n     */\n  }, {\n    key: \"pushParam\",\n    value: function pushParam(paramName, paramValue) {\n      this.thread.pushParam(paramName, paramValue);\n    }\n    /**\n     * Retrieve the stored parameter value for a given parameter name.\n     * @param {string} paramName The procedure's parameter name.\n     * @return {*} The parameter's current stored value.\n     */\n  }, {\n    key: \"getParam\",\n    value: function getParam(paramName) {\n      return this.thread.getParam(paramName);\n    }\n    /**\n     * Start all relevant hats.\n     * @param {!string} requestedHat Opcode of hats to start.\n     * @param {object=} optMatchFields Optionally, fields to match on the hat.\n     * @param {Target=} optTarget Optionally, a target to restrict to.\n     * @return {Array.<Thread>} List of threads started by this function.\n     */\n  }, {\n    key: \"startHats\",\n    value: function startHats(requestedHat, optMatchFields, optTarget) {\n      // Store thread and sequencer to ensure we can return to the calling block's context.\n      // startHats may execute further blocks and dirty the BlockUtility's execution context\n      // and confuse the calling block when we return to it.\n      var callerThread = this.thread;\n      var callerSequencer = this.sequencer;\n      var result = this.sequencer.runtime.startHats(requestedHat, optMatchFields, optTarget); // Restore thread and sequencer to prior values before we return to the calling block.\n      this.thread = callerThread;\n      this.sequencer = callerSequencer;\n      return result;\n    }\n    /**\n     * Query a named IO device.\n     * @param {string} device The name of like the device, like keyboard.\n     * @param {string} func The name of the device's function to query.\n     * @param {Array.<*>} args Arguments to pass to the device's function.\n     * @return {*} The expected output for the device's function.\n     */\n  }, {\n    key: \"ioQuery\",\n    value: function ioQuery(device, func, args) {\n      // Find the I/O device and execute the query/function call.\n      if (this.sequencer.runtime.ioDevices[device] && this.sequencer.runtime.ioDevices[device][func]) {\n        var devObject = this.sequencer.runtime.ioDevices[device];\n        return devObject[func].apply(devObject, args);\n      }\n    }\n  }, {\n    key: \"target\",\n    get: function get() {\n      return this.thread.target;\n    }\n    /**\n     * The runtime the block primitive is running in.\n     * @type {Runtime}\n     */\n  }, {\n    key: \"runtime\",\n    get: function get() {\n      return this.sequencer.runtime;\n    }\n    /**\n     * Use the runtime's currentMSecs value as a timestamp value for now\n     * This is useful in some cases where we need compatibility with Scratch 2\n     * @type {function}\n     */\n  }, {\n    key: \"nowObj\",\n    get: function get() {\n      if (this.runtime) {\n        return this._nowObj;\n      }\n      return null;\n    }\n    /**\n     * The stack frame used by loop and other blocks to track internal state.\n     * @type {object}\n     */\n  }, {\n    key: \"stackFrame\",\n    get: function get() {\n      var frame = this.thread.peekStackFrame();\n      if (frame.executionContext === null) {\n        frame.executionContext = {};\n      }\n      return frame.executionContext;\n    }\n  }]);\n  return BlockUtility;\n}();\nmodule.exports = BlockUtility;\n })