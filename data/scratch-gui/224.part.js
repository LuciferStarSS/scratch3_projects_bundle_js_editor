/* 224 */\n (function(module, exports) {\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n/**\n * Recycle bin for empty stackFrame objects\n * @type Array<_StackFrame>\n */\nvar _stackFrameFreeList = [];\n/**\n * A frame used for each level of the stack. A general purpose\n * place to store a bunch of execution context and parameters\n * @param {boolean} warpMode Whether this level of the stack is warping\n * @constructor\n * @private\n */\nvar _StackFrame = function () {\n  function _StackFrame(warpMode) {\n    _classCallCheck(this, _StackFrame);\n    /**\n     * Whether this level of the stack is a loop.\n     * @type {boolean}\n     */\n    this.isLoop = false;\n    /**\n     * Whether this level is in warp mode.  Is set by some legacy blocks and\n     * \"turbo mode\"\n     * @type {boolean}\n     */\n    this.warpMode = warpMode;\n    /**\n     * Reported value from just executed block.\n     * @type {Any}\n     */\n    this.justReported = null;\n    /**\n     * The active block that is waiting on a promise.\n     * @type {string}\n     */\n    this.reporting = '';\n    /**\n     * Persists reported inputs during async block.\n     * @type {Object}\n     */\n    this.reported = null;\n    /**\n     * Name of waiting reporter.\n     * @type {string}\n     */\n    this.waitingReporter = null;\n    /**\n     * Procedure parameters.\n     * @type {Object}\n     */\n    this.params = null;\n    /**\n     * A context passed to block implementations.\n     * @type {Object}\n     */\n    this.executionContext = null;\n  }\n  /**\n   * Reset all properties of the frame to pristine null and false states.\n   * Used to recycle.\n   * @return {_StackFrame} this\n   */\n  _createClass(_StackFrame, [{\n    key: \"reset\",\n    value: function reset() {\n      this.isLoop = false;\n      this.warpMode = false;\n      this.justReported = null;\n      this.reported = null;\n      this.waitingReporter = null;\n      this.params = null;\n      this.executionContext = null;\n      return this;\n    }\n    /**\n     * Reuse an active stack frame in the stack.\n     * @param {?boolean} warpMode defaults to current warpMode\n     * @returns {_StackFrame} this\n     */\n  }, {\n    key: \"reuse\",\n    value: function reuse() {\n      var warpMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.warpMode;\n      this.reset();\n      this.warpMode = Boolean(warpMode);\n      return this;\n    }\n    /**\n     * Create or recycle a stack frame object.\n     * @param {boolean} warpMode Enable warpMode on this frame.\n     * @returns {_StackFrame} The clean stack frame with correct warpMode setting.\n     */\n  }], [{\n    key: \"create\",\n    value: function create(warpMode) {\n      var stackFrame = _stackFrameFreeList.pop();\n      if (typeof stackFrame !== 'undefined') {\n        stackFrame.warpMode = Boolean(warpMode);\n        return stackFrame;\n      }\n      return new _StackFrame(warpMode);\n    }\n    /**\n     * Put a stack frame object into the recycle bin for reuse.\n     * @param {_StackFrame} stackFrame The frame to reset and recycle.\n     */\n  }, {\n    key: \"release\",\n    value: function release(stackFrame) {\n      if (typeof stackFrame !== 'undefined') {\n        _stackFrameFreeList.push(stackFrame.reset());\n      }\n    }\n  }]);\n  return _StackFrame;\n}();\n/**\n * A thread is a running stack context and all the metadata needed.\n * @param {?string} firstBlock First block to execute in the thread.\n * @constructor\n */\nvar Thread = function () {\n  function Thread(firstBlock) {\n    _classCallCheck(this, Thread);\n    /**\n     * ID of top block of the thread\n     * @type {!string}\n     */\n    this.topBlock = firstBlock;\n    /**\n     * Stack for the thread. When the sequencer enters a control structure,\n     * the block is pushed onto the stack so we know where to exit.\n     * @type {Array.<string>}\n     */\n    this.stack = [];\n    /**\n     * Stack frames for the thread. Store metadata for the executing blocks.\n     * @type {Array.<_StackFrame>}\n     */\n    this.stackFrames = [];\n    /**\n     * Status of the thread, one of three states (below)\n     * @type {number}\n     */\n    this.status = 0;\n    /* Thread.STATUS_RUNNING */\n    /**\n     * Whether the thread is killed in the middle of execution.\n     * @type {boolean}\n     */\n    this.isKilled = false;\n    /**\n     * Target of this thread.\n     * @type {?Target}\n     */\n    this.target = null;\n    /**\n     * The Blocks this thread will execute.\n     * @type {Blocks}\n     */\n    this.blockContainer = null;\n    /**\n     * Whether the thread requests its script to glow during this frame.\n     * @type {boolean}\n     */\n    this.requestScriptGlowInFrame = false;\n    /**\n     * Which block ID should glow during this frame, if any.\n     * @type {?string}\n     */\n    this.blockGlowInFrame = null;\n    /**\n     * A timer for when the thread enters warp mode.\n     * Substitutes the sequencer's count toward WORK_TIME on a per-thread basis.\n     * @type {?Timer}\n     */\n    this.warpTimer = null;\n    this.justReported = null;\n  }\n  /**\n   * Thread status for initialized or running thread.\n   * This is the default state for a thread - execution should run normally,\n   * stepping from block to block.\n   * @const\n   */\n  _createClass(Thread, [{\n    key: \"pushStack\",\n    /**\n     * Push stack and update stack frames appropriately.\n     * @param {string} blockId Block ID to push to stack.\n     */\n    value: function pushStack(blockId) {\n      this.stack.push(blockId); // Push an empty stack frame, if we need one.\n      // Might not, if we just popped the stack.\n      if (this.stack.length > this.stackFrames.length) {\n        var parent = this.stackFrames[this.stackFrames.length - 1];\n        this.stackFrames.push(_StackFrame.create(typeof parent !== 'undefined' && parent.warpMode));\n      }\n    }\n    /**\n     * Reset the stack frame for use by the next block.\n     * (avoids popping and re-pushing a new stack frame - keeps the warpmode the same\n     * @param {string} blockId Block ID to push to stack.\n     */\n  }, {\n    key: \"reuseStackForNextBlock\",\n    value: function reuseStackForNextBlock(blockId) {\n      this.stack[this.stack.length - 1] = blockId;\n      this.stackFrames[this.stackFrames.length - 1].reuse();\n    }\n    /**\n     * Pop last block on the stack and its stack frame.\n     * @return {string} Block ID popped from the stack.\n     */\n  }, {\n    key: \"popStack\",\n    value: function popStack() {\n      _StackFrame.release(this.stackFrames.pop());\n      return this.stack.pop();\n    }\n    /**\n     * Pop back down the stack frame until we hit a procedure call or the stack frame is emptied\n     */\n  }, {\n    key: \"stopThisScript\",\n    value: function stopThisScript() {\n      var blockID = this.peekStack();\n      while (blockID !== null) {\n        var block = this.target.blocks.getBlock(blockID);\n        if (typeof block !== 'undefined' && block.opcode === 'procedures_call') {\n          break;\n        }\n        this.popStack();\n        blockID = this.peekStack();\n      }\n      if (this.stack.length === 0) {\n        // Clean up!\n        this.requestScriptGlowInFrame = false;\n        this.status = Thread.STATUS_DONE;\n      }\n    }\n    /**\n     * Get top stack item.\n     * @return {?string} Block ID on top of stack.\n     */\n  }, {\n    key: \"peekStack\",\n    value: function peekStack() {\n      return this.stack.length > 0 ? this.stack[this.stack.length - 1] : null;\n    }\n    /**\n     * Get top stack frame.\n     * @return {?object} Last stack frame stored on this thread.\n     */\n  }, {\n    key: \"peekStackFrame\",\n    value: function peekStackFrame() {\n      return this.stackFrames.length > 0 ? this.stackFrames[this.stackFrames.length - 1] : null;\n    }\n    /**\n     * Get stack frame above the current top.\n     * @return {?object} Second to last stack frame stored on this thread.\n     */\n  }, {\n    key: \"peekParentStackFrame\",\n    value: function peekParentStackFrame() {\n      return this.stackFrames.length > 1 ? this.stackFrames[this.stackFrames.length - 2] : null;\n    }\n    /**\n     * Push a reported value to the parent of the current stack frame.\n     * @param {*} value Reported value to push.\n     */\n  }, {\n    key: \"pushReportedValue\",\n    value: function pushReportedValue(value) {\n      this.justReported = typeof value === 'undefined' ? null : value;\n    }\n    /**\n     * Initialize procedure parameters on this stack frame.\n     */\n  }, {\n    key: \"initParams\",\n    value: function initParams() {\n      var stackFrame = this.peekStackFrame();\n      if (stackFrame.params === null) {\n        stackFrame.params = {};\n      }\n    }\n    /**\n     * Add a parameter to the stack frame.\n     * Use when calling a procedure with parameter values.\n     * @param {!string} paramName Name of parameter.\n     * @param {*} value Value to set for parameter.\n     */\n  }, {\n    key: \"pushParam\",\n    value: function pushParam(paramName, value) {\n      var stackFrame = this.peekStackFrame();\n      stackFrame.params[paramName] = value;\n    }\n    /**\n     * Get a parameter at the lowest possible level of the stack.\n     * @param {!string} paramName Name of parameter.\n     * @return {*} value Value for parameter.\n     */\n  }, {\n    key: \"getParam\",\n    value: function getParam(paramName) {\n      for (var i = this.stackFrames.length - 1; i >= 0; i--) {\n        var frame = this.stackFrames[i];\n        if (frame.params === null) {\n          continue;\n        }\n        if (frame.params.hasOwnProperty(paramName)) {\n          return frame.params[paramName];\n        }\n        return null;\n      }\n      return null;\n    }\n    /**\n     * Whether the current execution of a thread is at the top of the stack.\n     * @return {boolean} True if execution is at top of the stack.\n     */\n  }, {\n    key: \"atStackTop\",\n    value: function atStackTop() {\n      return this.peekStack() === this.topBlock;\n    }\n    /**\n     * Switch the thread to the next block at the current level of the stack.\n     * For example, this is used in a standard sequence of blocks,\n     * where execution proceeds from one block to the next.\n     */\n  }, {\n    key: \"goToNextBlock\",\n    value: function goToNextBlock() {\n      var nextBlockId = this.target.blocks.getNextBlock(this.peekStack());\n      this.reuseStackForNextBlock(nextBlockId);\n    }\n    /**\n     * Attempt to determine whether a procedure call is recursive,\n     * by examining the stack.\n     * @param {!string} procedureCode Procedure code of procedure being called.\n     * @return {boolean} True if the call appears recursive.\n     */\n  }, {\n    key: \"isRecursiveCall\",\n    value: function isRecursiveCall(procedureCode) {\n      var callCount = 5; // Max number of enclosing procedure calls to examine.\n      var sp = this.stack.length - 1;\n      for (var i = sp - 1; i >= 0; i--) {\n        var block = this.target.blocks.getBlock(this.stack[i]);\n        if (block.opcode === 'procedures_call' && block.mutation.proccode === procedureCode) {\n          return true;\n        }\n        if (--callCount < 0) return false;\n      }\n      return false;\n    }\n  }], [{\n    key: \"STATUS_RUNNING\",\n    get: function get() {\n      return 0;\n    }\n    /**\n     * Threads are in this state when a primitive is waiting on a promise;\n     * execution is paused until the promise changes thread status.\n     * @const\n     */\n  }, {\n    key: \"STATUS_PROMISE_WAIT\",\n    get: function get() {\n      return 1;\n    }\n    /**\n     * Thread status for yield.\n     * @const\n     */\n  }, {\n    key: \"STATUS_YIELD\",\n    get: function get() {\n      return 2;\n    }\n    /**\n     * Thread status for a single-tick yield. This will be cleared when the\n     * thread is resumed.\n     * @const\n     */\n  }, {\n    key: \"STATUS_YIELD_TICK\",\n    get: function get() {\n      return 3;\n    }\n    /**\n     * Thread status for a finished/done thread.\n     * Thread is in this state when there are no more blocks to execute.\n     * @const\n     */\n  }, {\n    key: \"STATUS_DONE\",\n    get: function get() {\n      return 4;\n    }\n  }]);\n  return Thread;\n}();\nmodule.exports = Thread;\n })