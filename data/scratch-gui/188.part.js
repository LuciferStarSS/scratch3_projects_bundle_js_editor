/* 188 */\n (function(module, exports, __webpack_require__) {\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nvar twgl = __webpack_require__(103);\nvar ShaderManager = function () {\n  /**\n   * @param {WebGLRenderingContext} gl WebGL rendering context to create shaders for\n   * @constructor\n   */\n  function ShaderManager(gl) {\n    _classCallCheck(this, ShaderManager);\n    this._gl = gl;\n    /**\n     * The cache of all shaders compiled so far, filled on demand.\n     * @type {Object<ShaderManager.DRAW_MODE, Array<ProgramInfo>>}\n     * @private\n     */\n    this._shaderCache = {};\n    for (var modeName in ShaderManager.DRAW_MODE) {\n      if (Object.prototype.hasOwnProperty.call(ShaderManager.DRAW_MODE, modeName)) {\n        this._shaderCache[modeName] = [];\n      }\n    }\n  }\n  /**\n   * Fetch the shader for a particular set of active effects.\n   * Build the shader if necessary.\n   * @param {ShaderManager.DRAW_MODE} drawMode Draw normally, silhouette, etc.\n   * @param {int} effectBits Bitmask representing the enabled effects.\n   * @returns {ProgramInfo} The shader's program info.\n   */\n  _createClass(ShaderManager, [{\n    key: \"getShader\",\n    value: function getShader(drawMode, effectBits) {\n      var cache = this._shaderCache[drawMode];\n      if (drawMode === ShaderManager.DRAW_MODE.silhouette) {\n        // Silhouette mode isn't affected by these effects.\n        effectBits &= ~(ShaderManager.EFFECT_INFO.color.mask | ShaderManager.EFFECT_INFO.brightness.mask);\n      }\n      var shader = cache[effectBits];\n      if (!shader) {\n        shader = cache[effectBits] = this._buildShader(drawMode, effectBits);\n      }\n      return shader;\n    }\n    /**\n     * Build the shader for a particular set of active effects.\n     * @param {ShaderManager.DRAW_MODE} drawMode Draw normally, silhouette, etc.\n     * @param {int} effectBits Bitmask representing the enabled effects.\n     * @returns {ProgramInfo} The new shader's program info.\n     * @private\n     */\n  }, {\n    key: \"_buildShader\",\n    value: function _buildShader(drawMode, effectBits) {\n      var numEffects = ShaderManager.EFFECTS.length;\n      var defines = [\"#define DRAW_MODE_\".concat(drawMode)];\n      for (var index = 0; index < numEffects; ++index) {\n        if ((effectBits & 1 << index) !== 0) {\n          defines.push(\"#define ENABLE_\".concat(ShaderManager.EFFECTS[index]));\n        }\n      }\n      var definesText = \"\".concat(defines.join('\\n'), \"\\n\");\n      /* eslint-disable global-require */\n      var vsFullText = definesText + __webpack_require__(1248);\n      var fsFullText = definesText + __webpack_require__(1249);\n      /* eslint-enable global-require */\n      return twgl.createProgramInfo(this._gl, [vsFullText, fsFullText]);\n    }\n  }]);\n  return ShaderManager;\n}();\n/**\n * @typedef {object} ShaderManager.Effect\n * @prop {int} mask - The bit in 'effectBits' representing the effect.\n * @prop {function} converter - A conversion function which takes a Scratch value (generally in the range\n *   0..100 or -100..100) and maps it to a value useful to the shader. This\n *   mapping may not be reversible.\n * @prop {boolean} shapeChanges - Whether the effect could change the drawn shape.\n */\n/**\n * Mapping of each effect name to info about that effect.\n * @enum {ShaderManager.Effect}\n */\nShaderManager.EFFECT_INFO = {\n  /** Color effect */\n  color: {\n    uniformName: 'u_color',\n    mask: 1 << 0,\n    converter: function converter(x) {\n      return x / 200 % 1;\n    },\n    shapeChanges: false\n  },\n  /** Fisheye effect */\n  fisheye: {\n    uniformName: 'u_fisheye',\n    mask: 1 << 1,\n    converter: function converter(x) {\n      return Math.max(0, (x + 100) / 100);\n    },\n    shapeChanges: true\n  },\n  /** Whirl effect */\n  whirl: {\n    uniformName: 'u_whirl',\n    mask: 1 << 2,\n    converter: function converter(x) {\n      return -x * Math.PI / 180;\n    },\n    shapeChanges: true\n  },\n  /** Pixelate effect */\n  pixelate: {\n    uniformName: 'u_pixelate',\n    mask: 1 << 3,\n    converter: function converter(x) {\n      return Math.abs(x) / 10;\n    },\n    shapeChanges: true\n  },\n  /** Mosaic effect */\n  mosaic: {\n    uniformName: 'u_mosaic',\n    mask: 1 << 4,\n    converter: function converter(x) {\n      x = Math.round((Math.abs(x) + 10) / 10);\n      /** @todo cap by Math.min(srcWidth, srcHeight) */\n      return Math.max(1, Math.min(x, 512));\n    },\n    shapeChanges: true\n  },\n  /** Brightness effect */\n  brightness: {\n    uniformName: 'u_brightness',\n    mask: 1 << 5,\n    converter: function converter(x) {\n      return Math.max(-100, Math.min(x, 100)) / 100;\n    },\n    shapeChanges: false\n  },\n  /** Ghost effect */\n  ghost: {\n    uniformName: 'u_ghost',\n    mask: 1 << 6,\n    converter: function converter(x) {\n      return 1 - Math.max(0, Math.min(x, 100)) / 100;\n    },\n    shapeChanges: false\n  }\n};\n/**\n * The name of each supported effect.\n * @type {Array}\n */\nShaderManager.EFFECTS = Object.keys(ShaderManager.EFFECT_INFO);\n/**\n * The available draw modes.\n * @readonly\n * @enum {string}\n */\nShaderManager.DRAW_MODE = {\n  /**\n   * Draw normally. Its output will use premultiplied alpha.\n   */\n  default: 'default',\n  /**\n   * Draw with non-premultiplied alpha. Useful for reading pixels from GL into an ImageData object.\n   */\n  straightAlpha: 'straightAlpha',\n  /**\n   * Draw a silhouette using a solid color.\n   */\n  silhouette: 'silhouette',\n  /**\n   * Draw only the parts of the drawable which match a particular color.\n   */\n  colorMask: 'colorMask',\n  /**\n   * Draw a line with caps.\n   */\n  line: 'line',\n  /**\n   * Draw the background in a certain color. Must sometimes be used instead of gl.clear.\n   */\n  background: 'background'\n};\nmodule.exports = ShaderManager;\n })