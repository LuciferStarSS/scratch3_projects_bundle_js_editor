/* 958 */\n (function(module, exports, __webpack_require__) {\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nvar ArgumentType = __webpack_require__(63);\nvar BlockType = __webpack_require__(45);\nvar TargetType = __webpack_require__(432);\nvar Cast = __webpack_require__(48);\nvar Clone = __webpack_require__(113);\nvar Color = __webpack_require__(180);\nvar formatMessage = __webpack_require__(71);\nvar MathUtil = __webpack_require__(62);\nvar RenderedTarget = __webpack_require__(219);\nvar log = __webpack_require__(39);\nvar StageLayering = __webpack_require__(115);\n/**\n * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.\n * @type {string}\n */\n// eslint-disable-next-line max-len\nvar blockIconURI = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHZpZXdCb3g9IjAgMCA0MCA0MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48dGl0bGU+cGVuLWljb248L3RpdGxlPjxnIHN0cm9rZT0iIzU3NUU3NSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiPjxwYXRoIGQ9Ik04Ljc1MyAzNC42MDJsLTQuMjUgMS43OCAxLjc4My00LjIzN2MxLjIxOC0yLjg5MiAyLjkwNy01LjQyMyA1LjAzLTcuNTM4TDMxLjA2NiA0LjkzYy44NDYtLjg0MiAyLjY1LS40MSA0LjAzMi45NjcgMS4zOCAxLjM3NSAxLjgxNiAzLjE3My45NyA0LjAxNUwxNi4zMTggMjkuNTljLTIuMTIzIDIuMTE2LTQuNjY0IDMuOC03LjU2NSA1LjAxMiIgZmlsbD0iI0ZGRiIvPjxwYXRoIGQ9Ik0yOS40MSA2LjExcy00LjQ1LTIuMzc4LTguMjAyIDUuNzcyYy0xLjczNCAzLjc2Ni00LjM1IDEuNTQ2LTQuMzUgMS41NDYiLz48cGF0aCBkPSJNMzYuNDIgOC44MjVjMCAuNDYzLS4xNC44NzMtLjQzMiAxLjE2NGwtOS4zMzUgOS4zYy4yODItLjI5LjQxLS42NjguNDEtMS4xMiAwLS44NzQtLjUwNy0xLjk2My0xLjQwNi0yLjg2OC0xLjM2Mi0xLjM1OC0zLjE0Ny0xLjgtNC4wMDItLjk5TDMwLjk5IDUuMDFjLjg0NC0uODQgMi42NS0uNDEgNC4wMzUuOTYuODk4LjkwNCAxLjM5NiAxLjk4MiAxLjM5NiAyLjg1NU0xMC41MTUgMzMuNzc0Yy0uNTczLjMwMi0xLjE1Ny41Ny0xLjc2NC44M0w0LjUgMzYuMzgybDEuNzg2LTQuMjM1Yy4yNTgtLjYwNC41My0xLjE4Ni44MzMtMS43NTcuNjkuMTgzIDEuNDQ4LjYyNSAyLjEwOCAxLjI4Mi42Ni42NTggMS4xMDIgMS40MTIgMS4yODcgMi4xMDIiIGZpbGw9IiM0Qzk3RkYiLz48cGF0aCBkPSJNMzYuNDk4IDguNzQ4YzAgLjQ2NC0uMTQuODc0LS40MzMgMS4xNjVsLTE5Ljc0MiAxOS42OGMtMi4xMyAyLjExLTQuNjczIDMuNzkzLTcuNTcyIDUuMDFMNC41IDM2LjM4bC45NzQtMi4zMTYgMS45MjUtLjgwOGMyLjg5OC0xLjIxOCA1LjQ0LTIuOSA3LjU3LTUuMDFsMTkuNzQzLTE5LjY4Yy4yOTItLjI5Mi40MzItLjcwMi40MzItMS4xNjUgMC0uNjQ2LS4yNy0xLjQtLjc4LTIuMTIyLjI1LjE3Mi41LjM3Ny43MzcuNjE0Ljg5OC45MDUgMS4zOTYgMS45ODMgMS4zOTYgMi44NTYiIGZpbGw9IiM1NzVFNzUiIG9wYWNpdHk9Ii4xNSIvPjxwYXRoIGQ9Ik0xOC40NSAxMi44M2MwIC41LS40MDQuOTA1LS45MDQuOTA1cy0uOTA1LS40MDUtLjkwNS0uOTA0YzAtLjUuNDA3LS45MDMuOTA2LS45MDMuNSAwIC45MDQuNDA0LjkwNC45MDR6IiBmaWxsPSIjNTc1RTc1Ii8+PC9nPjwvc3ZnPg==';\n/**\n * Enum for pen color parameter values.\n * @readonly\n * @enum {string}\n */\nvar ColorParam = {\n  COLOR: 'color',\n  SATURATION: 'saturation',\n  BRIGHTNESS: 'brightness',\n  TRANSPARENCY: 'transparency'\n};\n/**\n * @typedef {object} PenState - the pen state associated with a particular target.\n * @property {Boolean} penDown - tracks whether the pen should draw for this target.\n * @property {number} color - the current color (hue) of the pen.\n * @property {PenAttributes} penAttributes - cached pen attributes for the renderer. This is the authoritative value for\n *   diameter but not for pen color.\n */\n/**\n * Host for the Pen-related blocks in Scratch 3.0\n * @param {Runtime} runtime - the runtime instantiating this block package.\n * @constructor\n */\nvar Scratch3PenBlocks = function () {\n  function Scratch3PenBlocks(runtime) {\n    _classCallCheck(this, Scratch3PenBlocks);\n    /**\n     * The runtime instantiating this block package.\n     * @type {Runtime}\n     */\n    this.runtime = runtime;\n    /**\n     * The ID of the renderer Drawable corresponding to the pen layer.\n     * @type {int}\n     * @private\n     */\n    this._penDrawableId = -1;\n    /**\n     * The ID of the renderer Skin corresponding to the pen layer.\n     * @type {int}\n     * @private\n     */\n    this._penSkinId = -1;\n    this._onTargetCreated = this._onTargetCreated.bind(this);\n    this._onTargetMoved = this._onTargetMoved.bind(this);\n    runtime.on('targetWasCreated', this._onTargetCreated);\n    runtime.on('RUNTIME_DISPOSED', this.clear.bind(this));\n  }\n  /**\n   * The default pen state, to be used when a target has no existing pen state.\n   * @type {PenState}\n   */\n  _createClass(Scratch3PenBlocks, [{\n    key: \"_clampPenSize\",\n    /**\n     * Clamp a pen size value to the range allowed by the pen.\n     * @param {number} requestedSize - the requested pen size.\n     * @returns {number} the clamped size.\n     * @private\n     */\n    value: function _clampPenSize(requestedSize) {\n      return MathUtil.clamp(requestedSize, Scratch3PenBlocks.PEN_SIZE_RANGE.min, Scratch3PenBlocks.PEN_SIZE_RANGE.max);\n    }\n    /**\n     * Retrieve the ID of the renderer \"Skin\" corresponding to the pen layer. If\n     * the pen Skin doesn't yet exist, create it.\n     * @returns {int} the Skin ID of the pen layer, or -1 on failure.\n     * @private\n     */\n  }, {\n    key: \"_getPenLayerID\",\n    value: function _getPenLayerID() {\n      if (this._penSkinId < 0 && this.runtime.renderer) {\n        this._penSkinId = this.runtime.renderer.createPenSkin();\n        this._penDrawableId = this.runtime.renderer.createDrawable(StageLayering.PEN_LAYER);\n        this.runtime.renderer.updateDrawableSkinId(this._penDrawableId, this._penSkinId);\n      }\n      return this._penSkinId;\n    }\n    /**\n     * @param {Target} target - collect pen state for this target. Probably, but not necessarily, a RenderedTarget.\n     * @returns {PenState} the mutable pen state associated with that target. This will be created if necessary.\n     * @private\n     */\n  }, {\n    key: \"_getPenState\",\n    value: function _getPenState(target) {\n      var penState = target.getCustomState(Scratch3PenBlocks.STATE_KEY);\n      if (!penState) {\n        penState = Clone.simple(Scratch3PenBlocks.DEFAULT_PEN_STATE);\n        target.setCustomState(Scratch3PenBlocks.STATE_KEY, penState);\n      }\n      return penState;\n    }\n    /**\n     * When a pen-using Target is cloned, clone the pen state.\n     * @param {Target} newTarget - the newly created target.\n     * @param {Target} [sourceTarget] - the target used as a source for the new clone, if any.\n     * @listens Runtime#event:targetWasCreated\n     * @private\n     */\n  }, {\n    key: \"_onTargetCreated\",\n    value: function _onTargetCreated(newTarget, sourceTarget) {\n      if (sourceTarget) {\n        var penState = sourceTarget.getCustomState(Scratch3PenBlocks.STATE_KEY);\n        if (penState) {\n          newTarget.setCustomState(Scratch3PenBlocks.STATE_KEY, Clone.simple(penState));\n          if (penState.penDown) {\n            newTarget.addListener(RenderedTarget.EVENT_TARGET_MOVED, this._onTargetMoved);\n          }\n        }\n      }\n    }\n    /**\n     * Handle a target which has moved. This only fires when the pen is down.\n     * @param {RenderedTarget} target - the target which has moved.\n     * @param {number} oldX - the previous X position.\n     * @param {number} oldY - the previous Y position.\n     * @param {boolean} isForce - whether the movement was forced.\n     * @private\n     */\n  }, {\n    key: \"_onTargetMoved\",\n    value: function _onTargetMoved(target, oldX, oldY, isForce) {\n      // Only move the pen if the movement isn't forced (ie. dragged).\n      if (!isForce) {\n        var penSkinId = this._getPenLayerID();\n        if (penSkinId >= 0) {\n          var penState = this._getPenState(target);\n          this.runtime.renderer.penLine(penSkinId, penState.penAttributes, oldX, oldY, target.x, target.y);\n          this.runtime.requestRedraw();\n        }\n      }\n    }\n    /**\n     * Wrap a color input into the range (0,100).\n     * @param {number} value - the value to be wrapped.\n     * @returns {number} the wrapped value.\n     * @private\n     */\n  }, {\n    key: \"_wrapColor\",\n    value: function _wrapColor(value) {\n      return MathUtil.wrapClamp(value, 0, 100);\n    }\n    /**\n     * Initialize color parameters menu with localized strings\n     * @returns {array} of the localized text and values for each menu element\n     * @private\n     */\n  }, {\n    key: \"_initColorParam\",\n    value: function _initColorParam() {\n      return [{\n        text: formatMessage({\n          id: 'pen.colorMenu.color',\n          default: 'color',\n          description: 'label for color element in color picker for pen extension'\n        }),\n        value: ColorParam.COLOR\n      }, {\n        text: formatMessage({\n          id: 'pen.colorMenu.saturation',\n          default: 'saturation',\n          description: 'label for saturation element in color picker for pen extension'\n        }),\n        value: ColorParam.SATURATION\n      }, {\n        text: formatMessage({\n          id: 'pen.colorMenu.brightness',\n          default: 'brightness',\n          description: 'label for brightness element in color picker for pen extension'\n        }),\n        value: ColorParam.BRIGHTNESS\n      }, {\n        text: formatMessage({\n          id: 'pen.colorMenu.transparency',\n          default: 'transparency',\n          description: 'label for transparency element in color picker for pen extension'\n        }),\n        value: ColorParam.TRANSPARENCY\n      }];\n    }\n    /**\n     * Clamp a pen color parameter to the range (0,100).\n     * @param {number} value - the value to be clamped.\n     * @returns {number} the clamped value.\n     * @private\n     */\n  }, {\n    key: \"_clampColorParam\",\n    value: function _clampColorParam(value) {\n      return MathUtil.clamp(value, 0, 100);\n    }\n    /**\n     * Convert an alpha value to a pen transparency value.\n     * Alpha ranges from 0 to 1, where 0 is transparent and 1 is opaque.\n     * Transparency ranges from 0 to 100, where 0 is opaque and 100 is transparent.\n     * @param {number} alpha - the input alpha value.\n     * @returns {number} the transparency value.\n     * @private\n     */\n  }, {\n    key: \"_alphaToTransparency\",\n    value: function _alphaToTransparency(alpha) {\n      return (1.0 - alpha) * 100.0;\n    }\n    /**\n     * Convert a pen transparency value to an alpha value.\n     * Alpha ranges from 0 to 1, where 0 is transparent and 1 is opaque.\n     * Transparency ranges from 0 to 100, where 0 is opaque and 100 is transparent.\n     * @param {number} transparency - the input transparency value.\n     * @returns {number} the alpha value.\n     * @private\n     */\n  }, {\n    key: \"_transparencyToAlpha\",\n    value: function _transparencyToAlpha(transparency) {\n      return 1.0 - transparency / 100.0;\n    }\n    /**\n     * @returns {object} metadata for this extension and its blocks.\n     */\n  }, {\n    key: \"getInfo\",\n    value: function getInfo() {\n      return {\n        id: 'pen',\n        name: formatMessage({\n          id: 'pen.categoryName',\n          default: 'Pen',\n          description: 'Label for the pen extension category'\n        }),\n        blockIconURI: blockIconURI,\n        blocks: [{\n          opcode: 'clear',\n          blockType: BlockType.COMMAND,\n          text: formatMessage({\n            id: 'pen.clear',\n            default: 'erase all',\n            description: 'erase all pen trails and stamps'\n          })\n        }, {\n          opcode: 'stamp',\n          blockType: BlockType.COMMAND,\n          text: formatMessage({\n            id: 'pen.stamp',\n            default: 'stamp',\n            description: 'render current costume on the background'\n          }),\n          filter: [TargetType.SPRITE]\n        }, {\n          opcode: 'penDown',\n          blockType: BlockType.COMMAND,\n          text: formatMessage({\n            id: 'pen.penDown',\n            default: 'pen down',\n            description: 'start leaving a trail when the sprite moves'\n          }),\n          filter: [TargetType.SPRITE]\n        }, {\n          opcode: 'penUp',\n          blockType: BlockType.COMMAND,\n          text: formatMessage({\n            id: 'pen.penUp',\n            default: 'pen up',\n            description: 'stop leaving a trail behind the sprite'\n          }),\n          filter: [TargetType.SPRITE]\n        }, {\n          opcode: 'setPenColorToColor',\n          blockType: BlockType.COMMAND,\n          text: formatMessage({\n            id: 'pen.setColor',\n            default: 'set pen color to [COLOR]',\n            description: 'set the pen color to a particular (RGB) value'\n          }),\n          arguments: {\n            COLOR: {\n              type: ArgumentType.COLOR\n            }\n          },\n          filter: [TargetType.SPRITE]\n        }, {\n          opcode: 'changePenColorParamBy',\n          blockType: BlockType.COMMAND,\n          text: formatMessage({\n            id: 'pen.changeColorParam',\n            default: 'change pen [COLOR_PARAM] by [VALUE]',\n            description: 'change the state of a pen color parameter'\n          }),\n          arguments: {\n            COLOR_PARAM: {\n              type: ArgumentType.STRING,\n              menu: 'colorParam',\n              defaultValue: ColorParam.COLOR\n            },\n            VALUE: {\n              type: ArgumentType.NUMBER,\n              defaultValue: 10\n            }\n          },\n          filter: [TargetType.SPRITE]\n        }, {\n          opcode: 'setPenColorParamTo',\n          blockType: BlockType.COMMAND,\n          text: formatMessage({\n            id: 'pen.setColorParam',\n            default: 'set pen [COLOR_PARAM] to [VALUE]',\n            description: 'set the state for a pen color parameter e.g. saturation'\n          }),\n          arguments: {\n            COLOR_PARAM: {\n              type: ArgumentType.STRING,\n              menu: 'colorParam',\n              defaultValue: ColorParam.COLOR\n            },\n            VALUE: {\n              type: ArgumentType.NUMBER,\n              defaultValue: 50\n            }\n          },\n          filter: [TargetType.SPRITE]\n        }, {\n          opcode: 'changePenSizeBy',\n          blockType: BlockType.COMMAND,\n          text: formatMessage({\n            id: 'pen.changeSize',\n            default: 'change pen size by [SIZE]',\n            description: 'change the diameter of the trail left by a sprite'\n          }),\n          arguments: {\n            SIZE: {\n              type: ArgumentType.NUMBER,\n              defaultValue: 1\n            }\n          },\n          filter: [TargetType.SPRITE]\n        }, {\n          opcode: 'setPenSizeTo',\n          blockType: BlockType.COMMAND,\n          text: formatMessage({\n            id: 'pen.setSize',\n            default: 'set pen size to [SIZE]',\n            description: 'set the diameter of a trail left by a sprite'\n          }),\n          arguments: {\n            SIZE: {\n              type: ArgumentType.NUMBER,\n              defaultValue: 1\n            }\n          },\n          filter: [TargetType.SPRITE]\n        },\n        /* Legacy blocks, should not be shown in flyout */\n        {\n          opcode: 'setPenShadeToNumber',\n          blockType: BlockType.COMMAND,\n          text: formatMessage({\n            id: 'pen.setShade',\n            default: 'set pen shade to [SHADE]',\n            description: 'legacy pen blocks - set pen shade'\n          }),\n          arguments: {\n            SHADE: {\n              type: ArgumentType.NUMBER,\n              defaultValue: 1\n            }\n          },\n          hideFromPalette: true\n        }, {\n          opcode: 'changePenShadeBy',\n          blockType: BlockType.COMMAND,\n          text: formatMessage({\n            id: 'pen.changeShade',\n            default: 'change pen shade by [SHADE]',\n            description: 'legacy pen blocks - change pen shade'\n          }),\n          arguments: {\n            SHADE: {\n              type: ArgumentType.NUMBER,\n              defaultValue: 1\n            }\n          },\n          hideFromPalette: true\n        }, {\n          opcode: 'setPenHueToNumber',\n          blockType: BlockType.COMMAND,\n          text: formatMessage({\n            id: 'pen.setHue',\n            default: 'set pen color to [HUE]',\n            description: 'legacy pen blocks - set pen color to number'\n          }),\n          arguments: {\n            HUE: {\n              type: ArgumentType.NUMBER,\n              defaultValue: 1\n            }\n          },\n          hideFromPalette: true\n        }, {\n          opcode: 'changePenHueBy',\n          blockType: BlockType.COMMAND,\n          text: formatMessage({\n            id: 'pen.changeHue',\n            default: 'change pen color by [HUE]',\n            description: 'legacy pen blocks - change pen color'\n          }),\n          arguments: {\n            HUE: {\n              type: ArgumentType.NUMBER,\n              defaultValue: 1\n            }\n          },\n          hideFromPalette: true\n        }],\n        menus: {\n          colorParam: {\n            acceptReporters: true,\n            items: this._initColorParam()\n          }\n        }\n      };\n    }\n    /**\n     * The pen \"clear\" block clears the pen layer's contents.\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var penSkinId = this._getPenLayerID();\n      if (penSkinId >= 0) {\n        this.runtime.renderer.penClear(penSkinId);\n        this.runtime.requestRedraw();\n      }\n    }\n    /**\n     * The pen \"stamp\" block stamps the current drawable's image onto the pen layer.\n     * @param {object} args - the block arguments.\n     * @param {object} util - utility object provided by the runtime.\n     */\n  }, {\n    key: \"stamp\",\n    value: function stamp(args, util) {\n      var penSkinId = this._getPenLayerID();\n      if (penSkinId >= 0) {\n        var target = util.target;\n        this.runtime.renderer.penStamp(penSkinId, target.drawableID);\n        this.runtime.requestRedraw();\n      }\n    }\n    /**\n     * The pen \"pen down\" block causes the target to leave pen trails on future motion.\n     * @param {object} args - the block arguments.\n     * @param {object} util - utility object provided by the runtime.\n     */\n  }, {\n    key: \"penDown\",\n    value: function penDown(args, util) {\n      var target = util.target;\n      var penState = this._getPenState(target);\n      if (!penState.penDown) {\n        penState.penDown = true;\n        target.addListener(RenderedTarget.EVENT_TARGET_MOVED, this._onTargetMoved);\n      }\n      var penSkinId = this._getPenLayerID();\n      if (penSkinId >= 0) {\n        this.runtime.renderer.penPoint(penSkinId, penState.penAttributes, target.x, target.y);\n        this.runtime.requestRedraw();\n      }\n    }\n    /**\n     * The pen \"pen up\" block stops the target from leaving pen trails.\n     * @param {object} args - the block arguments.\n     * @param {object} util - utility object provided by the runtime.\n     */\n  }, {\n    key: \"penUp\",\n    value: function penUp(args, util) {\n      var target = util.target;\n      var penState = this._getPenState(target);\n      if (penState.penDown) {\n        penState.penDown = false;\n        target.removeListener(RenderedTarget.EVENT_TARGET_MOVED, this._onTargetMoved);\n      }\n    }\n    /**\n     * The pen \"set pen color to {color}\" block sets the pen to a particular RGB color.\n     * The transparency is reset to 0.\n     * @param {object} args - the block arguments.\n     *  @property {int} COLOR - the color to set, expressed as a 24-bit RGB value (0xRRGGBB).\n     * @param {object} util - utility object provided by the runtime.\n     */\n  }, {\n    key: \"setPenColorToColor\",\n    value: function setPenColorToColor(args, util) {\n      var penState = this._getPenState(util.target);\n      var rgb = Cast.toRgbColorObject(args.COLOR);\n      var hsv = Color.rgbToHsv(rgb);\n      penState.color = hsv.h / 360 * 100;\n      penState.saturation = hsv.s * 100;\n      penState.brightness = hsv.v * 100;\n      if (rgb.hasOwnProperty('a')) {\n        penState.transparency = 100 * (1 - rgb.a / 255.0);\n      } else {\n        penState.transparency = 0;\n      } // Set the legacy \"shade\" value the same way scratch 2 did.\n      penState._shade = penState.brightness / 2;\n      this._updatePenColor(penState);\n    }\n    /**\n     * Update the cached color from the color, saturation, brightness and transparency values\n     * in the provided PenState object.\n     * @param {PenState} penState - the pen state to update.\n     * @private\n     */\n  }, {\n    key: \"_updatePenColor\",\n    value: function _updatePenColor(penState) {\n      var rgb = Color.hsvToRgb({\n        h: penState.color * 360 / 100,\n        s: penState.saturation / 100,\n        v: penState.brightness / 100\n      });\n      penState.penAttributes.color4f[0] = rgb.r / 255.0;\n      penState.penAttributes.color4f[1] = rgb.g / 255.0;\n      penState.penAttributes.color4f[2] = rgb.b / 255.0;\n      penState.penAttributes.color4f[3] = this._transparencyToAlpha(penState.transparency);\n    }\n    /**\n     * Set or change a single color parameter on the pen state, and update the pen color.\n     * @param {ColorParam} param - the name of the color parameter to set or change.\n     * @param {number} value - the value to set or change the param by.\n     * @param {PenState} penState - the pen state to update.\n     * @param {boolean} change - if true change param by value, if false set param to value.\n     * @private\n     */\n  }, {\n    key: \"_setOrChangeColorParam\",\n    value: function _setOrChangeColorParam(param, value, penState, change) {\n      switch (param) {\n        case ColorParam.COLOR:\n          penState.color = this._wrapColor(value + (change ? penState.color : 0));\n          break;\n        case ColorParam.SATURATION:\n          penState.saturation = this._clampColorParam(value + (change ? penState.saturation : 0));\n          break;\n        case ColorParam.BRIGHTNESS:\n          penState.brightness = this._clampColorParam(value + (change ? penState.brightness : 0));\n          break;\n        case ColorParam.TRANSPARENCY:\n          penState.transparency = this._clampColorParam(value + (change ? penState.transparency : 0));\n          break;\n        default:\n          log.warn(\"Tried to set or change unknown color parameter: \".concat(param));\n      }\n      this._updatePenColor(penState);\n    }\n    /**\n     * The \"change pen {ColorParam} by {number}\" block changes one of the pen's color parameters\n     * by a given amound.\n     * @param {object} args - the block arguments.\n     *  @property {ColorParam} COLOR_PARAM - the name of the selected color parameter.\n     *  @property {number} VALUE - the amount to change the selected parameter by.\n     * @param {object} util - utility object provided by the runtime.\n     */\n  }, {\n    key: \"changePenColorParamBy\",\n    value: function changePenColorParamBy(args, util) {\n      var penState = this._getPenState(util.target);\n      this._setOrChangeColorParam(args.COLOR_PARAM, Cast.toNumber(args.VALUE), penState, true);\n    }\n    /**\n     * The \"set pen {ColorParam} to {number}\" block sets one of the pen's color parameters\n     * to a given amound.\n     * @param {object} args - the block arguments.\n     *  @property {ColorParam} COLOR_PARAM - the name of the selected color parameter.\n     *  @property {number} VALUE - the amount to set the selected parameter to.\n     * @param {object} util - utility object provided by the runtime.\n     */\n  }, {\n    key: \"setPenColorParamTo\",\n    value: function setPenColorParamTo(args, util) {\n      var penState = this._getPenState(util.target);\n      this._setOrChangeColorParam(args.COLOR_PARAM, Cast.toNumber(args.VALUE), penState, false);\n    }\n    /**\n     * The pen \"change pen size by {number}\" block changes the pen size by the given amount.\n     * @param {object} args - the block arguments.\n     *  @property {number} SIZE - the amount of desired size change.\n     * @param {object} util - utility object provided by the runtime.\n     */\n  }, {\n    key: \"changePenSizeBy\",\n    value: function changePenSizeBy(args, util) {\n      var penAttributes = this._getPenState(util.target).penAttributes;\n      penAttributes.diameter = this._clampPenSize(penAttributes.diameter + Cast.toNumber(args.SIZE));\n    }\n    /**\n     * The pen \"set pen size to {number}\" block sets the pen size to the given amount.\n     * @param {object} args - the block arguments.\n     *  @property {number} SIZE - the amount of desired size change.\n     * @param {object} util - utility object provided by the runtime.\n     */\n  }, {\n    key: \"setPenSizeTo\",\n    value: function setPenSizeTo(args, util) {\n      var penAttributes = this._getPenState(util.target).penAttributes;\n      penAttributes.diameter = this._clampPenSize(Cast.toNumber(args.SIZE));\n    }\n    /* LEGACY OPCODES */\n    /**\n     * Scratch 2 \"hue\" param is equivelant to twice the new \"color\" param.\n     * @param {object} args - the block arguments.\n     *  @property {number} HUE - the amount to set the hue to.\n     * @param {object} util - utility object provided by the runtime.\n     */\n  }, {\n    key: \"setPenHueToNumber\",\n    value: function setPenHueToNumber(args, util) {\n      var penState = this._getPenState(util.target);\n      var hueValue = Cast.toNumber(args.HUE);\n      var colorValue = hueValue / 2;\n      this._setOrChangeColorParam(ColorParam.COLOR, colorValue, penState, false);\n      this._setOrChangeColorParam(ColorParam.TRANSPARENCY, 0, penState, false);\n      this._legacyUpdatePenColor(penState);\n    }\n    /**\n     * Scratch 2 \"hue\" param is equivelant to twice the new \"color\" param.\n     * @param {object} args - the block arguments.\n     *  @property {number} HUE - the amount of desired hue change.\n     * @param {object} util - utility object provided by the runtime.\n     */\n  }, {\n    key: \"changePenHueBy\",\n    value: function changePenHueBy(args, util) {\n      var penState = this._getPenState(util.target);\n      var hueChange = Cast.toNumber(args.HUE);\n      var colorChange = hueChange / 2;\n      this._setOrChangeColorParam(ColorParam.COLOR, colorChange, penState, true);\n      this._legacyUpdatePenColor(penState);\n    }\n    /**\n     * Use legacy \"set shade\" code to calculate RGB value for shade,\n     * then convert back to HSV and store those components.\n     * It is important to also track the given shade in penState._shade\n     * because it cannot be accurately backed out of the new HSV later.\n     * @param {object} args - the block arguments.\n     *  @property {number} SHADE - the amount to set the shade to.\n     * @param {object} util - utility object provided by the runtime.\n     */\n  }, {\n    key: \"setPenShadeToNumber\",\n    value: function setPenShadeToNumber(args, util) {\n      var penState = this._getPenState(util.target);\n      var newShade = Cast.toNumber(args.SHADE); // Wrap clamp the new shade value the way scratch 2 did.\n      newShade = newShade % 200;\n      if (newShade < 0) newShade += 200; // And store the shade that was used to compute this new color for later use.\n      penState._shade = newShade;\n      this._legacyUpdatePenColor(penState);\n    }\n    /**\n     * Because \"shade\" cannot be backed out of hsv consistently, use the previously\n     * stored penState._shade to make the shade change.\n     * @param {object} args - the block arguments.\n     *  @property {number} SHADE - the amount of desired shade change.\n     * @param {object} util - utility object provided by the runtime.\n     */\n  }, {\n    key: \"changePenShadeBy\",\n    value: function changePenShadeBy(args, util) {\n      var penState = this._getPenState(util.target);\n      var shadeChange = Cast.toNumber(args.SHADE);\n      this.setPenShadeToNumber({\n        SHADE: penState._shade + shadeChange\n      }, util);\n    }\n    /**\n     * Update the pen state's color from its hue & shade values, Scratch 2.0 style.\n     * @param {object} penState - update the HSV & RGB values in this pen state from its hue & shade values.\n     * @private\n     */\n  }, {\n    key: \"_legacyUpdatePenColor\",\n    value: function _legacyUpdatePenColor(penState) {\n      // Create the new color in RGB using the scratch 2 \"shade\" model\n      var rgb = Color.hsvToRgb({\n        h: penState.color * 360 / 100,\n        s: 1,\n        v: 1\n      });\n      var shade = penState._shade > 100 ? 200 - penState._shade : penState._shade;\n      if (shade < 50) {\n        rgb = Color.mixRgb(Color.RGB_BLACK, rgb, (10 + shade) / 60);\n      } else {\n        rgb = Color.mixRgb(rgb, Color.RGB_WHITE, (shade - 50) / 60);\n      } // Update the pen state according to new color\n      var hsv = Color.rgbToHsv(rgb);\n      penState.color = 100 * hsv.h / 360;\n      penState.saturation = 100 * hsv.s;\n      penState.brightness = 100 * hsv.v;\n      this._updatePenColor(penState);\n    }\n  }], [{\n    key: \"DEFAULT_PEN_STATE\",\n    get: function get() {\n      return {\n        penDown: false,\n        color: 66.66,\n        saturation: 100,\n        brightness: 100,\n        transparency: 0,\n        _shade: 50,\n        // Used only for legacy `change shade by` blocks\n        penAttributes: {\n          color4f: [0, 0, 1, 1],\n          diameter: 1\n        }\n      };\n    }\n    /**\n     * The minimum and maximum allowed pen size.\n     * The maximum is twice the diagonal of the stage, so that even an\n     * off-stage sprite can fill it.\n     * @type {{min: number, max: number}}\n     */\n  }, {\n    key: \"PEN_SIZE_RANGE\",\n    get: function get() {\n      return {\n        min: 1,\n        max: 1200\n      };\n    }\n    /**\n     * The key to load & store a target's pen-related state.\n     * @type {string}\n     */\n  }, {\n    key: \"STATE_KEY\",\n    get: function get() {\n      return 'Scratch.pen';\n    }\n  }]);\n  return Scratch3PenBlocks;\n}();\nmodule.exports = Scratch3PenBlocks;\n })