/* 1300 */\n (function(module, exports, __webpack_require__) {\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nvar Matrix = __webpack_require__(493);\nvar SvgElement = __webpack_require__(314);\nvar log = __webpack_require__(1301);\n/**\n * @fileOverview Apply transforms to match stroke width appearance in 2.0 and 3.0\n */\n// Adapted from paper.js's Path.applyTransform\nvar _parseTransform = function _parseTransform(domElement) {\n  var matrix = Matrix.identity();\n  var string = domElement.attributes && domElement.attributes.transform && domElement.attributes.transform.value;\n  if (!string) return matrix; // https://www.w3.org/TR/SVG/types.html#DataTypeTransformList\n  // Parse SVG transform string. First we split at /)\\s*/, to separate\n  // commands\n  var transforms = string.split(/\\)\\s*/g);\n  var _iterator = _createForOfIteratorHelper(transforms),\n      _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var transform = _step.value;\n      if (!transform) break; // Command come before the '(', values after\n      var parts = transform.split(/\\(\\s*/);\n      var command = parts[0].trim();\n      var v = parts[1].split(/[\\s,]+/g); // Convert values to floats\n      for (var j = 0; j < v.length; j++) {\n        v[j] = parseFloat(v[j]);\n      }\n      switch (command) {\n        case 'matrix':\n          matrix = Matrix.compose(matrix, {\n            a: v[0],\n            b: v[1],\n            c: v[2],\n            d: v[3],\n            e: v[4],\n            f: v[5]\n          });\n          break;\n        case 'rotate':\n          matrix = Matrix.compose(matrix, Matrix.rotateDEG(v[0], v[1] || 0, v[2] || 0));\n          break;\n        case 'translate':\n          matrix = Matrix.compose(matrix, Matrix.translate(v[0], v[1] || 0));\n          break;\n        case 'scale':\n          matrix = Matrix.compose(matrix, Matrix.scale(v[0], v[1] || v[0]));\n          break;\n        case 'skewX':\n          matrix = Matrix.compose(matrix, Matrix.skewDEG(v[0], 0));\n          break;\n        case 'skewY':\n          matrix = Matrix.compose(matrix, Matrix.skewDEG(0, v[0]));\n          break;\n        default:\n          log.error(\"Couldn't parse: \".concat(command));\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return matrix;\n}; // Adapted from paper.js's Matrix.decompose\n// Given a matrix, return the x and y scale factors of the matrix\nvar _getScaleFactor = function _getScaleFactor(matrix) {\n  var a = matrix.a;\n  var b = matrix.b;\n  var c = matrix.c;\n  var d = matrix.d;\n  var det = a * d - b * c;\n  if (a !== 0 || b !== 0) {\n    var r = Math.sqrt(a * a + b * b);\n    return {\n      x: r,\n      y: det / r\n    };\n  }\n  if (c !== 0 || d !== 0) {\n    var s = Math.sqrt(c * c + d * d);\n    return {\n      x: det / s,\n      y: s\n    };\n  } // a = b = c = d = 0\n  return {\n    x: 0,\n    y: 0\n  };\n}; // Returns null if matrix is not invertible. Otherwise returns given ellipse\n// transformed by transform, an object {radiusX, radiusY, rotation}.\nvar _calculateTransformedEllipse = function _calculateTransformedEllipse(radiusX, radiusY, theta, transform) {\n  theta = -theta * Math.PI / 180;\n  var a = transform.a;\n  var b = -transform.c;\n  var c = -transform.b;\n  var d = transform.d; // Since other parameters determine the translation of the ellipse in SVG, we do not need to worry\n  // about what e and f are.\n  var det = a * d - b * c; // Non-invertible matrix\n  if (det === 0) return null; // rotA, rotB, and rotC represent Ax^2 + Bxy + Cy^2 = 1 coefficients for a rotated ellipse formula\n  var sinT = Math.sin(theta);\n  var cosT = Math.cos(theta);\n  var sin2T = Math.sin(2 * theta);\n  var rotA = cosT * cosT / radiusX / radiusX + sinT * sinT / radiusY / radiusY;\n  var rotB = sin2T / radiusX / radiusX - sin2T / radiusY / radiusY;\n  var rotC = sinT * sinT / radiusX / radiusX + cosT * cosT / radiusY / radiusY; // Calculate the ellipse formula of the transformed ellipse\n  // A, B, and C represent Ax^2 + Bxy + Cy^2 = 1 / det / det coefficients in a transformed ellipse formula\n  // scaled by inverse det squared (to preserve accuracy)\n  var A = rotA * d * d - rotB * d * c + rotC * c * c;\n  var B = -2 * rotA * b * d + rotB * a * d + rotB * b * c - 2 * rotC * a * c;\n  var C = rotA * b * b - rotB * a * b + rotC * a * a; // Derive new radii and theta from the transformed ellipse formula\n  var newRadiusXOverDet = Math.sqrt(2) * Math.sqrt((A + C - Math.sqrt(A * A + B * B - 2 * A * C + C * C)) / (-B * B + 4 * A * C));\n  var newRadiusYOverDet = 1 / Math.sqrt(A + C - 1 / newRadiusXOverDet / newRadiusXOverDet);\n  var temp = (A - 1 / newRadiusXOverDet / newRadiusXOverDet) / (1 / newRadiusYOverDet / newRadiusYOverDet - 1 / newRadiusXOverDet / newRadiusXOverDet);\n  if (temp < 0 && Math.abs(temp) < 1e-8) temp = 0; // Fix floating point issue\n  temp = Math.sqrt(temp);\n  if (Math.abs(1 - temp) < 1e-8) temp = 1; // Fix floating point issue\n  // Solve for which of the two possible thetas is correct\n  var newTheta = Math.asin(temp);\n  temp = B / (1 / newRadiusXOverDet / newRadiusXOverDet - 1 / newRadiusYOverDet / newRadiusYOverDet);\n  var newTheta2 = -newTheta;\n  if (Math.abs(Math.sin(2 * newTheta2) - temp) < Math.abs(Math.sin(2 * newTheta) - temp)) {\n    newTheta = newTheta2;\n  }\n  return {\n    radiusX: newRadiusXOverDet * det,\n    radiusY: newRadiusYOverDet * det,\n    rotation: -newTheta * 180 / Math.PI\n  };\n}; // Adapted from paper.js's PathItem.setPathData\nvar _transformPath = function _transformPath(pathString, transform) {\n  if (!transform || Matrix.toString(transform) === Matrix.toString(Matrix.identity())) return pathString; // First split the path data into parts of command-coordinates pairs\n  // Commands are any of these characters: mzlhvcsqta\n  var parts = pathString && pathString.match(/[mlhvcsqtaz][^mlhvcsqtaz]*/ig);\n  var coords;\n  var relative = false;\n  var previous;\n  var control;\n  var current = {\n    x: 0,\n    y: 0\n  };\n  var start = {\n    x: 0,\n    y: 0\n  };\n  var result = '';\n  var getCoord = function getCoord(index, coord) {\n    var val = +coords[index];\n    if (relative) {\n      val += current[coord];\n    }\n    return val;\n  };\n  var getPoint = function getPoint(index) {\n    return {\n      x: getCoord(index, 'x'),\n      y: getCoord(index + 1, 'y')\n    };\n  };\n  var roundTo4Places = function roundTo4Places(num) {\n    return Number(num.toFixed(4));\n  }; // Returns the transformed point as a string\n  var getString = function getString(point) {\n    var transformed = Matrix.applyToPoint(transform, point);\n    return \"\".concat(roundTo4Places(transformed.x), \" \").concat(roundTo4Places(transformed.y), \" \");\n  };\n  for (var i = 0, l = parts && parts.length; i < l; i++) {\n    var part = parts[i];\n    var command = part[0];\n    var lower = command.toLowerCase(); // Match all coordinate values\n    coords = part.match(/[+-]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][+-]?\\d+)?/g);\n    var length = coords && coords.length;\n    relative = command === lower; // Fix issues with z in the middle of SVG path data, not followed by\n    // a m command, see paper.js#413:\n    if (previous === 'z' && !/[mz]/.test(lower)) {\n      result += \"M \".concat(current.x, \" \").concat(current.y, \" \");\n    }\n    switch (lower) {\n      case 'm': // Move to\n      case 'l':\n        // Line to\n        {\n          var move = lower === 'm';\n          for (var j = 0; j < length; j += 2) {\n            result += move ? 'M ' : 'L ';\n            current = getPoint(j);\n            result += getString(current);\n            if (move) {\n              start = current;\n              move = false;\n            }\n          }\n          control = current;\n          break;\n        }\n      case 'h': // Horizontal line\n      case 'v':\n        // Vertical line\n        {\n          var coord = lower === 'h' ? 'x' : 'y';\n          current = {\n            x: current.x,\n            y: current.y\n          }; // Clone as we're going to modify it.\n          for (var _j = 0; _j < length; _j++) {\n            current[coord] = getCoord(_j, coord);\n            result += \"L \".concat(getString(current));\n          }\n          control = current;\n          break;\n        }\n      case 'c':\n        // Cubic Bezier curve\n        for (var _j2 = 0; _j2 < length; _j2 += 6) {\n          var handle1 = getPoint(_j2);\n          control = getPoint(_j2 + 2);\n          current = getPoint(_j2 + 4);\n          result += \"C \".concat(getString(handle1)).concat(getString(control)).concat(getString(current));\n        }\n        break;\n      case 's':\n        // Smooth cubic Bezier curve\n        for (var _j3 = 0; _j3 < length; _j3 += 4) {\n          var _handle = /[cs]/.test(previous) ? {\n            x: current.x * 2 - control.x,\n            y: current.y * 2 - control.y\n          } : current;\n          control = getPoint(_j3);\n          current = getPoint(_j3 + 2);\n          result += \"C \".concat(getString(_handle)).concat(getString(control)).concat(getString(current));\n          previous = lower;\n        }\n        break;\n      case 'q':\n        // Quadratic Bezier curve\n        for (var _j4 = 0; _j4 < length; _j4 += 4) {\n          control = getPoint(_j4);\n          current = getPoint(_j4 + 2);\n          result += \"Q \".concat(getString(control)).concat(getString(current));\n        }\n        break;\n      case 't':\n        // Smooth quadratic Bezier curve\n        for (var _j5 = 0; _j5 < length; _j5 += 2) {\n          control = /[qt]/.test(previous) ? {\n            x: current.x * 2 - control.x,\n            y: current.y * 2 - control.y\n          } : current;\n          current = getPoint(_j5);\n          result += \"Q \".concat(getString(control)).concat(getString(current));\n          previous = lower;\n        }\n        break;\n      case 'a':\n        // Elliptical arc curve\n        for (var _j6 = 0; _j6 < length; _j6 += 7) {\n          current = getPoint(_j6 + 5);\n          var rx = +coords[_j6];\n          var ry = +coords[_j6 + 1];\n          var rotation = +coords[_j6 + 2];\n          var largeArcFlag = +coords[_j6 + 3];\n          var clockwiseFlag = +coords[_j6 + 4];\n          var newEllipse = _calculateTransformedEllipse(rx, ry, rotation, transform);\n          var matrixScale = _getScaleFactor(transform);\n          if (newEllipse) {\n            if (matrixScale.x > 0 && matrixScale.y < 0 || matrixScale.x < 0 && matrixScale.y > 0) {\n              clockwiseFlag = clockwiseFlag ^ 1;\n            }\n            result += \"A \".concat(roundTo4Places(Math.abs(newEllipse.radiusX)), \" \") + \"\".concat(roundTo4Places(Math.abs(newEllipse.radiusY)), \" \") + \"\".concat(roundTo4Places(newEllipse.rotation), \" \").concat(largeArcFlag, \" \") + \"\".concat(clockwiseFlag, \" \").concat(getString(current));\n          } else {\n            result += \"L \".concat(getString(current));\n          }\n        }\n        break;\n      case 'z':\n        // Close path\n        result += \"Z \"; // Correctly handle relative m commands, see paper.js#1101:\n        current = start;\n        break;\n    }\n    previous = lower;\n  }\n  return result;\n};\nvar GRAPHICS_ELEMENTS = ['circle', 'ellipse', 'image', 'line', 'path', 'polygon', 'polyline', 'rect', 'text', 'use'];\nvar CONTAINER_ELEMENTS = ['a', 'defs', 'g', 'marker', 'glyph', 'missing-glyph', 'pattern', 'svg', 'switch', 'symbol'];\nvar _isContainerElement = function _isContainerElement(element) {\n  return element.tagName && CONTAINER_ELEMENTS.includes(element.tagName.toLowerCase());\n};\nvar _isGraphicsElement = function _isGraphicsElement(element) {\n  return element.tagName && GRAPHICS_ELEMENTS.includes(element.tagName.toLowerCase());\n};\nvar _isPathWithTransformAndStroke = function _isPathWithTransformAndStroke(element, strokeWidth) {\n  if (!element.attributes) return false;\n  strokeWidth = element.attributes['stroke-width'] ? Number(element.attributes['stroke-width'].value) : Number(strokeWidth);\n  return strokeWidth && element.tagName && element.tagName.toLowerCase() === 'path' && element.attributes.d && element.attributes.d.value;\n};\nvar _quadraticMean = function _quadraticMean(a, b) {\n  return Math.sqrt((a * a + b * b) / 2);\n};\nvar _createGradient = function _createGradient(gradientId, svgTag, bbox, matrix) {\n  // Adapted from Paper.js's SvgImport.getValue\n  var getValue = function getValue(node, name, isString, allowNull, allowPercent, defaultValue) {\n    // Interpret value as number. Never return NaN, but 0 instead.\n    // If the value is a sequence of numbers, parseFloat will\n    // return the first occurring number, which is enough for now.\n    var value = SvgElement.get(node, name);\n    var res;\n    if (value === null) {\n      if (defaultValue) {\n        res = defaultValue;\n        if (/%\\s*$/.test(res)) {\n          value = defaultValue;\n          res = parseFloat(value);\n        }\n      } else if (allowNull) {\n        res = null;\n      } else if (isString) {\n        res = '';\n      } else {\n        res = 0;\n      }\n    } else if (isString) {\n      res = value;\n    } else {\n      res = parseFloat(value);\n    } // Support for dimensions in percentage of the root size. If root-size\n    // is not set (e.g. during <defs>), just scale the percentage value to\n    // 0..1, as required by gradients with gradientUnits=\"objectBoundingBox\"\n    if (/%\\s*$/.test(value)) {\n      var size = allowPercent ? 1 : bbox[/x|^width/.test(name) ? 'width' : 'height'];\n      return res / 100 * size;\n    }\n    return res;\n  };\n  var getPoint = function getPoint(node, x, y, allowNull, allowPercent, defaultX, defaultY) {\n    x = getValue(node, x || 'x', false, allowNull, allowPercent, defaultX);\n    y = getValue(node, y || 'y', false, allowNull, allowPercent, defaultY);\n    return allowNull && (x === null || y === null) ? null : {\n      x: x,\n      y: y\n    };\n  };\n  var defs = svgTag.getElementsByTagName('defs');\n  if (defs.length === 0) {\n    defs = SvgElement.create('defs');\n    svgTag.appendChild(defs);\n  } else {\n    defs = defs[0];\n  } // Clone the old gradient. We'll make a new one, since the gradient might be reused elsewhere\n  // with different transform matrix\n  var oldGradient = svgTag.getElementById(gradientId);\n  if (!oldGradient) return;\n  var radial = oldGradient.tagName.toLowerCase() === 'radialgradient';\n  var newGradient = svgTag.getElementById(gradientId).cloneNode(true\n  /* deep */\n  ); // Give the new gradient a new ID\n  var matrixString = Matrix.toString(matrix);\n  matrixString = matrixString.substring(8, matrixString.length - 1);\n  var newGradientId = \"\".concat(gradientId, \"-\").concat(matrixString);\n  newGradient.setAttribute('id', newGradientId); // This gradient already exists and was transformed before. Just reuse the already-transformed one.\n  if (svgTag.getElementById(newGradientId)) {\n    // This is the same code as in the end of the function, but I don't feel like wrapping the next 80 lines\n    // in an `if (!svgTag.getElementById(newGradientId))` block\n    return \"url(#\".concat(newGradientId, \")\");\n  }\n  var scaleToBounds = getValue(newGradient, 'gradientUnits', true) !== 'userSpaceOnUse';\n  var origin;\n  var destination;\n  var radius;\n  var focal;\n  if (radial) {\n    origin = getPoint(newGradient, 'cx', 'cy', false, scaleToBounds, '50%', '50%');\n    radius = getValue(newGradient, 'r', false, false, scaleToBounds, '50%');\n    focal = getPoint(newGradient, 'fx', 'fy', true, scaleToBounds);\n  } else {\n    origin = getPoint(newGradient, 'x1', 'y1', false, scaleToBounds);\n    destination = getPoint(newGradient, 'x2', 'y2', false, scaleToBounds, '1');\n    if (origin.x === destination.x && origin.y === destination.y) {\n      // If it's degenerate, use the color of the last stop, as described by\n      // https://www.w3.org/TR/SVG/pservers.html#LinearGradientNotes\n      var stops = newGradient.getElementsByTagName('stop');\n      if (!stops.length || !stops[stops.length - 1].attributes || !stops[stops.length - 1].attributes['stop-color']) {\n        return null;\n      }\n      return stops[stops.length - 1].attributes['stop-color'].value;\n    }\n  } // Transform points\n  // Emulate SVG's gradientUnits=\"objectBoundingBox\"\n  if (scaleToBounds) {\n    var boundsMatrix = Matrix.compose(Matrix.translate(bbox.x, bbox.y), Matrix.scale(bbox.width, bbox.height));\n    origin = Matrix.applyToPoint(boundsMatrix, origin);\n    if (destination) destination = Matrix.applyToPoint(boundsMatrix, destination);\n    if (radius) {\n      radius = _quadraticMean(bbox.width, bbox.height) * radius;\n    }\n    if (focal) focal = Matrix.applyToPoint(boundsMatrix, focal);\n  }\n  if (radial) {\n    origin = Matrix.applyToPoint(matrix, origin);\n    var matrixScale = _getScaleFactor(matrix);\n    radius = _quadraticMean(matrixScale.x, matrixScale.y) * radius;\n    if (focal) focal = Matrix.applyToPoint(matrix, focal);\n  } else {\n    var dot = function dot(a, b) {\n      return a.x * b.x + a.y * b.y;\n    };\n    var multiply = function multiply(coefficient, v) {\n      return {\n        x: coefficient * v.x,\n        y: coefficient * v.y\n      };\n    };\n    var add = function add(a, b) {\n      return {\n        x: a.x + b.x,\n        y: a.y + b.y\n      };\n    };\n    var subtract = function subtract(a, b) {\n      return {\n        x: a.x - b.x,\n        y: a.y - b.y\n      };\n    }; // The line through origin and gradientPerpendicular is the line at which the gradient starts\n    var gradientPerpendicular = Math.abs(origin.x - destination.x) < 1e-8 ? add(origin, {\n      x: 1,\n      y: (origin.x - destination.x) / (destination.y - origin.y)\n    }) : add(origin, {\n      x: (destination.y - origin.y) / (origin.x - destination.x),\n      y: 1\n    }); // Transform points\n    gradientPerpendicular = Matrix.applyToPoint(matrix, gradientPerpendicular);\n    origin = Matrix.applyToPoint(matrix, origin);\n    destination = Matrix.applyToPoint(matrix, destination); // Calculate the direction that the gradient has changed to\n    var originToPerpendicular = subtract(gradientPerpendicular, origin);\n    var originToDestination = subtract(destination, origin);\n    var gradientDirection = Math.abs(originToPerpendicular.x) < 1e-8 ? {\n      x: 1,\n      y: -originToPerpendicular.x / originToPerpendicular.y\n    } : {\n      x: -originToPerpendicular.y / originToPerpendicular.x,\n      y: 1\n    }; // Set the destination so that the gradient moves in the correct direction, by projecting the destination vector\n    // onto the gradient direction vector\n    var projectionCoeff = dot(originToDestination, gradientDirection) / dot(gradientDirection, gradientDirection);\n    var projection = multiply(projectionCoeff, gradientDirection);\n    destination = {\n      x: origin.x + projection.x,\n      y: origin.y + projection.y\n    };\n  } // Put values back into svg\n  if (radial) {\n    newGradient.setAttribute('cx', Number(origin.x.toFixed(4)));\n    newGradient.setAttribute('cy', Number(origin.y.toFixed(4)));\n    newGradient.setAttribute('r', Number(radius.toFixed(4)));\n    if (focal) {\n      newGradient.setAttribute('fx', Number(focal.x.toFixed(4)));\n      newGradient.setAttribute('fy', Number(focal.y.toFixed(4)));\n    }\n  } else {\n    newGradient.setAttribute('x1', Number(origin.x.toFixed(4)));\n    newGradient.setAttribute('y1', Number(origin.y.toFixed(4)));\n    newGradient.setAttribute('x2', Number(destination.x.toFixed(4)));\n    newGradient.setAttribute('y2', Number(destination.y.toFixed(4)));\n  }\n  newGradient.setAttribute('gradientUnits', 'userSpaceOnUse');\n  defs.appendChild(newGradient);\n  return \"url(#\".concat(newGradientId, \")\");\n}; // Adapted from paper.js's SvgImport.getDefinition\nvar _parseUrl = function _parseUrl(value, windowRef) {\n  // When url() comes from a style property, '#'' seems to be missing on\n  // WebKit. We also get variations of quotes or no quotes, single or\n  // double, so handle it all with one regular expression:\n  var match = value && value.match(/\\((?:[\"'#]*)([^\"')]+)/);\n  var name = match && match[1];\n  var res = name && windowRef ? // This is required by Firefox, which can produce absolute\n  // urls for local gradients, see paperjs#1001:\n  name.replace(\"\".concat(windowRef.location.href.split('#')[0], \"#\"), '') : name;\n  return res;\n};\n/**\n * Scratch 2.0 displays stroke widths in a \"normalized\" way, that is,\n * if a shape with a stroke width has a transform applied, it will be\n * rendered with a stroke that is the same width all the way around,\n * instead of stretched looking.\n *\n * The vector paint editor also prefers to normalize the stroke width,\n * rather than keep track of transforms at the group level, as this\n * simplifies editing (e.g. stroke width 3 always means the same thickness)\n *\n * This function performs that normalization process, pushing transforms\n * on groups down to the leaf level and averaging out the stroke width\n * around the shapes. Note that this doens't just change stroke widths, it\n * changes path data and attributes throughout the SVG.\n *\n * @param {SVGElement} svgTag The SVG dom object\n * @param {Window} windowRef The window to use. Need to pass in for\n *     tests to work, as they get angry at even the mention of window.\n * @param {object} bboxForTesting The bounds to use. Need to pass in for\n *     tests only, because getBBox doesn't work in Node. This should\n *     be the bounds of the svgTag without including stroke width or transforms.\n * @return {void}\n */\nvar transformStrokeWidths = function transformStrokeWidths(svgTag, windowRef, bboxForTesting) {\n  var inherited = Matrix.identity();\n  var applyTransforms = function applyTransforms(element, matrix, strokeWidth, fill, stroke) {\n    if (_isContainerElement(element)) {\n      // Push fills and stroke width down to leaves\n      if (element.attributes['stroke-width']) {\n        strokeWidth = element.attributes['stroke-width'].value;\n      }\n      if (element.attributes) {\n        if (element.attributes.fill) fill = element.attributes.fill.value;\n        if (element.attributes.stroke) stroke = element.attributes.stroke.value;\n      } // If any child nodes don't take attributes, leave the attributes\n      // at the parent level.\n      for (var i = 0; i < element.childNodes.length; i++) {\n        applyTransforms(element.childNodes[i], Matrix.compose(matrix, _parseTransform(element)), strokeWidth, fill, stroke);\n      }\n      element.removeAttribute('transform');\n      element.removeAttribute('stroke-width');\n      element.removeAttribute('fill');\n      element.removeAttribute('stroke');\n    } else if (_isPathWithTransformAndStroke(element, strokeWidth)) {\n      if (element.attributes['stroke-width']) {\n        strokeWidth = element.attributes['stroke-width'].value;\n      }\n      if (element.attributes.fill) fill = element.attributes.fill.value;\n      if (element.attributes.stroke) stroke = element.attributes.stroke.value;\n      matrix = Matrix.compose(matrix, _parseTransform(element));\n      if (Matrix.toString(matrix) === Matrix.toString(Matrix.identity())) {\n        element.removeAttribute('transform');\n        element.setAttribute('stroke-width', strokeWidth);\n        if (fill) element.setAttribute('fill', fill);\n        if (stroke) element.setAttribute('stroke', stroke);\n        return;\n      } // Transform gradient\n      var fillGradientId = _parseUrl(fill, windowRef);\n      var strokeGradientId = _parseUrl(stroke, windowRef);\n      if (fillGradientId || strokeGradientId) {\n        var doc = windowRef.document; // Need path bounds to transform gradient\n        var svgSpot = doc.createElement('span');\n        var bbox;\n        if (bboxForTesting) {\n          bbox = bboxForTesting;\n        } else {\n          try {\n            doc.body.appendChild(svgSpot);\n            var svg = SvgElement.set(doc.createElementNS(SvgElement.svg, 'svg'));\n            var path = SvgElement.set(doc.createElementNS(SvgElement.svg, 'path'));\n            path.setAttribute('d', element.attributes.d.value);\n            svg.appendChild(path);\n            svgSpot.appendChild(svg); // Take the bounding box.\n            bbox = svg.getBBox();\n          } finally {\n            // Always destroy the element, even if, for example, getBBox throws.\n            doc.body.removeChild(svgSpot);\n          }\n        }\n        if (fillGradientId) {\n          var newFillRef = _createGradient(fillGradientId, svgTag, bbox, matrix);\n          if (newFillRef) fill = newFillRef;\n        }\n        if (strokeGradientId) {\n          var newStrokeRef = _createGradient(strokeGradientId, svgTag, bbox, matrix);\n          if (newStrokeRef) stroke = newStrokeRef;\n        }\n      } // Transform path data\n      element.setAttribute('d', _transformPath(element.attributes.d.value, matrix));\n      element.removeAttribute('transform'); // Transform stroke width\n      var matrixScale = _getScaleFactor(matrix);\n      element.setAttribute('stroke-width', _quadraticMean(matrixScale.x, matrixScale.y) * strokeWidth);\n      if (fill) element.setAttribute('fill', fill);\n      if (stroke) element.setAttribute('stroke', stroke);\n    } else if (_isGraphicsElement(element)) {\n      // Push stroke width, fill, and stroke down to leaves\n      if (strokeWidth && !element.attributes['stroke-width']) {\n        element.setAttribute('stroke-width', strokeWidth);\n      }\n      if (fill && !element.attributes.fill) {\n        element.setAttribute('fill', fill);\n      }\n      if (stroke && !element.attributes.stroke) {\n        element.setAttribute('stroke', stroke);\n      } // Push transform down to leaves\n      matrix = Matrix.compose(matrix, _parseTransform(element));\n      if (Matrix.toString(matrix) === Matrix.toString(Matrix.identity())) {\n        element.removeAttribute('transform');\n      } else {\n        element.setAttribute('transform', Matrix.toString(matrix));\n      }\n    }\n  };\n  applyTransforms(svgTag, inherited, 1\n  /* default SVG stroke width */\n  );\n};\nmodule.exports = transformStrokeWidths;\n })