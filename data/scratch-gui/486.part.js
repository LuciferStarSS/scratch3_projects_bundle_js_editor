/* 486 */\n (function(module, exports) {\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nvar Rectangle = function () {\n  /**\n   * A utility for creating and comparing axis-aligned rectangles.\n   * Rectangles are always initialized to the \"largest possible rectangle\";\n   * use one of the init* methods below to set up a particular rectangle.\n   * @constructor\n   */\n  function Rectangle() {\n    _classCallCheck(this, Rectangle);\n    this.left = -Infinity;\n    this.right = Infinity;\n    this.bottom = -Infinity;\n    this.top = Infinity;\n  }\n  /**\n   * Initialize a Rectangle from given Scratch-coordinate bounds.\n   * @param {number} left Left bound of the rectangle.\n   * @param {number} right Right bound of the rectangle.\n   * @param {number} bottom Bottom bound of the rectangle.\n   * @param {number} top Top bound of the rectangle.\n   */\n  _createClass(Rectangle, [{\n    key: \"initFromBounds\",\n    value: function initFromBounds(left, right, bottom, top) {\n      this.left = left;\n      this.right = right;\n      this.bottom = bottom;\n      this.top = top;\n    }\n    /**\n     * Initialize a Rectangle to the minimum AABB around a set of points.\n     * @param {Array<Array<number>>} points Array of [x, y] points.\n     */\n  }, {\n    key: \"initFromPointsAABB\",\n    value: function initFromPointsAABB(points) {\n      this.left = Infinity;\n      this.right = -Infinity;\n      this.top = -Infinity;\n      this.bottom = Infinity;\n      for (var i = 0; i < points.length; i++) {\n        var x = points[i][0];\n        var y = points[i][1];\n        if (x < this.left) {\n          this.left = x;\n        }\n        if (x > this.right) {\n          this.right = x;\n        }\n        if (y > this.top) {\n          this.top = y;\n        }\n        if (y < this.bottom) {\n          this.bottom = y;\n        }\n      }\n    }\n    /**\n     * Initialize a Rectangle to a 1 unit square centered at 0 x 0 transformed\n     * by a model matrix.\n     * @param {Array.<number>} m A 4x4 matrix to transform the rectangle by.\n     * @tutorial Rectangle-AABB-Matrix\n     */\n  }, {\n    key: \"initFromModelMatrix\",\n    value: function initFromModelMatrix(m) {\n      // In 2D space, we will soon use the 2x2 \"top left\" scale and rotation\n      // submatrix, while we store and the 1x2 \"top right\" that position\n      // vector.\n      var m30 = m[3 * 4 + 0];\n      var m31 = m[3 * 4 + 1]; // \"Transform\" a (0.5, 0.5) vector by the scale and rotation matrix but\n      // sum the absolute of each component instead of use the signed values.\n      var x = Math.abs(0.5 * m[0 * 4 + 0]) + Math.abs(0.5 * m[1 * 4 + 0]);\n      var y = Math.abs(0.5 * m[0 * 4 + 1]) + Math.abs(0.5 * m[1 * 4 + 1]); // And adding them to the position components initializes our Rectangle.\n      this.left = -x + m30;\n      this.right = x + m30;\n      this.top = y + m31;\n      this.bottom = -y + m31;\n    }\n    /**\n     * Determine if this Rectangle intersects some other.\n     * Note that this is a comparison assuming the Rectangle was\n     * initialized with Scratch-space bounds or points.\n     * @param {!Rectangle} other Rectangle to check if intersecting.\n     * @return {boolean} True if this Rectangle intersects other.\n     */\n  }, {\n    key: \"intersects\",\n    value: function intersects(other) {\n      return this.left <= other.right && other.left <= this.right && this.top >= other.bottom && other.top >= this.bottom;\n    }\n    /**\n     * Determine if this Rectangle fully contains some other.\n     * Note that this is a comparison assuming the Rectangle was\n     * initialized with Scratch-space bounds or points.\n     * @param {!Rectangle} other Rectangle to check if fully contained.\n     * @return {boolean} True if this Rectangle fully contains other.\n     */\n  }, {\n    key: \"contains\",\n    value: function contains(other) {\n      return other.left > this.left && other.right < this.right && other.top < this.top && other.bottom > this.bottom;\n    }\n    /**\n     * Clamp a Rectangle to bounds.\n     * @param {number} left Left clamp.\n     * @param {number} right Right clamp.\n     * @param {number} bottom Bottom clamp.\n     * @param {number} top Top clamp.\n     */\n  }, {\n    key: \"clamp\",\n    value: function clamp(left, right, bottom, top) {\n      this.left = Math.max(this.left, left);\n      this.right = Math.min(this.right, right);\n      this.bottom = Math.max(this.bottom, bottom);\n      this.top = Math.min(this.top, top);\n      this.left = Math.min(this.left, right);\n      this.right = Math.max(this.right, left);\n      this.bottom = Math.min(this.bottom, top);\n      this.top = Math.max(this.top, bottom);\n    }\n    /**\n     * Push out the Rectangle to integer bounds.\n     */\n  }, {\n    key: \"snapToInt\",\n    value: function snapToInt() {\n      this.left = Math.floor(this.left);\n      this.right = Math.ceil(this.right);\n      this.bottom = Math.floor(this.bottom);\n      this.top = Math.ceil(this.top);\n    }\n    /**\n     * Compute the intersection of two bounding Rectangles.\n     * Could be an impossible box if they don't intersect.\n     * @param {Rectangle} a One rectangle\n     * @param {Rectangle} b Other rectangle\n     * @param {?Rectangle} result A resulting storage rectangle  (safe to pass\n     *                            a or b if you want to overwrite one)\n     * @returns {Rectangle} resulting rectangle\n     */\n  }, {\n    key: \"width\",\n    /**\n     * Width of the Rectangle.\n     * @return {number} Width of rectangle.\n     */\n    get: function get() {\n      return Math.abs(this.left - this.right);\n    }\n    /**\n     * Height of the Rectangle.\n     * @return {number} Height of rectangle.\n     */\n  }, {\n    key: \"height\",\n    get: function get() {\n      return Math.abs(this.top - this.bottom);\n    }\n  }], [{\n    key: \"intersect\",\n    value: function intersect(a, b) {\n      var result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Rectangle();\n      result.left = Math.max(a.left, b.left);\n      result.right = Math.min(a.right, b.right);\n      result.top = Math.min(a.top, b.top);\n      result.bottom = Math.max(a.bottom, b.bottom);\n      return result;\n    }\n    /**\n     * Compute the union of two bounding Rectangles.\n     * @param {Rectangle} a One rectangle\n     * @param {Rectangle} b Other rectangle\n     * @param {?Rectangle} result A resulting storage rectangle  (safe to pass\n     *                            a or b if you want to overwrite one)\n     * @returns {Rectangle} resulting rectangle\n     */\n  }, {\n    key: \"union\",\n    value: function union(a, b) {\n      var result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Rectangle();\n      result.left = Math.min(a.left, b.left);\n      result.right = Math.max(a.right, b.right); // Scratch Space - +y is up\n      result.top = Math.max(a.top, b.top);\n      result.bottom = Math.min(a.bottom, b.bottom);\n      return result;\n    }\n  }]);\n  return Rectangle;\n}();\nmodule.exports = Rectangle;\n })