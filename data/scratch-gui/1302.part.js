/* 1302 */\n (function(module, exports, __webpack_require__) {\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nvar base64js = __webpack_require__(1303);\n/**\n * Adapts Scratch 2.0 bitmaps for use in scratch 3.0\n */\nvar BitmapAdapter = function () {\n  /**\n   * @param {?function} makeImage HTML image constructor. Tests can provide this.\n   * @param {?function} makeCanvas HTML canvas constructor. Tests can provide this.\n   */\n  function BitmapAdapter(makeImage, makeCanvas) {\n    _classCallCheck(this, BitmapAdapter);\n    this._makeImage = makeImage ? makeImage : function () {\n      return new Image();\n    };\n    this._makeCanvas = makeCanvas ? makeCanvas : function () {\n      return document.createElement('canvas');\n    };\n  } // Returns a canvas with the resized image\n  _createClass(BitmapAdapter, [{\n    key: \"resize\",\n    value: function resize(image, newWidth, newHeight) {\n      // Resize in a 2 step process, matching width first, then height, in order\n      // to preserve nearest-neighbor sampling.\n      var stretchWidthCanvas = this._makeCanvas();\n      stretchWidthCanvas.width = newWidth;\n      stretchWidthCanvas.height = image.height;\n      var context = stretchWidthCanvas.getContext('2d',{willReadFrequently:true});\n      context.imageSmoothingEnabled = false;\n      context.drawImage(image, 0, 0, stretchWidthCanvas.width, stretchWidthCanvas.height);\n      var stretchHeightCanvas = this._makeCanvas();\n      stretchHeightCanvas.width = newWidth;\n      stretchHeightCanvas.height = newHeight;\n      context = stretchHeightCanvas.getContext('2d',{willReadFrequently:true});\n      context.imageSmoothingEnabled = false;\n      context.drawImage(stretchWidthCanvas, 0, 0, stretchHeightCanvas.width, stretchHeightCanvas.height);\n      return stretchHeightCanvas;\n    }\n    /**\n     * Scratch 2.0 had resolution 1 and 2 bitmaps. All bitmaps in Scratch 3.0 are equivalent\n     * to resolution 2 bitmaps. Therefore, converting a resolution 1 bitmap means doubling\n     * it in width and height.\n     * @param {!string} dataURI Base 64 encoded image data of the bitmap\n     * @param {!function} callback Node-style callback that returns updated dataURI if conversion succeeded\n     */\n  }, {\n    key: \"convertResolution1Bitmap\",\n    value: function convertResolution1Bitmap(dataURI, callback) {\n      var _this = this;\n      var image = this._makeImage();\n      image.src = dataURI;\n      image.onload = function () {\n        callback(null, _this.resize(image, image.width * 2, image.height * 2).toDataURL());\n      };\n      image.onerror = function () {\n        callback('Image load failed');\n      };\n    }\n    /**\n     * Given width/height of an uploaded item, return width/height the image will be resized\n     * to in Scratch 3.0\n     * @param {!number} oldWidth original width\n     * @param {!number} oldHeight original height\n     * @return {object} Array of new width, new height\n     */\n  }, {\n    key: \"getResizedWidthHeight\",\n    value: function getResizedWidthHeight(oldWidth, oldHeight) {\n      var STAGE_WIDTH = 480;\n      var STAGE_HEIGHT = 360;\n      var STAGE_RATIO = STAGE_WIDTH / STAGE_HEIGHT; // If both dimensions are smaller than or equal to corresponding stage dimension,\n      // double both dimensions\n      if (oldWidth <= STAGE_WIDTH && oldHeight <= STAGE_HEIGHT) {\n        return {\n          width: oldWidth * 2,\n          height: oldHeight * 2\n        };\n      } // If neither dimension is larger than 2x corresponding stage dimension,\n      // this is an in-between image, return it as is\n      if (oldWidth <= STAGE_WIDTH * 2 && oldHeight <= STAGE_HEIGHT * 2) {\n        return {\n          width: oldWidth,\n          height: oldHeight\n        };\n      }\n      var imageRatio = oldWidth / oldHeight; // Otherwise, figure out how to resize\n      if (imageRatio >= STAGE_RATIO) {\n        // Wide Image\n        return {\n          width: STAGE_WIDTH * 2,\n          height: STAGE_WIDTH * 2 / imageRatio\n        };\n      } // In this case we have either:\n      // - A wide image, but not with as big a ratio between width and height,\n      // making it so that fitting the width to double stage size would leave\n      // the height too big to fit in double the stage height\n      // - A square image that's still larger than the double at least\n      // one of the stage dimensions, so pick the smaller of the two dimensions (to fit)\n      // - A tall image\n      // In any of these cases, resize the image to fit the height to double the stage height\n      return {\n        width: STAGE_HEIGHT * 2 * imageRatio,\n        height: STAGE_HEIGHT * 2\n      };\n    }\n    /**\n     * Given bitmap data, resize as necessary.\n     * @param {ArrayBuffer | string} fileData Base 64 encoded image data of the bitmap\n     * @param {string} fileType The MIME type of this file\n     * @returns {Promise} Resolves to resized image data Uint8Array\n     */\n  }, {\n    key: \"importBitmap\",\n    value: function importBitmap(fileData, fileType) {\n      var _this2 = this;\n      var dataURI = fileData;\n      if (fileData instanceof ArrayBuffer) {\n        dataURI = this.convertBinaryToDataURI(fileData, fileType);\n      }\n      return new Promise(function (resolve, reject) {\n        var image = _this2._makeImage();\n        image.src = dataURI;\n        image.onload = function () {\n          var newSize = _this2.getResizedWidthHeight(image.width, image.height);\n          if (newSize.width === image.width && newSize.height === image.height) {\n            // No change\n            resolve(_this2.convertDataURIToBinary(dataURI));\n          } else {\n            var resizedDataURI = _this2.resize(image, newSize.width, newSize.height).toDataURL();\n            resolve(_this2.convertDataURIToBinary(resizedDataURI));\n          }\n        };\n        image.onerror = function () {\n          reject('Image load failed');\n        };\n      });\n    } // TODO consolidate with scratch-vm/src/util/base64-util.js\n    // From https://gist.github.com/borismus/1032746\n  }, {\n    key: \"convertDataURIToBinary\",\n    value: function convertDataURIToBinary(dataURI) {\n      var BASE64_MARKER = ';base64,';\n      var base64Index = dataURI.indexOf(BASE64_MARKER) + BASE64_MARKER.length;\n      var base64 = dataURI.substring(base64Index);\n      var raw = window.atob(base64);\n      var rawLength = raw.length;\n      var array = new Uint8Array(new ArrayBuffer(rawLength));\n      for (var i = 0; i < rawLength; i++) {\n        array[i] = raw.charCodeAt(i);\n      }\n      return array;\n    }\n  }, {\n    key: \"convertBinaryToDataURI\",\n    value: function convertBinaryToDataURI(arrayBuffer, contentType) {\n      return \"data:\".concat(contentType, \";base64,\").concat(base64js.fromByteArray(new Uint8Array(arrayBuffer)));\n    }\n  }]);\n  return BitmapAdapter;\n}();\nmodule.exports = BitmapAdapter;\n })