/* 1189 */\n (function(module, exports, __webpack_require__) {\n\"use strict\";\n/*\nCopyright (c) 2014, Yahoo! Inc. All rights reserved.\nCopyrights licensed under the New BSD License.\nSee the accompanying LICENSE file for terms.\n*/\n/* jslint esnext: true */\nvar src$utils$$ = __webpack_require__(482), src$es5$$ = __webpack_require__(1190), src$compiler$$ = __webpack_require__(1191), intl$messageformat$parser$$ = __webpack_require__(1192);\nexports[\"default\"] = MessageFormat;\n// -- MessageFormat --------------------------------------------------------\nfunction MessageFormat(message, locales, formats) {\n    // Parse string messages into an AST.\n    var ast = typeof message === 'string' ?\n            MessageFormat.__parse(message) : message;\n    if (!(ast && ast.type === 'messageFormatPattern')) {\n        throw new TypeError('A message must be provided as a String or AST.');\n    }\n    // Creates a new object with the specified `formats` merged with the default\n    // formats.\n    formats = this._mergeFormats(MessageFormat.formats, formats);\n    // Defined first because it's used to build the format pattern.\n    src$es5$$.defineProperty(this, '_locale',  {value: this._resolveLocale(locales)});\n    // Compile the `ast` to a pattern that is highly optimized for repeated\n    // `format()` invocations. **Note:** This passes the `locales` set provided\n    // to the constructor instead of just the resolved locale.\n    var pluralFn = this._findPluralRuleFunction(this._locale);\n    var pattern  = this._compilePattern(ast, locales, formats, pluralFn);\n    // \"Bind\" `format()` method to `this` so it can be passed by reference like\n    // the other `Intl` APIs.\n    var messageFormat = this;\n    this.format = function (values) {\n      try {\n        return messageFormat._format(pattern, values);\n      } catch (e) {\n        if (e.variableId) {\n          throw new Error(\n            'The intl string context variable \\'' + e.variableId + '\\'' +\n            ' was not provided to the string \\'' + message + '\\''\n          );\n        } else {\n          throw e;\n        }\n      }\n    };\n}\n// Default format options used as the prototype of the `formats` provided to the\n// constructor. These are used when constructing the internal Intl.NumberFormat\n// and Intl.DateTimeFormat instances.\nsrc$es5$$.defineProperty(MessageFormat, 'formats', {\n    enumerable: true,\n    value: {\n        number: {\n            'currency': {\n                style: 'currency'\n            },\n            'percent': {\n                style: 'percent'\n            }\n        },\n        date: {\n            'short': {\n                month: 'numeric',\n                day  : 'numeric',\n                year : '2-digit'\n            },\n            'medium': {\n                month: 'short',\n                day  : 'numeric',\n                year : 'numeric'\n            },\n            'long': {\n                month: 'long',\n                day  : 'numeric',\n                year : 'numeric'\n            },\n            'full': {\n                weekday: 'long',\n                month  : 'long',\n                day    : 'numeric',\n                year   : 'numeric'\n            }\n        },\n        time: {\n            'short': {\n                hour  : 'numeric',\n                minute: 'numeric'\n            },\n            'medium':  {\n                hour  : 'numeric',\n                minute: 'numeric',\n                second: 'numeric'\n            },\n            'long': {\n                hour        : 'numeric',\n                minute      : 'numeric',\n                second      : 'numeric',\n                timeZoneName: 'short'\n            },\n            'full': {\n                hour        : 'numeric',\n                minute      : 'numeric',\n                second      : 'numeric',\n                timeZoneName: 'short'\n            }\n        }\n    }\n});\n// Define internal private properties for dealing with locale data.\nsrc$es5$$.defineProperty(MessageFormat, '__localeData__', {value: src$es5$$.objCreate(null)});\nsrc$es5$$.defineProperty(MessageFormat, '__addLocaleData', {value: function (data) {\n    if (!(data && data.locale)) {\n        throw new Error(\n            'Locale data provided to IntlMessageFormat is missing a ' +\n            '`locale` property'\n        );\n    }\n    MessageFormat.__localeData__[data.locale.toLowerCase()] = data;\n}});\n// Defines `__parse()` static method as an exposed private.\nsrc$es5$$.defineProperty(MessageFormat, '__parse', {value: intl$messageformat$parser$$[\"default\"].parse});\n// Define public `defaultLocale` property which defaults to English, but can be\n// set by the developer.\nsrc$es5$$.defineProperty(MessageFormat, 'defaultLocale', {\n    enumerable: true,\n    writable  : true,\n    value     : undefined\n});\nMessageFormat.prototype.resolvedOptions = function () {\n    // TODO: Provide anything else?\n    return {\n        locale: this._locale\n    };\n};\nMessageFormat.prototype._compilePattern = function (ast, locales, formats, pluralFn) {\n    var compiler = new src$compiler$$[\"default\"](locales, formats, pluralFn);\n    return compiler.compile(ast);\n};\nMessageFormat.prototype._findPluralRuleFunction = function (locale) {\n    var localeData = MessageFormat.__localeData__;\n    var data       = localeData[locale.toLowerCase()];\n    // The locale data is de-duplicated, so we have to traverse the locale's\n    // hierarchy until we find a `pluralRuleFunction` to return.\n    while (data) {\n        if (data.pluralRuleFunction) {\n            return data.pluralRuleFunction;\n        }\n        data = data.parentLocale && localeData[data.parentLocale.toLowerCase()];\n    }\n    throw new Error(\n        'Locale data added to IntlMessageFormat is missing a ' +\n        '`pluralRuleFunction` for :' + locale\n    );\n};\nMessageFormat.prototype._format = function (pattern, values) {\n    var result = '',\n        i, len, part, id, value, err;\n    for (i = 0, len = pattern.length; i < len; i += 1) {\n        part = pattern[i];\n        // Exist early for string parts.\n        if (typeof part === 'string') {\n            result += part;\n            continue;\n        }\n        id = part.id;\n        // Enforce that all required values are provided by the caller.\n        if (!(values && src$utils$$.hop.call(values, id))) {\n          err = new Error('A value must be provided for: ' + id);\n          err.variableId = id;\n          throw err;\n        }\n        value = values[id];\n        // Recursively format plural and select parts' option â€” which can be a\n        // nested pattern structure. The choosing of the option to use is\n        // abstracted-by and delegated-to the part helper object.\n        if (part.options) {\n            result += this._format(part.getOption(value), values);\n        } else {\n            result += part.format(value);\n        }\n    }\n    return result;\n};\nMessageFormat.prototype._mergeFormats = function (defaults, formats) {\n    var mergedFormats = {},\n        type, mergedType;\n    for (type in defaults) {\n        if (!src$utils$$.hop.call(defaults, type)) { continue; }\n        mergedFormats[type] = mergedType = src$es5$$.objCreate(defaults[type]);\n        if (formats && src$utils$$.hop.call(formats, type)) {\n            src$utils$$.extend(mergedType, formats[type]);\n        }\n    }\n    return mergedFormats;\n};\nMessageFormat.prototype._resolveLocale = function (locales) {\n    if (typeof locales === 'string') {\n        locales = [locales];\n    }\n    // Create a copy of the array so we can push on the default locale.\n    locales = (locales || []).concat(MessageFormat.defaultLocale);\n    var localeData = MessageFormat.__localeData__;\n    var i, len, localeParts, data;\n    // Using the set of locales + the default locale, we look for the first one\n    // which that has been registered. When data does not exist for a locale, we\n    // traverse its ancestors to find something that's been registered within\n    // its hierarchy of locales. Since we lack the proper `parentLocale` data\n    // here, we must take a naive approach to traversal.\n    for (i = 0, len = locales.length; i < len; i += 1) {\n        localeParts = locales[i].toLowerCase().split('-');\n        while (localeParts.length) {\n            data = localeData[localeParts.join('-')];\n            if (data) {\n                // Return the normalized locale string; e.g., we return \"en-US\",\n                // instead of \"en-us\".\n                return data.locale;\n            }\n            localeParts.pop();\n        }\n    }\n    var defaultLocale = locales.pop();\n    throw new Error(\n        'No locale data has been added to IntlMessageFormat for: ' +\n        locales.join(', ') + ', or the default locale: ' + defaultLocale\n    );\n};\n/*# sourceMappingURL=core.js.map*/ })