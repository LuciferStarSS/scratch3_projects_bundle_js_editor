/* 1237 */\n (function(module, exports, __webpack_require__) {\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nvar log = __webpack_require__(229);\n/**\n * A symbol indicating all targets are to be effected.\n * @const {string}\n */\nvar ALL_TARGETS = '*';\nvar SoundBank = function () {\n  /**\n   * A bank of sounds that can be played.\n   * @constructor\n   * @param {AudioEngine} audioEngine - related AudioEngine\n   * @param {EffectChain} effectChainPrime - original EffectChain cloned for\n   *     playing sounds\n   */\n  function SoundBank(audioEngine, effectChainPrime) {\n    _classCallCheck(this, SoundBank);\n    /**\n     * AudioEngine this SoundBank is related to.\n     * @type {AudioEngine}\n     */\n    this.audioEngine = audioEngine;\n    /**\n     * Map of ids to soundPlayers.\n     * @type {object<SoundPlayer>}\n     */\n    this.soundPlayers = {};\n    /**\n     * Map of targets by sound id.\n     * @type {Map<string, Target>}\n     */\n    this.playerTargets = new Map();\n    /**\n     * Map of effect chains by sound id.\n     * @type {Map<string, EffectChain}\n     */\n    this.soundEffects = new Map();\n    /**\n     * Original EffectChain cloned for every playing sound.\n     * @type {EffectChain}\n     */\n    this.effectChainPrime = effectChainPrime;\n  }\n  /**\n   * Add a sound player instance likely from AudioEngine.decodeSoundPlayer\n   * @param {SoundPlayer} soundPlayer - SoundPlayer to add\n   */\n  _createClass(SoundBank, [{\n    key: \"addSoundPlayer\",\n    value: function addSoundPlayer(soundPlayer) {\n      this.soundPlayers[soundPlayer.id] = soundPlayer;\n    }\n    /**\n     * Get a sound player by id.\n     * @param {string} soundId - sound to look for\n     * @returns {SoundPlayer} instance of sound player for the id\n     */\n  }, {\n    key: \"getSoundPlayer\",\n    value: function getSoundPlayer(soundId) {\n      if (!this.soundPlayers[soundId]) {\n        log.error(\"SoundBank.getSoundPlayer(\".concat(soundId, \"): called missing sound in bank\"));\n      }\n      return this.soundPlayers[soundId];\n    }\n    /**\n     * Get a sound EffectChain by id.\n     * @param {string} sound - sound to look for an EffectChain\n     * @returns {EffectChain} available EffectChain for this id\n     */\n  }, {\n    key: \"getSoundEffects\",\n    value: function getSoundEffects(sound) {\n      if (!this.soundEffects.has(sound)) {\n        this.soundEffects.set(sound, this.effectChainPrime.clone());\n      }\n      return this.soundEffects.get(sound);\n    }\n    /**\n     * Play a sound.\n     * @param {Target} target - Target to play for\n     * @param {string} soundId - id of sound to play\n     * @returns {Promise} promise that resolves when the sound finishes playback\n     */\n  }, {\n    key: \"playSound\",\n    value: function playSound(target, soundId) {\n      var effects = this.getSoundEffects(soundId);\n      var player = this.getSoundPlayer(soundId);\n      if (this.playerTargets.get(soundId) !== target) {\n        // make sure to stop the old sound, effectively \"forking\" the output\n        // when the target switches before we adjust it's effects\n        player.stop();\n      }\n      this.playerTargets.set(soundId, target);\n      effects.addSoundPlayer(player);\n      effects.setEffectsFromTarget(target);\n      player.connect(effects);\n      player.play();\n      return player.finished();\n    }\n    /**\n     * Set the effects (pan, pitch, and volume) from values on the given target.\n     * @param {Target} target - target to set values from\n     */\n  }, {\n    key: \"setEffects\",\n    value: function setEffects(target) {\n      var _this = this;\n      this.playerTargets.forEach(function (playerTarget, key) {\n        if (playerTarget === target) {\n          _this.getSoundEffects(key).setEffectsFromTarget(target);\n        }\n      });\n    }\n    /**\n     * Stop playback of sound by id if was lasted played by the target.\n     * @param {Target} target - target to check if it last played the sound\n     * @param {string} soundId - id of the sound to stop\n     */\n  }, {\n    key: \"stop\",\n    value: function stop(target, soundId) {\n      if (this.playerTargets.get(soundId) === target) {\n        this.soundPlayers[soundId].stop();\n      }\n    }\n    /**\n     * Stop all sounds for all targets or a specific target.\n     * @param {Target|string} target - a symbol for all targets or the target\n     *     to stop sounds for\n     */\n  }, {\n    key: \"stopAllSounds\",\n    value: function stopAllSounds() {\n      var _this2 = this;\n      var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ALL_TARGETS;\n      this.playerTargets.forEach(function (playerTarget, key) {\n        if (target === ALL_TARGETS || playerTarget === target) {\n          _this2.getSoundPlayer(key).stop();\n        }\n      });\n    }\n    /**\n     * Dispose of all EffectChains and SoundPlayers.\n     */\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.playerTargets.clear();\n      this.soundEffects.forEach(function (effects) {\n        return effects.dispose();\n      });\n      this.soundEffects.clear();\n      for (var soundId in this.soundPlayers) {\n        if (this.soundPlayers.hasOwnProperty(soundId)) {\n          this.soundPlayers[soundId].dispose();\n        }\n      }\n      this.soundPlayers = {};\n    }\n  }]);\n  return SoundBank;\n}();\nmodule.exports = SoundBank;\n })