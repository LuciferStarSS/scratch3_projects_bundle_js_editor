/* 1239 */\n (function(module, exports, __webpack_require__) {\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nvar EventEmitter = __webpack_require__(91);\nvar hull = __webpack_require__(1240);\nvar twgl = __webpack_require__(103);\nvar BitmapSkin = __webpack_require__(1245);\nvar Drawable = __webpack_require__(1247);\nvar Rectangle = __webpack_require__(486);\nvar PenSkin = __webpack_require__(1250);\nvar RenderConstants = __webpack_require__(230);\nvar ShaderManager = __webpack_require__(188);\nvar SVGSkin = __webpack_require__(1251);\nvar TextBubbleSkin = __webpack_require__(1266);\nvar EffectTransform = __webpack_require__(487);\nvar log = __webpack_require__(488);\nvar __isTouchingDrawablesPoint = twgl.v3.create();\nvar __candidatesBounds = new Rectangle();\nvar __fenceBounds = new Rectangle();\nvar __touchingColor = new Uint8ClampedArray(4);\nvar __blendColor = new Uint8ClampedArray(4); // More pixels than this and we give up to the GPU and take the cost of readPixels\n// Width * Height * Number of drawables at location\nvar __cpuTouchingColorPixelCount = 4e4;\n/**\n * @callback RenderWebGL#idFilterFunc\n * @param {int} drawableID The ID to filter.\n * @return {bool} True if the ID passes the filter, otherwise false.\n */\n/**\n * Maximum touch size for a picking check.\n * @todo Figure out a reasonable max size. Maybe this should be configurable?\n * @type {Array<int>}\n * @memberof RenderWebGL\n */\nvar MAX_TOUCH_SIZE = [3, 3];\n/**\n * Passed to the uniforms for mask in touching color\n */\nvar MASK_TOUCHING_COLOR_TOLERANCE = 2;\n/**\n * Maximum number of pixels in either dimension of \"extracted drawable\" data\n * @type {int}\n */\nvar MAX_EXTRACTED_DRAWABLE_DIMENSION = 2048;\n/**\n * Determines if the mask color is \"close enough\" (only test the 6 top bits for\n * each color).  These bit masks are what scratch 2 used to use, so we do the same.\n * @param {Uint8Array} a A color3b or color4b value.\n * @param {Uint8Array} b A color3b or color4b value.\n * @returns {boolean} If the colors match within the parameters.\n */\nvar maskMatches = function maskMatches(a, b) {\n  return (// has some non-alpha component to test against\n    a[3] > 0 && (a[0] & 252) === (b[0] & 252) && (a[1] & 252) === (b[1] & 252) && (a[2] & 252) === (b[2] & 252)\n  );\n};\n/**\n * Determines if the given color is \"close enough\" (only test the 5 top bits for\n * red and green, 4 bits for blue).  These bit masks are what scratch 2 used to use,\n * so we do the same.\n * @param {Uint8Array} a A color3b or color4b value.\n * @param {Uint8Array} b A color3b or color4b value / or a larger array when used with offsets\n * @param {number} offset An offset into the `b` array, which lets you use a larger array to test\n *                  multiple values at the same time.\n * @returns {boolean} If the colors match within the parameters.\n */\nvar colorMatches = function colorMatches(a, b, offset) {\n  return (a[0] & 248) === (b[offset + 0] & 248) && (a[1] & 248) === (b[offset + 1] & 248) && (a[2] & 240) === (b[offset + 2] & 240);\n};\n/**\n * Sprite Fencing - The number of pixels a sprite is required to leave remaining\n * onscreen around the edge of the staging area.\n * @type {number}\n */\nvar FENCE_WIDTH = 15;\nvar RenderWebGL = function (_EventEmitter) {\n  _inherits(RenderWebGL, _EventEmitter);\n  var _super = _createSuper(RenderWebGL);\n  _createClass(RenderWebGL, null, [{\n    key: \"isSupported\",\n    /**\n     * Check if this environment appears to support this renderer before attempting to create an instance.\n     * Catching an exception from the constructor is also a valid way to test for (lack of) support.\n     * @param {canvas} [optCanvas] - An optional canvas to use for the test. Otherwise a temporary canvas will be used.\n     * @returns {boolean} - True if this environment appears to support this renderer, false otherwise.\n     */\n    value: function isSupported(optCanvas) {\n      try {\n        // Create the context the same way that the constructor will: attributes may make the difference.\n        return !!RenderWebGL._getContext(optCanvas || document.createElement('canvas'));\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * Ask TWGL to create a rendering context with the attributes used by this renderer.\n     * @param {canvas} canvas - attach the context to this canvas.\n     * @returns {WebGLRenderingContext} - a TWGL rendering context (backed by either WebGL 1.0 or 2.0).\n     * @private\n     */\n  }, {\n    key: \"_getContext\",\n    value: function _getContext(canvas) {\n      return twgl.getWebGLContext(canvas, {\n        alpha: false,\n        stencil: true,\n        antialias: false\n      });\n    }\n    /**\n     * Create a renderer for drawing Scratch sprites to a canvas using WebGL.\n     * Coordinates will default to Scratch 2.0 values if unspecified.\n     * The stage's \"native\" size will be calculated from the these coordinates.\n     * For example, the defaults result in a native size of 480x360.\n     * Queries such as \"touching color?\" will always execute at the native size.\n     * @see RenderWebGL#setStageSize\n     * @see RenderWebGL#resize\n     * @param {canvas} canvas The canvas to draw onto.\n     * @param {int} [xLeft=-240] The x-coordinate of the left edge.\n     * @param {int} [xRight=240] The x-coordinate of the right edge.\n     * @param {int} [yBottom=-180] The y-coordinate of the bottom edge.\n     * @param {int} [yTop=180] The y-coordinate of the top edge.\n     * @constructor\n     * @listens RenderWebGL#event:NativeSizeChanged\n     */\n  }]);\n  function RenderWebGL(canvas, xLeft, xRight, yBottom, yTop) {\n    var _this;\n    _classCallCheck(this, RenderWebGL);\n    _this = _super.call(this);\n    /** @type {WebGLRenderingContext} */\n    var gl = _this._gl = RenderWebGL._getContext(canvas);\n    if (!gl) {\n      throw new Error('Could not get WebGL context: this browser or environment may not support WebGL.');\n    }\n    /** @type {RenderWebGL.UseGpuModes} */\n    _this._useGpuMode = RenderWebGL.UseGpuModes.Automatic;\n    /** @type {Drawable[]} */\n    _this._allDrawables = [];\n    /** @type {Skin[]} */\n    _this._allSkins = [];\n    /** @type {Array<int>} */\n    _this._drawList = []; // A list of layer group names in the order they should appear\n    // from furthest back to furthest in front.\n    /** @type {Array<String>} */\n    _this._groupOrdering = [];\n    /**\n     * @typedef LayerGroup\n     * @property {int} groupIndex The relative position of this layer group in the group ordering\n     * @property {int} drawListOffset The absolute position of this layer group in the draw list\n     * This number gets updated as drawables get added to or deleted from the draw list.\n     */\n    // Map of group name to layer group\n    /** @type {Object.<string, LayerGroup>} */\n    _this._layerGroups = {};\n    /** @type {int} */\n    _this._nextDrawableId = RenderConstants.ID_NONE + 1;\n    /** @type {int} */\n    _this._nextSkinId = RenderConstants.ID_NONE + 1;\n    /** @type {module:twgl/m4.Mat4} */\n    _this._projection = twgl.m4.identity();\n    /** @type {ShaderManager} */\n    _this._shaderManager = new ShaderManager(gl);\n    /** @type {HTMLCanvasElement} */\n    _this._tempCanvas = document.createElement('canvas');\n    /** @type {any} */\n    _this._regionId = null;\n    /** @type {function} */\n    _this._exitRegion = null;\n    /** @type {object} */\n    _this._backgroundDrawRegionId = {\n      enter: function enter() {\n        return _this._enterDrawBackground();\n      },\n      exit: function exit() {\n        return _this._exitDrawBackground();\n      }\n    };\n    /** @type {Array.<snapshotCallback>} */\n    _this._snapshotCallbacks = [];\n    /** @type {Array<number>} */\n    // Don't set this directly-- use setBackgroundColor so it stays in sync with _backgroundColor3b\n    _this._backgroundColor4f = [0, 0, 0, 1];\n    /** @type {Uint8ClampedArray} */\n    // Don't set this directly-- use setBackgroundColor so it stays in sync with _backgroundColor4f\n    _this._backgroundColor3b = new Uint8ClampedArray(3);\n    _this._createGeometry();\n    _this.on(RenderConstants.Events.NativeSizeChanged, _this.onNativeSizeChanged);\n    _this.setBackgroundColor(1, 1, 1);\n    _this.setStageSize(xLeft || -240, xRight || 240, yBottom || -180, yTop || 180);\n    _this.resize(_this._nativeSize[0], _this._nativeSize[1]);\n    gl.disable(gl.DEPTH_TEST);\n    /** @todo disable when no partial transparency? */\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n    return _this;\n  }\n  /**\n   * @returns {WebGLRenderingContext} the WebGL rendering context associated with this renderer.\n   */\n  _createClass(RenderWebGL, [{\n    key: \"resize\",\n    /**\n     * Set the physical size of the stage in device-independent pixels.\n     * This will be multiplied by the device's pixel ratio on high-DPI displays.\n     * @param {int} pixelsWide The desired width in device-independent pixels.\n     * @param {int} pixelsTall The desired height in device-independent pixels.\n     */\n    value: function resize(pixelsWide, pixelsTall) {\n      var canvas = this._gl.canvas;\n      var pixelRatio = window.devicePixelRatio || 1;\n      var newWidth = pixelsWide * pixelRatio;\n      var newHeight = pixelsTall * pixelRatio; // Certain operations, such as moving the color picker, call `resize` once per frame, even though the canvas\n      // size doesn't change. To avoid unnecessary canvas updates, check that we *really* need to resize the canvas.\n      if (canvas.width !== newWidth || canvas.height !== newHeight) {\n        canvas.width = newWidth;\n        canvas.height = newHeight; // Resizing the canvas causes it to be cleared, so redraw it.\n        this.draw();\n      }\n    }\n    /**\n     * Set the background color for the stage. The stage will be cleared with this\n     * color each frame.\n     * @param {number} red The red component for the background.\n     * @param {number} green The green component for the background.\n     * @param {number} blue The blue component for the background.\n     */\n  }, {\n    key: \"setBackgroundColor\",\n    value: function setBackgroundColor(red, green, blue) {\n      this._backgroundColor4f[0] = red;\n      this._backgroundColor4f[1] = green;\n      this._backgroundColor4f[2] = blue;\n      this._backgroundColor3b[0] = red * 255;\n      this._backgroundColor3b[1] = green * 255;\n      this._backgroundColor3b[2] = blue * 255;\n    }\n    /**\n     * Tell the renderer to draw various debug information to the provided canvas\n     * during certain operations.\n     * @param {canvas} canvas The canvas to use for debug output.\n     */\n  }, {\n    key: \"setDebugCanvas\",\n    value: function setDebugCanvas(canvas) {\n      this._debugCanvas = canvas;\n    }\n    /**\n     * Control the use of the GPU or CPU paths in `isTouchingColor`.\n     * @param {RenderWebGL.UseGpuModes} useGpuMode - automatically decide, force CPU, or force GPU.\n     */\n  }, {\n    key: \"setUseGpuMode\",\n    value: function setUseGpuMode(useGpuMode) {\n      this._useGpuMode = useGpuMode;\n    }\n    /**\n     * Set logical size of the stage in Scratch units.\n     * @param {int} xLeft The left edge's x-coordinate. Scratch 2 uses -240.\n     * @param {int} xRight The right edge's x-coordinate. Scratch 2 uses 240.\n     * @param {int} yBottom The bottom edge's y-coordinate. Scratch 2 uses -180.\n     * @param {int} yTop The top edge's y-coordinate. Scratch 2 uses 180.\n     */\n  }, {\n    key: \"setStageSize\",\n    value: function setStageSize(xLeft, xRight, yBottom, yTop) {\n      this._xLeft = xLeft;\n      this._xRight = xRight;\n      this._yBottom = yBottom;\n      this._yTop = yTop; // swap yBottom & yTop to fit Scratch convention of +y=up\n      this._projection = twgl.m4.ortho(xLeft, xRight, yBottom, yTop, -1, 1);\n      this._setNativeSize(Math.abs(xRight - xLeft), Math.abs(yBottom - yTop));\n    }\n    /**\n     * @return {Array<int>} the \"native\" size of the stage, which is used for pen, query renders, etc.\n     */\n  }, {\n    key: \"getNativeSize\",\n    value: function getNativeSize() {\n      return [this._nativeSize[0], this._nativeSize[1]];\n    }\n    /**\n     * Set the \"native\" size of the stage, which is used for pen, query renders, etc.\n     * @param {int} width - the new width to set.\n     * @param {int} height - the new height to set.\n     * @private\n     * @fires RenderWebGL#event:NativeSizeChanged\n     */\n  }, {\n    key: \"_setNativeSize\",\n    value: function _setNativeSize(width, height) {\n      this._nativeSize = [width, height];\n      this.emit(RenderConstants.Events.NativeSizeChanged, {\n        newSize: this._nativeSize\n      });\n    }\n    /**\n     * Create a new bitmap skin from a snapshot of the provided bitmap data.\n     * @param {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} bitmapData - new contents for this skin.\n     * @param {!int} [costumeResolution=1] - The resolution to use for this bitmap.\n     * @param {?Array<number>} [rotationCenter] Optional: rotation center of the skin. If not supplied, the center of\n     * the skin will be used.\n     * @returns {!int} the ID for the new skin.\n     */\n  }, {\n    key: \"createBitmapSkin\",\n    value: function createBitmapSkin(bitmapData, costumeResolution, rotationCenter) {\n      var skinId = this._nextSkinId++;\n      var newSkin = new BitmapSkin(skinId, this);\n      newSkin.setBitmap(bitmapData, costumeResolution, rotationCenter);\n      this._allSkins[skinId] = newSkin;\n      return skinId;\n    }\n    /**\n     * Create a new SVG skin.\n     * @param {!string} svgData - new SVG to use.\n     * @param {?Array<number>} rotationCenter Optional: rotation center of the skin. If not supplied, the center of the\n     * skin will be used\n     * @returns {!int} the ID for the new skin.\n     */\n  }, {\n    key: \"createSVGSkin\",\n    value: function createSVGSkin(svgData, rotationCenter) {\n      var skinId = this._nextSkinId++;\n      var newSkin = new SVGSkin(skinId, this);\n      newSkin.setSVG(svgData, rotationCenter);\n      this._allSkins[skinId] = newSkin;\n      return skinId;\n    }\n    /**\n     * Create a new PenSkin - a skin which implements a Scratch pen layer.\n     * @returns {!int} the ID for the new skin.\n     */\n  }, {\n    key: \"createPenSkin\",\n    value: function createPenSkin() {\n      var skinId = this._nextSkinId++;\n      var newSkin = new PenSkin(skinId, this);\n      this._allSkins[skinId] = newSkin;\n      return skinId;\n    }\n    /**\n     * Create a new SVG skin using the text bubble svg creator. The rotation center\n     * is always placed at the top left.\n     * @param {!string} type - either \"say\" or \"think\".\n     * @param {!string} text - the text for the bubble.\n     * @param {!boolean} pointsLeft - which side the bubble is pointing.\n     * @returns {!int} the ID for the new skin.\n     */\n  }, {\n    key: \"createTextSkin\",\n    value: function createTextSkin(type, text, pointsLeft) {\n      var skinId = this._nextSkinId++;\n      var newSkin = new TextBubbleSkin(skinId, this);\n      newSkin.setTextBubble(type, text, pointsLeft);\n      this._allSkins[skinId] = newSkin;\n      return skinId;\n    }\n    /**\n     * Update an existing SVG skin, or create an SVG skin if the previous skin was not SVG.\n     * @param {!int} skinId the ID for the skin to change.\n     * @param {!string} svgData - new SVG to use.\n     * @param {?Array<number>} rotationCenter Optional: rotation center of the skin. If not supplied, the center of the\n     * skin will be used\n     */\n  }, {\n    key: \"updateSVGSkin\",\n    value: function updateSVGSkin(skinId, svgData, rotationCenter) {\n      if (this._allSkins[skinId] instanceof SVGSkin) {\n        this._allSkins[skinId].setSVG(svgData, rotationCenter);\n        return;\n      }\n      var newSkin = new SVGSkin(skinId, this);\n      newSkin.setSVG(svgData, rotationCenter);\n      this._reskin(skinId, newSkin);\n    }\n    /**\n     * Update an existing bitmap skin, or create a bitmap skin if the previous skin was not bitmap.\n     * @param {!int} skinId the ID for the skin to change.\n     * @param {!ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imgData - new contents for this skin.\n     * @param {!number} bitmapResolution - the resolution scale for a bitmap costume.\n     * @param {?Array<number>} rotationCenter Optional: rotation center of the skin. If not supplied, the center of the\n     * skin will be used\n     */\n  }, {\n    key: \"updateBitmapSkin\",\n    value: function updateBitmapSkin(skinId, imgData, bitmapResolution, rotationCenter) {\n      if (this._allSkins[skinId] instanceof BitmapSkin) {\n        this._allSkins[skinId].setBitmap(imgData, bitmapResolution, rotationCenter);\n        return;\n      }\n      var newSkin = new BitmapSkin(skinId, this);\n      newSkin.setBitmap(imgData, bitmapResolution, rotationCenter);\n      this._reskin(skinId, newSkin);\n    }\n  }, {\n    key: \"_reskin\",\n    value: function _reskin(skinId, newSkin) {\n      var oldSkin = this._allSkins[skinId];\n      this._allSkins[skinId] = newSkin; // Tell drawables to update\n      var _iterator = _createForOfIteratorHelper(this._allDrawables),\n          _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var drawable = _step.value;\n          if (drawable && drawable.skin === oldSkin) {\n            drawable.skin = newSkin;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      oldSkin.dispose();\n    }\n    /**\n     * Update a skin using the text bubble svg creator.\n     * @param {!int} skinId the ID for the skin to change.\n     * @param {!string} type - either \"say\" or \"think\".\n     * @param {!string} text - the text for the bubble.\n     * @param {!boolean} pointsLeft - which side the bubble is pointing.\n     */\n  }, {\n    key: \"updateTextSkin\",\n    value: function updateTextSkin(skinId, type, text, pointsLeft) {\n      if (this._allSkins[skinId] instanceof TextBubbleSkin) {\n        this._allSkins[skinId].setTextBubble(type, text, pointsLeft);\n        return;\n      }\n      var newSkin = new TextBubbleSkin(skinId, this);\n      newSkin.setTextBubble(type, text, pointsLeft);\n      this._reskin(skinId, newSkin);\n    }\n    /**\n     * Destroy an existing skin. Do not use the skin or its ID after calling this.\n     * @param {!int} skinId - The ID of the skin to destroy.\n     */\n  }, {\n    key: \"destroySkin\",\n    value: function destroySkin(skinId) {\n      var oldSkin = this._allSkins[skinId];\n      oldSkin.dispose();\n      delete this._allSkins[skinId];\n    }\n    /**\n     * Create a new Drawable and add it to the scene.\n     * @param {string} group Layer group to add the drawable to\n     * @returns {int} The ID of the new Drawable.\n     */\n  }, {\n    key: \"createDrawable\",\n    value: function createDrawable(group) {\n      if (!group || !Object.prototype.hasOwnProperty.call(this._layerGroups, group)) {\n        log.warn('Cannot create a drawable without a known layer group');\n        return;\n      }\n      var drawableID = this._nextDrawableId++;\n      var drawable = new Drawable(drawableID);\n      this._allDrawables[drawableID] = drawable;\n      this._addToDrawList(drawableID, group);\n      drawable.skin = null;\n      return drawableID;\n    }\n    /**\n     * Set the layer group ordering for the renderer.\n     * @param {Array<string>} groupOrdering The ordered array of layer group\n     * names\n     */\n  }, {\n    key: \"setLayerGroupOrdering\",\n    value: function setLayerGroupOrdering(groupOrdering) {\n      this._groupOrdering = groupOrdering;\n      for (var i = 0; i < this._groupOrdering.length; i++) {\n        this._layerGroups[this._groupOrdering[i]] = {\n          groupIndex: i,\n          drawListOffset: 0\n        };\n      }\n    }\n  }, {\n    key: \"_addToDrawList\",\n    value: function _addToDrawList(drawableID, group) {\n      var currentLayerGroup = this._layerGroups[group];\n      var currentGroupOrderingIndex = currentLayerGroup.groupIndex;\n      var drawListOffset = this._endIndexForKnownLayerGroup(currentLayerGroup);\n      this._drawList.splice(drawListOffset, 0, drawableID);\n      this._updateOffsets('add', currentGroupOrderingIndex);\n    }\n  }, {\n    key: \"_updateOffsets\",\n    value: function _updateOffsets(updateType, currentGroupOrderingIndex) {\n      for (var i = currentGroupOrderingIndex + 1; i < this._groupOrdering.length; i++) {\n        var laterGroupName = this._groupOrdering[i];\n        if (updateType === 'add') {\n          this._layerGroups[laterGroupName].drawListOffset++;\n        } else if (updateType === 'delete') {\n          this._layerGroups[laterGroupName].drawListOffset--;\n        }\n      }\n    }\n  }, {\n    key: \"_endIndexForKnownLayerGroup\",\n    // Given a layer group, return the index where it ends (non-inclusive),\n    // e.g. the returned index does not have a drawable from this layer group in it)\n    value: function _endIndexForKnownLayerGroup(layerGroup) {\n      var groupIndex = layerGroup.groupIndex;\n      if (groupIndex === this._groupOrdering.length - 1) {\n        return this._drawList.length;\n      }\n      return this._layerGroups[this._groupOrdering[groupIndex + 1]].drawListOffset;\n    }\n    /**\n     * Destroy a Drawable, removing it from the scene.\n     * @param {int} drawableID The ID of the Drawable to remove.\n     * @param {string} group Group name that the drawable belongs to\n     */\n  }, {\n    key: \"destroyDrawable\",\n    value: function destroyDrawable(drawableID, group) {\n      if (!group || !Object.prototype.hasOwnProperty.call(this._layerGroups, group)) {\n        log.warn('Cannot destroy drawable without known layer group.');\n        return;\n      }\n      var drawable = this._allDrawables[drawableID];\n      drawable.dispose();\n      delete this._allDrawables[drawableID];\n      var currentLayerGroup = this._layerGroups[group];\n      var endIndex = this._endIndexForKnownLayerGroup(currentLayerGroup);\n      var index = currentLayerGroup.drawListOffset;\n      while (index < endIndex) {\n        if (this._drawList[index] === drawableID) {\n          break;\n        }\n        index++;\n      }\n      if (index < endIndex) {\n        this._drawList.splice(index, 1);\n        this._updateOffsets('delete', currentLayerGroup.groupIndex);\n      } else {\n        log.warn('Could not destroy drawable that could not be found in layer group.');\n        return;\n      }\n    }\n    /**\n     * Returns the position of the given drawableID in the draw list. This is\n     * the absolute position irrespective of layer group.\n     * @param {number} drawableID The drawable ID to find.\n     * @return {number} The postion of the given drawable ID.\n     */\n  }, {\n    key: \"getDrawableOrder\",\n    value: function getDrawableOrder(drawableID) {\n      return this._drawList.indexOf(drawableID);\n    }\n    /**\n     * Set a drawable's order in the drawable list (effectively, z/layer).\n     * Can be used to move drawables to absolute positions in the list,\n     * or relative to their current positions.\n     * \"go back N layers\": setDrawableOrder(id, -N, true, 1); (assuming stage at 0).\n     * \"go to back\": setDrawableOrder(id, 1); (assuming stage at 0).\n     * \"go to front\": setDrawableOrder(id, Infinity);\n     * @param {int} drawableID ID of Drawable to reorder.\n     * @param {number} order New absolute order or relative order adjusment.\n     * @param {string=} group Name of layer group drawable belongs to.\n     * Reordering will not take place if drawable cannot be found within the bounds\n     * of the layer group.\n     * @param {boolean=} optIsRelative If set, `order` refers to a relative change.\n     * @param {number=} optMin If set, order constrained to be at least `optMin`.\n     * @return {?number} New order if changed, or null.\n     */\n  }, {\n    key: \"setDrawableOrder\",\n    value: function setDrawableOrder(drawableID, order, group, optIsRelative, optMin) {\n      if (!group || !Object.prototype.hasOwnProperty.call(this._layerGroups, group)) {\n        log.warn('Cannot set the order of a drawable without a known layer group.');\n        return;\n      }\n      var currentLayerGroup = this._layerGroups[group];\n      var startIndex = currentLayerGroup.drawListOffset;\n      var endIndex = this._endIndexForKnownLayerGroup(currentLayerGroup);\n      var oldIndex = startIndex;\n      while (oldIndex < endIndex) {\n        if (this._drawList[oldIndex] === drawableID) {\n          break;\n        }\n        oldIndex++;\n      }\n      if (oldIndex < endIndex) {\n        // Remove drawable from the list.\n        if (order === 0) {\n          return oldIndex;\n        }\n        var _ = this._drawList.splice(oldIndex, 1)[0]; // Determine new index.\n        var newIndex = order;\n        if (optIsRelative) {\n          newIndex += oldIndex;\n        }\n        var possibleMin = (optMin || 0) + startIndex;\n        var min = possibleMin >= startIndex && possibleMin < endIndex ? possibleMin : startIndex;\n        newIndex = Math.max(newIndex, min);\n        newIndex = Math.min(newIndex, endIndex); // Insert at new index.\n        this._drawList.splice(newIndex, 0, drawableID);\n        return newIndex;\n      }\n      return null;\n    }\n    /**\n     * Draw all current drawables and present the frame on the canvas.\n     */\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      this._doExitDrawRegion();\n      var gl = this._gl;\n      twgl.bindFramebufferInfo(gl, null);\n      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n      gl.clearColor.apply(gl, _toConsumableArray(this._backgroundColor4f));\n      gl.clear(gl.COLOR_BUFFER_BIT);\n      this._drawThese(this._drawList, ShaderManager.DRAW_MODE.default, this._projection);\n      if (this._snapshotCallbacks.length > 0) {\n       var snapshot = gl.canvas.toDataURL();\n       $.ajax({\n          url:'saveScreenshot.php',\n             type:'POST',\n             data:snapshot,\n             processData:false,\n             contentType:false,\n             success:function (data) {\n                autosaveStatus(data);\n             }\n         });\n         this._snapshotCallbacks.length=0;\n        \/\/this._snapshotCallbacks.forEach(function (cb) {\n       \/\/  return cb(snapshot);\n        \/\/});\n        \/\/this._snapshotCallbacks = [];\n      }\n    }\n    /**\n     * Get the precise bounds for a Drawable.\n     * @param {int} drawableID ID of Drawable to get bounds for.\n     * @return {object} Bounds for a tight box around the Drawable.\n     */\n  }, {\n    key: \"getBounds\",\n    value: function getBounds(drawableID) {\n      var drawable = this._allDrawables[drawableID]; // Tell the Drawable about its updated convex hull, if necessary.\n      if (drawable.needsConvexHullPoints()) {\n        var points = this._getConvexHullPointsForDrawable(drawableID);\n        drawable.setConvexHullPoints(points);\n      }\n      var bounds = drawable.getFastBounds(); // In debug mode, draw the bounds.\n      if (this._debugCanvas) {\n        var gl = this._gl;\n        this._debugCanvas.width = gl.canvas.width;\n        this._debugCanvas.height = gl.canvas.height;\n        var context = this._debugCanvas.getContext('2d',{willReadFrequently:true});\n        context.drawImage(gl.canvas, 0, 0);\n        context.strokeStyle = '#FF0000';\n        var pr = window.devicePixelRatio;\n        context.strokeRect(pr * (bounds.left + this._nativeSize[0] / 2), pr * (-bounds.top + this._nativeSize[1] / 2), pr * (bounds.right - bounds.left), pr * (-bounds.bottom + bounds.top));\n      }\n      return bounds;\n    }\n    /**\n     * Get the precise bounds for a Drawable around the top slice.\n     * Used for positioning speech bubbles more closely to the sprite.\n     * @param {int} drawableID ID of Drawable to get bubble bounds for.\n     * @return {object} Bounds for a tight box around the Drawable top slice.\n     */\n  }, {\n    key: \"getBoundsForBubble\",\n    value: function getBoundsForBubble(drawableID) {\n      var drawable = this._allDrawables[drawableID]; // Tell the Drawable about its updated convex hull, if necessary.\n      if (drawable.needsConvexHullPoints()) {\n        var points = this._getConvexHullPointsForDrawable(drawableID);\n        drawable.setConvexHullPoints(points);\n      }\n      var bounds = drawable.getBoundsForBubble(); // In debug mode, draw the bounds.\n      if (this._debugCanvas) {\n        var gl = this._gl;\n        this._debugCanvas.width = gl.canvas.width;\n        this._debugCanvas.height = gl.canvas.height;\n        var context = this._debugCanvas.getContext('2d',{willReadFrequently:true});\n        context.drawImage(gl.canvas, 0, 0);\n        context.strokeStyle = '#FF0000';\n        var pr = window.devicePixelRatio;\n        context.strokeRect(pr * (bounds.left + this._nativeSize[0] / 2), pr * (-bounds.top + this._nativeSize[1] / 2), pr * (bounds.right - bounds.left), pr * (-bounds.bottom + bounds.top));\n      }\n      return bounds;\n    }\n    /**\n     * Get the current skin (costume) size of a Drawable.\n     * @param {int} drawableID The ID of the Drawable to measure.\n     * @return {Array<number>} Skin size, width and height.\n     */\n  }, {\n    key: \"getCurrentSkinSize\",\n    value: function getCurrentSkinSize(drawableID) {\n      var drawable = this._allDrawables[drawableID];\n      return this.getSkinSize(drawable.skin.id);\n    }\n    /**\n     * Get the size of a skin by ID.\n     * @param {int} skinID The ID of the Skin to measure.\n     * @return {Array<number>} Skin size, width and height.\n     */\n  }, {\n    key: \"getSkinSize\",\n    value: function getSkinSize(skinID) {\n      var skin = this._allSkins[skinID];\n      return skin.size;\n    }\n    /**\n     * Get the rotation center of a skin by ID.\n     * @param {int} skinID The ID of the Skin\n     * @return {Array<number>} The rotationCenterX and rotationCenterY\n     */\n  }, {\n    key: \"getSkinRotationCenter\",\n    value: function getSkinRotationCenter(skinID) {\n      var skin = this._allSkins[skinID];\n      return skin.calculateRotationCenter();\n    }\n    /**\n     * Check if a particular Drawable is touching a particular color.\n     * Unlike touching drawable, if the \"tester\" is invisble, we will still test.\n     * @param {int} drawableID The ID of the Drawable to check.\n     * @param {Array<int>} color3b Test if the Drawable is touching this color.\n     * @param {Array<int>} [mask3b] Optionally mask the check to this part of Drawable.\n     * @returns {boolean} True iff the Drawable is touching the color.\n     */\n  }, {\n    key: \"isTouchingColor\",\n    value: function isTouchingColor(drawableID, color3b, mask3b) {\n      var candidates = this._candidatesTouching(drawableID, this._visibleDrawList);\n      var bounds;\n      if (colorMatches(color3b, this._backgroundColor3b, 0)) {\n        // If the color we're checking for is the background color, don't confine the check to\n        // candidate drawables' bounds--since the background spans the entire stage, we must check\n        // everything that lies inside the drawable.\n        bounds = this._touchingBounds(drawableID); // e.g. empty costume, or off the stage\n        if (bounds === null) return false;\n      } else if (candidates.length === 0) {\n        // If not checking for the background color, we can return early if there are no candidate drawables.\n        return false;\n      } else {\n        bounds = this._candidatesBounds(candidates);\n      }\n      var maxPixelsForCPU = this._getMaxPixelsForCPU();\n      var debugCanvasContext = this._debugCanvas && this._debugCanvas.getContext('2d',{willReadFrequently:true});\n      if (debugCanvasContext) {\n        this._debugCanvas.width = bounds.width;\n        this._debugCanvas.height = bounds.height;\n      } // if there are just too many pixels to CPU render efficiently, we need to let readPixels happen\n      if (bounds.width * bounds.height * (candidates.length + 1) >= maxPixelsForCPU) {\n        this._isTouchingColorGpuStart(drawableID, candidates.map(function (_ref) {\n          var id = _ref.id;\n          return id;\n        }).reverse(), bounds, color3b, mask3b);\n      }\n      var drawable = this._allDrawables[drawableID];\n      var point = __isTouchingDrawablesPoint;\n      var color = __touchingColor;\n      var hasMask = Boolean(mask3b);\n      drawable.updateCPURenderAttributes(); // Masked drawable ignores ghost effect\n      var effectMask = ~ShaderManager.EFFECT_INFO.ghost.mask; // Scratch Space - +y is top\n      for (var y = bounds.bottom; y <= bounds.top; y++) {\n        if (bounds.width * (y - bounds.bottom) * (candidates.length + 1) >= maxPixelsForCPU) {\n          return this._isTouchingColorGpuFin(bounds, color3b, y - bounds.bottom);\n        }\n        for (var x = bounds.left; x <= bounds.right; x++) {\n          point[1] = y;\n          point[0] = x; // if we use a mask, check our sample color...\n          if (hasMask ? maskMatches(Drawable.sampleColor4b(point, drawable, color, effectMask), mask3b) : drawable.isTouching(point)) {\n            RenderWebGL.sampleColor3b(point, candidates, color);\n            if (debugCanvasContext) {\n              debugCanvasContext.fillStyle = \"rgb(\".concat(color[0], \",\").concat(color[1], \",\").concat(color[2], \")\");\n              debugCanvasContext.fillRect(x - bounds.left, bounds.bottom - y, 1, 1);\n            } // ...and the target color is drawn at this pixel\n            if (colorMatches(color, color3b, 0)) {\n              return true;\n            }\n          }\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"_getMaxPixelsForCPU\",\n    value: function _getMaxPixelsForCPU() {\n      switch (this._useGpuMode) {\n        case RenderWebGL.UseGpuModes.ForceCPU:\n          return Infinity;\n        case RenderWebGL.UseGpuModes.ForceGPU:\n          return 0;\n        case RenderWebGL.UseGpuModes.Automatic:\n        default:\n          return __cpuTouchingColorPixelCount;\n      }\n    }\n  }, {\n    key: \"_enterDrawBackground\",\n    value: function _enterDrawBackground() {\n      var gl = this.gl;\n      var currentShader = this._shaderManager.getShader(ShaderManager.DRAW_MODE.background, 0);\n      gl.disable(gl.BLEND);\n      gl.useProgram(currentShader.program);\n      twgl.setBuffersAndAttributes(gl, currentShader, this._bufferInfo);\n    }\n  }, {\n    key: \"_exitDrawBackground\",\n    value: function _exitDrawBackground() {\n      var gl = this.gl;\n      gl.enable(gl.BLEND);\n    }\n  }, {\n    key: \"_isTouchingColorGpuStart\",\n    value: function _isTouchingColorGpuStart(drawableID, candidateIDs, bounds, color3b, mask3b) {\n      this._doExitDrawRegion();\n      var gl = this._gl;\n      twgl.bindFramebufferInfo(gl, this._queryBufferInfo); // Limit size of viewport to the bounds around the target Drawable,\n      // and create the projection matrix for the draw.\n      gl.viewport(0, 0, bounds.width, bounds.height);\n      var projection = twgl.m4.ortho(bounds.left, bounds.right, bounds.top, bounds.bottom, -1, 1); // Clear the query buffer to fully transparent. This will be the color of pixels that fail the stencil test.\n      gl.clearColor(0, 0, 0, 0);\n      gl.clear(gl.COLOR_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);\n      var extraUniforms;\n      if (mask3b) {\n        extraUniforms = {\n          u_colorMask: [mask3b[0] / 255, mask3b[1] / 255, mask3b[2] / 255],\n          u_colorMaskTolerance: MASK_TOUCHING_COLOR_TOLERANCE / 255\n        };\n      }\n      try {\n        // Using the stencil buffer, mask out the drawing to either the drawable's alpha channel\n        // or pixels of the drawable which match the mask color, depending on whether a mask color is given.\n        // Masked-out pixels will not be checked.\n        gl.enable(gl.STENCIL_TEST);\n        gl.stencilFunc(gl.ALWAYS, 1, 1);\n        gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);\n        gl.colorMask(false, false, false, false);\n        this._drawThese([drawableID], mask3b ? ShaderManager.DRAW_MODE.colorMask : ShaderManager.DRAW_MODE.silhouette, projection, {\n          extraUniforms: extraUniforms,\n          ignoreVisibility: true,\n          // Touching color ignores sprite visibility,\n          effectMask: ~ShaderManager.EFFECT_INFO.ghost.mask\n        });\n        gl.stencilFunc(gl.EQUAL, 1, 1);\n        gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);\n        gl.colorMask(true, true, true, true); // Draw the background as a quad. Drawing a background with gl.clear will not mask to the stenciled area.\n        this.enterDrawRegion(this._backgroundDrawRegionId);\n        var uniforms = {\n          u_backgroundColor: this._backgroundColor4f\n        };\n        var currentShader = this._shaderManager.getShader(ShaderManager.DRAW_MODE.background, 0);\n        twgl.setUniforms(currentShader, uniforms);\n        twgl.drawBufferInfo(gl, this._bufferInfo, gl.TRIANGLES); // Draw the candidate drawables on top of the background.\n        this._drawThese(candidateIDs, ShaderManager.DRAW_MODE.default, projection, {\n          idFilterFunc: function idFilterFunc(testID) {\n            return testID !== drawableID;\n          }\n        });\n      } finally {\n        gl.colorMask(true, true, true, true);\n        gl.disable(gl.STENCIL_TEST);\n        this._doExitDrawRegion();\n      }\n    }\n  }, {\n    key: \"_isTouchingColorGpuFin\",\n    value: function _isTouchingColorGpuFin(bounds, color3b, stop) {\n      var gl = this._gl;\n      var pixels = new Uint8Array(Math.floor(bounds.width * (bounds.height - stop) * 4));\n      gl.readPixels(0, 0, bounds.width, bounds.height - stop, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n      if (this._debugCanvas) {\n        this._debugCanvas.width = bounds.width;\n        this._debugCanvas.height = bounds.height;\n        var context = this._debugCanvas.getContext('2d',{willReadFrequently:true});\n        var imageData = context.getImageData(0, 0, bounds.width, bounds.height - stop);\n        imageData.data.set(pixels);\n        context.putImageData(imageData, 0, 0);\n      }\n      for (var pixelBase = 0; pixelBase < pixels.length; pixelBase += 4) {\n        // Transparent pixels are masked (either by the drawable's alpha channel or color mask).\n        if (pixels[pixelBase + 3] !== 0 && colorMatches(color3b, pixels, pixelBase)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    /**\n     * Check if a particular Drawable is touching any in a set of Drawables.\n     * @param {int} drawableID The ID of the Drawable to check.\n     * @param {?Array<int>} candidateIDs The Drawable IDs to check, otherwise all visible drawables in the renderer\n     * @returns {boolean} True if the Drawable is touching one of candidateIDs.\n     */\n  }, {\n    key: \"isTouchingDrawables\",\n    value: function isTouchingDrawables(drawableID) {\n      var _this2 = this;\n      var candidateIDs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._drawList;\n      var candidates = this._candidatesTouching(drawableID, // even if passed an invisible drawable, we will NEVER touch it!\n      candidateIDs.filter(function (id) {\n        return _this2._allDrawables[id]._visible;\n      })); // if we are invisble we don't touch anything.\n      if (candidates.length === 0 || !this._allDrawables[drawableID]._visible) {\n        return false;\n      } // Get the union of all the candidates intersections.\n      var bounds = this._candidatesBounds(candidates);\n      var drawable = this._allDrawables[drawableID];\n      var point = __isTouchingDrawablesPoint;\n      drawable.updateCPURenderAttributes(); // This is an EXTREMELY brute force collision detector, but it is\n      // still faster than asking the GPU to give us the pixels.\n      for (var x = bounds.left; x <= bounds.right; x++) {\n        // Scratch Space - +y is top\n        point[0] = x;\n        for (var y = bounds.bottom; y <= bounds.top; y++) {\n          point[1] = y;\n          if (drawable.isTouching(point)) {\n            for (var index = 0; index < candidates.length; index++) {\n              if (candidates[index].drawable.isTouching(point)) {\n                return true;\n              }\n            }\n          }\n        }\n      }\n      return false;\n    }\n    /**\n     * Convert a client based x/y position on the canvas to a Scratch 3 world space\n     * Rectangle.  This creates recangles with a radius to cover selecting multiple\n     * scratch pixels with touch / small render areas.\n     *\n     * @param {int} centerX The client x coordinate of the picking location.\n     * @param {int} centerY The client y coordinate of the picking location.\n     * @param {int} [width] The client width of the touch event (optional).\n     * @param {int} [height] The client width of the touch event (optional).\n     * @returns {Rectangle} Scratch world space rectangle, iterate bottom <= top,\n     *                      left <= right.\n     */\n  }, {\n    key: \"clientSpaceToScratchBounds\",\n    value: function clientSpaceToScratchBounds(centerX, centerY) {\n      var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n      var gl = this._gl;\n      var clientToScratchX = this._nativeSize[0] / gl.canvas.clientWidth;\n      var clientToScratchY = this._nativeSize[1] / gl.canvas.clientHeight;\n      width *= clientToScratchX;\n      height *= clientToScratchY;\n      width = Math.max(1, Math.min(Math.round(width), MAX_TOUCH_SIZE[0]));\n      height = Math.max(1, Math.min(Math.round(height), MAX_TOUCH_SIZE[1]));\n      var x = centerX * clientToScratchX - (width - 1) / 2; // + because scratch y is inverted\n      var y = centerY * clientToScratchY + (height - 1) / 2;\n      var xOfs = width % 2 ? 0 : -0.5; // y is offset +0.5\n      var yOfs = height % 2 ? 0 : -0.5;\n      var bounds = new Rectangle();\n      bounds.initFromBounds(Math.floor(this._xLeft + x + xOfs), Math.floor(this._xLeft + x + xOfs + width - 1), Math.ceil(this._yTop - y + yOfs), Math.ceil(this._yTop - y + yOfs + height - 1));\n      return bounds;\n    }\n    /**\n     * Determine if the drawable is touching a client based x/y.  Helper method for sensing\n     * touching mouse-pointer.  Ignores visibility.\n     *\n     * @param {int} drawableID The ID of the drawable to check.\n     * @param {int} centerX The client x coordinate of the picking location.\n     * @param {int} centerY The client y coordinate of the picking location.\n     * @param {int} [touchWidth] The client width of the touch event (optional).\n     * @param {int} [touchHeight] The client height of the touch event (optional).\n     * @returns {boolean} If the drawable has any pixels that would draw in the touch area\n     */\n  }, {\n    key: \"drawableTouching\",\n    value: function drawableTouching(drawableID, centerX, centerY, touchWidth, touchHeight) {\n      var drawable = this._allDrawables[drawableID];\n      if (!drawable) {\n        return false;\n      }\n      var bounds = this.clientSpaceToScratchBounds(centerX, centerY, touchWidth, touchHeight);\n      var worldPos = twgl.v3.create();\n      drawable.updateCPURenderAttributes();\n      for (worldPos[1] = bounds.bottom; worldPos[1] <= bounds.top; worldPos[1]++) {\n        for (worldPos[0] = bounds.left; worldPos[0] <= bounds.right; worldPos[0]++) {\n          if (drawable.isTouching(worldPos)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n    /**\n     * Detect which sprite, if any, is at the given location.\n     * This function will pick all drawables that are visible, unless specific\n     * candidate drawable IDs are provided.  Used for determining what is clicked\n     * or dragged.  Will not select hidden / ghosted sprites.\n     *\n     * @param {int} centerX The client x coordinate of the picking location.\n     * @param {int} centerY The client y coordinate of the picking location.\n     * @param {int} [touchWidth] The client width of the touch event (optional).\n     * @param {int} [touchHeight] The client height of the touch event (optional).\n     * @param {Array<int>} [candidateIDs] The Drawable IDs to pick from, otherwise all visible drawables.\n     * @returns {int} The ID of the topmost Drawable under the picking location, or\n     * RenderConstants.ID_NONE if there is no Drawable at that location.\n     */\n  }, {\n    key: \"pick\",\n    value: function pick(centerX, centerY, touchWidth, touchHeight, candidateIDs) {\n      var _this3 = this;\n      var bounds = this.clientSpaceToScratchBounds(centerX, centerY, touchWidth, touchHeight);\n      if (bounds.left === -Infinity || bounds.bottom === -Infinity) {\n        return false;\n      }\n      candidateIDs = (candidateIDs || this._drawList).filter(function (id) {\n        var drawable = _this3._allDrawables[id]; // default pick list ignores visible and ghosted sprites.\n        if (drawable.getVisible() && drawable.getUniforms().u_ghost !== 0) {\n          var drawableBounds = drawable.getFastBounds();\n          var inRange = bounds.intersects(drawableBounds);\n          if (!inRange) return false;\n          drawable.updateCPURenderAttributes();\n          return true;\n        }\n        return false;\n      });\n      if (candidateIDs.length === 0) {\n        return false;\n      }\n      var hits = [];\n      var worldPos = twgl.v3.create(0, 0, 0); // Iterate over the scratch pixels and check if any candidate can be\n      // touched at that point.\n      for (worldPos[1] = bounds.bottom; worldPos[1] <= bounds.top; worldPos[1]++) {\n        for (worldPos[0] = bounds.left; worldPos[0] <= bounds.right; worldPos[0]++) {\n          // Check candidates in the reverse order they would have been\n          // drawn. This will determine what candiate's silhouette pixel\n          // would have been drawn at the point.\n          for (var d = candidateIDs.length - 1; d >= 0; d--) {\n            var id = candidateIDs[d];\n            var drawable = this._allDrawables[id];\n            if (drawable.isTouching(worldPos)) {\n              hits[id] = (hits[id] || 0) + 1;\n              break;\n            }\n          }\n        }\n      } // Bias toward selecting anything over nothing\n      hits[RenderConstants.ID_NONE] = 0;\n      var hit = RenderConstants.ID_NONE;\n      for (var hitID in hits) {\n        if (Object.prototype.hasOwnProperty.call(hits, hitID) && hits[hitID] > hits[hit]) {\n          hit = hitID;\n        }\n      }\n      return Number(hit);\n    }\n    /**\n     * @typedef DrawableExtractionOld\n     * @property {Uint8Array} data Raw pixel data for the drawable\n     * @property {int} width Drawable bounding box width\n     * @property {int} height Drawable bounding box height\n     * @property {Array<number>} scratchOffset [x, y] offset in Scratch coordinates\n     * from the drawable position to the client x, y coordinate\n     * @property {int} x The x coordinate relative to drawable bounding box\n     * @property {int} y The y coordinate relative to drawable bounding box\n     */\n    /**\n     * Return drawable pixel data and picking coordinates relative to the drawable bounds\n     * @param {int} drawableID The ID of the drawable to get pixel data for\n     * @param {int} x The client x coordinate of the picking location.\n     * @param {int} y The client y coordinate of the picking location.\n     * @return {?DrawableExtractionOld} Data about the picked drawable\n     * @deprecated Use {@link extractDrawableScreenSpace} instead.\n     */\n  }, {\n    key: \"extractDrawable\",\n    value: function extractDrawable(drawableID, x, y) {\n      this._doExitDrawRegion();\n      var drawable = this._allDrawables[drawableID];\n      if (!drawable) return null; // Convert client coordinates into absolute scratch units\n      var scratchX = this._nativeSize[0] * (x / this._gl.canvas.clientWidth - 0.5);\n      var scratchY = this._nativeSize[1] * (y / this._gl.canvas.clientHeight - 0.5);\n      var gl = this._gl;\n      var bounds = drawable.getFastBounds();\n      bounds.snapToInt(); // Set a reasonable max limit width and height for the bufferInfo bounds\n      var maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n      var clampedWidth = Math.min(2048, bounds.width, maxTextureSize);\n      var clampedHeight = Math.min(2048, bounds.height, maxTextureSize); // Make a new bufferInfo since this._queryBufferInfo is limited to 480x360\n      var attachments = [{\n        format: gl.RGBA\n      }, {\n        format: gl.DEPTH_STENCIL\n      }];\n      var bufferInfo = twgl.createFramebufferInfo(gl, attachments, clampedWidth, clampedHeight);\n      try {\n        // If the new bufferInfo is invalid, fall back to using the smaller _queryBufferInfo\n        twgl.bindFramebufferInfo(gl, bufferInfo);\n        if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {\n          twgl.bindFramebufferInfo(gl, this._queryBufferInfo);\n        } // Translate to scratch units relative to the drawable\n        var pickX = scratchX - bounds.left;\n        var pickY = scratchY + bounds.top; // Limit size of viewport to the bounds around the target Drawable,\n        // and create the projection matrix for the draw.\n        gl.viewport(0, 0, bounds.width, bounds.height);\n        var projection = twgl.m4.ortho(bounds.left, bounds.right, bounds.top, bounds.bottom, -1, 1);\n        gl.clearColor(0, 0, 0, 0);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n        try {\n          gl.disable(gl.BLEND); // ImageData objects store alpha un-premultiplied, so draw with the `straightAlpha` draw mode.\n          this._drawThese([drawableID], ShaderManager.DRAW_MODE.straightAlpha, projection, {\n            effectMask: ~ShaderManager.EFFECT_INFO.ghost.mask\n          });\n        } finally {\n          gl.enable(gl.BLEND);\n        }\n        var data = new Uint8Array(Math.floor(bounds.width * bounds.height * 4));\n        gl.readPixels(0, 0, bounds.width, bounds.height, gl.RGBA, gl.UNSIGNED_BYTE, data);\n        if (this._debugCanvas) {\n          this._debugCanvas.width = bounds.width;\n          this._debugCanvas.height = bounds.height;\n          var ctx = this._debugCanvas.getContext('2d',{willReadFrequently:true});\n          var imageData = ctx.createImageData(bounds.width, bounds.height);\n          imageData.data.set(data);\n          ctx.putImageData(imageData, 0, 0);\n          ctx.beginPath();\n          ctx.arc(pickX, pickY, 3, 0, 2 * Math.PI, false);\n          ctx.fillStyle = 'white';\n          ctx.fill();\n          ctx.lineWidth = 1;\n          ctx.strokeStyle = 'black';\n          ctx.stroke();\n        }\n        return {\n          data: data,\n          width: bounds.width,\n          height: bounds.height,\n          scratchOffset: [-scratchX + drawable._position[0], -scratchY - drawable._position[1]],\n          x: pickX,\n          y: pickY\n        };\n      } finally {\n        gl.deleteFramebuffer(bufferInfo.framebuffer);\n      }\n    }\n    /**\n     * @typedef DrawableExtraction\n     * @property {ImageData} data Raw pixel data for the drawable\n     * @property {number} x The x coordinate of the drawable's bounding box's top-left corner, in 'CSS pixels'\n     * @property {number} y The y coordinate of the drawable's bounding box's top-left corner, in 'CSS pixels'\n     * @property {number} width The drawable's bounding box width, in 'CSS pixels'\n     * @property {number} height The drawable's bounding box height, in 'CSS pixels'\n     */\n    /**\n     * Return a drawable's pixel data and bounds in screen space.\n     * @param {int} drawableID The ID of the drawable to get pixel data for\n     * @return {DrawableExtraction} Data about the picked drawable\n     */\n  }, {\n    key: \"extractDrawableScreenSpace\",\n    value: function extractDrawableScreenSpace(drawableID) {\n      var drawable = this._allDrawables[drawableID];\n      if (!drawable) throw new Error(\"Could not extract drawable with ID \".concat(drawableID, \"; it does not exist\"));\n      this._doExitDrawRegion();\n      var nativeCenterX = this._nativeSize[0] * 0.5;\n      var nativeCenterY = this._nativeSize[1] * 0.5;\n      var scratchBounds = drawable.getFastBounds();\n      var canvas = this.canvas; // Ratio of the screen-space scale of the stage's canvas to the \"native size\" of the stage\n      var scaleFactor = canvas.width / this._nativeSize[0]; // Bounds of the extracted drawable, in \"canvas pixel space\"\n      // (origin is 0, 0, destination is the canvas width, height).\n      var canvasSpaceBounds = new Rectangle();\n      canvasSpaceBounds.initFromBounds((scratchBounds.left + nativeCenterX) * scaleFactor, (scratchBounds.right + nativeCenterX) * scaleFactor, // in \"canvas space\", +y is down, but Rectangle methods assume bottom < top, so swap them\n      (nativeCenterY - scratchBounds.top) * scaleFactor, (nativeCenterY - scratchBounds.bottom) * scaleFactor);\n      canvasSpaceBounds.snapToInt(); // undo the transformation to transform the bounds, snapped to \"canvas-pixel space\", back to \"Scratch space\"\n      // We have to transform -> snap -> invert transform so that the \"Scratch-space\" bounds are snapped in\n      // \"canvas-pixel space\".\n      scratchBounds.initFromBounds(canvasSpaceBounds.left / scaleFactor - nativeCenterX, canvasSpaceBounds.right / scaleFactor - nativeCenterX, nativeCenterY - canvasSpaceBounds.top / scaleFactor, nativeCenterY - canvasSpaceBounds.bottom / scaleFactor);\n      var gl = this._gl; // Set a reasonable max limit width and height for the bufferInfo bounds\n      var maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n      var clampedWidth = Math.min(MAX_EXTRACTED_DRAWABLE_DIMENSION, canvasSpaceBounds.width, maxTextureSize);\n      var clampedHeight = Math.min(MAX_EXTRACTED_DRAWABLE_DIMENSION, canvasSpaceBounds.height, maxTextureSize); // Make a new bufferInfo since this._queryBufferInfo is limited to 480x360\n      var bufferInfo = twgl.createFramebufferInfo(gl, [{\n        format: gl.RGBA\n      }], clampedWidth, clampedHeight);\n      try {\n        twgl.bindFramebufferInfo(gl, bufferInfo); // Limit size of viewport to the bounds around the target Drawable,\n        // and create the projection matrix for the draw.\n        gl.viewport(0, 0, clampedWidth, clampedHeight);\n        var projection = twgl.m4.ortho(scratchBounds.left, scratchBounds.right, scratchBounds.top, scratchBounds.bottom, -1, 1);\n        gl.clearColor(0, 0, 0, 0);\n        gl.clear(gl.COLOR_BUFFER_BIT); // Don't apply the ghost effect. TODO: is this an intentional design decision?\n        this._drawThese([drawableID], ShaderManager.DRAW_MODE.straightAlpha, projection, {\n          effectMask: ~ShaderManager.EFFECT_INFO.ghost.mask\n        });\n        var data = new Uint8Array(Math.floor(clampedWidth * clampedHeight * 4));\n        gl.readPixels(0, 0, clampedWidth, clampedHeight, gl.RGBA, gl.UNSIGNED_BYTE, data); // readPixels can only read into a Uint8Array, but ImageData has to take a Uint8ClampedArray.\n        // We can share the same underlying buffer between them to avoid having to copy any data.\n        var imageData = new ImageData(new Uint8ClampedArray(data.buffer), clampedWidth, clampedHeight); // On high-DPI devices, the canvas' width (in canvas pixels) will be larger than its width in CSS pixels.\n        // We want to return the CSS-space bounds,\n        // so take into account the ratio between the canvas' pixel dimensions and its layout dimensions.\n        // This is usually the same as 1 / window.devicePixelRatio, but if e.g. you zoom your browser window without\n        // the canvas resizing, then it'll differ.\n        var ratio = canvas.getBoundingClientRect().width / canvas.width;\n        return {\n          imageData: imageData,\n          x: canvasSpaceBounds.left * ratio,\n          y: canvasSpaceBounds.bottom * ratio,\n          width: canvasSpaceBounds.width * ratio,\n          height: canvasSpaceBounds.height * ratio\n        };\n      } finally {\n        gl.deleteFramebuffer(bufferInfo.framebuffer);\n      }\n    }\n    /**\n     * @typedef ColorExtraction\n     * @property {Uint8Array} data Raw pixel data for the drawable\n     * @property {int} width Drawable bounding box width\n     * @property {int} height Drawable bounding box height\n     * @property {object} color Color object with RGBA properties at picked location\n     */\n    /**\n     * Return drawable pixel data and color at a given position\n     * @param {int} x The client x coordinate of the picking location.\n     * @param {int} y The client y coordinate of the picking location.\n     * @param {int} radius The client radius to extract pixels with.\n     * @return {?ColorExtraction} Data about the picked color\n     */\n  }, {\n    key: \"extractColor\",\n    value: function extractColor(x, y, radius) {\n      this._doExitDrawRegion();\n      var scratchX = Math.round(this._nativeSize[0] * (x / this._gl.canvas.clientWidth - 0.5));\n      var scratchY = Math.round(-this._nativeSize[1] * (y / this._gl.canvas.clientHeight - 0.5));\n      var gl = this._gl;\n      twgl.bindFramebufferInfo(gl, this._queryBufferInfo);\n      var bounds = new Rectangle();\n      bounds.initFromBounds(scratchX - radius, scratchX + radius, scratchY - radius, scratchY + radius);\n      var pickX = scratchX - bounds.left;\n      var pickY = bounds.top - scratchY;\n      gl.viewport(0, 0, bounds.width, bounds.height);\n      var projection = twgl.m4.ortho(bounds.left, bounds.right, bounds.top, bounds.bottom, -1, 1);\n      gl.clearColor.apply(gl, _toConsumableArray(this._backgroundColor4f));\n      gl.clear(gl.COLOR_BUFFER_BIT);\n      this._drawThese(this._drawList, ShaderManager.DRAW_MODE.default, projection);\n      var data = new Uint8Array(Math.floor(bounds.width * bounds.height * 4));\n      gl.readPixels(0, 0, bounds.width, bounds.height, gl.RGBA, gl.UNSIGNED_BYTE, data);\n      var pixelBase = Math.floor(4 * (pickY * bounds.width + pickX));\n      var color = {\n        r: data[pixelBase],\n        g: data[pixelBase + 1],\n        b: data[pixelBase + 2],\n        a: data[pixelBase + 3]\n      };\n      if (this._debugCanvas) {\n        this._debugCanvas.width = bounds.width;\n        this._debugCanvas.height = bounds.height;\n        var ctx = this._debugCanvas.getContext('2d',{willReadFrequently:true});\n        var imageData = ctx.createImageData(bounds.width, bounds.height);\n        imageData.data.set(data);\n        ctx.putImageData(imageData, 0, 0);\n        ctx.strokeStyle = 'black';\n        ctx.fillStyle = \"rgba(\".concat(color.r, \", \").concat(color.g, \", \").concat(color.b, \", \").concat(color.a, \")\");\n        ctx.rect(pickX - 4, pickY - 4, 8, 8);\n        ctx.fill();\n        ctx.stroke();\n      }\n      return {\n        data: data,\n        width: bounds.width,\n        height: bounds.height,\n        color: color\n      };\n    }\n    /**\n     * Get the candidate bounding box for a touching query.\n     * @param {int} drawableID ID for drawable of query.\n     * @return {?Rectangle} Rectangle bounds for touching query, or null.\n     */\n  }, {\n    key: \"_touchingBounds\",\n    value: function _touchingBounds(drawableID) {\n      var drawable = this._allDrawables[drawableID];\n      /** @todo remove this once URL-based skin setting is removed. */\n      if (!drawable.skin || !drawable.skin.getTexture([100, 100])) return null;\n      var bounds = drawable.getFastBounds(); // Limit queries to the stage size.\n      bounds.clamp(this._xLeft, this._xRight, this._yBottom, this._yTop); // Use integer coordinates for queries - weird things happen\n      // when you provide float width/heights to gl.viewport and projection.\n      bounds.snapToInt();\n      if (bounds.width === 0 || bounds.height === 0) {\n        // No space to query.\n        return null;\n      }\n      return bounds;\n    }\n    /**\n     * Filter a list of candidates for a touching query into only those that\n     * could possibly intersect the given bounds.\n     * @param {int} drawableID - ID for drawable of query.\n     * @param {Array<int>} candidateIDs - Candidates for touching query.\n     * @return {?Array< {id, drawable, intersection} >} Filtered candidates with useful data.\n     */\n  }, {\n    key: \"_candidatesTouching\",\n    value: function _candidatesTouching(drawableID, candidateIDs) {\n      var bounds = this._touchingBounds(drawableID);\n      var result = [];\n      if (bounds === null) {\n        return result;\n      } // iterate through the drawables list BACKWARDS - we want the top most item to be the first we check\n      for (var index = candidateIDs.length - 1; index >= 0; index--) {\n        var id = candidateIDs[index];\n        if (id !== drawableID) {\n          var drawable = this._allDrawables[id]; // Text bubbles aren't considered in \"touching\" queries\n          if (drawable.skin instanceof TextBubbleSkin) continue;\n          if (drawable.skin && drawable._visible) {\n            // Update the CPU position data\n            drawable.updateCPURenderAttributes();\n            var candidateBounds = drawable.getFastBounds(); // Push bounds out to integers. If a drawable extends out into half a pixel, that half-pixel still\n            // needs to be tested. Plus, in some areas we construct another rectangle from the union of these,\n            // and iterate over its pixels (width * height). Turns out that doesn't work so well when the\n            // width/height aren't integers.\n            candidateBounds.snapToInt();\n            if (bounds.intersects(candidateBounds)) {\n              result.push({\n                id: id,\n                drawable: drawable,\n                intersection: Rectangle.intersect(bounds, candidateBounds)\n              });\n            }\n          }\n        }\n      }\n      return result;\n    }\n    /**\n     * Helper to get the union bounds from a set of candidates returned from the above method\n     * @private\n     * @param {Array<object>} candidates info from _candidatesTouching\n     * @return {Rectangle} the outer bounding box union\n     */\n  }, {\n    key: \"_candidatesBounds\",\n    value: function _candidatesBounds(candidates) {\n      return candidates.reduce(function (memo, _ref2) {\n        var intersection = _ref2.intersection;\n        if (!memo) {\n          return intersection;\n        } // store the union of the two rectangles in our static rectangle instance\n        return Rectangle.union(memo, intersection, __candidatesBounds);\n      }, null);\n    }\n    /**\n     * Update a drawable's skin.\n     * @param {number} drawableID The drawable's id.\n     * @param {number} skinId The skin to update to.\n     */\n  }, {\n    key: \"updateDrawableSkinId\",\n    value: function updateDrawableSkinId(drawableID, skinId) {\n      var drawable = this._allDrawables[drawableID]; // TODO: https://github.com/LLK/scratch-vm/issues/2288\n      if (!drawable) return;\n      drawable.skin = this._allSkins[skinId];\n    }\n    /**\n     * Update a drawable's position.\n     * @param {number} drawableID The drawable's id.\n     * @param {Array.<number>} position The new position.\n     */\n  }, {\n    key: \"updateDrawablePosition\",\n    value: function updateDrawablePosition(drawableID, position) {\n      var drawable = this._allDrawables[drawableID]; // TODO: https://github.com/LLK/scratch-vm/issues/2288\n      if (!drawable) return;\n      drawable.updatePosition(position);\n    }\n    /**\n     * Update a drawable's direction.\n     * @param {number} drawableID The drawable's id.\n     * @param {number} direction A new direction.\n     */\n  }, {\n    key: \"updateDrawableDirection\",\n    value: function updateDrawableDirection(drawableID, direction) {\n      var drawable = this._allDrawables[drawableID]; // TODO: https://github.com/LLK/scratch-vm/issues/2288\n      if (!drawable) return;\n      drawable.updateDirection(direction);\n    }\n    /**\n     * Update a drawable's scale.\n     * @param {number} drawableID The drawable's id.\n     * @param {Array.<number>} scale A new scale.\n     */\n  }, {\n    key: \"updateDrawableScale\",\n    value: function updateDrawableScale(drawableID, scale) {\n      var drawable = this._allDrawables[drawableID]; // TODO: https://github.com/LLK/scratch-vm/issues/2288\n      if (!drawable) return;\n      drawable.updateScale(scale);\n    }\n    /**\n     * Update a drawable's direction and scale together.\n     * @param {number} drawableID The drawable's id.\n     * @param {number} direction A new direction.\n     * @param {Array.<number>} scale A new scale.\n     */\n  }, {\n    key: \"updateDrawableDirectionScale\",\n    value: function updateDrawableDirectionScale(drawableID, direction, scale) {\n      var drawable = this._allDrawables[drawableID]; // TODO: https://github.com/LLK/scratch-vm/issues/2288\n      if (!drawable) return;\n      drawable.updateDirection(direction);\n      drawable.updateScale(scale);\n    }\n    /**\n     * Update a drawable's visibility.\n     * @param {number} drawableID The drawable's id.\n     * @param {boolean} visible Will the drawable be visible?\n     */\n  }, {\n    key: \"updateDrawableVisible\",\n    value: function updateDrawableVisible(drawableID, visible) {\n      var drawable = this._allDrawables[drawableID]; // TODO: https://github.com/LLK/scratch-vm/issues/2288\n      if (!drawable) return;\n      drawable.updateVisible(visible);\n    }\n    /**\n     * Update a drawable's visual effect.\n     * @param {number} drawableID The drawable's id.\n     * @param {string} effectName The effect to change.\n     * @param {number} value A new effect value.\n     */\n  }, {\n    key: \"updateDrawableEffect\",\n    value: function updateDrawableEffect(drawableID, effectName, value) {\n      var drawable = this._allDrawables[drawableID]; // TODO: https://github.com/LLK/scratch-vm/issues/2288\n      if (!drawable) return;\n      drawable.updateEffect(effectName, value);\n    }\n    /**\n     * Update the position, direction, scale, or effect properties of this Drawable.\n     * @deprecated Use specific updateDrawable* methods instead.\n     * @param {int} drawableID The ID of the Drawable to update.\n     * @param {object.<string,*>} properties The new property values to set.\n     */\n  }, {\n    key: \"updateDrawableProperties\",\n    value: function updateDrawableProperties(drawableID, properties) {\n      var drawable = this._allDrawables[drawableID];\n      if (!drawable) {\n        /**\n         * @todo(https://github.com/LLK/scratch-vm/issues/2288) fix whatever's wrong in the VM which causes this, then add a warning or throw here.\n         * Right now this happens so much on some projects that a warning or exception here can hang the browser.\n         */\n        return;\n      }\n      if ('skinId' in properties) {\n        this.updateDrawableSkinId(drawableID, properties.skinId);\n      }\n      drawable.updateProperties(properties);\n    }\n    /**\n     * Update the position object's x & y members to keep the drawable fenced in view.\n     * @param {int} drawableID - The ID of the Drawable to update.\n     * @param {Array.<number, number>} position to be fenced - An array of type [x, y]\n     * @return {Array.<number, number>} The fenced position as an array [x, y]\n     */\n  }, {\n    key: \"getFencedPositionOfDrawable\",\n    value: function getFencedPositionOfDrawable(drawableID, position) {\n      var x = position[0];\n      var y = position[1];\n      var drawable = this._allDrawables[drawableID];\n      if (!drawable) {\n        // @todo(https://github.com/LLK/scratch-vm/issues/2288) fix whatever's wrong in the VM which causes this, then add a warning or throw here.\n        // Right now this happens so much on some projects that a warning or exception here can hang the browser.\n        return [x, y];\n      }\n      var dx = x - drawable._position[0];\n      var dy = y - drawable._position[1];\n      var aabb = drawable._skin.getFenceBounds(drawable, __fenceBounds);\n      var inset = Math.floor(Math.min(aabb.width, aabb.height) / 2);\n      var sx = this._xRight - Math.min(FENCE_WIDTH, inset);\n      if (aabb.right + dx < -sx) {\n        x = Math.ceil(drawable._position[0] - (sx + aabb.right));\n      } else if (aabb.left + dx > sx) {\n        x = Math.floor(drawable._position[0] + (sx - aabb.left));\n      }\n      var sy = this._yTop - Math.min(FENCE_WIDTH, inset);\n      if (aabb.top + dy < -sy) {\n        y = Math.ceil(drawable._position[1] - (sy + aabb.top));\n      } else if (aabb.bottom + dy > sy) {\n        y = Math.floor(drawable._position[1] + (sy - aabb.bottom));\n      }\n      return [x, y];\n    }\n    /**\n     * Clear a pen layer.\n     * @param {int} penSkinID - the unique ID of a Pen Skin.\n     */\n  }, {\n    key: \"penClear\",\n    value: function penClear(penSkinID) {\n      var skin =\n      /** @type {PenSkin} */\n      this._allSkins[penSkinID];\n      skin.clear();\n    }\n    /**\n     * Draw a point on a pen layer.\n     * @param {int} penSkinID - the unique ID of a Pen Skin.\n     * @param {PenAttributes} penAttributes - how the point should be drawn.\n     * @param {number} x - the X coordinate of the point to draw.\n     * @param {number} y - the Y coordinate of the point to draw.\n     */\n  }, {\n    key: \"penPoint\",\n    value: function penPoint(penSkinID, penAttributes, x, y) {\n      var skin =\n      /** @type {PenSkin} */\n      this._allSkins[penSkinID];\n      skin.drawPoint(penAttributes, x, y);\n    }\n    /**\n     * Draw a line on a pen layer.\n     * @param {int} penSkinID - the unique ID of a Pen Skin.\n     * @param {PenAttributes} penAttributes - how the line should be drawn.\n     * @param {number} x0 - the X coordinate of the beginning of the line.\n     * @param {number} y0 - the Y coordinate of the beginning of the line.\n     * @param {number} x1 - the X coordinate of the end of the line.\n     * @param {number} y1 - the Y coordinate of the end of the line.\n     */\n  }, {\n    key: \"penLine\",\n    value: function penLine(penSkinID, penAttributes, x0, y0, x1, y1) {\n      var skin =\n      /** @type {PenSkin} */\n      this._allSkins[penSkinID];\n      skin.drawLine(penAttributes, x0, y0, x1, y1);\n    }\n    /**\n     * Stamp a Drawable onto a pen layer.\n     * @param {int} penSkinID - the unique ID of a Pen Skin.\n     * @param {int} stampID - the unique ID of the Drawable to use as the stamp.\n     */\n  }, {\n    key: \"penStamp\",\n    value: function penStamp(penSkinID, stampID) {\n      var stampDrawable = this._allDrawables[stampID];\n      if (!stampDrawable) {\n        return;\n      }\n      var bounds = this._touchingBounds(stampID);\n      if (!bounds) {\n        return;\n      }\n      this._doExitDrawRegion();\n      var skin =\n      /** @type {PenSkin} */\n      this._allSkins[penSkinID];\n      var gl = this._gl;\n      twgl.bindFramebufferInfo(gl, skin._framebuffer); // Limit size of viewport to the bounds around the stamp Drawable and create the projection matrix for the draw.\n      gl.viewport(this._nativeSize[0] * 0.5 + bounds.left, this._nativeSize[1] * 0.5 - bounds.top, bounds.width, bounds.height);\n      var projection = twgl.m4.ortho(bounds.left, bounds.right, bounds.top, bounds.bottom, -1, 1); // Draw the stamped sprite onto the PenSkin's framebuffer.\n      this._drawThese([stampID], ShaderManager.DRAW_MODE.default, projection, {\n        ignoreVisibility: true\n      });\n      skin._silhouetteDirty = true;\n    }\n    /* ******\n     * Truly internal functions: these support the functions above.\n     ********/\n    /**\n     * Build geometry (vertex and index) buffers.\n     * @private\n     */\n  }, {\n    key: \"_createGeometry\",\n    value: function _createGeometry() {\n      var quad = {\n        a_position: {\n          numComponents: 2,\n          data: [-0.5, -0.5, 0.5, -0.5, -0.5, 0.5, -0.5, 0.5, 0.5, -0.5, 0.5, 0.5]\n        },\n        a_texCoord: {\n          numComponents: 2,\n          data: [1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1]\n        }\n      };\n      this._bufferInfo = twgl.createBufferInfoFromArrays(this._gl, quad);\n    }\n    /**\n     * Respond to a change in the \"native\" rendering size. The native size is used by buffers which are fixed in size\n     * regardless of the size of the main render target. This includes the buffers used for queries such as picking and\n     * color-touching. The fixed size allows (more) consistent behavior across devices and presentation modes.\n     * @param {object} event - The change event.\n     * @private\n     */\n  }, {\n    key: \"onNativeSizeChanged\",\n    value: function onNativeSizeChanged(event) {\n      var _event$newSize = _slicedToArray(event.newSize, 2),\n          width = _event$newSize[0],\n          height = _event$newSize[1];\n      var gl = this._gl;\n      var attachments = [{\n        format: gl.RGBA\n      }, {\n        format: gl.DEPTH_STENCIL\n      }];\n      if (!this._pickBufferInfo) {\n        this._pickBufferInfo = twgl.createFramebufferInfo(gl, attachments, MAX_TOUCH_SIZE[0], MAX_TOUCH_SIZE[1]);\n      }\n      /** @todo should we create this on demand to save memory? */\n      // A 480x360 32-bpp buffer is 675 KiB.\n      if (this._queryBufferInfo) {\n        twgl.resizeFramebufferInfo(gl, this._queryBufferInfo, attachments, width, height);\n      } else {\n        this._queryBufferInfo = twgl.createFramebufferInfo(gl, attachments, width, height);\n      }\n    }\n    /**\n     * Enter a draw region.\n     *\n     * A draw region is where multiple draw operations are performed with the\n     * same GL state. WebGL performs poorly when it changes state like blend\n     * mode. Marking a collection of state values as a \"region\" the renderer\n     * can skip superfluous extra state calls when it is already in that\n     * region. Since one region may be entered from within another a exit\n     * handle can also be registered that is called when a new region is about\n     * to be entered to restore a common inbetween state.\n     *\n     * @param {any} regionId - id of the region to enter\n     * @param {function} enter - handle to call when first entering a region\n     * @param {function} exit - handle to call when leaving a region\n     */\n  }, {\n    key: \"enterDrawRegion\",\n    value: function enterDrawRegion(regionId) {\n      var enter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : regionId.enter;\n      var exit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : regionId.exit;\n      if (this._regionId !== regionId) {\n        this._doExitDrawRegion();\n        this._regionId = regionId;\n        enter();\n        this._exitRegion = exit;\n      }\n    }\n    /**\n     * Forcefully exit the current region returning to a common inbetween GL\n     * state.\n     */\n  }, {\n    key: \"_doExitDrawRegion\",\n    value: function _doExitDrawRegion() {\n      if (this._exitRegion !== null) {\n        this._exitRegion();\n      }\n      this._exitRegion = null;\n      this._regionId = null;\n    }\n    /**\n     * Get the screen-space scale of a drawable, as percentages of the drawable's \"normal\" size.\n     * @param {Drawable} drawable The drawable whose screen-space scale we're fetching.\n     * @returns {Array<number>} The screen-space X and Y dimensions of the drawable's scale, as percentages.\n     */\n  }, {\n    key: \"_getDrawableScreenSpaceScale\",\n    value: function _getDrawableScreenSpaceScale(drawable) {\n      return [drawable.scale[0] * this._gl.canvas.width / this._nativeSize[0], drawable.scale[1] * this._gl.canvas.height / this._nativeSize[1]];\n    }\n    /**\n     * Draw a set of Drawables, by drawable ID\n     * @param {Array<int>} drawables The Drawable IDs to draw, possibly this._drawList.\n     * @param {ShaderManager.DRAW_MODE} drawMode Draw normally, silhouette, etc.\n     * @param {module:twgl/m4.Mat4} projection The projection matrix to use.\n     * @param {object} [opts] Options for drawing\n     * @param {idFilterFunc} opts.filter An optional filter function.\n     * @param {object.<string,*>} opts.extraUniforms Extra uniforms for the shaders.\n     * @param {int} opts.effectMask Bitmask for effects to allow\n     * @param {boolean} opts.ignoreVisibility Draw all, despite visibility (e.g. stamping, touching color)\n     * @private\n     */\n  }, {\n    key: \"_drawThese\",\n    value: function _drawThese(drawables, drawMode, projection) {\n      var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var gl = this._gl;\n      var currentShader = null;\n      var numDrawables = drawables.length;\n      for (var drawableIndex = 0; drawableIndex < numDrawables; ++drawableIndex) {\n        var drawableID = drawables[drawableIndex]; // If we have a filter, check whether the ID fails\n        if (opts.filter && !opts.filter(drawableID)) continue;\n        var drawable = this._allDrawables[drawableID];\n        /** @todo check if drawable is inside the viewport before anything else */\n        // Hidden drawables (e.g., by a \"hide\" block) are not drawn unless\n        // the ignoreVisibility flag is used (e.g. for stamping or touchingColor).\n        if (!drawable.getVisible() && !opts.ignoreVisibility) continue; // Combine drawable scale with the native vs. backing pixel ratio\n        var drawableScale = this._getDrawableScreenSpaceScale(drawable); // If the skin or texture isn't ready yet, skip it.\n        if (!drawable.skin || !drawable.skin.getTexture(drawableScale)) continue;\n        var uniforms = {};\n        var effectBits = drawable.enabledEffects;\n        effectBits &= Object.prototype.hasOwnProperty.call(opts, 'effectMask') ? opts.effectMask : effectBits;\n        var newShader = this._shaderManager.getShader(drawMode, effectBits); // Manually perform region check. Do not create functions inside a\n        // loop.\n        if (this._regionId !== newShader) {\n          this._doExitDrawRegion();\n          this._regionId = newShader;\n          currentShader = newShader;\n          gl.useProgram(currentShader.program);\n          twgl.setBuffersAndAttributes(gl, currentShader, this._bufferInfo);\n          Object.assign(uniforms, {\n            u_projectionMatrix: projection\n          });\n        }\n        Object.assign(uniforms, drawable.skin.getUniforms(drawableScale), drawable.getUniforms()); // Apply extra uniforms after the Drawable's, to allow overwriting.\n        if (opts.extraUniforms) {\n          Object.assign(uniforms, opts.extraUniforms);\n        }\n        if (uniforms.u_skin) {\n          twgl.setTextureParameters(gl, uniforms.u_skin, {\n            minMag: drawable.skin.useNearest(drawableScale, drawable) ? gl.NEAREST : gl.LINEAR\n          });\n        }\n        twgl.setUniforms(currentShader, uniforms);\n        twgl.drawBufferInfo(gl, this._bufferInfo, gl.TRIANGLES);\n      }\n      this._regionId = null;\n    }\n    /**\n     * Get the convex hull points for a particular Drawable.\n     * To do this, calculate it based on the drawable's Silhouette.\n     * @param {int} drawableID The Drawable IDs calculate convex hull for.\n     * @return {Array<Array<number>>} points Convex hull points, as [[x, y], ...]\n     */\n  }, {\n    key: \"_getConvexHullPointsForDrawable\",\n    value: function _getConvexHullPointsForDrawable(drawableID) {\n      var drawable = this._allDrawables[drawableID];\n      var _drawable$skin$size = _slicedToArray(drawable.skin.size, 2),\n          width = _drawable$skin$size[0],\n          height = _drawable$skin$size[1]; // No points in the hull if invisible or size is 0.\n      if (!drawable.getVisible() || width === 0 || height === 0) {\n        return [];\n      }\n      drawable.updateCPURenderAttributes();\n      /**\n       * Return the determinant of two vectors, the vector from A to B and the vector from A to C.\n       *\n       * The determinant is useful in this case to know if AC is counter-clockwise from AB.\n       * A positive value means that AC is counter-clockwise from AB. A negative value means AC is clockwise from AB.\n       *\n       * @param {Float32Array} A A 2d vector in space.\n       * @param {Float32Array} B A 2d vector in space.\n       * @param {Float32Array} C A 2d vector in space.\n       * @return {number} Greater than 0 if counter clockwise, less than if clockwise, 0 if all points are on a line.\n       */\n      var determinant = function determinant(A, B, C) {\n        // AB = B - A\n        // AC = C - A\n        // det (AB BC) = AB0 * AC1 - AB1 * AC0\n        return (B[0] - A[0]) * (C[1] - A[1]) - (B[1] - A[1]) * (C[0] - A[0]);\n      }; // This algorithm for calculating the convex hull somewhat resembles the monotone chain algorithm.\n      // The main difference is that instead of sorting the points by x-coordinate, and y-coordinate in case of ties,\n      // it goes through them by y-coordinate in the outer loop and x-coordinate in the inner loop.\n      // This gives us \"left\" and \"right\" hulls, whereas the monotone chain algorithm gives \"top\" and \"bottom\" hulls.\n      // Adapted from https://github.com/LLK/scratch-flash/blob/dcbeeb59d44c3be911545dfe54d46a32404f8e69/src/scratch/ScratchCostume.as#L369-L413\n      var leftHull = [];\n      var rightHull = []; // While convex hull algorithms usually push and pop values from the list of hull points,\n      // here, we keep indices for the \"last\" point in each array. Any points past these indices are ignored.\n      // This is functionally equivalent to pushing and popping from a \"stack\" of hull points.\n      var leftEndPointIndex = -1;\n      var rightEndPointIndex = -1;\n      var _pixelPos = twgl.v3.create();\n      var _effectPos = twgl.v3.create();\n      var currentPoint; // *Not* Scratch Space-- +y is bottom\n      // Loop over all rows of pixels, starting at the top\n      for (var y = 0; y < height; y++) {\n        _pixelPos[1] = y / height; // We start at the leftmost point, then go rightwards until we hit an opaque pixel\n        var x = 0;\n        for (; x < width; x++) {\n          _pixelPos[0] = x / width;\n          EffectTransform.transformPoint(drawable, _pixelPos, _effectPos);\n          if (drawable.skin.isTouchingLinear(_effectPos)) {\n            currentPoint = [x, y];\n            break;\n          }\n        } // If we managed to loop all the way through, there are no opaque pixels on this row. Go to the next one\n        if (x >= width) {\n          continue;\n        } // Because leftEndPointIndex is initialized to -1, this is skipped for the first two rows.\n        // It runs only when there are enough points in the left hull to make at least one line.\n        // If appending the current point to the left hull makes a counter-clockwise turn,\n        // we want to append the current point. Otherwise, we decrement the index of the \"last\" hull point until the\n        // current point makes a counter-clockwise turn.\n        // This decrementing has the same effect as popping from the point list, but is hopefully faster.\n        while (leftEndPointIndex > 0) {\n          if (determinant(leftHull[leftEndPointIndex], leftHull[leftEndPointIndex - 1], currentPoint) > 0) {\n            break;\n          } else {\n            // leftHull.pop();\n            --leftEndPointIndex;\n          }\n        } // This has the same effect as pushing to the point list.\n        // This \"list head pointer\" coding style leaves excess points dangling at the end of the list,\n        // but that doesn't matter; we simply won't copy them over to the final hull.\n        // leftHull.push(currentPoint);\n        leftHull[++leftEndPointIndex] = currentPoint; // Now we repeat the process for the right side, looking leftwards for a pixel.\n        for (x = width - 1; x >= 0; x--) {\n          _pixelPos[0] = x / width;\n          EffectTransform.transformPoint(drawable, _pixelPos, _effectPos);\n          if (drawable.skin.isTouchingLinear(_effectPos)) {\n            currentPoint = [x, y];\n            break;\n          }\n        } // Because we're coming at this from the right, it goes clockwise this time.\n        while (rightEndPointIndex > 0) {\n          if (determinant(rightHull[rightEndPointIndex], rightHull[rightEndPointIndex - 1], currentPoint) < 0) {\n            break;\n          } else {\n            --rightEndPointIndex;\n          }\n        }\n        rightHull[++rightEndPointIndex] = currentPoint;\n      } // Start off \"hullPoints\" with the left hull points.\n      var hullPoints = leftHull; // This is where we get rid of those dangling extra points.\n      hullPoints.length = leftEndPointIndex + 1; // Add points from the right side in reverse order so all points are ordered clockwise.\n      for (var j = rightEndPointIndex; j >= 0; --j) {\n        hullPoints.push(rightHull[j]);\n      } // Simplify boundary points using hull.js.\n      // TODO: Remove this; this algorithm already generates convex hulls.\n      return hull(hullPoints, Infinity);\n    }\n    /**\n     * Sample a \"final\" color from an array of drawables at a given scratch space.\n     * Will blend any alpha values with the drawables \"below\" it.\n     * @param {twgl.v3} vec Scratch Vector Space to sample\n     * @param {Array<Drawables>} drawables A list of drawables with the \"top most\"\n     *              drawable at index 0\n     * @param {Uint8ClampedArray} dst The color3b space to store the answer in.\n     * @return {Uint8ClampedArray} The dst vector with everything blended down.\n     */\n  }, {\n    key: \"requestSnapshot\",\n    /**\n     * @callback RenderWebGL#snapshotCallback\n     * @param {string} dataURI Data URI of the snapshot of the renderer\n     */\n    /**\n     * @param {snapshotCallback} callback Function called in the next frame with the snapshot data\n     */\n    value: function requestSnapshot(callback) {\n      this._snapshotCallbacks.push(callback);\n    }\n  }, {\n    key: \"gl\",\n    get: function get() {\n      return this._gl;\n    }\n    /**\n     * @returns {HTMLCanvasElement} the canvas of the WebGL rendering context associated with this renderer.\n     */\n  }, {\n    key: \"canvas\",\n    get: function get() {\n      return this._gl && this._gl.canvas;\n    }\n  }, {\n    key: \"_visibleDrawList\",\n    get: function get() {\n      var _this4 = this;\n      return this._drawList.filter(function (id) {\n        return _this4._allDrawables[id]._visible;\n      });\n    }\n  }], [{\n    key: \"sampleColor3b\",\n    value: function sampleColor3b(vec, drawables, dst) {\n      dst = dst || new Uint8ClampedArray(3);\n      dst.fill(0);\n      var blendAlpha = 1;\n      for (var index = 0; blendAlpha !== 0 && index < drawables.length; index++) {\n        /*\n        if (left > vec[0] || right < vec[0] ||\n            bottom > vec[1] || top < vec[0]) {\n            continue;\n        }\n        */\n        Drawable.sampleColor4b(vec, drawables[index].drawable, __blendColor); // Equivalent to gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA)\n        dst[0] += __blendColor[0] * blendAlpha;\n        dst[1] += __blendColor[1] * blendAlpha;\n        dst[2] += __blendColor[2] * blendAlpha;\n        blendAlpha *= 1 - __blendColor[3] / 255;\n      } // Backdrop could be transparent, so we need to go to the \"clear color\" of the\n      // draw scene (white) as a fallback if everything was alpha\n      dst[0] += blendAlpha * 255;\n      dst[1] += blendAlpha * 255;\n      dst[2] += blendAlpha * 255;\n      return dst;\n    }\n  }]);\n  return RenderWebGL;\n}(EventEmitter); // :3\nRenderWebGL.prototype.canHazPixels = RenderWebGL.prototype.extractDrawable;\n/**\n * Values for setUseGPU()\n * @enum {string}\n */\nRenderWebGL.UseGpuModes = {\n  /**\n   * Heuristically decide whether to use the GPU path, the CPU path, or a dynamic mixture of the two.\n   */\n  Automatic: 'Automatic',\n  /**\n   * Always use the GPU path.\n   */\n  ForceGPU: 'ForceGPU',\n  /**\n   * Always use the CPU path.\n   */\n  ForceCPU: 'ForceCPU'\n};\nmodule.exports = RenderWebGL;\n })