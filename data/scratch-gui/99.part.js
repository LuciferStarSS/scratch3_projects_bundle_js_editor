/* 99 */\n (function(module, __webpack_exports__, __webpack_require__) {\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return reducer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return initialState; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return addMonitorRect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return getInitialPosition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return moveMonitorRect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"g\", function() { return resizeMonitorRect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return removeMonitorRect; });\n/* unused harmony export PADDING */\n/* unused harmony export SCREEN_HEIGHT */\n/* unused harmony export SCREEN_WIDTH */\n var _lib_log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nvar ADD_MONITOR_RECT = 'scratch-gui/monitors/ADD_MONITOR_RECT';\nvar MOVE_MONITOR_RECT = 'scratch-gui/monitors/MOVE_MONITOR_RECT';\nvar RESIZE_MONITOR_RECT = 'scratch-gui/monitors/RESIZE_MONITOR_RECT';\nvar REMOVE_MONITOR_RECT = 'scratch-gui/monitors/REMOVE_MONITOR_RECT';\nvar initialState = {\n  monitors: {},\n  savedMonitorPositions: {}\n}; // Verify that the rectangle formed by the 2 points is well-formed\nvar _verifyRect = function _verifyRect(upperStart, lowerEnd) {\n  if (isNaN(upperStart.x) || isNaN(upperStart.y) || isNaN(lowerEnd.x) || isNaN(lowerEnd.y)) {\n    return false;\n  }\n  if (!(upperStart.x < lowerEnd.x)) {\n    return false;\n  }\n  if (!(upperStart.y < lowerEnd.y)) {\n    return false;\n  }\n  return true;\n};\nvar _addMonitorRect = function _addMonitorRect(state, action) {\n  if (state.monitors.hasOwnProperty(action.monitorId)) {\n    _lib_log__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].error(\"Can't add monitor, monitor with id \".concat(action.monitorId, \" already exists.\"));\n    return state;\n  }\n  if (!_verifyRect(action.upperStart, action.lowerEnd)) {\n    _lib_log__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].error(\"Monitor rectangle not formatted correctly\");\n    return state;\n  }\n  return {\n    monitors: Object.assign({}, state.monitors, _defineProperty({}, action.monitorId, {\n      upperStart: action.upperStart,\n      lowerEnd: action.lowerEnd\n    })),\n    savedMonitorPositions: action.savePosition ? Object.assign({}, state.savedMonitorPositions, _defineProperty({}, action.monitorId, {\n      x: action.upperStart.x,\n      y: action.upperStart.y\n    })) : state.savedMonitorPositions\n  };\n};\nvar _moveMonitorRect = function _moveMonitorRect(state, action) {\n  if (!state.monitors.hasOwnProperty(action.monitorId)) {\n    _lib_log__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].error(\"Can't move monitor, monitor with id \".concat(action.monitorId, \" does not exist.\"));\n    return state;\n  }\n  if (isNaN(action.newX) || isNaN(action.newY)) {\n    _lib_log__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].error(\"Monitor rectangle not formatted correctly\");\n    return state;\n  }\n  var oldMonitor = state.monitors[action.monitorId];\n  if (oldMonitor.upperStart.x === action.newX && oldMonitor.upperStart.y === action.newY) {\n    // Hasn't moved\n    return state;\n  }\n  var monitorWidth = oldMonitor.lowerEnd.x - oldMonitor.upperStart.x;\n  var monitorHeight = oldMonitor.lowerEnd.y - oldMonitor.upperStart.y;\n  return {\n    monitors: Object.assign({}, state.monitors, _defineProperty({}, action.monitorId, {\n      upperStart: {\n        x: action.newX,\n        y: action.newY\n      },\n      lowerEnd: {\n        x: action.newX + monitorWidth,\n        y: action.newY + monitorHeight\n      }\n    })),\n    // User generated position is saved\n    savedMonitorPositions: Object.assign({}, state.savedMonitorPositions, _defineProperty({}, action.monitorId, {\n      x: action.newX,\n      y: action.newY\n    }))\n  };\n};\nvar _resizeMonitorRect = function _resizeMonitorRect(state, action) {\n  if (!state.monitors.hasOwnProperty(action.monitorId)) {\n    _lib_log__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].error(\"Can't resize monitor, monitor with id \".concat(action.monitorId, \" does not exist.\"));\n    return state;\n  }\n  if (isNaN(action.newWidth) || isNaN(action.newHeight) || action.newWidth <= 0 || action.newHeight <= 0) {\n    _lib_log__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].error(\"Monitor rectangle not formatted correctly\");\n    return state;\n  }\n  var oldMonitor = state.monitors[action.monitorId];\n  var newMonitor = {\n    upperStart: oldMonitor.upperStart,\n    lowerEnd: {\n      x: oldMonitor.upperStart.x + action.newWidth,\n      y: oldMonitor.upperStart.y + action.newHeight\n    }\n  };\n  if (newMonitor.lowerEnd.x === oldMonitor.lowerEnd.x && newMonitor.lowerEnd.y === oldMonitor.lowerEnd.y) {\n    // no change\n    return state;\n  }\n  return {\n    monitors: Object.assign({}, state.monitors, _defineProperty({}, action.monitorId, newMonitor)),\n    savedMonitorPositions: state.savedMonitorPositions\n  };\n};\nvar _removeMonitorRect = function _removeMonitorRect(state, action) {\n  if (!state.monitors.hasOwnProperty(action.monitorId)) {\n    _lib_log__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].error(\"Can't remove monitor, monitor with id \".concat(action.monitorId, \" does not exist.\"));\n    return state;\n  }\n  var newMonitors = Object.assign({}, state.monitors);\n  delete newMonitors[action.monitorId];\n  return {\n    monitors: newMonitors,\n    savedMonitorPositions: state.savedMonitorPositions\n  };\n};\nvar reducer = function reducer(state, action) {\n  if (typeof state === 'undefined') state = initialState;\n  switch (action.type) {\n    case ADD_MONITOR_RECT:\n      return _addMonitorRect(state, action);\n    case MOVE_MONITOR_RECT:\n      return _moveMonitorRect(state, action);\n    case RESIZE_MONITOR_RECT:\n      return _resizeMonitorRect(state, action);\n    case REMOVE_MONITOR_RECT:\n      return _removeMonitorRect(state, action);\n    default:\n      return state;\n  }\n}; // Init position --------------------------\nvar PADDING = 5; // @todo fix these numbers when we fix https://github.com/LLK/scratch-gui/issues/980\nvar SCREEN_WIDTH = 400;\nvar SCREEN_HEIGHT = 300;\nvar SCREEN_EDGE_BUFFER = 40;\nvar _rectsIntersect = function _rectsIntersect(rect1, rect2) {\n  // If one rectangle is on left side of other\n  if (rect1.upperStart.x >= rect2.lowerEnd.x || rect2.upperStart.x >= rect1.lowerEnd.x) return false; // If one rectangle is above other\n  if (rect1.upperStart.y >= rect2.lowerEnd.y || rect2.upperStart.y >= rect1.lowerEnd.y) return false;\n  return true;\n}; // We need to place a monitor with the given width and height. Return a rect defining where it should be placed.\nvar getInitialPosition = function getInitialPosition(state, monitorId, eltWidth, eltHeight) {\n  // If this monitor was purposefully moved to a certain position before, put it back in that position\n  if (state.savedMonitorPositions.hasOwnProperty(monitorId)) {\n    var saved = state.savedMonitorPositions[monitorId];\n    return {\n      upperStart: saved,\n      lowerEnd: {\n        x: saved.x + eltWidth,\n        y: saved.y + eltHeight\n      }\n    };\n  } // Try all starting positions for the new monitor to find one that doesn't intersect others\n  var endXs = [0];\n  var endYs = [0];\n  var lastX = null;\n  var lastY = null;\n  for (var monitor in state.monitors) {\n    var x = state.monitors[monitor].lowerEnd.x;\n    x = Math.ceil(x / 50) * 50; // Try to choose a sensible \"tab width\" so more monitors line up\n    endXs.push(x);\n    endYs.push(Math.ceil(state.monitors[monitor].lowerEnd.y));\n  }\n  endXs.sort(function (a, b) {\n    return a - b;\n  });\n  endYs.sort(function (a, b) {\n    return a - b;\n  }); // We'll use plan B if the monitor doesn't fit anywhere (too long or tall)\n  var planB = null;\n  for (var _i = 0, _endXs = endXs; _i < _endXs.length; _i++) {\n    var _x = _endXs[_i];\n    if (_x === lastX) {\n      continue;\n    }\n    lastX = _x;\n    var _iterator = _createForOfIteratorHelper(endYs),\n        _step;\n    try {\n      outer: for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var y = _step.value;\n        if (y === lastY) {\n          continue;\n        }\n        lastY = y;\n        var monitorRect = {\n          upperStart: {\n            x: _x + PADDING,\n            y: y + PADDING\n          },\n          lowerEnd: {\n            x: _x + PADDING + eltWidth,\n            y: y + PADDING + eltHeight\n          }\n        }; // Intersection testing rect that includes padding\n        var rect = {\n          upperStart: {\n            x: _x,\n            y: y\n          },\n          lowerEnd: {\n            x: _x + eltWidth + 2 * PADDING,\n            y: y + eltHeight + 2 * PADDING\n          }\n        };\n        for (var _monitor in state.monitors) {\n          if (_rectsIntersect(state.monitors[_monitor], rect)) {\n            continue outer;\n          }\n        } // If the rect overlaps the ends of the screen\n        if (rect.lowerEnd.x > SCREEN_WIDTH || rect.lowerEnd.y > SCREEN_HEIGHT) {\n          // If rect is not too close to completely off screen, set it as plan B\n          if (!planB && !(rect.upperStart.x + SCREEN_EDGE_BUFFER > SCREEN_WIDTH || rect.upperStart.y + SCREEN_EDGE_BUFFER > SCREEN_HEIGHT)) {\n            planB = monitorRect;\n          }\n          continue;\n        }\n        return monitorRect;\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  } // If the monitor is too long to fit anywhere, put it in the leftmost spot available\n  // that intersects the right or bottom edge and isn't too close to the edge.\n  if (planB) {\n    return planB;\n  } // If plan B fails and there's nowhere reasonable to put it, plan C is to place the monitor randomly\n  var randX = Math.ceil(Math.random() * (SCREEN_WIDTH / 2));\n  var randY = Math.ceil(Math.random() * (SCREEN_HEIGHT - SCREEN_EDGE_BUFFER));\n  return {\n    upperStart: {\n      x: randX,\n      y: randY\n    },\n    lowerEnd: {\n      x: randX + eltWidth,\n      y: randY + eltHeight\n    }\n  };\n}; // Action creators ------------------------\n/**\n * @param {!string} monitorId Id to add\n * @param {!object} upperStart upper point defining the rectangle\n * @param {!number} upperStart.x X of top point that defines the monitor location\n * @param {!number} upperStart.y Y of top point that defines the monitor location\n * @param {!object} lowerEnd lower point defining the rectangle\n * @param {!number} lowerEnd.x X of bottom point that defines the monitor location\n * @param {!number} lowerEnd.y Y of bottom point that defines the monitor location\n * @param {?boolean} savePosition True if the placement should be saved when adding the monitor\n * @returns {object} action to add a new monitor at the location\n */\nvar addMonitorRect = function addMonitorRect(monitorId, upperStart, lowerEnd, savePosition) {\n  return {\n    type: ADD_MONITOR_RECT,\n    monitorId: monitorId,\n    upperStart: upperStart,\n    lowerEnd: lowerEnd,\n    savePosition: savePosition\n  };\n};\n/**\n * @param {!string} monitorId Id for monitor to move\n * @param {!number} newX X of top point that defines the monitor location\n * @param {!number} newY Y of top point that defines the monitor location\n * @returns {object} action to move an existing monitor to the location\n */\nvar moveMonitorRect = function moveMonitorRect(monitorId, newX, newY) {\n  return {\n    type: MOVE_MONITOR_RECT,\n    monitorId: monitorId,\n    newX: newX,\n    newY: newY\n  };\n};\n/**\n * @param {!string} monitorId Id for monitor to resize\n * @param {!number} newWidth Width to set monitor to\n * @param {!number} newHeight Height to set monitor to\n * @returns {object} action to resize an existing monitor to the given dimensions\n */\nvar resizeMonitorRect = function resizeMonitorRect(monitorId, newWidth, newHeight) {\n  return {\n    type: RESIZE_MONITOR_RECT,\n    monitorId: monitorId,\n    newWidth: newWidth,\n    newHeight: newHeight\n  };\n};\n/**\n * @param {!string} monitorId Id for monitor to remove\n * @returns {object} action to remove an existing monitor\n */\nvar removeMonitorRect = function removeMonitorRect(monitorId) {\n  return {\n    type: REMOVE_MONITOR_RECT,\n    monitorId: monitorId\n  };\n};\n })