/* 450 */\n (function(module, exports, __webpack_require__) {\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nvar EventEmitter = __webpack_require__(91);\nvar _require = __webpack_require__(181),\n    OrderedMap = _require.OrderedMap;\nvar ArgumentType = __webpack_require__(63);\nvar Blocks = __webpack_require__(135);\nvar BlocksRuntimeCache = __webpack_require__(441);\nvar BlockType = __webpack_require__(45);\nvar Profiler = __webpack_require__(1074);\nvar Sequencer = __webpack_require__(1075);\nvar execute = __webpack_require__(451);\nvar ScratchBlocksConstants = __webpack_require__(1077);\nvar TargetType = __webpack_require__(432);\nvar Thread = __webpack_require__(224);\nvar log = __webpack_require__(39);\nvar maybeFormatMessage = __webpack_require__(428);\nvar StageLayering = __webpack_require__(115);\nvar Variable = __webpack_require__(114);\nvar xmlEscape = __webpack_require__(220);\nvar ScratchLinkWebSocket = __webpack_require__(1078); // Virtual I/O devices.\nvar Clock = __webpack_require__(1079);\nvar Cloud = __webpack_require__(1080);\nvar Keyboard = __webpack_require__(1081);\nvar Mouse = __webpack_require__(1082);\nvar MouseWheel = __webpack_require__(1083);\nvar UserData = __webpack_require__(1084);\nvar Video = __webpack_require__(452);\nvar StringUtil = __webpack_require__(102);\nvar uid = __webpack_require__(94);\nvar defaultBlockPackages = {\n  scratch3_control: __webpack_require__(1085),\n  scratch3_event: __webpack_require__(1086),\n  scratch3_looks: __webpack_require__(1087),\n  scratch3_motion: __webpack_require__(1088),\n  scratch3_operators: __webpack_require__(1089),\n  scratch3_sound: __webpack_require__(1090),\n  scratch3_sensing: __webpack_require__(1091),\n  scratch3_data: __webpack_require__(1092),\n  scratch3_procedures: __webpack_require__(1093)\n};\nvar defaultExtensionColors = ['#0FBD8C', '#0DA57A', '#0B8E69'];\n/**\n * Information used for converting Scratch argument types into scratch-blocks data.\n * @type {object.<ArgumentType, {shadowType: string, fieldType: string}>}\n */\nvar ArgumentTypeMap = function () {\n  var map = {};\n  map[ArgumentType.ANGLE] = {\n    shadow: {\n      type: 'math_angle',\n      // We specify fieldNames here so that we can pick\n      // create and populate a field with the defaultValue\n      // specified in the extension.\n      // When the `fieldName` property is not specified,\n      // the <field></field> will be left out of the XML and\n      // the scratch-blocks defaults for that field will be\n      // used instead (e.g. default of 0 for number fields)\n      fieldName: 'NUM'\n    }\n  };\n  map[ArgumentType.COLOR] = {\n    shadow: {\n      type: 'colour_picker',\n      fieldName: 'COLOUR'\n    }\n  };\n  map[ArgumentType.NUMBER] = {\n    shadow: {\n      type: 'math_number',\n      fieldName: 'NUM'\n    }\n  };\n  map[ArgumentType.STRING] = {\n    shadow: {\n      type: 'text',\n      fieldName: 'TEXT'\n    }\n  };\n  map[ArgumentType.BOOLEAN] = {\n    check: 'Boolean'\n  };\n  map[ArgumentType.MATRIX] = {\n    shadow: {\n      type: 'matrix',\n      fieldName: 'MATRIX'\n    }\n  };\n  map[ArgumentType.NOTE] = {\n    shadow: {\n      type: 'note',\n      fieldName: 'NOTE'\n    }\n  };\n  map[ArgumentType.IMAGE] = {\n    // Inline images are weird because they're not actually \"arguments\".\n    // They are more analagous to the label on a block.\n    fieldType: 'field_image'\n  };\n  return map;\n}();\n/**\n * A pair of functions used to manage the cloud variable limit,\n * to be used when adding (or attempting to add) or removing a cloud variable.\n * @typedef {object} CloudDataManager\n * @property {function} canAddCloudVariable A function to call to check that\n * a cloud variable can be added.\n * @property {function} addCloudVariable A function to call to track a new\n * cloud variable on the runtime.\n * @property {function} removeCloudVariable A function to call when\n * removing an existing cloud variable.\n * @property {function} hasCloudVariables A function to call to check that\n * the runtime has any cloud variables.\n */\n/**\n * Creates and manages cloud variable limit in a project,\n * and returns two functions to be used to add a new\n * cloud variable (while checking that it can be added)\n * and remove an existing cloud variable.\n * These are to be called whenever attempting to create or delete\n * a cloud variable.\n * @return {CloudDataManager} The functions to be used when adding or removing a\n * cloud variable.\n */\nvar cloudDataManager = function cloudDataManager() {\n  var limit = 10;\n  var count = 0;\n  var canAddCloudVariable = function canAddCloudVariable() {\n    return count < limit;\n  };\n  var addCloudVariable = function addCloudVariable() {\n    count++;\n  };\n  var removeCloudVariable = function removeCloudVariable() {\n    count--;\n  };\n  var hasCloudVariables = function hasCloudVariables() {\n    return count > 0;\n  };\n  return {\n    canAddCloudVariable: canAddCloudVariable,\n    addCloudVariable: addCloudVariable,\n    removeCloudVariable: removeCloudVariable,\n    hasCloudVariables: hasCloudVariables\n  };\n};\n/**\n * Numeric ID for Runtime._step in Profiler instances.\n * @type {number}\n */\nvar stepProfilerId = -1;\n/**\n * Numeric ID for Sequencer.stepThreads in Profiler instances.\n * @type {number}\n */\nvar stepThreadsProfilerId = -1;\n/**\n * Numeric ID for RenderWebGL.draw in Profiler instances.\n * @type {number}\n */\nvar rendererDrawProfilerId = -1;\n/**\n * Manages targets, scripts, and the sequencer.\n * @constructor\n */\nvar Runtime = function (_EventEmitter) {\n  _inherits(Runtime, _EventEmitter);\n  var _super = _createSuper(Runtime);\n  function Runtime() {\n    var _this;\n    _classCallCheck(this, Runtime);\n    _this = _super.call(this);\n    /**\n     * Target management and storage.\n     * @type {Array.<!Target>}\n     */\n    _this.targets = [];\n    /**\n     * Targets in reverse order of execution. Shares its order with drawables.\n     * @type {Array.<!Target>}\n     */\n    _this.executableTargets = [];\n    /**\n     * A list of threads that are currently running in the VM.\n     * Threads are added when execution starts and pruned when execution ends.\n     * @type {Array.<Thread>}\n     */\n    _this.threads = [];\n    /** @type {!Sequencer} */\n    _this.sequencer = new Sequencer(_assertThisInitialized(_this));\n    /**\n     * Storage container for flyout blocks.\n     * These will execute on `_editingTarget.`\n     * @type {!Blocks}\n     */\n    _this.flyoutBlocks = new Blocks(_assertThisInitialized(_this), true\n    /* force no glow */\n    );\n    /**\n     * Storage container for monitor blocks.\n     * These will execute on a target maybe\n     * @type {!Blocks}\n     */\n    _this.monitorBlocks = new Blocks(_assertThisInitialized(_this), true\n    /* force no glow */\n    );\n    /**\n     * Currently known editing target for the VM.\n     * @type {?Target}\n     */\n    _this._editingTarget = null;\n    /**\n     * Map to look up a block primitive's implementation function by its opcode.\n     * This is a two-step lookup: package name first, then primitive name.\n     * @type {Object.<string, Function>}\n     */\n    _this._primitives = {};\n    /**\n     * Map to look up all block information by extended opcode.\n     * @type {Array.<CategoryInfo>}\n     * @private\n     */\n    _this._blockInfo = [];\n    /**\n     * Map to look up hat blocks' metadata.\n     * Keys are opcode for hat, values are metadata objects.\n     * @type {Object.<string, Object>}\n     */\n    _this._hats = {};\n    /**\n     * A list of script block IDs that were glowing during the previous frame.\n     * @type {!Array.<!string>}\n     */\n    _this._scriptGlowsPreviousFrame = [];\n    /**\n     * Number of non-monitor threads running during the previous frame.\n     * @type {number}\n     */\n    _this._nonMonitorThreadCount = 0;\n    /**\n     * All threads that finished running and were removed from this.threads\n     * by behaviour in Sequencer.stepThreads.\n     * @type {Array<Thread>}\n     */\n    _this._lastStepDoneThreads = null;\n    /**\n     * Currently known number of clones, used to enforce clone limit.\n     * @type {number}\n     */\n    _this._cloneCounter = 0;\n    /**\n     * Flag to emit a targets update at the end of a step. When target data\n     * changes, this flag is set to true.\n     * @type {boolean}\n     */\n    _this._refreshTargets = false;\n    /**\n     * Map to look up all monitor block information by opcode.\n     * @type {object}\n     * @private\n     */\n    _this.monitorBlockInfo = {};\n    /**\n     * Ordered map of all monitors, which are MonitorReporter objects.\n     */\n    _this._monitorState = OrderedMap({});\n    /**\n     * Monitor state from last tick\n     */\n    _this._prevMonitorState = OrderedMap({});\n    /**\n     * Whether the project is in \"turbo mode.\"\n     * @type {Boolean}\n     */\n    _this.turboMode = false;\n    /**\n     * Whether the project is in \"compatibility mode\" (30 TPS).\n     * @type {Boolean}\n     */\n    _this.compatibilityMode = false;\n    /**\n     * A reference to the current runtime stepping interval, set\n     * by a `setInterval`.\n     * @type {!number}\n     */\n    _this._steppingInterval = null;\n    /**\n     * Current length of a step.\n     * Changes as mode switches, and used by the sequencer to calculate\n     * WORK_TIME.\n     * @type {!number}\n     */\n    _this.currentStepTime = null; // Set an intial value for this.currentMSecs\n    _this.updateCurrentMSecs();\n    /**\n     * Whether any primitive has requested a redraw.\n     * Affects whether `Sequencer.stepThreads` will yield\n     * after stepping each thread.\n     * Reset on every frame.\n     * @type {boolean}\n     */\n    _this.redrawRequested = false; // Register all given block packages.\n    _this._registerBlockPackages(); // Register and initialize \"IO devices\", containers for processing\n    // I/O related data.\n    /** @type {Object.<string, Object>} */\n    _this.ioDevices = {\n      clock: new Clock(_assertThisInitialized(_this)),\n      cloud: new Cloud(_assertThisInitialized(_this)),\n      keyboard: new Keyboard(_assertThisInitialized(_this)),\n      mouse: new Mouse(_assertThisInitialized(_this)),\n      mouseWheel: new MouseWheel(_assertThisInitialized(_this)),\n      userData: new UserData(),\n      video: new Video(_assertThisInitialized(_this))\n    };\n    /**\n     * A list of extensions, used to manage hardware connection.\n     */\n    _this.peripheralExtensions = {};\n    /**\n     * A runtime profiler that records timed events for later playback to\n     * diagnose Scratch performance.\n     * @type {Profiler}\n     */\n    _this.profiler = null;\n    var newCloudDataManager = cloudDataManager();\n    /**\n     * Check wether the runtime has any cloud data.\n     * @type {function}\n     * @return {boolean} Whether or not the runtime currently has any\n     * cloud variables.\n     */\n    _this.hasCloudData = newCloudDataManager.hasCloudVariables;\n    /**\n     * A function which checks whether a new cloud variable can be added\n     * to the runtime.\n     * @type {function}\n     * @return {boolean} Whether or not a new cloud variable can be added\n     * to the runtime.\n     */\n    _this.canAddCloudVariable = newCloudDataManager.canAddCloudVariable;\n    /**\n     * A function that tracks a new cloud variable in the runtime,\n     * updating the cloud variable limit. Calling this function will\n     * emit a cloud data update event if this is the first cloud variable\n     * being added.\n     * @type {function}\n     */\n    _this.addCloudVariable = _this._initializeAddCloudVariable(newCloudDataManager);\n    /**\n     * A function which updates the runtime's cloud variable limit\n     * when removing a cloud variable and emits a cloud update event\n     * if the last of the cloud variables is being removed.\n     * @type {function}\n     */\n    _this.removeCloudVariable = _this._initializeRemoveCloudVariable(newCloudDataManager);\n    return _this;\n  }\n  /**\n   * Width of the stage, in pixels.\n   * @const {number}\n   */\n  _createClass(Runtime, [{\n    key: \"_initializeAddCloudVariable\",\n    // -----------------------------------------------------------------------------\n    // -----------------------------------------------------------------------------\n    // Helper function for initializing the addCloudVariable function\n    value: function _initializeAddCloudVariable(newCloudDataManager) {\n      var _this2 = this;\n      // The addCloudVariable function\n      return function () {\n        var hadCloudVarsBefore = _this2.hasCloudData();\n        newCloudDataManager.addCloudVariable();\n        if (!hadCloudVarsBefore && _this2.hasCloudData()) {\n          _this2.emit(Runtime.HAS_CLOUD_DATA_UPDATE, true);\n        }\n      };\n    } // Helper function for initializing the removeCloudVariable function\n  }, {\n    key: \"_initializeRemoveCloudVariable\",\n    value: function _initializeRemoveCloudVariable(newCloudDataManager) {\n      var _this3 = this;\n      return function () {\n        var hadCloudVarsBefore = _this3.hasCloudData();\n        newCloudDataManager.removeCloudVariable();\n        if (hadCloudVarsBefore && !_this3.hasCloudData()) {\n          _this3.emit(Runtime.HAS_CLOUD_DATA_UPDATE, false);\n        }\n      };\n    }\n    /**\n     * Register default block packages with this runtime.\n     * @todo Prefix opcodes with package name.\n     * @private\n     */\n  }, {\n    key: \"_registerBlockPackages\",\n    value: function _registerBlockPackages() {\n      for (var packageName in defaultBlockPackages) {\n        if (defaultBlockPackages.hasOwnProperty(packageName)) {\n          // @todo pass a different runtime depending on package privilege?\n          var packageObject = new defaultBlockPackages[packageName](this); // Collect primitives from package.\n          if (packageObject.getPrimitives) {\n            var packagePrimitives = packageObject.getPrimitives();\n            for (var op in packagePrimitives) {\n              if (packagePrimitives.hasOwnProperty(op)) {\n                this._primitives[op] = packagePrimitives[op].bind(packageObject);\n              }\n            }\n          } // Collect hat metadata from package.\n          if (packageObject.getHats) {\n            var packageHats = packageObject.getHats();\n            for (var hatName in packageHats) {\n              if (packageHats.hasOwnProperty(hatName)) {\n                this._hats[hatName] = packageHats[hatName];\n              }\n            }\n          } // Collect monitored from package.\n          if (packageObject.getMonitored) {\n            this.monitorBlockInfo = Object.assign({}, this.monitorBlockInfo, packageObject.getMonitored());\n          }\n        }\n      }\n    }\n  }, {\n    key: \"getMonitorState\",\n    value: function getMonitorState() {\n      return this._monitorState;\n    }\n    /**\n     * Generate an extension-specific menu ID.\n     * @param {string} menuName - the name of the menu.\n     * @param {string} extensionId - the ID of the extension hosting the menu.\n     * @returns {string} - the constructed ID.\n     * @private\n     */\n  }, {\n    key: \"_makeExtensionMenuId\",\n    value: function _makeExtensionMenuId(menuName, extensionId) {\n      return \"\".concat(extensionId, \"_menu_\").concat(xmlEscape(menuName));\n    }\n    /**\n     * Create a context (\"args\") object for use with `formatMessage` on messages which might be target-specific.\n     * @param {Target} [target] - the target to use as context. If a target is not provided, default to the current\n     * editing target or the stage.\n     */\n  }, {\n    key: \"makeMessageContextForTarget\",\n    value: function makeMessageContextForTarget(target) {\n      var context = {};\n      target = target || this.getEditingTarget() || this.getTargetForStage();\n      if (target) {\n        context.targetType = target.isStage ? TargetType.STAGE : TargetType.SPRITE;\n      }\n    }\n    /**\n     * Register the primitives provided by an extension.\n     * @param {ExtensionMetadata} extensionInfo - information about the extension (id, blocks, etc.)\n     * @private\n     */\n  }, {\n    key: \"_registerExtensionPrimitives\",\n    value: function _registerExtensionPrimitives(extensionInfo) {\n      var categoryInfo = {\n        id: extensionInfo.id,\n        name: maybeFormatMessage(extensionInfo.name),\n        showStatusButton: extensionInfo.showStatusButton,\n        blockIconURI: extensionInfo.blockIconURI,\n        menuIconURI: extensionInfo.menuIconURI\n      };\n      if (extensionInfo.color1) {\n        categoryInfo.color1 = extensionInfo.color1;\n        categoryInfo.color2 = extensionInfo.color2;\n        categoryInfo.color3 = extensionInfo.color3;\n      } else {\n        categoryInfo.color1 = defaultExtensionColors[0];\n        categoryInfo.color2 = defaultExtensionColors[1];\n        categoryInfo.color3 = defaultExtensionColors[2];\n      }\n      this._blockInfo.push(categoryInfo);\n      this._fillExtensionCategory(categoryInfo, extensionInfo);\n      for (var fieldTypeName in categoryInfo.customFieldTypes) {\n        if (extensionInfo.customFieldTypes.hasOwnProperty(fieldTypeName)) {\n          var fieldTypeInfo = categoryInfo.customFieldTypes[fieldTypeName]; // Emit events for custom field types from extension\n          this.emit(Runtime.EXTENSION_FIELD_ADDED, {\n            name: \"field_\".concat(fieldTypeInfo.extendedName),\n            implementation: fieldTypeInfo.fieldImplementation\n          });\n        }\n      }\n      this.emit(Runtime.EXTENSION_ADDED, categoryInfo);\n    }\n    /**\n     * Reregister the primitives for an extension\n     * @param  {ExtensionMetadata} extensionInfo - new info (results of running getInfo) for an extension\n     * @private\n     */\n  }, {\n    key: \"_refreshExtensionPrimitives\",\n    value: function _refreshExtensionPrimitives(extensionInfo) {\n      var categoryInfo = this._blockInfo.find(function (info) {\n        return info.id === extensionInfo.id;\n      });\n      if (categoryInfo) {\n        categoryInfo.name = maybeFormatMessage(extensionInfo.name);\n        this._fillExtensionCategory(categoryInfo, extensionInfo);\n        this.emit(Runtime.BLOCKSINFO_UPDATE, categoryInfo);\n      }\n    }\n    /**\n     * Read extension information, convert menus, blocks and custom field types\n     * and store the results in the provided category object.\n     * @param {CategoryInfo} categoryInfo - the category to be filled\n     * @param {ExtensionMetadata} extensionInfo - the extension metadata to read\n     * @private\n     */\n  }, {\n    key: \"_fillExtensionCategory\",\n    value: function _fillExtensionCategory(categoryInfo, extensionInfo) {\n      categoryInfo.blocks = [];\n      categoryInfo.customFieldTypes = {};\n      categoryInfo.menus = [];\n      categoryInfo.menuInfo = {};\n      for (var menuName in extensionInfo.menus) {\n        if (extensionInfo.menus.hasOwnProperty(menuName)) {\n          var menuInfo = extensionInfo.menus[menuName];\n          var convertedMenu = this._buildMenuForScratchBlocks(menuName, menuInfo, categoryInfo);\n          categoryInfo.menus.push(convertedMenu);\n          categoryInfo.menuInfo[menuName] = menuInfo;\n        }\n      }\n      for (var fieldTypeName in extensionInfo.customFieldTypes) {\n        if (extensionInfo.customFieldTypes.hasOwnProperty(fieldTypeName)) {\n          var fieldType = extensionInfo.customFieldTypes[fieldTypeName];\n          var fieldTypeInfo = this._buildCustomFieldInfo(fieldTypeName, fieldType, extensionInfo.id, categoryInfo);\n          categoryInfo.customFieldTypes[fieldTypeName] = fieldTypeInfo;\n        }\n      }\n      var _iterator = _createForOfIteratorHelper(extensionInfo.blocks),\n          _step2;\n      try {\n        for (_iterator.s(); !(_step2 = _iterator.n()).done;) {\n          var blockInfo = _step2.value;\n          try {\n            var convertedBlock = this._convertForScratchBlocks(blockInfo, categoryInfo);\n            categoryInfo.blocks.push(convertedBlock);\n            if (convertedBlock.json) {\n              var opcode = convertedBlock.json.type;\n              if (blockInfo.blockType !== BlockType.EVENT) {\n                this._primitives[opcode] = convertedBlock.info.func;\n              }\n              if (blockInfo.blockType === BlockType.EVENT || blockInfo.blockType === BlockType.HAT) {\n                this._hats[opcode] = {\n                  edgeActivated: blockInfo.isEdgeActivated,\n                  restartExistingThreads: blockInfo.shouldRestartExistingThreads\n                };\n              }\n            }\n          } catch (e) {\n            log.error('Error parsing block: ', {\n              block: blockInfo,\n              error: e\n            });\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    /**\n     * Convert the given extension menu items into the scratch-blocks style of list of pairs.\n     * If the menu is dynamic (e.g. the passed in argument is a function), return the input unmodified.\n     * @param {object} menuItems - an array of menu items or a function to retrieve such an array\n     * @returns {object} - an array of 2 element arrays or the original input function\n     * @private\n     */\n  }, {\n    key: \"_convertMenuItems\",\n    value: function _convertMenuItems(menuItems) {\n      if (typeof menuItems !== 'function') {\n        var extensionMessageContext = this.makeMessageContextForTarget();\n        return menuItems.map(function (item) {\n          var formattedItem = maybeFormatMessage(item, extensionMessageContext);\n          switch (_typeof(formattedItem)) {\n            case 'string':\n              return [formattedItem, formattedItem];\n            case 'object':\n              return [maybeFormatMessage(item.text, extensionMessageContext), item.value];\n            default:\n              throw new Error(\"Can't interpret menu item: \".concat(JSON.stringify(item)));\n          }\n        });\n      }\n      return menuItems;\n    }\n    /**\n     * Build the scratch-blocks JSON for a menu. Note that scratch-blocks treats menus as a special kind of block.\n     * @param {string} menuName - the name of the menu\n     * @param {object} menuInfo - a description of this menu and its items\n     * @property {*} items - an array of menu items or a function to retrieve such an array\n     * @property {boolean} [acceptReporters] - if true, allow dropping reporters onto this menu\n     * @param {CategoryInfo} categoryInfo - the category for this block\n     * @returns {object} - a JSON-esque object ready for scratch-blocks' consumption\n     * @private\n     */\n  }, {\n    key: \"_buildMenuForScratchBlocks\",\n    value: function _buildMenuForScratchBlocks(menuName, menuInfo, categoryInfo) {\n      var menuId = this._makeExtensionMenuId(menuName, categoryInfo.id);\n      var menuItems = this._convertMenuItems(menuInfo.items);\n      return {\n        json: {\n          message0: '%1',\n          type: menuId,\n          inputsInline: true,\n          output: 'String',\n          colour: categoryInfo.color1,\n          colourSecondary: categoryInfo.color2,\n          colourTertiary: categoryInfo.color3,\n          outputShape: menuInfo.acceptReporters ? ScratchBlocksConstants.OUTPUT_SHAPE_ROUND : ScratchBlocksConstants.OUTPUT_SHAPE_SQUARE,\n          args0: [{\n            type: 'field_dropdown',\n            name: menuName,\n            options: menuItems\n          }]\n        }\n      };\n    }\n  }, {\n    key: \"_buildCustomFieldInfo\",\n    value: function _buildCustomFieldInfo(fieldName, fieldInfo, extensionId, categoryInfo) {\n      var extendedName = \"\".concat(extensionId, \"_\").concat(fieldName);\n      return {\n        fieldName: fieldName,\n        extendedName: extendedName,\n        argumentTypeInfo: {\n          shadow: {\n            type: extendedName,\n            fieldName: \"field_\".concat(extendedName)\n          }\n        },\n        scratchBlocksDefinition: this._buildCustomFieldTypeForScratchBlocks(extendedName, fieldInfo.output, fieldInfo.outputShape, categoryInfo),\n        fieldImplementation: fieldInfo.implementation\n      };\n    }\n    /**\n     * Build the scratch-blocks JSON needed for a fieldType.\n     * Custom field types need to be namespaced to the extension so that extensions can't interfere with each other\n     * @param  {string} fieldName - The name of the field\n     * @param {string} output - The output of the field\n     * @param {number} outputShape - Shape of the field (from ScratchBlocksConstants)\n     * @param {object} categoryInfo - The category the field belongs to (Used to set its colors)\n     * @returns {object} - Object to be inserted into scratch-blocks\n     */\n  }, {\n    key: \"_buildCustomFieldTypeForScratchBlocks\",\n    value: function _buildCustomFieldTypeForScratchBlocks(fieldName, output, outputShape, categoryInfo) {\n      return {\n        json: {\n          type: fieldName,\n          message0: '%1',\n          inputsInline: true,\n          output: output,\n          colour: categoryInfo.color1,\n          colourSecondary: categoryInfo.color2,\n          colourTertiary: categoryInfo.color3,\n          outputShape: outputShape,\n          args0: [{\n            name: \"field_\".concat(fieldName),\n            type: \"field_\".concat(fieldName)\n          }]\n        }\n      };\n    }\n    /**\n     * Convert ExtensionBlockMetadata into data ready for scratch-blocks.\n     * @param {ExtensionBlockMetadata} blockInfo - the block info to convert\n     * @param {CategoryInfo} categoryInfo - the category for this block\n     * @returns {ConvertedBlockInfo} - the converted & original block information\n     * @private\n     */\n  }, {\n    key: \"_convertForScratchBlocks\",\n    value: function _convertForScratchBlocks(blockInfo, categoryInfo) {\n      if (blockInfo === '---') {\n        return this._convertSeparatorForScratchBlocks(blockInfo);\n      }\n      if (blockInfo.blockType === BlockType.BUTTON) {\n        return this._convertButtonForScratchBlocks(blockInfo);\n      }\n      return this._convertBlockForScratchBlocks(blockInfo, categoryInfo);\n    }\n    /**\n     * Convert ExtensionBlockMetadata into scratch-blocks JSON & XML, and generate a proxy function.\n     * @param {ExtensionBlockMetadata} blockInfo - the block to convert\n     * @param {CategoryInfo} categoryInfo - the category for this block\n     * @returns {ConvertedBlockInfo} - the converted & original block information\n     * @private\n     */\n  }, {\n    key: \"_convertBlockForScratchBlocks\",\n    value: function _convertBlockForScratchBlocks(blockInfo, categoryInfo) {\n      var extendedOpcode = \"\".concat(categoryInfo.id, \"_\").concat(blockInfo.opcode);\n      var blockJSON = {\n        type: extendedOpcode,\n        inputsInline: true,\n        category: categoryInfo.name,\n        colour: categoryInfo.color1,\n        colourSecondary: categoryInfo.color2,\n        colourTertiary: categoryInfo.color3\n      };\n      var context = {\n        // TODO: store this somewhere so that we can map args appropriately after translation.\n        // This maps an arg name to its relative position in the original (usually English) block text.\n        // When displaying a block in another language we'll need to run a `replace` action similar to the one\n        // below, but each `[ARG]` will need to be replaced with the number in this map.\n        argsMap: {},\n        blockJSON: blockJSON,\n        categoryInfo: categoryInfo,\n        blockInfo: blockInfo,\n        inputList: []\n      }; // If an icon for the extension exists, prepend it to each block, with a vertical separator.\n      // We can overspecify an icon for each block, but if no icon exists on a block, fall back to\n      // the category block icon.\n      var iconURI = blockInfo.blockIconURI || categoryInfo.blockIconURI;\n      if (iconURI) {\n        blockJSON.extensions = ['scratch_extension'];\n        blockJSON.message0 = '%1 %2';\n        var iconJSON = {\n          type: 'field_image',\n          src: iconURI,\n          width: 40,\n          height: 40\n        };\n        var separatorJSON = {\n          type: 'field_vertical_separator'\n        };\n        blockJSON.args0 = [iconJSON, separatorJSON];\n      }\n      switch (blockInfo.blockType) {\n        case BlockType.COMMAND:\n          blockJSON.outputShape = ScratchBlocksConstants.OUTPUT_SHAPE_SQUARE;\n          blockJSON.previousStatement = null; // null = available connection; undefined = hat\n          if (!blockInfo.isTerminal) {\n            blockJSON.nextStatement = null; // null = available connection; undefined = terminal\n          }\n          break;\n        case BlockType.REPORTER:\n          blockJSON.output = 'String'; // TODO: distinguish number & string here?\n          blockJSON.outputShape = ScratchBlocksConstants.OUTPUT_SHAPE_ROUND;\n          break;\n        case BlockType.BOOLEAN:\n          blockJSON.output = 'Boolean';\n          blockJSON.outputShape = ScratchBlocksConstants.OUTPUT_SHAPE_HEXAGONAL;\n          break;\n        case BlockType.HAT:\n        case BlockType.EVENT:\n          if (!blockInfo.hasOwnProperty('isEdgeActivated')) {\n            // if absent, this property defaults to true\n            blockInfo.isEdgeActivated = true;\n          }\n          blockJSON.outputShape = ScratchBlocksConstants.OUTPUT_SHAPE_SQUARE;\n          blockJSON.nextStatement = null; // null = available connection; undefined = terminal\n          break;\n        case BlockType.CONDITIONAL:\n        case BlockType.LOOP:\n          blockInfo.branchCount = blockInfo.branchCount || 1;\n          blockJSON.outputShape = ScratchBlocksConstants.OUTPUT_SHAPE_SQUARE;\n          blockJSON.previousStatement = null; // null = available connection; undefined = hat\n          if (!blockInfo.isTerminal) {\n            blockJSON.nextStatement = null; // null = available connection; undefined = terminal\n          }\n          break;\n      }\n      var blockText = Array.isArray(blockInfo.text) ? blockInfo.text : [blockInfo.text];\n      var inTextNum = 0; // text for the next block \"arm\" is blockText[inTextNum]\n      var inBranchNum = 0; // how many branches have we placed into the JSON so far?\n      var outLineNum = 0; // used for scratch-blocks `message${outLineNum}` and `args${outLineNum}`\n      var convertPlaceholders = this._convertPlaceholders.bind(this, context);\n      var extensionMessageContext = this.makeMessageContextForTarget(); // alternate between a block \"arm\" with text on it and an open slot for a substack\n      while (inTextNum < blockText.length || inBranchNum < blockInfo.branchCount) {\n        if (inTextNum < blockText.length) {\n          context.outLineNum = outLineNum;\n          var lineText = maybeFormatMessage(blockText[inTextNum], extensionMessageContext);\n          var convertedText = lineText.replace(/\\[(.+?)]/g, convertPlaceholders);\n          if (blockJSON[\"message\".concat(outLineNum)]) {\n            blockJSON[\"message\".concat(outLineNum)] += convertedText;\n          } else {\n            blockJSON[\"message\".concat(outLineNum)] = convertedText;\n          }\n          ++inTextNum;\n          ++outLineNum;\n        }\n        if (inBranchNum < blockInfo.branchCount) {\n          blockJSON[\"message\".concat(outLineNum)] = '%1';\n          blockJSON[\"args\".concat(outLineNum)] = [{\n            type: 'input_statement',\n            name: \"SUBSTACK\".concat(inBranchNum > 0 ? inBranchNum + 1 : '')\n          }];\n          ++inBranchNum;\n          ++outLineNum;\n        }\n      }\n      if (blockInfo.blockType === BlockType.REPORTER) {\n        if (!blockInfo.disableMonitor && context.inputList.length === 0) {\n          blockJSON.checkboxInFlyout = true;\n        }\n      } else if (blockInfo.blockType === BlockType.LOOP) {\n        // Add icon to the bottom right of a loop block\n        blockJSON[\"lastDummyAlign\".concat(outLineNum)] = 'RIGHT';\n        blockJSON[\"message\".concat(outLineNum)] = '%1';\n        blockJSON[\"args\".concat(outLineNum)] = [{\n          type: 'field_image',\n          src: './static/blocks-media/repeat.svg',\n          // TODO: use a constant or make this configurable?\n          width: 24,\n          height: 24,\n          alt: '*',\n          // TODO remove this since we don't use collapsed blocks in scratch\n          flip_rtl: true\n        }];\n        ++outLineNum;\n      }\n      var mutation = blockInfo.isDynamic ? \"<mutation blockInfo=\\\"\".concat(xmlEscape(JSON.stringify(blockInfo)), \"\\\"/>\") : '';\n      var inputs = context.inputList.join('');\n      var blockXML = \"<block type=\\\"\".concat(extendedOpcode, \"\\\">\").concat(mutation).concat(inputs, \"</block>\");\n      return {\n        info: context.blockInfo,\n        json: context.blockJSON,\n        xml: blockXML\n      };\n    }\n    /**\n     * Generate a separator between blocks categories or sub-categories.\n     * @param {ExtensionBlockMetadata} blockInfo - the block to convert\n     * @param {CategoryInfo} categoryInfo - the category for this block\n     * @returns {ConvertedBlockInfo} - the converted & original block information\n     * @private\n     */\n  }, {\n    key: \"_convertSeparatorForScratchBlocks\",\n    value: function _convertSeparatorForScratchBlocks(blockInfo) {\n      return {\n        info: blockInfo,\n        xml: '<sep gap=\"36\"/>'\n      };\n    }\n    /**\n     * Convert a button for scratch-blocks. A button has no opcode but specifies a callback name in the `func` field.\n     * @param {ExtensionBlockMetadata} buttonInfo - the button to convert\n     * @property {string} func - the callback name\n     * @param {CategoryInfo} categoryInfo - the category for this button\n     * @returns {ConvertedBlockInfo} - the converted & original button information\n     * @private\n     */\n  }, {\n    key: \"_convertButtonForScratchBlocks\",\n    value: function _convertButtonForScratchBlocks(buttonInfo) {\n      // for now we only support these pre-defined callbacks handled in scratch-blocks\n      var supportedCallbackKeys = ['MAKE_A_LIST', 'MAKE_A_PROCEDURE', 'MAKE_A_VARIABLE'];\n      if (supportedCallbackKeys.indexOf(buttonInfo.func) < 0) {\n        log.error(\"Custom button callbacks not supported yet: \".concat(buttonInfo.func));\n      }\n      var extensionMessageContext = this.makeMessageContextForTarget();\n      var buttonText = maybeFormatMessage(buttonInfo.text, extensionMessageContext);\n      return {\n        info: buttonInfo,\n        xml: \"<button text=\\\"\".concat(buttonText, \"\\\" callbackKey=\\\"\").concat(buttonInfo.func, \"\\\"></button>\")\n      };\n    }\n    /**\n     * Helper for _convertPlaceholdes which handles inline images which are a specialized case of block \"arguments\".\n     * @param {object} argInfo Metadata about the inline image as specified by the extension\n     * @return {object} JSON blob for a scratch-blocks image field.\n     * @private\n     */\n  }, {\n    key: \"_constructInlineImageJson\",\n    value: function _constructInlineImageJson(argInfo) {\n      if (!argInfo.dataURI) {\n        log.warn('Missing data URI in extension block with argument type IMAGE');\n      }\n      return {\n        type: 'field_image',\n        src: argInfo.dataURI || '',\n        // TODO these probably shouldn't be hardcoded...?\n        width: 24,\n        height: 24,\n        // Whether or not the inline image should be flipped horizontally\n        // in RTL languages. Defaults to false, indicating that the\n        // image will not be flipped.\n        flip_rtl: argInfo.flipRTL || false\n      };\n    }\n    /**\n     * Helper for _convertForScratchBlocks which handles linearization of argument placeholders. Called as a callback\n     * from string#replace. In addition to the return value the JSON and XML items in the context will be filled.\n     * @param {object} context - information shared with _convertForScratchBlocks about the block, etc.\n     * @param {string} match - the overall string matched by the placeholder regex, including brackets: '[FOO]'.\n     * @param {string} placeholder - the name of the placeholder being matched: 'FOO'.\n     * @return {string} scratch-blocks placeholder for the argument: '%1'.\n     * @private\n     */\n  }, {\n    key: \"_convertPlaceholders\",\n    value: function _convertPlaceholders(context, match, placeholder) {\n      // Sanitize the placeholder to ensure valid XML\n      placeholder = placeholder.replace(/[<\"&]/, '_'); // Determine whether the argument type is one of the known standard field types\n      var argInfo = context.blockInfo.arguments[placeholder] || {};\n      var argTypeInfo = ArgumentTypeMap[argInfo.type] || {}; // Field type not a standard field type, see if extension has registered custom field type\n      if (!ArgumentTypeMap[argInfo.type] && context.categoryInfo.customFieldTypes[argInfo.type]) {\n        argTypeInfo = context.categoryInfo.customFieldTypes[argInfo.type].argumentTypeInfo;\n      } // Start to construct the scratch-blocks style JSON defining how the block should be\n      // laid out\n      var argJSON; // Most field types are inputs (slots on the block that can have other blocks plugged into them)\n      // check if this is not one of those cases. E.g. an inline image on a block.\n      if (argTypeInfo.fieldType === 'field_image') {\n        argJSON = this._constructInlineImageJson(argInfo);\n      } else {\n        // Construct input value\n        // Layout a block argument (e.g. an input slot on the block)\n        argJSON = {\n          type: 'input_value',\n          name: placeholder\n        };\n        var defaultValue = typeof argInfo.defaultValue === 'undefined' ? '' : xmlEscape(maybeFormatMessage(argInfo.defaultValue, this.makeMessageContextForTarget()).toString());\n        if (argTypeInfo.check) {\n          // Right now the only type of 'check' we have specifies that the\n          // input slot on the block accepts Boolean reporters, so it should be\n          // shaped like a hexagon\n          argJSON.check = argTypeInfo.check;\n        }\n        var valueName;\n        var shadowType;\n        var fieldName;\n        if (argInfo.menu) {\n          var menuInfo = context.categoryInfo.menuInfo[argInfo.menu];\n          if (menuInfo.acceptReporters) {\n            valueName = placeholder;\n            shadowType = this._makeExtensionMenuId(argInfo.menu, context.categoryInfo.id);\n            fieldName = argInfo.menu;\n          } else {\n            argJSON.type = 'field_dropdown';\n            argJSON.options = this._convertMenuItems(menuInfo.items);\n            valueName = null;\n            shadowType = null;\n            fieldName = placeholder;\n          }\n        } else {\n          valueName = placeholder;\n          shadowType = argTypeInfo.shadow && argTypeInfo.shadow.type || null;\n          fieldName = argTypeInfo.shadow && argTypeInfo.shadow.fieldName || null;\n        } // <value> is the ScratchBlocks name for a block input.\n        if (valueName) {\n          context.inputList.push(\"<value name=\\\"\".concat(placeholder, \"\\\">\"));\n        } // The <shadow> is a placeholder for a reporter and is visible when there's no reporter in this input.\n        // Boolean inputs don't need to specify a shadow in the XML.\n        if (shadowType) {\n          context.inputList.push(\"<shadow type=\\\"\".concat(shadowType, \"\\\">\"));\n        } // A <field> displays a dynamic value: a user-editable text field, a drop-down menu, etc.\n        // Leave out the field if defaultValue or fieldName are not specified\n        if (defaultValue && fieldName) {\n          context.inputList.push(\"<field name=\\\"\".concat(fieldName, \"\\\">\").concat(defaultValue, \"</field>\"));\n        }\n        if (shadowType) {\n          context.inputList.push('</shadow>');\n        }\n        if (valueName) {\n          context.inputList.push('</value>');\n        }\n      }\n      var argsName = \"args\".concat(context.outLineNum);\n      var blockArgs = context.blockJSON[argsName] = context.blockJSON[argsName] || [];\n      if (argJSON) blockArgs.push(argJSON);\n      var argNum = blockArgs.length;\n      context.argsMap[placeholder] = argNum;\n      return \"%\".concat(argNum);\n    }\n    /**\n     * @returns {Array.<object>} scratch-blocks XML for each category of extension blocks, in category order.\n     * @param {?Target} [target] - the active editing target (optional)\n     * @property {string} id - the category / extension ID\n     * @property {string} xml - the XML text for this category, starting with `<category>` and ending with `</category>`\n     */\n  }, {\n    key: \"getBlocksXML\",\n    value: function getBlocksXML(target) {\n      return this._blockInfo.map(function (categoryInfo) {\n        var name = categoryInfo.name,\n            color1 = categoryInfo.color1,\n            color2 = categoryInfo.color2; // Filter out blocks that aren't supposed to be shown on this target, as determined by the block info's\n        // `hideFromPalette` and `filter` properties.\n        var paletteBlocks = categoryInfo.blocks.filter(function (block) {\n          var blockFilterIncludesTarget = true; // If an editing target is not passed, include all blocks\n          // If the block info doesn't include a `filter` property, always include it\n          if (target && block.info.filter) {\n            blockFilterIncludesTarget = block.info.filter.includes(target.isStage ? TargetType.STAGE : TargetType.SPRITE);\n          } // If the block info's `hideFromPalette` is true, then filter out this block\n          return blockFilterIncludesTarget && !block.info.hideFromPalette;\n        });\n        var colorXML = \"colour=\\\"\".concat(color1, \"\\\" secondaryColour=\\\"\").concat(color2, \"\\\"\"); // Use a menu icon if there is one. Otherwise, use the block icon. If there's no icon,\n        // the category menu will show its default colored circle.\n        var menuIconURI = '';\n        if (categoryInfo.menuIconURI) {\n          menuIconURI = categoryInfo.menuIconURI;\n        } else if (categoryInfo.blockIconURI) {\n          menuIconURI = categoryInfo.blockIconURI;\n        }\n        var menuIconXML = menuIconURI ? \"iconURI=\\\"\".concat(menuIconURI, \"\\\"\") : '';\n        var statusButtonXML = '';\n        if (categoryInfo.showStatusButton) {\n          statusButtonXML = 'showStatusButton=\"true\"';\n        }\n        return {\n          id: categoryInfo.id,\n          xml: \"<category name=\\\"\".concat(name, \"\\\" id=\\\"\").concat(categoryInfo.id, \"\\\" \").concat(statusButtonXML, \" \").concat(colorXML, \" \").concat(menuIconXML, \">\").concat(paletteBlocks.map(function (block) {\n            return block.xml;\n          }).join(''), \"</category>\")\n        };\n      });\n    }\n    /**\n     * @returns {Array.<string>} - an array containing the scratch-blocks JSON information for each dynamic block.\n     */\n  }, {\n    key: \"getBlocksJSON\",\n    value: function getBlocksJSON() {\n      return this._blockInfo.reduce(function (result, categoryInfo) {\n        return result.concat(categoryInfo.blocks.map(function (blockInfo) {\n          return blockInfo.json;\n        }));\n      }, []);\n    }\n    /**\n     * Get a scratch link socket.\n     * @param {string} type Either BLE or BT\n     * @returns {ScratchLinkSocket} The scratch link socket.\n     */\n  }, {\n    key: \"getScratchLinkSocket\",\n    value: function getScratchLinkSocket(type) {\n      var factory = this._linkSocketFactory || this._defaultScratchLinkSocketFactory;\n      return factory(type);\n    }\n    /**\n     * Configure how ScratchLink sockets are created. Factory must consume a \"type\" parameter\n     * either BT or BLE.\n     * @param {Function} factory The new factory for creating ScratchLink sockets.\n     */\n  }, {\n    key: \"configureScratchLinkSocketFactory\",\n    value: function configureScratchLinkSocketFactory(factory) {\n      this._linkSocketFactory = factory;\n    }\n    /**\n     * The default scratch link socket creator, using websockets to the installed device manager.\n     * @param {string} type Either BLE or BT\n     * @returns {ScratchLinkSocket} The new scratch link socket (a WebSocket object)\n     */\n  }, {\n    key: \"_defaultScratchLinkSocketFactory\",\n    value: function _defaultScratchLinkSocketFactory(type) {\n      return new ScratchLinkWebSocket(type);\n    }\n    /**\n     * Register an extension that communications with a hardware peripheral by id,\n     * to have access to it and its peripheral functions in the future.\n     * @param {string} extensionId - the id of the extension.\n     * @param {object} extension - the extension to register.\n     */\n  }, {\n    key: \"registerPeripheralExtension\",\n    value: function registerPeripheralExtension(extensionId, extension) {\n      this.peripheralExtensions[extensionId] = extension;\n    }\n    /**\n     * Tell the specified extension to scan for a peripheral.\n     * @param {string} extensionId - the id of the extension.\n     */\n  }, {\n    key: \"scanForPeripheral\",\n    value: function scanForPeripheral(extensionId) {\n      if (this.peripheralExtensions[extensionId]) {\n        this.peripheralExtensions[extensionId].scan();\n      }\n    }\n    /**\n     * Connect to the extension's specified peripheral.\n     * @param {string} extensionId - the id of the extension.\n     * @param {number} peripheralId - the id of the peripheral.\n     */\n  }, {\n    key: \"connectPeripheral\",\n    value: function connectPeripheral(extensionId, peripheralId) {\n      if (this.peripheralExtensions[extensionId]) {\n        this.peripheralExtensions[extensionId].connect(peripheralId);\n      }\n    }\n    /**\n     * Disconnect from the extension's connected peripheral.\n     * @param {string} extensionId - the id of the extension.\n     */\n  }, {\n    key: \"disconnectPeripheral\",\n    value: function disconnectPeripheral(extensionId) {\n      if (this.peripheralExtensions[extensionId]) {\n        this.peripheralExtensions[extensionId].disconnect();\n      }\n    }\n    /**\n     * Returns whether the extension has a currently connected peripheral.\n     * @param {string} extensionId - the id of the extension.\n     * @return {boolean} - whether the extension has a connected peripheral.\n     */\n  }, {\n    key: \"getPeripheralIsConnected\",\n    value: function getPeripheralIsConnected(extensionId) {\n      var isConnected = false;\n      if (this.peripheralExtensions[extensionId]) {\n        isConnected = this.peripheralExtensions[extensionId].isConnected();\n      }\n      return isConnected;\n    }\n    /**\n     * Emit an event to indicate that the microphone is being used to stream audio.\n     * @param {boolean} listening - true if the microphone is currently listening.\n     */\n  }, {\n    key: \"emitMicListening\",\n    value: function emitMicListening(listening) {\n      this.emit(Runtime.MIC_LISTENING, listening);\n    }\n    /**\n     * Retrieve the function associated with the given opcode.\n     * @param {!string} opcode The opcode to look up.\n     * @return {Function} The function which implements the opcode.\n     */\n  }, {\n    key: \"getOpcodeFunction\",\n    value: function getOpcodeFunction(opcode) {\n      return this._primitives[opcode];\n    }\n    /**\n     * Return whether an opcode represents a hat block.\n     * @param {!string} opcode The opcode to look up.\n     * @return {boolean} True if the op is known to be a hat.\n     */\n  }, {\n    key: \"getIsHat\",\n    value: function getIsHat(opcode) {\n      return this._hats.hasOwnProperty(opcode);\n    }\n    /**\n     * Return whether an opcode represents an edge-activated hat block.\n     * @param {!string} opcode The opcode to look up.\n     * @return {boolean} True if the op is known to be a edge-activated hat.\n     */\n  }, {\n    key: \"getIsEdgeActivatedHat\",\n    value: function getIsEdgeActivatedHat(opcode) {\n      return this._hats.hasOwnProperty(opcode) && this._hats[opcode].edgeActivated;\n    }\n    /**\n     * Attach the audio engine\n     * @param {!AudioEngine} audioEngine The audio engine to attach\n     */\n  }, {\n    key: \"attachAudioEngine\",\n    value: function attachAudioEngine(audioEngine) {\n      this.audioEngine = audioEngine;\n    }\n    /**\n     * Attach the renderer\n     * @param {!RenderWebGL} renderer The renderer to attach\n     */\n  }, {\n    key: \"attachRenderer\",\n    value: function attachRenderer(renderer) {\n      this.renderer = renderer;\n      this.renderer.setLayerGroupOrdering(StageLayering.LAYER_GROUPS);\n    }\n    /**\n     * Set the svg adapter, which converts scratch 2 svgs to scratch 3 svgs\n     * @param {!SvgRenderer} svgAdapter The adapter to attach\n     */\n  }, {\n    key: \"attachV2SVGAdapter\",\n    value: function attachV2SVGAdapter(svgAdapter) {\n      this.v2SvgAdapter = svgAdapter;\n    }\n    /**\n     * Set the bitmap adapter for the VM/runtime, which converts scratch 2\n     * bitmaps to scratch 3 bitmaps. (Scratch 3 bitmaps are all bitmap resolution 2)\n     * @param {!function} bitmapAdapter The adapter to attach\n     */\n  }, {\n    key: \"attachV2BitmapAdapter\",\n    value: function attachV2BitmapAdapter(bitmapAdapter) {\n      this.v2BitmapAdapter = bitmapAdapter;\n    }\n    /**\n     * Attach the storage module\n     * @param {!ScratchStorage} storage The storage module to attach\n     */\n  }, {\n    key: \"attachStorage\",\n    value: function attachStorage(storage) {\n      this.storage = storage;\n    } // -----------------------------------------------------------------------------\n    // -----------------------------------------------------------------------------\n    /**\n     * Create a thread and push it to the list of threads.\n     * @param {!string} id ID of block that starts the stack.\n     * @param {!Target} target Target to run thread on.\n     * @param {?object} opts optional arguments\n     * @param {?boolean} opts.stackClick true if the script was activated by clicking on the stack\n     * @param {?boolean} opts.updateMonitor true if the script should update a monitor value\n     * @return {!Thread} The newly created thread.\n     */\n  }, {\n    key: \"_pushThread\",\n    value: function _pushThread(id, target, opts) {\n      var thread = new Thread(id);\n      thread.target = target;\n      thread.stackClick = Boolean(opts && opts.stackClick);\n      thread.updateMonitor = Boolean(opts && opts.updateMonitor);\n      thread.blockContainer = thread.updateMonitor ? this.monitorBlocks : target.blocks;\n      thread.pushStack(id);\n      this.threads.push(thread);\n      return thread;\n    }\n    /**\n     * Stop a thread: stop running it immediately, and remove it from the thread list later.\n     * @param {!Thread} thread Thread object to remove from actives\n     */\n  }, {\n    key: \"_stopThread\",\n    value: function _stopThread(thread) {\n      // Mark the thread for later removal\n      thread.isKilled = true; // Inform sequencer to stop executing that thread.\n      this.sequencer.retireThread(thread);\n    }\n    /**\n     * Restart a thread in place, maintaining its position in the list of threads.\n     * This is used by `startHats` to and is necessary to ensure 2.0-like execution order.\n     * Test project: https://scratch.mit.edu/projects/130183108/\n     * @param {!Thread} thread Thread object to restart.\n     * @return {Thread} The restarted thread.\n     */\n  }, {\n    key: \"_restartThread\",\n    value: function _restartThread(thread) {\n      var newThread = new Thread(thread.topBlock);\n      newThread.target = thread.target;\n      newThread.stackClick = thread.stackClick;\n      newThread.updateMonitor = thread.updateMonitor;\n      newThread.blockContainer = thread.blockContainer;\n      newThread.pushStack(thread.topBlock);\n      var i = this.threads.indexOf(thread);\n      if (i > -1) {\n        this.threads[i] = newThread;\n        return newThread;\n      }\n      this.threads.push(thread);\n      return thread;\n    }\n    /**\n     * Return whether a thread is currently active/running.\n     * @param {?Thread} thread Thread object to check.\n     * @return {boolean} True if the thread is active/running.\n     */\n  }, {\n    key: \"isActiveThread\",\n    value: function isActiveThread(thread) {\n      return thread.stack.length > 0 && thread.status !== Thread.STATUS_DONE && this.threads.indexOf(thread) > -1;\n    }\n    /**\n     * Return whether a thread is waiting for more information or done.\n     * @param {?Thread} thread Thread object to check.\n     * @return {boolean} True if the thread is waiting\n     */\n  }, {\n    key: \"isWaitingThread\",\n    value: function isWaitingThread(thread) {\n      return thread.status === Thread.STATUS_PROMISE_WAIT || thread.status === Thread.STATUS_YIELD_TICK || !this.isActiveThread(thread);\n    }\n    /**\n     * Toggle a script.\n     * @param {!string} topBlockId ID of block that starts the script.\n     * @param {?object} opts optional arguments to toggle script\n     * @param {?string} opts.target target ID for target to run script on. If not supplied, uses editing target.\n     * @param {?boolean} opts.stackClick true if the user activated the stack by clicking, false if not. This\n     *     determines whether we show a visual report when turning on the script.\n     */\n  }, {\n    key: \"toggleScript\",\n    value: function toggleScript(topBlockId, opts) {\n      opts = Object.assign({\n        target: this._editingTarget,\n        stackClick: false\n      }, opts); // Remove any existing thread.\n      for (var i = 0; i < this.threads.length; i++) {\n        // Toggling a script that's already running turns it off\n        if (this.threads[i].topBlock === topBlockId && this.threads[i].status !== Thread.STATUS_DONE) {\n          var blockContainer = opts.target.blocks;\n          var opcode = blockContainer.getOpcode(blockContainer.getBlock(topBlockId));\n          if (this.getIsEdgeActivatedHat(opcode) && this.threads[i].stackClick !== opts.stackClick) {\n            // Allow edge activated hat thread stack click to coexist with\n            // edge activated hat thread that runs every frame\n            continue;\n          }\n          this._stopThread(this.threads[i]);\n          return;\n        }\n      } // Otherwise add it.\n      this._pushThread(topBlockId, opts.target, opts);\n    }\n    /**\n     * Enqueue a script that when finished will update the monitor for the block.\n     * @param {!string} topBlockId ID of block that starts the script.\n     * @param {?Target} optTarget target Target to run script on. If not supplied, uses editing target.\n     */\n  }, {\n    key: \"addMonitorScript\",\n    value: function addMonitorScript(topBlockId, optTarget) {\n      if (!optTarget) optTarget = this._editingTarget;\n      for (var i = 0; i < this.threads.length; i++) {\n        // Don't re-add the script if it's already running\n        if (this.threads[i].topBlock === topBlockId && this.threads[i].status !== Thread.STATUS_DONE && this.threads[i].updateMonitor) {\n          return;\n        }\n      } // Otherwise add it.\n      this._pushThread(topBlockId, optTarget, {\n        updateMonitor: true\n      });\n    }\n    /**\n     * Run a function `f` for all scripts in a workspace.\n     * `f` will be called with two parameters:\n     *  - the top block ID of the script.\n     *  - the target that owns the script.\n     * @param {!Function} f Function to call for each script.\n     * @param {Target=} optTarget Optionally, a target to restrict to.\n     */\n  }, {\n    key: \"allScriptsDo\",\n    value: function allScriptsDo(f, optTarget) {\n      var targets = this.executableTargets;\n      if (optTarget) {\n        targets = [optTarget];\n      }\n      for (var t = targets.length - 1; t >= 0; t--) {\n        var target = targets[t];\n        var scripts = target.blocks.getScripts();\n        for (var j = 0; j < scripts.length; j++) {\n          var topBlockId = scripts[j];\n          f(topBlockId, target);\n        }\n      }\n    }\n  }, {\n    key: \"allScriptsByOpcodeDo\",\n    value: function allScriptsByOpcodeDo(opcode, f, optTarget) {\n      var targets = this.executableTargets;\n      if (optTarget) {\n        targets = [optTarget];\n      }\n      for (var t = targets.length - 1; t >= 0; t--) {\n        var target = targets[t];\n        var scripts = BlocksRuntimeCache.getScripts(target.blocks, opcode);\n        for (var j = 0; j < scripts.length; j++) {\n          f(scripts[j], target);\n        }\n      }\n    }\n    /**\n     * Start all relevant hats.\n     * @param {!string} requestedHatOpcode Opcode of hats to start.\n     * @param {object=} optMatchFields Optionally, fields to match on the hat.\n     * @param {Target=} optTarget Optionally, a target to restrict to.\n     * @return {Array.<Thread>} List of threads started by this function.\n     */\n  }, {\n    key: \"startHats\",\n    value: function startHats(requestedHatOpcode, optMatchFields, optTarget) {\n      var _this4 = this;\n      if (!this._hats.hasOwnProperty(requestedHatOpcode)) {\n        // No known hat with this opcode.\n        return;\n      }\n      var instance = this;\n      var newThreads = []; // Look up metadata for the relevant hat.\n      var hatMeta = instance._hats[requestedHatOpcode];\n      for (var opts in optMatchFields) {\n        if (!optMatchFields.hasOwnProperty(opts)) continue;\n        optMatchFields[opts] = optMatchFields[opts].toUpperCase();\n      } // Consider all scripts, looking for hats with opcode `requestedHatOpcode`.\n      this.allScriptsByOpcodeDo(requestedHatOpcode, function (script, target) {\n        var topBlockId = script.blockId,\n            hatFields = script.fieldsOfInputs; // Match any requested fields.\n        // For example: ensures that broadcasts match.\n        // This needs to happen before the block is evaluated\n        // (i.e., before the predicate can be run) because \"broadcast and wait\"\n        // needs to have a precise collection of started threads.\n        for (var matchField in optMatchFields) {\n          if (hatFields[matchField].value !== optMatchFields[matchField]) {\n            // Field mismatch.\n            return;\n          }\n        }\n        if (hatMeta.restartExistingThreads) {\n          // If `restartExistingThreads` is true, we should stop\n          // any existing threads starting with the top block.\n          for (var i = 0; i < _this4.threads.length; i++) {\n            if (_this4.threads[i].target === target && _this4.threads[i].topBlock === topBlockId && // stack click threads and hat threads can coexist\n            !_this4.threads[i].stackClick) {\n              newThreads.push(_this4._restartThread(_this4.threads[i]));\n              return;\n            }\n          }\n        } else {\n          // If `restartExistingThreads` is false, we should\n          // give up if any threads with the top block are running.\n          for (var j = 0; j < _this4.threads.length; j++) {\n            if (_this4.threads[j].target === target && _this4.threads[j].topBlock === topBlockId && // stack click threads and hat threads can coexist\n            !_this4.threads[j].stackClick && _this4.threads[j].status !== Thread.STATUS_DONE) {\n              // Some thread is already running.\n              return;\n            }\n          }\n        } // Start the thread with this top block.\n        newThreads.push(_this4._pushThread(topBlockId, target));\n      }, optTarget); // For compatibility with Scratch 2, edge triggered hats need to be processed before\n      // threads are stepped. See ScratchRuntime.as for original implementation\n      newThreads.forEach(function (thread) {\n        execute(_this4.sequencer, thread);\n        thread.goToNextBlock();\n      });\n      return newThreads;\n    }\n    /**\n     * Dispose all targets. Return to clean state.\n     */\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.stopAll(); // Deleting each target's variable's monitors.\n      this.targets.forEach(function (target) {\n        if (target.isOriginal) target.deleteMonitors();\n      });\n      this.targets.map(this.disposeTarget, this);\n      this._monitorState = OrderedMap({});\n      this.emit(Runtime.RUNTIME_DISPOSED);\n      this.ioDevices.clock.resetProjectTimer(); // @todo clear out extensions? turboMode? etc.\n      // *********** Cloud *******************\n      // If the runtime currently has cloud data,\n      // emit a has cloud data update event resetting\n      // it to false\n      if (this.hasCloudData()) {\n        this.emit(Runtime.HAS_CLOUD_DATA_UPDATE, false);\n      }\n      this.ioDevices.cloud.clear(); // Reset runtime cloud data info\n      var newCloudDataManager = cloudDataManager();\n      this.hasCloudData = newCloudDataManager.hasCloudVariables;\n      this.canAddCloudVariable = newCloudDataManager.canAddCloudVariable;\n      this.addCloudVariable = this._initializeAddCloudVariable(newCloudDataManager);\n      this.removeCloudVariable = this._initializeRemoveCloudVariable(newCloudDataManager);\n    }\n    /**\n     * Add a target to the runtime. This tracks the sprite pane\n     * ordering of the target. The target still needs to be put\n     * into the correct execution order after calling this function.\n     * @param {Target} target target to add\n     */\n  }, {\n    key: \"addTarget\",\n    value: function addTarget(target) {\n      this.targets.push(target);\n      this.executableTargets.push(target);\n    }\n    /**\n     * Move a target in the execution order by a relative amount.\n     *\n     * A positve number will make the target execute earlier. A negative number\n     * will make the target execute later in the order.\n     *\n     * @param {Target} executableTarget target to move\n     * @param {number} delta number of positions to move target by\n     * @returns {number} new position in execution order\n     */\n  }, {\n    key: \"moveExecutable\",\n    value: function moveExecutable(executableTarget, delta) {\n      var oldIndex = this.executableTargets.indexOf(executableTarget);\n      this.executableTargets.splice(oldIndex, 1);\n      var newIndex = oldIndex + delta;\n      if (newIndex > this.executableTargets.length) {\n        newIndex = this.executableTargets.length;\n      }\n      if (newIndex <= 0) {\n        if (this.executableTargets.length > 0 && this.executableTargets[0].isStage) {\n          newIndex = 1;\n        } else {\n          newIndex = 0;\n        }\n      }\n      this.executableTargets.splice(newIndex, 0, executableTarget);\n      return newIndex;\n    }\n    /**\n     * Set a target to execute at a specific position in the execution order.\n     *\n     * Infinity will set the target to execute first. 0 will set the target to\n     * execute last (before the stage).\n     *\n     * @param {Target} executableTarget target to move\n     * @param {number} newIndex position in execution order to place the target\n     * @returns {number} new position in the execution order\n     */\n  }, {\n    key: \"setExecutablePosition\",\n    value: function setExecutablePosition(executableTarget, newIndex) {\n      var oldIndex = this.executableTargets.indexOf(executableTarget);\n      return this.moveExecutable(executableTarget, newIndex - oldIndex);\n    }\n    /**\n     * Remove a target from the execution set.\n     * @param {Target} executableTarget target to remove\n     */\n  }, {\n    key: \"removeExecutable\",\n    value: function removeExecutable(executableTarget) {\n      var oldIndex = this.executableTargets.indexOf(executableTarget);\n      if (oldIndex > -1) {\n        this.executableTargets.splice(oldIndex, 1);\n      }\n    }\n    /**\n     * Dispose of a target.\n     * @param {!Target} disposingTarget Target to dispose of.\n     */\n  }, {\n    key: \"disposeTarget\",\n    value: function disposeTarget(disposingTarget) {\n      this.targets = this.targets.filter(function (target) {\n        if (disposingTarget !== target) return true; // Allow target to do dispose actions.\n        target.dispose(); // Remove from list of targets.\n        return false;\n      });\n    }\n    /**\n     * Stop any threads acting on the target.\n     * @param {!Target} target Target to stop threads for.\n     * @param {Thread=} optThreadException Optional thread to skip.\n     */\n  }, {\n    key: \"stopForTarget\",\n    value: function stopForTarget(target, optThreadException) {\n      // Emit stop event to allow blocks to clean up any state.\n      this.emit(Runtime.STOP_FOR_TARGET, target, optThreadException); // Stop any threads on the target.\n      for (var i = 0; i < this.threads.length; i++) {\n        if (this.threads[i] === optThreadException) {\n          continue;\n        }\n        if (this.threads[i].target === target) {\n          this._stopThread(this.threads[i]);\n        }\n      }\n    }\n    /**\n     * Start all threads that start with the green flag.\n     */\n  }, {\n    key: \"greenFlag\",\n    value: function greenFlag() {\n      this.stopAll();\n      this.emit(Runtime.PROJECT_START);\n      this.ioDevices.clock.resetProjectTimer();\n      this.targets.forEach(function (target) {\n        return target.clearEdgeActivatedValues();\n      }); // Inform all targets of the green flag.\n      for (var i = 0; i < this.targets.length; i++) {\n        this.targets[i].onGreenFlag();\n      }\n      this.startHats('event_whenflagclicked');\n    }\n    /**\n     * Stop \"everything.\"\n     */\n  }, {\n    key: \"stopAll\",\n    value: function stopAll() {\n      scratchStatus(\"STOPALL\"); //Emit stop event to allow blocks to clean up any state.\n      this.emit(Runtime.PROJECT_STOP_ALL); // Dispose all clones.\n      var newTargets = [];\n      for (var i = 0; i < this.targets.length; i++) {\n        this.targets[i].onStopAll();\n        if (this.targets[i].hasOwnProperty('isOriginal') && !this.targets[i].isOriginal) {\n          this.targets[i].dispose();\n        } else {\n          newTargets.push(this.targets[i]);\n        }\n      }\n      this.targets = newTargets; // Dispose of the active thread.\n      if (this.sequencer.activeThread !== null) {\n        this._stopThread(this.sequencer.activeThread);\n      } // Remove all remaining threads from executing in the next tick.\n      this.threads = [];\n    }\n    /**\n     * Repeatedly run `sequencer.stepThreads` and filter out\n     * inactive threads after each iteration.\n     */\n  }, {\n    key: \"_step\",\n    value: function _step() {\n      if (this.profiler !== null) {\n        if (stepProfilerId === -1) {\n          stepProfilerId = this.profiler.idByName('Runtime._step');\n        }\n        this.profiler.start(stepProfilerId);\n      } // Clean up threads that were told to stop during or since the last step\n      this.threads = this.threads.filter(function (thread) {\n        return !thread.isKilled;\n      }); // Find all edge-activated hats, and add them to threads to be evaluated.\n      for (var hatType in this._hats) {\n        if (!this._hats.hasOwnProperty(hatType)) continue;\n        var hat = this._hats[hatType];\n        if (hat.edgeActivated) {\n          this.startHats(hatType);\n        }\n      }\n      this.redrawRequested = false;\n      this._pushMonitors();\n      if (this.profiler !== null) {\n        if (stepThreadsProfilerId === -1) {\n          stepThreadsProfilerId = this.profiler.idByName('Sequencer.stepThreads');\n        }\n        this.profiler.start(stepThreadsProfilerId);\n      }\n      var doneThreads = this.sequencer.stepThreads();\n      if (this.profiler !== null) {\n        this.profiler.stop();\n      }\n      this._updateGlows(doneThreads); // Add done threads so that even if a thread finishes within 1 frame, the green\n      // flag will still indicate that a script ran.\n      this._emitProjectRunStatus(this.threads.length + doneThreads.length - this._getMonitorThreadCount([].concat(_toConsumableArray(this.threads), _toConsumableArray(doneThreads)))); // Store threads that completed this iteration for testing and other\n      // internal purposes.\n      this._lastStepDoneThreads = doneThreads;\n      if (this.renderer) {\n        // @todo: Only render when this.redrawRequested or clones rendered.\n        if (this.profiler !== null) {\n          if (rendererDrawProfilerId === -1) {\n            rendererDrawProfilerId = this.profiler.idByName('RenderWebGL.draw');\n          }\n          this.profiler.start(rendererDrawProfilerId);\n        }\n        this.renderer.draw();\n        if (this.profiler !== null) {\n          this.profiler.stop();\n        }\n      }\n      if (this._refreshTargets) {\n        this.emit(Runtime.TARGETS_UPDATE, false\n        /* Don't emit project changed */\n        );\n        this._refreshTargets = false;\n      }\n      if (!this._prevMonitorState.equals(this._monitorState)) {\n        this.emit(Runtime.MONITORS_UPDATE, this._monitorState);\n        this._prevMonitorState = this._monitorState;\n      }\n      if (this.profiler !== null) {\n        this.profiler.stop();\n        this.profiler.reportFrames();\n      }\n    }\n    /**\n     * Get the number of threads in the given array that are monitor threads (threads\n     * that update monitor values, and don't count as running a script).\n     * @param {!Array.<Thread>} threads The set of threads to look through.\n     * @return {number} The number of monitor threads in threads.\n     */\n  }, {\n    key: \"_getMonitorThreadCount\",\n    value: function _getMonitorThreadCount(threads) {\n      var count = 0;\n      threads.forEach(function (thread) {\n        if (thread.updateMonitor) count++;\n      });\n      return count;\n    }\n    /**\n     * Queue monitor blocks to sequencer to be run.\n     */\n  }, {\n    key: \"_pushMonitors\",\n    value: function _pushMonitors() {\n      this.monitorBlocks.runAllMonitored(this);\n    }\n    /**\n     * Set the current editing target known by the runtime.\n     * @param {!Target} editingTarget New editing target.\n     */\n  }, {\n    key: \"setEditingTarget\",\n    value: function setEditingTarget(editingTarget) {\n      var oldEditingTarget = this._editingTarget;\n      this._editingTarget = editingTarget; // Script glows must be cleared.\n      this._scriptGlowsPreviousFrame = [];\n      this._updateGlows();\n      if (oldEditingTarget !== this._editingTarget) {\n        this.requestToolboxExtensionsUpdate();\n        scratchStatus(\"CHANGED\");\n      }\n    }\n    /**\n     * Set whether we are in 30 TPS compatibility mode.\n     * @param {boolean} compatibilityModeOn True iff in compatibility mode.\n     */\n  }, {\n    key: \"setCompatibilityMode\",\n    value: function setCompatibilityMode(compatibilityModeOn) {\n      this.compatibilityMode = compatibilityModeOn;\n      if (this._steppingInterval) {\n        clearInterval(this._steppingInterval);\n        this._steppingInterval = null;\n        this.start();\n      }\n    }\n    /**\n     * Emit glows/glow clears for scripts after a single tick.\n     * Looks at `this.threads` and notices which have turned on/off new glows.\n     * @param {Array.<Thread>=} optExtraThreads Optional list of inactive threads.\n     */\n  }, {\n    key: \"_updateGlows\",\n    value: function _updateGlows(optExtraThreads) {\n      var searchThreads = [];\n      searchThreads.push.apply(searchThreads, this.threads);\n      if (optExtraThreads) {\n        searchThreads.push.apply(searchThreads, optExtraThreads);\n      } // Set of scripts that request a glow this frame.\n      var requestedGlowsThisFrame = []; // Final set of scripts glowing during this frame.\n      var finalScriptGlows = []; // Find all scripts that should be glowing.\n      for (var i = 0; i < searchThreads.length; i++) {\n        var thread = searchThreads[i];\n        var target = thread.target;\n        if (target === this._editingTarget) {\n          var blockForThread = thread.blockGlowInFrame;\n          if (thread.requestScriptGlowInFrame || thread.stackClick) {\n            var script = target.blocks.getTopLevelScript(blockForThread);\n            if (!script) {\n              // Attempt to find in flyout blocks.\n              script = this.flyoutBlocks.getTopLevelScript(blockForThread);\n            }\n            if (script) {\n              requestedGlowsThisFrame.push(script);\n            }\n          }\n        }\n      } // Compare to previous frame.\n      for (var j = 0; j < this._scriptGlowsPreviousFrame.length; j++) {\n        var previousFrameGlow = this._scriptGlowsPreviousFrame[j];\n        if (requestedGlowsThisFrame.indexOf(previousFrameGlow) < 0) {\n          // Glow turned off.\n          this.glowScript(previousFrameGlow, false);\n        } else {\n          // Still glowing.\n          finalScriptGlows.push(previousFrameGlow);\n        }\n      }\n      for (var k = 0; k < requestedGlowsThisFrame.length; k++) {\n        var currentFrameGlow = requestedGlowsThisFrame[k];\n        if (this._scriptGlowsPreviousFrame.indexOf(currentFrameGlow) < 0) {\n          // Glow turned on.\n          this.glowScript(currentFrameGlow, true);\n          finalScriptGlows.push(currentFrameGlow);\n        }\n      }\n      this._scriptGlowsPreviousFrame = finalScriptGlows;\n    }\n    /**\n     * Emit run start/stop after each tick. Emits when `this.threads.length` goes\n     * between non-zero and zero\n     *\n     * @param {number} nonMonitorThreadCount The new nonMonitorThreadCount\n     */\n  }, {\n    key: \"_emitProjectRunStatus\",\n    value: function _emitProjectRunStatus(nonMonitorThreadCount) {\n      if (this._nonMonitorThreadCount === 0 && nonMonitorThreadCount > 0) {\n        this.emit(Runtime.PROJECT_RUN_START);\n      }\n      if (this._nonMonitorThreadCount > 0 && nonMonitorThreadCount === 0) {\n        this.emit(Runtime.PROJECT_RUN_STOP);\n      }\n      this._nonMonitorThreadCount = nonMonitorThreadCount;\n    }\n    /**\n     * \"Quiet\" a script's glow: stop the VM from generating glow/unglow events\n     * about that script. Use when a script has just been deleted, but we may\n     * still be tracking glow data about it.\n     * @param {!string} scriptBlockId Id of top-level block in script to quiet.\n     */\n  }, {\n    key: \"quietGlow\",\n    value: function quietGlow(scriptBlockId) {\n      var index = this._scriptGlowsPreviousFrame.indexOf(scriptBlockId);\n      if (index > -1) {\n        this._scriptGlowsPreviousFrame.splice(index, 1);\n      }\n    }\n    /**\n     * Emit feedback for block glowing (used in the sequencer).\n     * @param {?string} blockId ID for the block to update glow\n     * @param {boolean} isGlowing True to turn on glow; false to turn off.\n     */\n  }, {\n    key: \"glowBlock\",\n    value: function glowBlock(blockId, isGlowing) {\n      if (isGlowing) {\n        this.emit(Runtime.BLOCK_GLOW_ON, {\n          id: blockId\n        });\n      } else {\n        this.emit(Runtime.BLOCK_GLOW_OFF, {\n          id: blockId\n        });\n      }\n    }\n    /**\n     * Emit feedback for script glowing.\n     * @param {?string} topBlockId ID for the top block to update glow\n     * @param {boolean} isGlowing True to turn on glow; false to turn off.\n     */\n  }, {\n    key: \"glowScript\",\n    value: function glowScript(topBlockId, isGlowing) {\n      if (isGlowing) {\n        this.emit(Runtime.SCRIPT_GLOW_ON, {\n          id: topBlockId\n        });\n      } else {\n        this.emit(Runtime.SCRIPT_GLOW_OFF, {\n          id: topBlockId\n        });\n      }\n    }\n    /**\n     * Emit whether blocks are being dragged over gui\n     * @param {boolean} areBlocksOverGui True if blocks are dragged out of blocks workspace, false otherwise\n     */\n  }, {\n    key: \"emitBlockDragUpdate\",\n    value: function emitBlockDragUpdate(areBlocksOverGui) {\n      this.emit(Runtime.BLOCK_DRAG_UPDATE, areBlocksOverGui);\n      scratchStatus(\"BACKUPNEEDED\");\n    }\n    /**\n     * Emit event to indicate that the block drag has ended with the blocks outside the blocks workspace\n     * @param {Array.<object>} blocks The set of blocks dragged to the GUI\n     * @param {string} topBlockId The original id of the top block being dragged\n     */\n  }, {\n    key: \"emitBlockEndDrag\",\n    value: function emitBlockEndDrag(blocks, topBlockId) {\n      this.emit(Runtime.BLOCK_DRAG_END, blocks, topBlockId);\n    }\n    /**\n     * Emit value for reporter to show in the blocks.\n     * @param {string} blockId ID for the block.\n     * @param {string} value Value to show associated with the block.\n     */\n  }, {\n    key: \"visualReport\",\n    value: function visualReport(blockId, value) {\n      this.emit(Runtime.VISUAL_REPORT, {\n        id: blockId,\n        value: String(value)\n      });\n    }\n    /**\n     * Add a monitor to the state. If the monitor already exists in the state,\n     * updates those properties that are defined in the given monitor record.\n     * @param {!MonitorRecord} monitor Monitor to add.\n     */\n  }, {\n    key: \"requestAddMonitor\",\n    value: function requestAddMonitor(monitor) {\n      var id = monitor.get('id');\n      if (!this.requestUpdateMonitor(monitor)) {\n        // update monitor if it exists in the state\n        // if the monitor did not exist in the state, add it\n        this._monitorState = this._monitorState.set(id, monitor);\n      }\n    }\n    /**\n     * Update a monitor in the state and report success/failure of update.\n     * @param {!Map} monitor Monitor values to update. Values on the monitor with overwrite\n     *     values on the old monitor with the same ID. If a value isn't defined on the new monitor,\n     *     the old monitor will keep its old value.\n     * @return {boolean} true if monitor exists in the state and was updated, false if it did not exist.\n     */\n  }, {\n    key: \"requestUpdateMonitor\",\n    value: function requestUpdateMonitor(monitor) {\n      var id = monitor.get('id');\n      if (this._monitorState.has(id)) {\n        this._monitorState = // Use mergeWith here to prevent undefined values from overwriting existing ones\n        this._monitorState.set(id, this._monitorState.get(id).mergeWith(function (prev, next) {\n          if (typeof next === 'undefined' || next === null) {\n            return prev;\n          }\n          return next;\n        }, monitor));\n        return true;\n      }\n      return false;\n    }\n    /**\n     * Removes a monitor from the state. Does nothing if the monitor already does\n     * not exist in the state.\n     * @param {!string} monitorId ID of the monitor to remove.\n     */\n  }, {\n    key: \"requestRemoveMonitor\",\n    value: function requestRemoveMonitor(monitorId) {\n      this._monitorState = this._monitorState.delete(monitorId);\n    }\n    /**\n     * Hides a monitor and returns success/failure of action.\n     * @param {!string} monitorId ID of the monitor to hide.\n     * @return {boolean} true if monitor exists and was updated, false otherwise\n     */\n  }, {\n    key: \"requestHideMonitor\",\n    value: function requestHideMonitor(monitorId) {\n      return this.requestUpdateMonitor(new Map([['id', monitorId], ['visible', false]]));\n    }\n    /**\n     * Shows a monitor and returns success/failure of action.\n     * not exist in the state.\n     * @param {!string} monitorId ID of the monitor to show.\n     * @return {boolean} true if monitor exists and was updated, false otherwise\n     */\n  }, {\n    key: \"requestShowMonitor\",\n    value: function requestShowMonitor(monitorId) {\n      return this.requestUpdateMonitor(new Map([['id', monitorId], ['visible', true]]));\n    }\n    /**\n     * Removes all monitors with the given target ID from the state. Does nothing if\n     * the monitor already does not exist in the state.\n     * @param {!string} targetId Remove all monitors with given target ID.\n     */\n  }, {\n    key: \"requestRemoveMonitorByTargetId\",\n    value: function requestRemoveMonitorByTargetId(targetId) {\n      this._monitorState = this._monitorState.filterNot(function (value) {\n        return value.targetId === targetId;\n      });\n    }\n    /**\n     * Get a target by its id.\n     * @param {string} targetId Id of target to find.\n     * @return {?Target} The target, if found.\n     */\n  }, {\n    key: \"getTargetById\",\n    value: function getTargetById(targetId) {\n      for (var i = 0; i < this.targets.length; i++) {\n        var target = this.targets[i];\n        if (target.id === targetId) {\n          return target;\n        }\n      }\n    }\n    /**\n     * Get the first original (non-clone-block-created) sprite given a name.\n     * @param {string} spriteName Name of sprite to look for.\n     * @return {?Target} Target representing a sprite of the given name.\n     */\n  }, {\n    key: \"getSpriteTargetByName\",\n    value: function getSpriteTargetByName(spriteName) {\n      for (var i = 0; i < this.targets.length; i++) {\n        var target = this.targets[i];\n        if (target.isStage) {\n          continue;\n        }\n        if (target.sprite && target.sprite.name === spriteName) {\n          return target;\n        }\n      }\n    }\n    /**\n     * Get a target by its drawable id.\n     * @param {number} drawableID drawable id of target to find\n     * @return {?Target} The target, if found\n     */\n  }, {\n    key: \"getTargetByDrawableId\",\n    value: function getTargetByDrawableId(drawableID) {\n      for (var i = 0; i < this.targets.length; i++) {\n        var target = this.targets[i];\n        if (target.drawableID === drawableID) return target;\n      }\n    }\n    /**\n     * Update the clone counter to track how many clones are created.\n     * @param {number} changeAmount How many clones have been created/destroyed.\n     */\n  }, {\n    key: \"changeCloneCounter\",\n    value: function changeCloneCounter(changeAmount) {\n      this._cloneCounter += changeAmount;\n    }\n    /**\n     * Return whether there are clones available.\n     * @return {boolean} True until the number of clones hits Runtime.MAX_CLONES.\n     */\n  }, {\n    key: \"clonesAvailable\",\n    value: function clonesAvailable() {\n      return this._cloneCounter < Runtime.MAX_CLONES;\n    }\n    /**\n     * Report that the project has loaded in the Virtual Machine.\n     */\n  }, {\n    key: \"emitProjectLoaded\",\n    value: function emitProjectLoaded() {\n    this.emit(Runtime.PROJECT_LOADED);\n    scratchStatus(\"LOADED\");\n  }\n    /**\n     * Report that the project has changed in a way that would affect serialization\n     */\n  }, {\n    key: \"emitProjectChanged\",\n    value: function emitProjectChanged() {\n      this.emit(Runtime.PROJECT_CHANGED);\n    }\n    /**\n     * Report that a new target has been created, possibly by cloning an existing target.\n     * @param {Target} newTarget - the newly created target.\n     * @param {Target} [sourceTarget] - the target used as a source for the new clone, if any.\n     * @fires Runtime#targetWasCreated\n     */\n  }, {\n    key: \"fireTargetWasCreated\",\n    value: function fireTargetWasCreated(newTarget, sourceTarget) {\n      this.emit('targetWasCreated', newTarget, sourceTarget);\n    }\n    /**\n     * Report that a clone target is being removed.\n     * @param {Target} target - the target being removed\n     * @fires Runtime#targetWasRemoved\n     */\n  }, {\n    key: \"fireTargetWasRemoved\",\n    value: function fireTargetWasRemoved(target) {\n      this.emit('targetWasRemoved', target);\n    }\n    /**\n     * Get a target representing the Scratch stage, if one exists.\n     * @return {?Target} The target, if found.\n     */\n  }, {\n    key: \"getTargetForStage\",\n    value: function getTargetForStage() {\n      for (var i = 0; i < this.targets.length; i++) {\n        var target = this.targets[i];\n        if (target.isStage) {\n          return target;\n        }\n      }\n    }\n    /**\n     * Get the editing target.\n     * @return {?Target} The editing target.\n     */\n  }, {\n    key: \"getEditingTarget\",\n    value: function getEditingTarget() {\n      return this._editingTarget;\n    }\n  }, {\n    key: \"getAllVarNamesOfType\",\n    value: function getAllVarNamesOfType(varType) {\n      var varNames = [];\n      var _iterator2 = _createForOfIteratorHelper(this.targets),\n          _step3;\n      try {\n        for (_iterator2.s(); !(_step3 = _iterator2.n()).done;) {\n          var target = _step3.value;\n          var targetVarNames = target.getAllVariableNamesInScopeByType(varType, true);\n          varNames = varNames.concat(targetVarNames);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return varNames;\n    }\n    /**\n     * Get the label or label function for an opcode\n     * @param {string} extendedOpcode - the opcode you want a label for\n     * @return {object} - object with label and category\n     * @property {string} category - the category for this opcode\n     * @property {Function} [labelFn] - function to generate the label for this opcode\n     * @property {string} [label] - the label for this opcode if `labelFn` is absent\n     */\n  }, {\n    key: \"getLabelForOpcode\",\n    value: function getLabelForOpcode(extendedOpcode) {\n      var _StringUtil$splitFirs = StringUtil.splitFirst(extendedOpcode, '_'),\n          _StringUtil$splitFirs2 = _slicedToArray(_StringUtil$splitFirs, 2),\n          category = _StringUtil$splitFirs2[0],\n          opcode = _StringUtil$splitFirs2[1];\n      if (!(category && opcode)) return;\n      var categoryInfo = this._blockInfo.find(function (ci) {\n        return ci.id === category;\n      });\n      if (!categoryInfo) return;\n      var block = categoryInfo.blocks.find(function (b) {\n        return b.info.opcode === opcode;\n      });\n      if (!block) return; // TODO: we may want to format the label in a locale-specific way.\n      return {\n        category: 'extension',\n        // This assumes that all extensions have the same monitor color.\n        label: \"\".concat(categoryInfo.name, \": \").concat(block.info.text)\n      };\n    }\n    /**\n     * Create a new global variable avoiding conflicts with other variable names.\n     * @param {string} variableName The desired variable name for the new global variable.\n     * This can be turned into a fresh name as necessary.\n     * @param {string} optVarId An optional ID to use for the variable. A new one will be generated\n     * if a falsey value for this parameter is provided.\n     * @param {string} optVarType The type of the variable to create. Defaults to Variable.SCALAR_TYPE.\n     * @return {Variable} The new variable that was created.\n     */\n  }, {\n    key: \"createNewGlobalVariable\",\n    value: function createNewGlobalVariable(variableName, optVarId, optVarType) {\n      var varType = typeof optVarType === 'string' ? optVarType : Variable.SCALAR_TYPE;\n      var allVariableNames = this.getAllVarNamesOfType(varType);\n      var newName = StringUtil.unusedName(variableName, allVariableNames);\n      var variable = new Variable(optVarId || uid(), newName, varType);\n      var stage = this.getTargetForStage();\n      stage.variables[variable.id] = variable;\n      return variable;\n    }\n    /**\n     * Tell the runtime to request a redraw.\n     * Use after a clone/sprite has completed some visible operation on the stage.\n     */\n  }, {\n    key: \"requestRedraw\",\n    value: function requestRedraw() {\n      this.redrawRequested = true;\n    }\n    /**\n     * Emit a targets update at the end of the step if the provided target is\n     * the original sprite\n     * @param {!Target} target Target requesting the targets update\n     */\n  }, {\n    key: \"requestTargetsUpdate\",\n    value: function requestTargetsUpdate(target) {\n      if (!target.isOriginal) return;\n      this._refreshTargets = true;\n    }\n    /**\n     * Emit an event that indicates that the blocks on the workspace need updating.\n     */\n  }, {\n    key: \"requestBlocksUpdate\",\n    value: function requestBlocksUpdate() {\n      this.emit(Runtime.BLOCKS_NEED_UPDATE);\n    }\n    /**\n     * Emit an event that indicates that the toolbox extension blocks need updating.\n     */\n  }, {\n    key: \"requestToolboxExtensionsUpdate\",\n    value: function requestToolboxExtensionsUpdate() {\n      this.emit(Runtime.TOOLBOX_EXTENSIONS_NEED_UPDATE);\n    }\n    /**\n     * Set up timers to repeatedly step in a browser.\n     */\n  }, {\n    key: \"start\",\n    value: function start() {\n      var _this5 = this;\n      // Do not start if we are already running\n      if (this._steppingInterval) return;\n      var interval = Runtime.THREAD_STEP_INTERVAL;\n      if (this.compatibilityMode) {\n        interval = Runtime.THREAD_STEP_INTERVAL_COMPATIBILITY;\n      }\n      this.currentStepTime = interval;\n      this._steppingInterval = setInterval(function () {\n        _this5._step();\n      }, interval);\n      this.emit(Runtime.RUNTIME_STARTED);\n    }\n    /**\n     * Turn on profiling.\n     * @param {Profiler/FrameCallback} onFrame A callback handle passed a\n     * profiling frame when the profiler reports its collected data.\n     */\n  }, {\n    key: \"enableProfiling\",\n    value: function enableProfiling(onFrame) {\n      if (Profiler.available()) {\n        this.profiler = new Profiler(onFrame);\n      }\n    }\n    /**\n     * Turn off profiling.\n     */\n  }, {\n    key: \"disableProfiling\",\n    value: function disableProfiling() {\n      this.profiler = null;\n    }\n    /**\n     * Update a millisecond timestamp value that is saved on the Runtime.\n     * This value is helpful in certain instances for compatibility with Scratch 2,\n     * which sometimes uses a `currentMSecs` timestamp value in Interpreter.as\n     */\n  }, {\n    key: \"updateCurrentMSecs\",\n    value: function updateCurrentMSecs() {\n      this.currentMSecs = Date.now();\n    }\n  }], [{\n    key: \"STAGE_WIDTH\",\n    get: function get() {\n      return 480;\n    }\n    /**\n     * Height of the stage, in pixels.\n     * @const {number}\n     */\n  }, {\n    key: \"STAGE_HEIGHT\",\n    get: function get() {\n      return 360;\n    }\n    /**\n     * Event name for glowing a script.\n     * @const {string}\n     */\n  }, {\n    key: \"SCRIPT_GLOW_ON\",\n    get: function get() {\n      return 'SCRIPT_GLOW_ON';\n    }\n    /**\n     * Event name for unglowing a script.\n     * @const {string}\n     */\n  }, {\n    key: \"SCRIPT_GLOW_OFF\",\n    get: function get() {\n      return 'SCRIPT_GLOW_OFF';\n    }\n    /**\n     * Event name for glowing a block.\n     * @const {string}\n     */\n  }, {\n    key: \"BLOCK_GLOW_ON\",\n    get: function get() {\n      return 'BLOCK_GLOW_ON';\n    }\n    /**\n     * Event name for unglowing a block.\n     * @const {string}\n     */\n  }, {\n    key: \"BLOCK_GLOW_OFF\",\n    get: function get() {\n      return 'BLOCK_GLOW_OFF';\n    }\n    /**\n     * Event name for a cloud data update\n     * to this project.\n     * @const {string}\n     */\n  }, {\n    key: \"HAS_CLOUD_DATA_UPDATE\",\n    get: function get() {\n      return 'HAS_CLOUD_DATA_UPDATE';\n    }\n    /**\n     * Event name for turning on turbo mode.\n     * @const {string}\n     */\n  }, {\n    key: \"TURBO_MODE_ON\",\n    get: function get() {\n      return 'TURBO_MODE_ON';\n    }\n    /**\n     * Event name for turning off turbo mode.\n     * @const {string}\n     */\n  }, {\n    key: \"TURBO_MODE_OFF\",\n    get: function get() {\n      return 'TURBO_MODE_OFF';\n    }\n    /**\n     * Event name when the project is started (threads may not necessarily be\n     * running).\n     * @const {string}\n     */\n  }, {\n    key: \"PROJECT_START\",\n    get: function get() {\n      return 'PROJECT_START';\n    }\n    /**\n     * Event name when threads start running.\n     * Used by the UI to indicate running status.\n     * @const {string}\n     */\n  }, {\n    key: \"PROJECT_RUN_START\",\n    get: function get() {\n      return 'PROJECT_RUN_START';\n    }\n    /**\n     * Event name when threads stop running\n     * Used by the UI to indicate not-running status.\n     * @const {string}\n     */\n  }, {\n    key: \"PROJECT_RUN_STOP\",\n    get: function get() {\n      return 'PROJECT_RUN_STOP';\n    }\n    /**\n     * Event name for project being stopped or restarted by the user.\n     * Used by blocks that need to reset state.\n     * @const {string}\n     */\n  }, {\n    key: \"PROJECT_STOP_ALL\",\n    get: function get() {\n      return 'PROJECT_STOP_ALL';\n    }\n    /**\n     * Event name for target being stopped by a stop for target call.\n     * Used by blocks that need to stop individual targets.\n     * @const {string}\n     */\n  }, {\n    key: \"STOP_FOR_TARGET\",\n    get: function get() {\n      return 'STOP_FOR_TARGET';\n    }\n    /**\n     * Event name for visual value report.\n     * @const {string}\n     */\n  }, {\n    key: \"VISUAL_REPORT\",\n    get: function get() {\n      return 'VISUAL_REPORT';\n    }\n    /**\n     * Event name for project loaded report.\n     * @const {string}\n     */\n  }, {\n    key: \"PROJECT_LOADED\",\n    get: function get() {\n      return 'PROJECT_LOADED';\n    }\n    /**\n     * Event name for report that a change was made that can be saved\n     * @const {string}\n     */\n  }, {\n    key: \"PROJECT_CHANGED\",\n    get: function get() {\n      return 'PROJECT_CHANGED';\n    }\n    /**\n     * Event name for report that a change was made to an extension in the toolbox.\n     * @const {string}\n     */\n  }, {\n    key: \"TOOLBOX_EXTENSIONS_NEED_UPDATE\",\n    get: function get() {\n      return 'TOOLBOX_EXTENSIONS_NEED_UPDATE';\n    }\n    /**\n     * Event name for targets update report.\n     * @const {string}\n     */\n  }, {\n    key: \"TARGETS_UPDATE\",\n    get: function get() {\n      return 'TARGETS_UPDATE';\n    }\n    /**\n     * Event name for monitors update.\n     * @const {string}\n     */\n  }, {\n    key: \"MONITORS_UPDATE\",\n    get: function get() {\n      return 'MONITORS_UPDATE';\n    }\n    /**\n     * Event name for block drag update.\n     * @const {string}\n     */\n  }, {\n    key: \"BLOCK_DRAG_UPDATE\",\n    get: function get() {\n      return 'BLOCK_DRAG_UPDATE';\n    }\n    /**\n     * Event name for block drag end.\n     * @const {string}\n     */\n  }, {\n    key: \"BLOCK_DRAG_END\",\n    get: function get() {\n      return 'BLOCK_DRAG_END';\n    }\n    /**\n     * Event name for reporting that an extension was added.\n     * @const {string}\n     */\n  }, {\n    key: \"EXTENSION_ADDED\",\n    get: function get() {\n      return 'EXTENSION_ADDED';\n    }\n    /**\n     * Event name for reporting that an extension as asked for a custom field to be added\n     * @const {string}\n     */\n  }, {\n    key: \"EXTENSION_FIELD_ADDED\",\n    get: function get() {\n      return 'EXTENSION_FIELD_ADDED';\n    }\n    /**\n     * Event name for updating the available set of peripheral devices.\n     * This causes the peripheral connection modal to update a list of\n     * available peripherals.\n     * @const {string}\n     */\n  }, {\n    key: \"PERIPHERAL_LIST_UPDATE\",\n    get: function get() {\n      return 'PERIPHERAL_LIST_UPDATE';\n    }\n    /**\n     * Event name for when the user picks a bluetooth device to connect to\n     * via Companion Device Manager (CDM)\n     * @const {string}\n     */\n  }, {\n    key: \"USER_PICKED_PERIPHERAL\",\n    get: function get() {\n      return 'USER_PICKED_PERIPHERAL';\n    }\n    /**\n     * Event name for reporting that a peripheral has connected.\n     * This causes the status button in the blocks menu to indicate 'connected'.\n     * @const {string}\n     */\n  }, {\n    key: \"PERIPHERAL_CONNECTED\",\n    get: function get() {\n      return 'PERIPHERAL_CONNECTED';\n    }\n    /**\n     * Event name for reporting that a peripheral has been intentionally disconnected.\n     * This causes the status button in the blocks menu to indicate 'disconnected'.\n     * @const {string}\n     */\n  }, {\n    key: \"PERIPHERAL_DISCONNECTED\",\n    get: function get() {\n      return 'PERIPHERAL_DISCONNECTED';\n    }\n    /**\n     * Event name for reporting that a peripheral has encountered a request error.\n     * This causes the peripheral connection modal to switch to an error state.\n     * @const {string}\n     */\n  }, {\n    key: \"PERIPHERAL_REQUEST_ERROR\",\n    get: function get() {\n      return 'PERIPHERAL_REQUEST_ERROR';\n    }\n    /**\n     * Event name for reporting that a peripheral connection has been lost.\n     * This causes a 'peripheral connection lost' error alert to display.\n     * @const {string}\n     */\n  }, {\n    key: \"PERIPHERAL_CONNECTION_LOST_ERROR\",\n    get: function get() {\n      return 'PERIPHERAL_CONNECTION_LOST_ERROR';\n    }\n    /**\n     * Event name for reporting that a peripheral has not been discovered.\n     * This causes the peripheral connection modal to show a timeout state.\n     * @const {string}\n     */\n  }, {\n    key: \"PERIPHERAL_SCAN_TIMEOUT\",\n    get: function get() {\n      return 'PERIPHERAL_SCAN_TIMEOUT';\n    }\n    /**\n     * Event name to indicate that the microphone is being used to stream audio.\n     * @const {string}\n     */\n  }, {\n    key: \"MIC_LISTENING\",\n    get: function get() {\n      return 'MIC_LISTENING';\n    }\n    /**\n     * Event name for reporting that blocksInfo was updated.\n     * @const {string}\n     */\n  }, {\n    key: \"BLOCKSINFO_UPDATE\",\n    get: function get() {\n      return 'BLOCKSINFO_UPDATE';\n    }\n    /**\n     * Event name when the runtime tick loop has been started.\n     * @const {string}\n     */\n  }, {\n    key: \"RUNTIME_STARTED\",\n    get: function get() {\n      return 'RUNTIME_STARTED';\n    }\n    /**\n     * Event name when the runtime dispose has been called.\n     * @const {string}\n     */\n  }, {\n    key: \"RUNTIME_DISPOSED\",\n    get: function get() {\n      return 'RUNTIME_DISPOSED';\n    }\n    /**\n     * Event name for reporting that a block was updated and needs to be rerendered.\n     * @const {string}\n     */\n  }, {\n    key: \"BLOCKS_NEED_UPDATE\",\n    get: function get() {\n      return 'BLOCKS_NEED_UPDATE';\n    }\n    /**\n     * How rapidly we try to step threads by default, in ms.\n     */\n  }, {\n    key: \"THREAD_STEP_INTERVAL\",\n    get: function get() {\n      return 1000 / 60;\n    }\n    /**\n     * In compatibility mode, how rapidly we try to step threads, in ms.\n     */\n  }, {\n    key: \"THREAD_STEP_INTERVAL_COMPATIBILITY\",\n    get: function get() {\n      return 1000 / 30;\n    }\n    /**\n     * How many clones can be created at a time.\n     * @const {number}\n     */\n  }, {\n    key: \"MAX_CLONES\",\n    get: function get() {\n      return 300;\n    }\n  }]);\n  return Runtime;\n}(EventEmitter);\n/**\n * Event fired after a new target has been created, possibly by cloning an existing target.\n *\n * @event Runtime#targetWasCreated\n * @param {Target} newTarget - the newly created target.\n * @param {Target} [sourceTarget] - the target used as a source for the new clone, if any.\n */\nmodule.exports = Runtime;\n })