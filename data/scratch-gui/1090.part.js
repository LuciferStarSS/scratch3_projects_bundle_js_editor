/* 1090 */\n (function(module, exports, __webpack_require__) {\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nvar MathUtil = __webpack_require__(62);\nvar Cast = __webpack_require__(48);\nvar Clone = __webpack_require__(113);\n/**\n * Occluded boolean value to make its use more understandable.\n * @const {boolean}\n */\nvar STORE_WAITING = true;\nvar Scratch3SoundBlocks = function () {\n  function Scratch3SoundBlocks(runtime) {\n    _classCallCheck(this, Scratch3SoundBlocks);\n    /**\n     * The runtime instantiating this block package.\n     * @type {Runtime}\n     */\n    this.runtime = runtime;\n    this.waitingSounds = {}; // Clear sound effects on green flag and stop button events.\n    this.stopAllSounds = this.stopAllSounds.bind(this);\n    this._stopWaitingSoundsForTarget = this._stopWaitingSoundsForTarget.bind(this);\n    this._clearEffectsForAllTargets = this._clearEffectsForAllTargets.bind(this);\n    if (this.runtime) {\n      this.runtime.on('PROJECT_STOP_ALL', this.stopAllSounds);\n      this.runtime.on('PROJECT_STOP_ALL', this._clearEffectsForAllTargets);\n      this.runtime.on('STOP_FOR_TARGET', this._stopWaitingSoundsForTarget);\n      this.runtime.on('PROJECT_START', this._clearEffectsForAllTargets);\n    }\n    this._onTargetCreated = this._onTargetCreated.bind(this);\n    if (this.runtime) {\n      runtime.on('targetWasCreated', this._onTargetCreated);\n    }\n  }\n  /**\n   * The key to load & store a target's sound-related state.\n   * @type {string}\n   */\n  _createClass(Scratch3SoundBlocks, [{\n    key: \"_getSoundState\",\n    /**\n     * @param {Target} target - collect sound state for this target.\n     * @returns {SoundState} the mutable sound state associated with that target. This will be created if necessary.\n     * @private\n     */\n    value: function _getSoundState(target) {\n      var soundState = target.getCustomState(Scratch3SoundBlocks.STATE_KEY);\n      if (!soundState) {\n        soundState = Clone.simple(Scratch3SoundBlocks.DEFAULT_SOUND_STATE);\n        target.setCustomState(Scratch3SoundBlocks.STATE_KEY, soundState);\n        target.soundEffects = soundState.effects;\n      }\n      return soundState;\n    }\n    /**\n     * When a Target is cloned, clone the sound state.\n     * @param {Target} newTarget - the newly created target.\n     * @param {Target} [sourceTarget] - the target used as a source for the new clone, if any.\n     * @listens Runtime#event:targetWasCreated\n     * @private\n     */\n  }, {\n    key: \"_onTargetCreated\",\n    value: function _onTargetCreated(newTarget, sourceTarget) {\n      if (sourceTarget) {\n        var soundState = sourceTarget.getCustomState(Scratch3SoundBlocks.STATE_KEY);\n        if (soundState && newTarget) {\n          newTarget.setCustomState(Scratch3SoundBlocks.STATE_KEY, Clone.simple(soundState));\n          this._syncEffectsForTarget(newTarget);\n        }\n      }\n    }\n    /**\n     * Retrieve the block primitives implemented by this package.\n     * @return {object.<string, Function>} Mapping of opcode to Function.\n     */\n  }, {\n    key: \"getPrimitives\",\n    value: function getPrimitives() {\n      return {\n        sound_play: this.playSound,\n        sound_playuntildone: this.playSoundAndWait,\n        sound_stopallsounds: this.stopAllSounds,\n        sound_seteffectto: this.setEffect,\n        sound_changeeffectby: this.changeEffect,\n        sound_cleareffects: this.clearEffects,\n        sound_sounds_menu: this.soundsMenu,\n        sound_beats_menu: this.beatsMenu,\n        sound_effects_menu: this.effectsMenu,\n        sound_setvolumeto: this.setVolume,\n        sound_changevolumeby: this.changeVolume,\n        sound_volume: this.getVolume\n      };\n    }\n  }, {\n    key: \"getMonitored\",\n    value: function getMonitored() {\n      return {\n        sound_volume: {\n          isSpriteSpecific: true,\n          getId: function getId(targetId) {\n            return \"\".concat(targetId, \"_volume\");\n          }\n        }\n      };\n    }\n  }, {\n    key: \"playSound\",\n    value: function playSound(args, util) {\n      // Don't return the promise, it's the only difference for AndWait\n      this._playSound(args, util);\n    }\n  }, {\n    key: \"playSoundAndWait\",\n    value: function playSoundAndWait(args, util) {\n      return this._playSound(args, util, STORE_WAITING);\n    }\n  }, {\n    key: \"_playSound\",\n    value: function _playSound(args, util, storeWaiting) {\n      var index = this._getSoundIndex(args.SOUND_MENU, util);\n      if (index >= 0) {\n        var target = util.target;\n        var sprite = target.sprite;\n        var soundId = sprite.sounds[index].soundId;\n        if (sprite.soundBank) {\n          if (storeWaiting === STORE_WAITING) {\n            this._addWaitingSound(target.id, soundId);\n          } else {\n            this._removeWaitingSound(target.id, soundId);\n          }\n          return sprite.soundBank.playSound(target, soundId);\n        }\n      }\n    }\n  }, {\n    key: \"_addWaitingSound\",\n    value: function _addWaitingSound(targetId, soundId) {\n      if (!this.waitingSounds[targetId]) {\n        this.waitingSounds[targetId] = new Set();\n      }\n      this.waitingSounds[targetId].add(soundId);\n    }\n  }, {\n    key: \"_removeWaitingSound\",\n    value: function _removeWaitingSound(targetId, soundId) {\n      if (!this.waitingSounds[targetId]) {\n        return;\n      }\n      this.waitingSounds[targetId].delete(soundId);\n    }\n  }, {\n    key: \"_getSoundIndex\",\n    value: function _getSoundIndex(soundName, util) {\n      // if the sprite has no sounds, return -1\n      var len = util.target.sprite.sounds.length;\n      if (len === 0) {\n        return -1;\n      } // look up by name first\n      var index = this.getSoundIndexByName(soundName, util);\n      if (index !== -1) {\n        return index;\n      } // then try using the sound name as a 1-indexed index\n      var oneIndexedIndex = parseInt(soundName, 10);\n      if (!isNaN(oneIndexedIndex)) {\n        return MathUtil.wrapClamp(oneIndexedIndex - 1, 0, len - 1);\n      } // could not be found as a name or converted to index, return -1\n      return -1;\n    }\n  }, {\n    key: \"getSoundIndexByName\",\n    value: function getSoundIndexByName(soundName, util) {\n      var sounds = util.target.sprite.sounds;\n      for (var i = 0; i < sounds.length; i++) {\n        if (sounds[i].name === soundName) {\n          return i;\n        }\n      } // if there is no sound by that name, return -1\n      return -1;\n    }\n  }, {\n    key: \"stopAllSounds\",\n    value: function stopAllSounds() {\n      if (this.runtime.targets === null) return;\n      var allTargets = this.runtime.targets;\n      for (var i = 0; i < allTargets.length; i++) {\n        this._stopAllSoundsForTarget(allTargets[i]);\n      }\n    }\n  }, {\n    key: \"_stopAllSoundsForTarget\",\n    value: function _stopAllSoundsForTarget(target) {\n      if (target.sprite.soundBank) {\n        target.sprite.soundBank.stopAllSounds(target);\n        if (this.waitingSounds[target.id]) {\n          this.waitingSounds[target.id].clear();\n        }\n      }\n    }\n  }, {\n    key: \"_stopWaitingSoundsForTarget\",\n    value: function _stopWaitingSoundsForTarget(target) {\n      if (target.sprite.soundBank) {\n        if (this.waitingSounds[target.id]) {\n          var _iterator = _createForOfIteratorHelper(this.waitingSounds[target.id].values()),\n              _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var soundId = _step.value;\n              target.sprite.soundBank.stop(target, soundId);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n          this.waitingSounds[target.id].clear();\n        }\n      }\n    }\n  }, {\n    key: \"setEffect\",\n    value: function setEffect(args, util) {\n      return this._updateEffect(args, util, false);\n    }\n  }, {\n    key: \"changeEffect\",\n    value: function changeEffect(args, util) {\n      return this._updateEffect(args, util, true);\n    }\n  }, {\n    key: \"_updateEffect\",\n    value: function _updateEffect(args, util, change) {\n      var effect = Cast.toString(args.EFFECT).toLowerCase();\n      var value = Cast.toNumber(args.VALUE);\n      var soundState = this._getSoundState(util.target);\n      if (!soundState.effects.hasOwnProperty(effect)) return;\n      if (change) {\n        soundState.effects[effect] += value;\n      } else {\n        soundState.effects[effect] = value;\n      }\n      var _Scratch3SoundBlocks$ = Scratch3SoundBlocks.EFFECT_RANGE[effect],\n          min = _Scratch3SoundBlocks$.min,\n          max = _Scratch3SoundBlocks$.max;\n      soundState.effects[effect] = MathUtil.clamp(soundState.effects[effect], min, max);\n      this._syncEffectsForTarget(util.target); // Yield until the next tick.\n      return Promise.resolve();\n    }\n  }, {\n    key: \"_syncEffectsForTarget\",\n    value: function _syncEffectsForTarget(target) {\n      if (!target || !target.sprite.soundBank) return;\n      target.soundEffects = this._getSoundState(target).effects;\n      target.sprite.soundBank.setEffects(target);\n    }\n  }, {\n    key: \"clearEffects\",\n    value: function clearEffects(args, util) {\n      this._clearEffectsForTarget(util.target);\n    }\n  }, {\n    key: \"_clearEffectsForTarget\",\n    value: function _clearEffectsForTarget(target) {\n      var soundState = this._getSoundState(target);\n      for (var effect in soundState.effects) {\n        if (!soundState.effects.hasOwnProperty(effect)) continue;\n        soundState.effects[effect] = 0;\n      }\n      this._syncEffectsForTarget(target);\n    }\n  }, {\n    key: \"_clearEffectsForAllTargets\",\n    value: function _clearEffectsForAllTargets() {\n      if (this.runtime.targets === null) return;\n      var allTargets = this.runtime.targets;\n      for (var i = 0; i < allTargets.length; i++) {\n        this._clearEffectsForTarget(allTargets[i]);\n      }\n    }\n  }, {\n    key: \"setVolume\",\n    value: function setVolume(args, util) {\n      var volume = Cast.toNumber(args.VOLUME);\n      return this._updateVolume(volume, util);\n    }\n  }, {\n    key: \"changeVolume\",\n    value: function changeVolume(args, util) {\n      var volume = Cast.toNumber(args.VOLUME) + util.target.volume;\n      return this._updateVolume(volume, util);\n    }\n  }, {\n    key: \"_updateVolume\",\n    value: function _updateVolume(volume, util) {\n      volume = MathUtil.clamp(volume, 0, 100);\n      util.target.volume = volume;\n      this._syncEffectsForTarget(util.target); // Yield until the next tick.\n      return Promise.resolve();\n    }\n  }, {\n    key: \"getVolume\",\n    value: function getVolume(args, util) {\n      return util.target.volume;\n    }\n  }, {\n    key: \"soundsMenu\",\n    value: function soundsMenu(args) {\n      return args.SOUND_MENU;\n    }\n  }, {\n    key: \"beatsMenu\",\n    value: function beatsMenu(args) {\n      return args.BEATS;\n    }\n  }, {\n    key: \"effectsMenu\",\n    value: function effectsMenu(args) {\n      return args.EFFECT;\n    }\n  }], [{\n    key: \"STATE_KEY\",\n    get: function get() {\n      return 'Scratch.sound';\n    }\n    /**\n     * The default sound-related state, to be used when a target has no existing sound state.\n     * @type {SoundState}\n     */\n  }, {\n    key: \"DEFAULT_SOUND_STATE\",\n    get: function get() {\n      return {\n        effects: {\n          pitch: 0,\n          pan: 0\n        }\n      };\n    }\n    /**\n     * The minimum and maximum MIDI note numbers, for clamping the input to play note.\n     * @type {{min: number, max: number}}\n     */\n  }, {\n    key: \"MIDI_NOTE_RANGE\",\n    get: function get() {\n      return {\n        min: 36,\n        max: 96\n      }; // C2 to C7\n    }\n    /**\n     * The minimum and maximum beat values, for clamping the duration of play note, play drum and rest.\n     * 100 beats at the default tempo of 60bpm is 100 seconds.\n     * @type {{min: number, max: number}}\n     */\n  }, {\n    key: \"BEAT_RANGE\",\n    get: function get() {\n      return {\n        min: 0,\n        max: 100\n      };\n    }\n    /** The minimum and maximum tempo values, in bpm.\n     * @type {{min: number, max: number}}\n     */\n  }, {\n    key: \"TEMPO_RANGE\",\n    get: function get() {\n      return {\n        min: 20,\n        max: 500\n      };\n    }\n    /** The minimum and maximum values for each sound effect.\n     * @type {{effect:{min: number, max: number}}}\n     */\n  }, {\n    key: \"EFFECT_RANGE\",\n    get: function get() {\n      return {\n        pitch: {\n          min: -360,\n          max: 360\n        },\n        // -3 to 3 octaves\n        pan: {\n          min: -100,\n          max: 100\n        } // 100% left to 100% right\n      };\n    }\n  }]);\n  return Scratch3SoundBlocks;\n}();\nmodule.exports = Scratch3SoundBlocks;\n })