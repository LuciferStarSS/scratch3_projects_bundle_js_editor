/* 1094 */\n (function(module, exports, __webpack_require__) {\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n/**\n * @file library.js\n *\n * Tony Hwang and John Maloney, January 2011\n * Michael \"Z\" Goddard, March 2018\n *\n * Video motion sensing primitives.\n */\nvar _require = __webpack_require__(1095),\n    motionVector = _require.motionVector,\n    scratchAtan2 = _require.scratchAtan2;\n/**\n * The width of the intended resolution to analyze for motion.\n * @type {number}\n */\nvar WIDTH = 480;\n/**\n * The height of the intended resolution to analyze for motion.\n * @type {number}\n */\nvar HEIGHT = 360;\n/**\n * A constant value to scale the magnitude of the x and y components called u\n * and v. This creates the motionAmount value.\n *\n * Old note: chosen empirically to give a range of roughly 0-100\n *\n * @type {number}\n */\nvar AMOUNT_SCALE = 100;\n/**\n * A constant value to scale the magnitude of the x and y components called u\n * and v in the local motion derivative. This creates the motionAmount value on\n * a target's motion state.\n *\n * Old note: note 2e-4 * activePixelNum is an experimentally tuned threshold\n * for my logitech Pro 9000 webcam - TTH\n *\n * @type {number}\n */\nvar LOCAL_AMOUNT_SCALE = AMOUNT_SCALE * 2e-4;\n/**\n * The motion amount must be higher than the THRESHOLD to calculate a new\n * direction value.\n * @type {number}\n */\nvar THRESHOLD = 10;\n/**\n * The size of the radius of the window of summarized values when considering\n * the motion inside the full resolution of the sample.\n * @type {number}\n */\nvar WINSIZE = 8;\n/**\n * A ceiling for the motionAmount stored to a local target's motion state. The\n * motionAmount is not allowed to be larger than LOCAL_MAX_AMOUNT.\n * @type {number}\n */\nvar LOCAL_MAX_AMOUNT = 100;\n/**\n * The motion amount for a target's local motion must be higher than the\n * LOCAL_THRESHOLD to calculate a new direction value.\n * @type {number}\n */\nvar LOCAL_THRESHOLD = THRESHOLD / 3;\n/**\n * Store the necessary image pixel data to compares frames of a video and\n * detect an amount and direction of motion in the full sample or in a\n * specified area.\n * @constructor\n */\nvar VideoMotion = function () {\n  function VideoMotion() {\n    _classCallCheck(this, VideoMotion);\n    /**\n     * The number of frames that have been added from a source.\n     * @type {number}\n     */\n    this.frameNumber = 0;\n    /**\n     * The frameNumber last analyzed.\n     * @type {number}\n     */\n    this.lastAnalyzedFrame = 0;\n    /**\n     * The amount of motion detected in the current frame.\n     * @type {number}\n     */\n    this.motionAmount = 0;\n    /**\n     * The direction the motion detected in the frame is general moving in.\n     * @type {number}\n     */\n    this.motionDirection = 0;\n    /**\n     * A copy of the current frame's pixel values. A index of the array is\n     * represented in RGBA. The lowest byte is red. The next is green. The\n     * next is blue. And the last is the alpha value of that pixel.\n     * @type {Uint32Array}\n     */\n    this.curr = null;\n    /**\n     * A copy of the last frame's pixel values.\n     * @type {Uint32Array}\n     */\n    this.prev = null;\n    /**\n     * A buffer for holding one component of a pixel's full value twice.\n     * One for the current value. And one for the last value.\n     * @type {number}\n     */\n    this._arrays = new ArrayBuffer(WIDTH * HEIGHT * 2 * 1);\n    /**\n     * A clamped uint8 view of _arrays. One component of each index of the\n     * curr member is copied into this array.\n     * @type {number}\n     */\n    this._curr = new Uint8ClampedArray(this._arrays, WIDTH * HEIGHT * 0 * 1, WIDTH * HEIGHT);\n    /**\n     * A clamped uint8 view of _arrays. One component of each index of the\n     * prev member is copied into this array.\n     * @type {number}\n     */\n    this._prev = new Uint8ClampedArray(this._arrays, WIDTH * HEIGHT * 1 * 1, WIDTH * HEIGHT);\n  }\n  /**\n   * Reset internal state so future frame analysis does not consider values\n   * from before this method was called.\n   */\n  _createClass(VideoMotion, [{\n    key: \"reset\",\n    value: function reset() {\n      this.frameNumber = 0;\n      this.lastAnalyzedFrame = 0;\n      this.motionAmount = this.motionDirection = 0;\n      this.prev = this.curr = null;\n    }\n    /**\n     * Add a frame to be next analyzed. The passed array represent a pixel with\n     * each index in the RGBA format.\n     * @param {Uint32Array} source - a source frame of pixels to copy\n     */\n  }, {\n    key: \"addFrame\",\n    value: function addFrame(source) {\n      this.frameNumber++; // Swap curr to prev.\n      this.prev = this.curr; // Create a clone of the array so any modifications made to the source\n      // array do not affect the work done in here.\n      this.curr = new Uint32Array(source.buffer.slice(0)); // Swap _prev and _curr. Copy one of the color components of the new\n      // array into _curr overwriting what was the old _prev data.\n      var _tmp = this._prev;\n      this._prev = this._curr;\n      this._curr = _tmp;\n      for (var i = 0; i < this.curr.length; i++) {\n        this._curr[i] = this.curr[i] & 0xff;\n      }\n    }\n    /**\n     * Analyze the current frame against the previous frame determining the\n     * amount of motion and direction of the motion.\n     */\n  }, {\n    key: \"analyzeFrame\",\n    value: function analyzeFrame() {\n      if (!this.curr || !this.prev) {\n        this.motionAmount = this.motionDirection = -1; // Don't have two frames to analyze yet\n        return;\n      } // Return early if new data has not been received.\n      if (this.lastAnalyzedFrame === this.frameNumber) {\n        return;\n      }\n      this.lastAnalyzedFrame = this.frameNumber;\n      var curr = this._curr,\n          prev = this._prev;\n      var winStep = WINSIZE * 2 + 1;\n      var wmax = WIDTH - WINSIZE - 1;\n      var hmax = HEIGHT - WINSIZE - 1; // Accumulate 2d motion vectors from groups of pixels and average it\n      // later.\n      var uu = 0;\n      var vv = 0;\n      var n = 0; // Iterate over groups of cells building up the components to determine\n      // a motion vector for each cell instead of the whole frame to avoid\n      // integer overflows.\n      for (var i = WINSIZE + 1; i < hmax; i += winStep) {\n        for (var j = WINSIZE + 1; j < wmax; j += winStep) {\n          var A2 = 0;\n          var A1B2 = 0;\n          var B1 = 0;\n          var C1 = 0;\n          var C2 = 0; // This is a performance critical math region.\n          var address = (i - WINSIZE) * WIDTH + j - WINSIZE;\n          var nextAddress = address + winStep;\n          var maxAddress = (i + WINSIZE) * WIDTH + j + WINSIZE;\n          for (; address <= maxAddress; address += WIDTH - winStep, nextAddress += WIDTH) {\n            for (; address <= nextAddress; address += 1) {\n              // The difference in color between the last frame and\n              // the current frame.\n              var gradT = prev[address] - curr[address]; // The difference between the pixel to the left and the\n              // pixel to the right.\n              var gradX = curr[address - 1] - curr[address + 1]; // The difference between the pixel above and the pixel\n              // below.\n              var gradY = curr[address - WIDTH] - curr[address + WIDTH]; // Add the combined values of this pixel to previously\n              // considered pixels.\n              A2 += gradX * gradX;\n              A1B2 += gradX * gradY;\n              B1 += gradY * gradY;\n              C2 += gradX * gradT;\n              C1 += gradY * gradT;\n            }\n          } // Use the accumalated values from the for loop to determine a\n          // motion direction.\n          var _motionVector = motionVector(A2, A1B2, B1, C2, C1),\n              u = _motionVector.u,\n              v = _motionVector.v; // If u and v are within negative winStep to positive winStep,\n          // add them to a sum that will later be averaged.\n          if (-winStep < u && u < winStep && -winStep < v && v < winStep) {\n            uu += u;\n            vv += v;\n            n++;\n          }\n        }\n      } // Average the summed vector values of all of the motion groups.\n      uu /= n;\n      vv /= n; // Scale the magnitude of the averaged UV vector.\n      this.motionAmount = Math.round(AMOUNT_SCALE * Math.hypot(uu, vv));\n      if (this.motionAmount > THRESHOLD) {\n        // Scratch direction\n        this.motionDirection = scratchAtan2(vv, uu);\n      }\n    }\n    /**\n     * Build motion amount and direction values based on stored current and\n     * previous frame that overlaps a given drawable.\n     * @param {Drawable} drawable - touchable and bounded drawable to build motion for\n     * @param {MotionState} state - state to store built values to\n     */\n  }, {\n    key: \"getLocalMotion\",\n    value: function getLocalMotion(drawable, state) {\n      if (!this.curr || !this.prev) {\n        state.motionAmount = state.motionDirection = -1; // Don't have two frames to analyze yet\n        return;\n      } // Skip if the current frame has already been considered for this state.\n      if (state.motionFrameNumber !== this.frameNumber) {\n        var prev = this._prev,\n            curr = this._curr; // The public APIs for Renderer#isTouching manage keeping the matrix and\n        // silhouette up-to-date, which is needed for drawable#isTouching to work (used below)\n        drawable.updateCPURenderAttributes(); // Restrict the region the amount and direction are built from to\n        // the area of the current frame overlapped by the given drawable's\n        // bounding box.\n        var boundingRect = drawable.getFastBounds(); // Transform the bounding box from scratch space to a space from 0,\n        // 0 to WIDTH, HEIGHT.\n        var xmin = Math.max(Math.floor(boundingRect.left + WIDTH / 2), 1);\n        var xmax = Math.min(Math.floor(boundingRect.right + WIDTH / 2), WIDTH - 1);\n        var ymin = Math.max(Math.floor(HEIGHT / 2 - boundingRect.top), 1);\n        var ymax = Math.min(Math.floor(HEIGHT / 2 - boundingRect.bottom), HEIGHT - 1);\n        var A2 = 0;\n        var A1B2 = 0;\n        var B1 = 0;\n        var C1 = 0;\n        var C2 = 0;\n        var scaleFactor = 0;\n        var position = [0, 0, 0]; // This is a performance critical math region.\n        for (var i = ymin; i < ymax; i++) {\n          for (var j = xmin; j < xmax; j++) {\n            // i and j are in a coordinate planning ranging from 0 to\n            // HEIGHT and 0 to WIDTH. Transform that into Scratch's\n            // range of HEIGHT / 2 to -HEIGHT / 2 and -WIDTH / 2 to\n            // WIDTH / 2;\n            position[0] = j - WIDTH / 2;\n            position[1] = HEIGHT / 2 - i; // Consider only pixels in the drawable that can touch the\n            // edge or other drawables. Empty space in the current skin\n            // is skipped.\n            if (drawable.isTouching(position)) {\n              var address = i * WIDTH + j; // The difference in color between the last frame and\n              // the current frame.\n              var gradT = prev[address] - curr[address]; // The difference between the pixel to the left and the\n              // pixel to the right.\n              var gradX = curr[address - 1] - curr[address + 1]; // The difference between the pixel above and the pixel\n              // below.\n              var gradY = curr[address - WIDTH] - curr[address + WIDTH]; // Add the combined values of this pixel to previously\n              // considered pixels.\n              A2 += gradX * gradX;\n              A1B2 += gradX * gradY;\n              B1 += gradY * gradY;\n              C2 += gradX * gradT;\n              C1 += gradY * gradT;\n              scaleFactor++;\n            }\n          }\n        } // Use the accumalated values from the for loop to determine a\n        // motion direction.\n        var _motionVector2 = motionVector(A2, A1B2, B1, C2, C1),\n            u = _motionVector2.u,\n            v = _motionVector2.v;\n        var activePixelNum = 0;\n        if (scaleFactor) {\n          // Store the area of the sprite in pixels\n          activePixelNum = scaleFactor;\n          scaleFactor /= 2 * WINSIZE * 2 * WINSIZE;\n          u = u / scaleFactor;\n          v = v / scaleFactor;\n        } // Scale the magnitude of the averaged UV vector and the number of\n        // overlapping drawable pixels.\n        state.motionAmount = Math.round(LOCAL_AMOUNT_SCALE * activePixelNum * Math.hypot(u, v));\n        if (state.motionAmount > LOCAL_MAX_AMOUNT) {\n          // Clip all magnitudes greater than 100.\n          state.motionAmount = LOCAL_MAX_AMOUNT;\n        }\n        if (state.motionAmount > LOCAL_THRESHOLD) {\n          // Scratch direction.\n          state.motionDirection = scratchAtan2(v, u);\n        } // Skip future calls on this state until a new frame is added.\n        state.motionFrameNumber = this.frameNumber;\n      }\n    }\n  }]);\n  return VideoMotion;\n}();\nmodule.exports = VideoMotion;\n })