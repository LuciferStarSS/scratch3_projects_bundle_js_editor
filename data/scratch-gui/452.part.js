/* 452 */\n (function(module, exports, __webpack_require__) {\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nvar StageLayering = __webpack_require__(115);\nvar Video = function () {\n  function Video(runtime) {\n    _classCallCheck(this, Video);\n    this.runtime = runtime;\n    /**\n     * @typedef VideoProvider\n     * @property {Function} enableVideo - Requests camera access from the user, and upon success,\n     * enables the video feed\n     * @property {Function} disableVideo - Turns off the video feed\n     * @property {Function} getFrame - Return frame data from the video feed in\n     * specified dimensions, format, and mirroring.\n     */\n    this.provider = null;\n    /**\n     * Id representing a Scratch Renderer skin the video is rendered to for\n     * previewing.\n     * @type {number}\n     */\n    this._skinId = -1;\n    /**\n     * Id for a drawable using the video's skin that will render as a video\n     * preview.\n     * @type {Drawable}\n     */\n    this._drawable = -1;\n    /**\n     * Store the last state of the video transparency ghost effect\n     * @type {number}\n     */\n    this._ghost = 0;\n    /**\n     * Store a flag that allows the preview to be forced transparent.\n     * @type {number}\n     */\n    this._forceTransparentPreview = false;\n  }\n  _createClass(Video, [{\n    key: \"setProvider\",\n    /**\n     * Set a video provider for this device. A default implementation of\n     * a video provider can be found in scratch-gui/src/lib/video/video-provider\n     * @param {VideoProvider} provider - Video provider to use\n     */\n    value: function setProvider(provider) {\n      this.provider = provider;\n    }\n    /**\n     * Request video be enabled.  Sets up video, creates video skin and enables preview.\n     *\n     * ioDevices.video.requestVideo()\n     *\n     * @return {Promise.<Video>} resolves a promise to this IO device when video is ready.\n     */\n  }, {\n    key: \"enableVideo\",\n    value: function enableVideo() {\n      var _this = this;\n      if (!this.provider) return null;\n      return this.provider.enableVideo().then(function () {\n        return _this._setupPreview();\n      });\n    }\n    /**\n     * Disable video stream (turn video off)\n     * @return {void}\n     */\n  }, {\n    key: \"disableVideo\",\n    value: function disableVideo() {\n      this._disablePreview();\n      if (!this.provider) return null;\n      this.provider.disableVideo();\n    }\n    /**\n     * Return frame data from the video feed in a specified dimensions, format, and mirroring.\n     *\n     * @param {object} frameInfo A descriptor of the frame you would like to receive.\n     * @param {Array.<number>} frameInfo.dimensions [width, height] array of numbers.  Defaults to [480,360]\n     * @param {boolean} frameInfo.mirror If you specificly want a mirror/non-mirror frame, defaults to the global\n     *                                   mirror state (ioDevices.video.mirror)\n     * @param {string} frameInfo.format Requested video format, available formats are 'image-data' and 'canvas'.\n     * @param {number} frameInfo.cacheTimeout Will reuse previous image data if the time since capture is less than\n     *                                        the cacheTimeout.  Defaults to 16ms.\n     *\n     * @return {ArrayBuffer|Canvas|string|null} Frame data in requested format, null when errors.\n     */\n  }, {\n    key: \"getFrame\",\n    value: function getFrame(_ref) {\n      var _ref$dimensions = _ref.dimensions,\n          dimensions = _ref$dimensions === void 0 ? Video.DIMENSIONS : _ref$dimensions,\n          _ref$mirror = _ref.mirror,\n          mirror = _ref$mirror === void 0 ? this.mirror : _ref$mirror,\n          _ref$format = _ref.format,\n          format = _ref$format === void 0 ? Video.FORMAT_IMAGE_DATA : _ref$format,\n          _ref$cacheTimeout = _ref.cacheTimeout,\n          cacheTimeout = _ref$cacheTimeout === void 0 ? this._frameCacheTimeout : _ref$cacheTimeout;\n      if (this.provider) return this.provider.getFrame({\n        dimensions: dimensions,\n        mirror: mirror,\n        format: format,\n        cacheTimeout: cacheTimeout\n      });\n      return null;\n    }\n    /**\n     * Set the preview ghost effect\n     * @param {number} ghost from 0 (visible) to 100 (invisible) - ghost effect\n     */\n  }, {\n    key: \"setPreviewGhost\",\n    value: function setPreviewGhost(ghost) {\n      this._ghost = ghost; // Confirm that the default value has been changed to a valid id for the drawable\n      if (this._drawable !== -1) {\n        this.runtime.renderer.updateDrawableEffect(this._drawable, 'ghost', this._forceTransparentPreview ? 100 : ghost);\n      }\n    }\n  }, {\n    key: \"_disablePreview\",\n    value: function _disablePreview() {\n      if (this._skinId !== -1) {\n        this.runtime.renderer.updateBitmapSkin(this._skinId, _construct(ImageData, _toConsumableArray(Video.DIMENSIONS)), 1);\n        this.runtime.renderer.updateDrawableVisible(this._drawable, false);\n      }\n      this._renderPreviewFrame = null;\n    }\n  }, {\n    key: \"_setupPreview\",\n    value: function _setupPreview() {\n      var _this2 = this;\n      var renderer = this.runtime.renderer;\n      if (!renderer) return;\n      if (this._skinId === -1 && this._drawable === -1) {\n        this._skinId = renderer.createBitmapSkin(_construct(ImageData, _toConsumableArray(Video.DIMENSIONS)), 1);\n        this._drawable = renderer.createDrawable(StageLayering.VIDEO_LAYER);\n        renderer.updateDrawableSkinId(this._drawable, this._skinId);\n      } // if we haven't already created and started a preview frame render loop, do so\n      if (!this._renderPreviewFrame) {\n        renderer.updateDrawableEffect(this._drawable, 'ghost', this._forceTransparentPreview ? 100 : this._ghost);\n        renderer.updateDrawableVisible(this._drawable, true);\n        this._renderPreviewFrame = function () {\n          clearTimeout(_this2._renderPreviewTimeout);\n          if (!_this2._renderPreviewFrame) {\n            return;\n          }\n          _this2._renderPreviewTimeout = setTimeout(_this2._renderPreviewFrame, _this2.runtime.currentStepTime);\n          var imageData = _this2.getFrame({\n            format: Video.FORMAT_IMAGE_DATA,\n            cacheTimeout: _this2.runtime.currentStepTime\n          });\n          if (!imageData) {\n            renderer.updateBitmapSkin(_this2._skinId, _construct(ImageData, _toConsumableArray(Video.DIMENSIONS)), 1);\n            return;\n          }\n          renderer.updateBitmapSkin(_this2._skinId, imageData, 1);\n          _this2.runtime.requestRedraw();\n        };\n        this._renderPreviewFrame();\n      }\n    }\n  }, {\n    key: \"postData\",\n    /**\n     * Method implemented by all IO devices to allow external changes.\n     * The only change available externally is hiding the preview, used e.g. to\n     * prevent drawing the preview into project thumbnails.\n     * @param {object} - data passed to this IO device.\n     * @property {boolean} forceTransparentPreview - whether the preview should be forced transparent.\n     */\n    value: function postData(_ref2) {\n      var forceTransparentPreview = _ref2.forceTransparentPreview;\n      this._forceTransparentPreview = forceTransparentPreview; // Setting the ghost to the current value will pick up the forceTransparentPreview\n      // flag and override the current ghost. The complexity is to prevent blocks\n      // from overriding forceTransparentPreview\n      this.setPreviewGhost(this._ghost);\n    }\n  }, {\n    key: \"videoReady\",\n    get: function get() {\n      if (this.provider) return this.provider.videoReady;\n      return false;\n    }\n  }], [{\n    key: \"FORMAT_IMAGE_DATA\",\n    get: function get() {\n      return 'image-data';\n    }\n  }, {\n    key: \"FORMAT_CANVAS\",\n    get: function get() {\n      return 'canvas';\n    }\n    /**\n     * Dimensions the video stream is analyzed at after its rendered to the\n     * sample canvas.\n     * @type {Array.<number>}\n     */\n  }, {\n    key: \"DIMENSIONS\",\n    get: function get() {\n      return [480, 360];\n    }\n    /**\n     * Order preview drawable is inserted at in the renderer.\n     * @type {number}\n     */\n  }, {\n    key: \"ORDER\",\n    get: function get() {\n      return 1;\n    }\n  }]);\n  return Video;\n}();\nmodule.exports = Video;\n })