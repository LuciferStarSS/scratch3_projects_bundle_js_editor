/* 984 */\n (function(module, exports, __webpack_require__) {\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nvar ArgumentType = __webpack_require__(63);\nvar BlockType = __webpack_require__(45);\nvar Clone = __webpack_require__(113);\nvar Cast = __webpack_require__(48);\nvar formatMessage = __webpack_require__(71);\nvar MathUtil = __webpack_require__(62);\nvar Timer = __webpack_require__(136);\n/**\n * The instrument and drum sounds, loaded as static assets.\n * @type {object}\n */\nvar assetData = {};\ntry {\n  assetData = __webpack_require__(985);\n} catch (e) {// Non-webpack environment, don't worry about assets.\n}\n/**\n * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.\n * @type {string}\n */\n// eslint-disable-next-line max-len\nvar blockIconURI = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHZpZXdCb3g9IjAgMCA0MCA0MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PHRpdGxlPm11c2ljLWJsb2NrLWljb248L3RpdGxlPjxkZWZzPjxwYXRoIGQ9Ik0zMi4xOCAyNS44NzRDMzIuNjM2IDI4LjE1NyAzMC41MTIgMzAgMjcuNDMzIDMwYy0zLjA3IDAtNS45MjMtMS44NDMtNi4zNzItNC4xMjYtLjQ1OC0yLjI4NSAxLjY2NS00LjEzNiA0Ljc0My00LjEzNi42NDcgMCAxLjI4My4wODQgMS44OS4yMzQuMzM4LjA4Ni42MzcuMTguOTM4LjMwMi44Ny0uMDItLjEwNC0yLjI5NC0xLjgzNS0xMi4yMy0yLjEzNC0xMi4zMDIgMy4wNi0xLjg3IDguNzY4LTIuNzUyIDUuNzA4LS44ODUuMDc2IDQuODItMy42NSAzLjg0NC0zLjcyNC0uOTg3LTQuNjUtNy4xNTMuMjYzIDE0LjczOHptLTE2Ljk5OCA1Ljk5QzE1LjYzIDM0LjE0OCAxMy41MDcgMzYgMTAuNDQgMzZjLTMuMDcgMC01LjkyMi0xLjg1Mi02LjM4LTQuMTM2LS40NDgtMi4yODQgMS42NzQtNC4xMzUgNC43NS00LjEzNSAxLjAwMyAwIDEuOTc1LjE5NiAyLjg1NS41NDMuODIyLS4wNTUtLjE1LTIuMzc3LTEuODYyLTEyLjIyOC0yLjEzMy0xMi4zMDMgMy4wNi0xLjg3IDguNzY0LTIuNzUzIDUuNzA2LS44OTQuMDc2IDQuODItMy42NDggMy44MzQtMy43MjQtLjk4Ny00LjY1LTcuMTUyLjI2MiAxNC43Mzh6IiBpZD0iYSIvPjwvZGVmcz48ZyBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPjx1c2UgZmlsbD0iI0ZGRiIgeGxpbms6aHJlZj0iI2EiLz48cGF0aCBzdHJva2Utb3BhY2l0eT0iLjEiIHN0cm9rZT0iIzAwMCIgZD0iTTI4LjQ1NiAyMS42NzVjLS4wMS0uMzEyLS4wODctLjgyNS0uMjU2LTEuNzAyLS4wOTYtLjQ5NS0uNjEyLTMuMDIyLS43NTMtMy43My0uMzk1LTEuOTgtLjc2LTMuOTItMS4xNDItNi4xMTMtLjczMi00LjIyMy0uNjkzLTYuMDUuMzQ0LTYuNTI3LjUtLjIzIDEuMDYtLjA4IDEuODQuMzUuNDE0LjIyNyAyLjE4MiAxLjM2NSAyLjA3IDEuMjk2IDEuOTk0IDEuMjQyIDMuNDY0IDEuNzc0IDQuOTMgMS41NDggMS41MjYtLjIzNyAyLjUwNC0uMDYgMi44NzYuNjE4LjM0OC42MzUuMDE1IDEuNDE2LS43MyAyLjE4LTEuNDcyIDEuNTE2LTMuOTc1IDIuNTE0LTUuODQ4IDIuMDIzLS44MjItLjIyLTEuMjM4LS40NjUtMi4zOC0xLjI2N2wtLjA5NS0uMDY2Yy4wNDcuNTkzLjI2NCAxLjc0LjcxNyAzLjgwMy4yOTQgMS4zMzYgMi4wOCA5LjE4NyAyLjYzNyAxMS42NzRsLjAwMi4wMTJjLjUyOCAyLjYzNy0xLjg3MyA0LjcyNC01LjIzNiA0LjcyNC0zLjI5IDAtNi4zNjMtMS45ODgtNi44NjItNC41MjgtLjUzLTIuNjQgMS44NzMtNC43MzQgNS4yMzMtNC43MzQuNjcyIDAgMS4zNDcuMDg1IDIuMDE0LjI1LjIyNy4wNTcuNDM2LjExOC42MzYuMTg3em0tMTYuOTk2IDUuOTljLS4wMS0uMzE4LS4wOS0uODM4LS4yNjYtMS43MzctLjA5LS40Ni0uNTk1LTIuOTM3LS43NTMtMy43MjctLjM5LTEuOTYtLjc1LTMuODktMS4xMy02LjA3LS43MzItNC4yMjMtLjY5Mi02LjA1LjM0NC02LjUyNi41MDItLjIzIDEuMDYtLjA4MiAxLjg0LjM1LjQxNS4yMjcgMi4xODIgMS4zNjQgMi4wNyAxLjI5NSAxLjk5MyAxLjI0MiAzLjQ2MiAxLjc3NCA0LjkyNiAxLjU0OCAxLjUyNS0uMjQgMi41MDQtLjA2NCAyLjg3Ni42MTQuMzQ4LjYzNS4wMTUgMS40MTUtLjcyOCAyLjE4LTEuNDc0IDEuNTE3LTMuOTc3IDIuNTEzLTUuODQ3IDIuMDE3LS44Mi0uMjItMS4yMzYtLjQ2NC0yLjM3OC0xLjI2N2wtLjA5NS0uMDY1Yy4wNDcuNTkzLjI2NCAxLjc0LjcxNyAzLjgwMi4yOTQgMS4zMzcgMi4wNzggOS4xOSAyLjYzNiAxMS42NzVsLjAwMy4wMTNjLjUxNyAyLjYzOC0xLjg4NCA0LjczMi01LjIzNCA0LjczMi0zLjI4NyAwLTYuMzYtMS45OTMtNi44Ny00LjU0LS41Mi0yLjY0IDEuODg0LTQuNzMgNS4yNC00LjczLjkwNSAwIDEuODAzLjE1IDIuNjUuNDM2eiIvPjwvZz48L3N2Zz4=';\n/**\n * Icon svg to be displayed in the category menu, encoded as a data URI.\n * @type {string}\n */\n// eslint-disable-next-line max-len\nvar menuIconURI = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTE2LjA5IDEyLjkzN2MuMjI4IDEuMTQxLS44MzMgMi4wNjMtMi4zNzMgMi4wNjMtMS41MzUgMC0yLjk2Mi0uOTIyLTMuMTg2LTIuMDYzLS4yMy0xLjE0Mi44MzMtMi4wNjggMi4zNzItMi4wNjguMzIzIDAgLjY0MS4wNDIuOTQ1LjExN2EzLjUgMy41IDAgMCAxIC40NjguMTUxYy40MzUtLjAxLS4wNTItMS4xNDctLjkxNy02LjExNC0xLjA2Ny02LjE1MiAxLjUzLS45MzUgNC4zODQtMS4zNzcgMi44NTQtLjQ0Mi4wMzggMi40MS0xLjgyNSAxLjkyMi0xLjg2Mi0uNDkzLTIuMzI1LTMuNTc3LjEzMiA3LjM3ek03LjQ2IDguNTYzYy0xLjg2Mi0uNDkzLTIuMzI1LTMuNTc2LjEzIDcuMzdDNy44MTYgMTcuMDczIDYuNzU0IDE4IDUuMjIgMThjLTEuNTM1IDAtMi45NjEtLjkyNi0zLjE5LTIuMDY4LS4yMjQtMS4xNDIuODM3LTIuMDY3IDIuMzc1LTIuMDY3LjUwMSAwIC45ODcuMDk4IDEuNDI3LjI3Mi40MTItLjAyOC0uMDc0LTEuMTg5LS45My02LjExNEMzLjgzNCAxLjg3IDYuNDMgNy4wODcgOS4yODIgNi42NDZjMi44NTQtLjQ0Ny4wMzggMi40MS0xLjgyMyAxLjkxN3oiIGZpbGw9IiM1NzVFNzUiIGZpbGwtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==';\n/**\n * Class for the music-related blocks in Scratch 3.0\n * @param {Runtime} runtime - the runtime instantiating this block package.\n * @constructor\n */\nvar Scratch3MusicBlocks = function () {\n  function Scratch3MusicBlocks(runtime) {\n    _classCallCheck(this, Scratch3MusicBlocks);\n    /**\n     * The runtime instantiating this block package.\n     * @type {Runtime}\n     */\n    this.runtime = runtime;\n    /**\n     * The number of drum and instrument sounds currently being played simultaneously.\n     * @type {number}\n     * @private\n     */\n    this._concurrencyCounter = 0;\n    /**\n     * An array of sound players, one for each drum sound.\n     * @type {Array}\n     * @private\n     */\n    this._drumPlayers = [];\n    /**\n     * An array of arrays of sound players. Each instrument has one or more audio players.\n     * @type {Array[]}\n     * @private\n     */\n    this._instrumentPlayerArrays = [];\n    /**\n     * An array of arrays of sound players. Each instrument mya have an audio player for each playable note.\n     * @type {Array[]}\n     * @private\n     */\n    this._instrumentPlayerNoteArrays = [];\n    /**\n     * An array of audio bufferSourceNodes. Each time you play an instrument or drum sound,\n     * a bufferSourceNode is created. We keep references to them to make sure their onended\n     * events can fire.\n     * @type {Array}\n     * @private\n     */\n    this._bufferSources = [];\n    this._loadAllSounds();\n    this._onTargetCreated = this._onTargetCreated.bind(this);\n    this.runtime.on('targetWasCreated', this._onTargetCreated);\n    this._playNoteForPicker = this._playNoteForPicker.bind(this);\n    this.runtime.on('PLAY_NOTE', this._playNoteForPicker);\n  }\n  /**\n   * Decode the full set of drum and instrument sounds, and store the audio buffers in arrays.\n   */\n  _createClass(Scratch3MusicBlocks, [{\n    key: \"_loadAllSounds\",\n    value: function _loadAllSounds() {\n      var _this = this;\n      var loadingPromises = [];\n      this.DRUM_INFO.forEach(function (drumInfo, index) {\n        var filePath = \"drums/\".concat(drumInfo.fileName);\n        var promise = _this._storeSound(filePath, index, _this._drumPlayers);\n        loadingPromises.push(promise);\n      });\n      this.INSTRUMENT_INFO.forEach(function (instrumentInfo, instrumentIndex) {\n        _this._instrumentPlayerArrays[instrumentIndex] = [];\n        _this._instrumentPlayerNoteArrays[instrumentIndex] = [];\n        instrumentInfo.samples.forEach(function (sample, noteIndex) {\n          var filePath = \"instruments/\".concat(instrumentInfo.dirName, \"/\").concat(sample);\n          var promise = _this._storeSound(filePath, noteIndex, _this._instrumentPlayerArrays[instrumentIndex]);\n          loadingPromises.push(promise);\n        });\n      });\n      Promise.all(loadingPromises).then(function () {// @TODO: Update the extension status indicator.\n      });\n    }\n    /**\n     * Decode a sound and store the player in an array.\n     * @param {string} filePath - the audio file name.\n     * @param {number} index - the index at which to store the audio player.\n     * @param {array} playerArray - the array of players in which to store it.\n     * @return {Promise} - a promise which will resolve once the sound has been stored.\n     */\n  }, {\n    key: \"_storeSound\",\n    value: function _storeSound(filePath, index, playerArray) {\n      var fullPath = \"\".concat(filePath, \".mp3\");\n      if (!assetData[fullPath]) return; // The sound player has already been downloaded via the manifest file required above.\n      var soundBuffer = assetData[fullPath];\n      return this._decodeSound(soundBuffer).then(function (player) {\n        playerArray[index] = player;\n      });\n    }\n    /**\n     * Decode a sound and return a promise with the audio buffer.\n     * @param  {ArrayBuffer} soundBuffer - a buffer containing the encoded audio.\n     * @return {Promise} - a promise which will resolve once the sound has decoded.\n     */\n  }, {\n    key: \"_decodeSound\",\n    value: function _decodeSound(soundBuffer) {\n      var engine = this.runtime.audioEngine;\n      if (!engine) {\n        return Promise.reject(new Error('No Audio Context Detected'));\n      } // Check for newer promise-based API\n      return engine.decodeSoundPlayer({\n        data: {\n          buffer: soundBuffer\n        }\n      });\n    }\n    /**\n     * Create data for a menu in scratch-blocks format, consisting of an array of objects with text and\n     * value properties. The text is a translated string, and the value is one-indexed.\n     * @param  {object[]} info - An array of info objects each having a name property.\n     * @return {array} - An array of objects with text and value properties.\n     * @private\n     */\n  }, {\n    key: \"_buildMenu\",\n    value: function _buildMenu(info) {\n      return info.map(function (entry, index) {\n        var obj = {};\n        obj.text = entry.name;\n        obj.value = String(index + 1);\n        return obj;\n      });\n    }\n    /**\n     * An array of info about each drum.\n     * @type {object[]}\n     * @param {string} name - the translatable name to display in the drums menu.\n     * @param {string} fileName - the name of the audio file containing the drum sound.\n     */\n  }, {\n    key: \"_getMusicState\",\n    /**\n     * @param {Target} target - collect music state for this target.\n     * @returns {MusicState} the mutable music state associated with that target. This will be created if necessary.\n     * @private\n     */\n    value: function _getMusicState(target) {\n      var musicState = target.getCustomState(Scratch3MusicBlocks.STATE_KEY);\n      if (!musicState) {\n        musicState = Clone.simple(Scratch3MusicBlocks.DEFAULT_MUSIC_STATE);\n        target.setCustomState(Scratch3MusicBlocks.STATE_KEY, musicState);\n      }\n      return musicState;\n    }\n    /**\n     * When a music-playing Target is cloned, clone the music state.\n     * @param {Target} newTarget - the newly created target.\n     * @param {Target} [sourceTarget] - the target used as a source for the new clone, if any.\n     * @listens Runtime#event:targetWasCreated\n     * @private\n     */\n  }, {\n    key: \"_onTargetCreated\",\n    value: function _onTargetCreated(newTarget, sourceTarget) {\n      if (sourceTarget) {\n        var musicState = sourceTarget.getCustomState(Scratch3MusicBlocks.STATE_KEY);\n        if (musicState) {\n          newTarget.setCustomState(Scratch3MusicBlocks.STATE_KEY, Clone.simple(musicState));\n        }\n      }\n    }\n    /**\n     * @returns {object} metadata for this extension and its blocks.\n     */\n  }, {\n    key: \"getInfo\",\n    value: function getInfo() {\n      return {\n        id: 'music',\n        name: formatMessage({\n          id: 'music.categoryName',\n          default: 'Music',\n          description: 'Label for the Music extension category'\n        }),\n        menuIconURI: menuIconURI,\n        blockIconURI: blockIconURI,\n        blocks: [{\n          opcode: 'playDrumForBeats',\n          blockType: BlockType.COMMAND,\n          text: formatMessage({\n            id: 'music.playDrumForBeats',\n            default: 'play drum [DRUM] for [BEATS] beats',\n            description: 'play drum sample for a number of beats'\n          }),\n          arguments: {\n            DRUM: {\n              type: ArgumentType.NUMBER,\n              menu: 'DRUM',\n              defaultValue: 1\n            },\n            BEATS: {\n              type: ArgumentType.NUMBER,\n              defaultValue: 0.25\n            }\n          }\n        }, {\n          opcode: 'midiPlayDrumForBeats',\n          blockType: BlockType.COMMAND,\n          text: formatMessage({\n            id: 'music.midiPlayDrumForBeats',\n            default: 'play drum [DRUM] for [BEATS] beats',\n            description: 'play drum sample for a number of beats according to a mapping of MIDI codes'\n          }),\n          arguments: {\n            DRUM: {\n              type: ArgumentType.NUMBER,\n              menu: 'DRUM',\n              defaultValue: 1\n            },\n            BEATS: {\n              type: ArgumentType.NUMBER,\n              defaultValue: 0.25\n            }\n          },\n          hideFromPalette: true\n        }, {\n          opcode: 'restForBeats',\n          blockType: BlockType.COMMAND,\n          text: formatMessage({\n            id: 'music.restForBeats',\n            default: 'rest for [BEATS] beats',\n            description: 'rest (play no sound) for a number of beats'\n          }),\n          arguments: {\n            BEATS: {\n              type: ArgumentType.NUMBER,\n              defaultValue: 0.25\n            }\n          }\n        }, {\n          opcode: 'playNoteForBeats',\n          blockType: BlockType.COMMAND,\n          text: formatMessage({\n            id: 'music.playNoteForBeats',\n            default: 'play note [NOTE] for [BEATS] beats',\n            description: 'play a note for a number of beats'\n          }),\n          arguments: {\n            NOTE: {\n              type: ArgumentType.NOTE,\n              defaultValue: 60\n            },\n            BEATS: {\n              type: ArgumentType.NUMBER,\n              defaultValue: 0.25\n            }\n          }\n        }, {\n          opcode: 'setInstrument',\n          blockType: BlockType.COMMAND,\n          text: formatMessage({\n            id: 'music.setInstrument',\n            default: 'set instrument to [INSTRUMENT]',\n            description: 'set the instrument (e.g. piano, guitar, trombone) for notes played'\n          }),\n          arguments: {\n            INSTRUMENT: {\n              type: ArgumentType.NUMBER,\n              menu: 'INSTRUMENT',\n              defaultValue: 1\n            }\n          }\n        }, {\n          opcode: 'midiSetInstrument',\n          blockType: BlockType.COMMAND,\n          text: formatMessage({\n            id: 'music.midiSetInstrument',\n            default: 'set instrument to [INSTRUMENT]',\n            description: 'set the instrument for notes played according to a mapping of MIDI codes'\n          }),\n          arguments: {\n            INSTRUMENT: {\n              type: ArgumentType.NUMBER,\n              defaultValue: 1\n            }\n          },\n          hideFromPalette: true\n        }, {\n          opcode: 'setTempo',\n          blockType: BlockType.COMMAND,\n          text: formatMessage({\n            id: 'music.setTempo',\n            default: 'set tempo to [TEMPO]',\n            description: 'set tempo (speed) for notes, drums, and rests played'\n          }),\n          arguments: {\n            TEMPO: {\n              type: ArgumentType.NUMBER,\n              defaultValue: 60\n            }\n          }\n        }, {\n          opcode: 'changeTempo',\n          blockType: BlockType.COMMAND,\n          text: formatMessage({\n            id: 'music.changeTempo',\n            default: 'change tempo by [TEMPO]',\n            description: 'change tempo (speed) for notes, drums, and rests played'\n          }),\n          arguments: {\n            TEMPO: {\n              type: ArgumentType.NUMBER,\n              defaultValue: 20\n            }\n          }\n        }, {\n          opcode: 'getTempo',\n          text: formatMessage({\n            id: 'music.getTempo',\n            default: 'tempo',\n            description: 'get the current tempo (speed) for notes, drums, and rests played'\n          }),\n          blockType: BlockType.REPORTER\n        }],\n        menus: {\n          DRUM: {\n            acceptReporters: true,\n            items: this._buildMenu(this.DRUM_INFO)\n          },\n          INSTRUMENT: {\n            acceptReporters: true,\n            items: this._buildMenu(this.INSTRUMENT_INFO)\n          }\n        }\n      };\n    }\n    /**\n     * Play a drum sound for some number of beats.\n     * @param {object} args - the block arguments.\n     * @param {object} util - utility object provided by the runtime.\n     * @property {int} DRUM - the number of the drum to play.\n     * @property {number} BEATS - the duration in beats of the drum sound.\n     */\n  }, {\n    key: \"playDrumForBeats\",\n    value: function playDrumForBeats(args, util) {\n      this._playDrumForBeats(args.DRUM, args.BEATS, util);\n    }\n    /**\n     * Play a drum sound for some number of beats according to the range of \"MIDI\" drum codes supported.\n     * This block is implemented for compatibility with old Scratch projects that use the\n     * 'drum:duration:elapsed:from:' block.\n     * @param {object} args - the block arguments.\n     * @param {object} util - utility object provided by the runtime.\n     */\n  }, {\n    key: \"midiPlayDrumForBeats\",\n    value: function midiPlayDrumForBeats(args, util) {\n      var drumNum = Cast.toNumber(args.DRUM);\n      drumNum = Math.round(drumNum);\n      var midiDescription = this.MIDI_DRUMS[drumNum - 35];\n      if (midiDescription) {\n        drumNum = midiDescription[0];\n      } else {\n        drumNum = 2; // Default instrument used in Scratch 2.0\n      }\n      drumNum += 1; // drumNum input to _playDrumForBeats is one-indexed\n      this._playDrumForBeats(drumNum, args.BEATS, util);\n    }\n    /**\n     * Internal code to play a drum sound for some number of beats.\n     * @param {number} drumNum - the drum number.\n     * @param {beats} beats - the duration in beats to pause after playing the sound.\n     * @param {object} util - utility object provided by the runtime.\n     */\n  }, {\n    key: \"_playDrumForBeats\",\n    value: function _playDrumForBeats(drumNum, beats, util) {\n      if (this._stackTimerNeedsInit(util)) {\n        drumNum = Cast.toNumber(drumNum);\n        drumNum = Math.round(drumNum);\n        drumNum -= 1; // drums are one-indexed\n        drumNum = MathUtil.wrapClamp(drumNum, 0, this.DRUM_INFO.length - 1);\n        beats = Cast.toNumber(beats);\n        beats = this._clampBeats(beats);\n        this._playDrumNum(util, drumNum);\n        this._startStackTimer(util, this._beatsToSec(beats));\n      } else {\n        this._checkStackTimer(util);\n      }\n    }\n    /**\n     * Play a drum sound using its 0-indexed number.\n     * @param {object} util - utility object provided by the runtime.\n     * @param {number} drumNum - the number of the drum to play.\n     * @private\n     */\n  }, {\n    key: \"_playDrumNum\",\n    value: function _playDrumNum(util, drumNum) {\n      var _this2 = this;\n      if (util.runtime.audioEngine === null) return;\n      if (util.target.sprite.soundBank === null) return; // If we're playing too many sounds, do not play the drum sound.\n      if (this._concurrencyCounter > Scratch3MusicBlocks.CONCURRENCY_LIMIT) {\n        return;\n      }\n      var player = this._drumPlayers[drumNum];\n      if (typeof player === 'undefined') return;\n      if (player.isPlaying && !player.isStarting) {\n        // Take the internal player state and create a new player with it.\n        // `.play` does this internally but then instructs the sound to\n        // stop.\n        player.take();\n      }\n      var engine = util.runtime.audioEngine;\n      var context = engine.audioContext;\n      var volumeGain = context.createGain();\n      volumeGain.gain.setValueAtTime(util.target.volume / 100, engine.currentTime);\n      volumeGain.connect(engine.getInputNode());\n      this._concurrencyCounter++;\n      player.once('stop', function () {\n        _this2._concurrencyCounter--;\n      });\n      player.play(); // Connect the player to the gain node.\n      player.connect({\n        getInputNode: function getInputNode() {\n          return volumeGain;\n        }\n      });\n    }\n    /**\n     * Rest for some number of beats.\n     * @param {object} args - the block arguments.\n     * @param {object} util - utility object provided by the runtime.\n     * @property {number} BEATS - the duration in beats of the rest.\n     */\n  }, {\n    key: \"restForBeats\",\n    value: function restForBeats(args, util) {\n      if (this._stackTimerNeedsInit(util)) {\n        var beats = Cast.toNumber(args.BEATS);\n        beats = this._clampBeats(beats);\n        this._startStackTimer(util, this._beatsToSec(beats));\n      } else {\n        this._checkStackTimer(util);\n      }\n    }\n    /**\n     * Play a note using the current musical instrument for some number of beats.\n     * This function processes the arguments, and handles the timing of the block's execution.\n     * @param {object} args - the block arguments.\n     * @param {object} util - utility object provided by the runtime.\n     * @property {number} NOTE - the pitch of the note to play, interpreted as a MIDI note number.\n     * @property {number} BEATS - the duration in beats of the note.\n     */\n  }, {\n    key: \"playNoteForBeats\",\n    value: function playNoteForBeats(args, util) {\n      if (this._stackTimerNeedsInit(util)) {\n        var note = Cast.toNumber(args.NOTE);\n        note = MathUtil.clamp(note, Scratch3MusicBlocks.MIDI_NOTE_RANGE.min, Scratch3MusicBlocks.MIDI_NOTE_RANGE.max);\n        var beats = Cast.toNumber(args.BEATS);\n        beats = this._clampBeats(beats); // If the duration is 0, do not play the note. In Scratch 2.0, \"play drum for 0 beats\" plays the drum,\n        // but \"play note for 0 beats\" is silent.\n        if (beats === 0) return;\n        var durationSec = this._beatsToSec(beats);\n        this._playNote(util, note, durationSec);\n        this._startStackTimer(util, durationSec);\n      } else {\n        this._checkStackTimer(util);\n      }\n    }\n  }, {\n    key: \"_playNoteForPicker\",\n    value: function _playNoteForPicker(noteNum, category) {\n      if (category !== this.getInfo().name) return;\n      var util = {\n        runtime: this.runtime,\n        target: this.runtime.getEditingTarget()\n      };\n      this._playNote(util, noteNum, 0.25);\n    }\n    /**\n     * Play a note using the current instrument for a duration in seconds.\n     * This function actually plays the sound, and handles the timing of the sound, including the\n     * \"release\" portion of the sound, which continues briefly after the block execution has finished.\n     * @param {object} util - utility object provided by the runtime.\n     * @param {number} note - the pitch of the note to play, interpreted as a MIDI note number.\n     * @param {number} durationSec - the duration in seconds to play the note.\n     * @private\n     */\n  }, {\n    key: \"_playNote\",\n    value: function _playNote(util, note, durationSec) {\n      var _this3 = this;\n      if (util.runtime.audioEngine === null) return;\n      if (util.target.sprite.soundBank === null) return; // If we're playing too many sounds, do not play the note.\n      if (this._concurrencyCounter > Scratch3MusicBlocks.CONCURRENCY_LIMIT) {\n        return;\n      } // Determine which of the audio samples for this instrument to play\n      var musicState = this._getMusicState(util.target);\n      var inst = musicState.currentInstrument;\n      var instrumentInfo = this.INSTRUMENT_INFO[inst];\n      var sampleArray = instrumentInfo.samples;\n      var sampleIndex = this._selectSampleIndexForNote(note, sampleArray); // If the audio sample has not loaded yet, bail out\n      if (typeof this._instrumentPlayerArrays[inst] === 'undefined') return;\n      if (typeof this._instrumentPlayerArrays[inst][sampleIndex] === 'undefined') return; // Fetch the sound player to play the note.\n      var engine = util.runtime.audioEngine;\n      if (!this._instrumentPlayerNoteArrays[inst][note]) {\n        this._instrumentPlayerNoteArrays[inst][note] = this._instrumentPlayerArrays[inst][sampleIndex].take();\n      }\n      var player = this._instrumentPlayerNoteArrays[inst][note];\n      if (player.isPlaying && !player.isStarting) {\n        // Take the internal player state and create a new player with it.\n        // `.play` does this internally but then instructs the sound to\n        // stop.\n        player.take();\n      } // Set its pitch.\n      var sampleNote = sampleArray[sampleIndex];\n      var notePitchInterval = this._ratioForPitchInterval(note - sampleNote); // Create gain nodes for this note's volume and release, and chain them\n      // to the output.\n      var context = engine.audioContext;\n      var volumeGain = context.createGain();\n      volumeGain.gain.setValueAtTime(util.target.volume / 100, engine.currentTime);\n      var releaseGain = context.createGain();\n      volumeGain.connect(releaseGain);\n      releaseGain.connect(engine.getInputNode()); // Schedule the release of the note, ramping its gain down to zero,\n      // and then stopping the sound.\n      var releaseDuration = this.INSTRUMENT_INFO[inst].releaseTime;\n      if (typeof releaseDuration === 'undefined') {\n        releaseDuration = 0.01;\n      }\n      var releaseStart = context.currentTime + durationSec;\n      var releaseEnd = releaseStart + releaseDuration;\n      releaseGain.gain.setValueAtTime(1, releaseStart);\n      releaseGain.gain.linearRampToValueAtTime(0.0001, releaseEnd);\n      this._concurrencyCounter++;\n      player.once('stop', function () {\n        _this3._concurrencyCounter--;\n      }); // Start playing the note\n      player.play(); // Connect the player to the gain node.\n      player.connect({\n        getInputNode: function getInputNode() {\n          return volumeGain;\n        }\n      }); // Set playback now after play creates the outputNode.\n      player.outputNode.playbackRate.value = notePitchInterval; // Schedule playback to stop.\n      player.outputNode.stop(releaseEnd);\n    }\n    /**\n     * The samples array for each instrument is the set of pitches of the available audio samples.\n     * This function selects the best one to use to play a given input note, and returns its index\n     * in the samples array.\n     * @param  {number} note - the input note to select a sample for.\n     * @param  {number[]} samples - an array of the pitches of the available samples.\n     * @return {index} the index of the selected sample in the samples array.\n     * @private\n     */\n  }, {\n    key: \"_selectSampleIndexForNote\",\n    value: function _selectSampleIndexForNote(note, samples) {\n      // Step backwards through the array of samples, i.e. in descending pitch, in order to find\n      // the sample that is the closest one below (or matching) the pitch of the input note.\n      for (var i = samples.length - 1; i >= 0; i--) {\n        if (note >= samples[i]) {\n          return i;\n        }\n      }\n      return 0;\n    }\n    /**\n     * Calcuate the frequency ratio for a given musical interval.\n     * @param  {number} interval - the pitch interval to convert.\n     * @return {number} a ratio corresponding to the input interval.\n     * @private\n     */\n  }, {\n    key: \"_ratioForPitchInterval\",\n    value: function _ratioForPitchInterval(interval) {\n      return Math.pow(2, interval / 12);\n    }\n    /**\n     * Clamp a duration in beats to the allowed min and max duration.\n     * @param  {number} beats - a duration in beats.\n     * @return {number} - the clamped duration.\n     * @private\n     */\n  }, {\n    key: \"_clampBeats\",\n    value: function _clampBeats(beats) {\n      return MathUtil.clamp(beats, Scratch3MusicBlocks.BEAT_RANGE.min, Scratch3MusicBlocks.BEAT_RANGE.max);\n    }\n    /**\n     * Convert a number of beats to a number of seconds, using the current tempo.\n     * @param  {number} beats - number of beats to convert to secs.\n     * @return {number} seconds - number of seconds `beats` will last.\n     * @private\n     */\n  }, {\n    key: \"_beatsToSec\",\n    value: function _beatsToSec(beats) {\n      return 60 / this.getTempo() * beats;\n    }\n    /**\n     * Check if the stack timer needs initialization.\n     * @param {object} util - utility object provided by the runtime.\n     * @return {boolean} - true if the stack timer needs to be initialized.\n     * @private\n     */\n  }, {\n    key: \"_stackTimerNeedsInit\",\n    value: function _stackTimerNeedsInit(util) {\n      return !util.stackFrame.timer;\n    }\n    /**\n     * Start the stack timer and the yield the thread if necessary.\n     * @param {object} util - utility object provided by the runtime.\n     * @param {number} duration - a duration in seconds to set the timer for.\n     * @private\n     */\n  }, {\n    key: \"_startStackTimer\",\n    value: function _startStackTimer(util, duration) {\n      util.stackFrame.timer = new Timer();\n      util.stackFrame.timer.start();\n      util.stackFrame.duration = duration;\n      util.yield();\n    }\n    /**\n     * Check the stack timer, and if its time is not up yet, yield the thread.\n     * @param {object} util - utility object provided by the runtime.\n     * @private\n     */\n  }, {\n    key: \"_checkStackTimer\",\n    value: function _checkStackTimer(util) {\n      var timeElapsed = util.stackFrame.timer.timeElapsed();\n      if (timeElapsed < util.stackFrame.duration * 1000) {\n        util.yield();\n      }\n    }\n    /**\n     * Select an instrument for playing notes.\n     * @param {object} args - the block arguments.\n     * @param {object} util - utility object provided by the runtime.\n     * @property {int} INSTRUMENT - the number of the instrument to select.\n     */\n  }, {\n    key: \"setInstrument\",\n    value: function setInstrument(args, util) {\n      this._setInstrument(args.INSTRUMENT, util, false);\n    }\n    /**\n     * Select an instrument for playing notes according to a mapping of MIDI codes to Scratch instrument numbers.\n     * This block is implemented for compatibility with old Scratch projects that use the 'midiInstrument:' block.\n     * @param {object} args - the block arguments.\n     * @param {object} util - utility object provided by the runtime.\n     * @property {int} INSTRUMENT - the MIDI number of the instrument to select.\n     */\n  }, {\n    key: \"midiSetInstrument\",\n    value: function midiSetInstrument(args, util) {\n      this._setInstrument(args.INSTRUMENT, util, true);\n    }\n    /**\n     * Internal code to select an instrument for playing notes. If mapMidi is true, set the instrument according to\n     * the MIDI to Scratch instrument mapping.\n     * @param {number} instNum - the instrument number.\n     * @param {object} util - utility object provided by the runtime.\n     * @param {boolean} mapMidi - whether or not instNum is a MIDI instrument number.\n     */\n  }, {\n    key: \"_setInstrument\",\n    value: function _setInstrument(instNum, util, mapMidi) {\n      var musicState = this._getMusicState(util.target);\n      instNum = Cast.toNumber(instNum);\n      instNum = Math.round(instNum);\n      instNum -= 1; // instruments are one-indexed\n      if (mapMidi) {\n        instNum = (this.MIDI_INSTRUMENTS[instNum] || 0) - 1;\n      }\n      instNum = MathUtil.wrapClamp(instNum, 0, this.INSTRUMENT_INFO.length - 1);\n      musicState.currentInstrument = instNum;\n    }\n    /**\n     * Set the current tempo to a new value.\n     * @param {object} args - the block arguments.\n     * @property {number} TEMPO - the tempo, in beats per minute.\n     */\n  }, {\n    key: \"setTempo\",\n    value: function setTempo(args) {\n      var tempo = Cast.toNumber(args.TEMPO);\n      this._updateTempo(tempo);\n    }\n    /**\n     * Change the current tempo by some amount.\n     * @param {object} args - the block arguments.\n     * @property {number} TEMPO - the amount to change the tempo, in beats per minute.\n     */\n  }, {\n    key: \"changeTempo\",\n    value: function changeTempo(args) {\n      var change = Cast.toNumber(args.TEMPO);\n      var tempo = change + this.getTempo();\n      this._updateTempo(tempo);\n    }\n    /**\n     * Update the current tempo, clamping it to the min and max allowable range.\n     * @param {number} tempo - the tempo to set, in beats per minute.\n     * @private\n     */\n  }, {\n    key: \"_updateTempo\",\n    value: function _updateTempo(tempo) {\n      tempo = MathUtil.clamp(tempo, Scratch3MusicBlocks.TEMPO_RANGE.min, Scratch3MusicBlocks.TEMPO_RANGE.max);\n      var stage = this.runtime.getTargetForStage();\n      if (stage) {\n        stage.tempo = tempo;\n      }\n    }\n    /**\n     * Get the current tempo.\n     * @return {number} - the current tempo, in beats per minute.\n     */\n  }, {\n    key: \"getTempo\",\n    value: function getTempo() {\n      var stage = this.runtime.getTargetForStage();\n      if (stage) {\n        return stage.tempo;\n      }\n      return 60;\n    }\n  }, {\n    key: \"DRUM_INFO\",\n    get: function get() {\n      return [{\n        name: formatMessage({\n          id: 'music.drumSnare',\n          default: '(1) Snare Drum',\n          description: 'Sound of snare drum as used in a standard drum kit'\n        }),\n        fileName: '1-snare'\n      }, {\n        name: formatMessage({\n          id: 'music.drumBass',\n          default: '(2) Bass Drum',\n          description: 'Sound of bass drum as used in a standard drum kit'\n        }),\n        fileName: '2-bass-drum'\n      }, {\n        name: formatMessage({\n          id: 'music.drumSideStick',\n          default: '(3) Side Stick',\n          description: 'Sound of a drum stick hitting the side of a drum (usually the snare)'\n        }),\n        fileName: '3-side-stick'\n      }, {\n        name: formatMessage({\n          id: 'music.drumCrashCymbal',\n          default: '(4) Crash Cymbal',\n          description: 'Sound of a drum stick hitting a crash cymbal'\n        }),\n        fileName: '4-crash-cymbal'\n      }, {\n        name: formatMessage({\n          id: 'music.drumOpenHiHat',\n          default: '(5) Open Hi-Hat',\n          description: 'Sound of a drum stick hitting a hi-hat while open'\n        }),\n        fileName: '5-open-hi-hat'\n      }, {\n        name: formatMessage({\n          id: 'music.drumClosedHiHat',\n          default: '(6) Closed Hi-Hat',\n          description: 'Sound of a drum stick hitting a hi-hat while closed'\n        }),\n        fileName: '6-closed-hi-hat'\n      }, {\n        name: formatMessage({\n          id: 'music.drumTambourine',\n          default: '(7) Tambourine',\n          description: 'Sound of a tambourine being struck'\n        }),\n        fileName: '7-tambourine'\n      }, {\n        name: formatMessage({\n          id: 'music.drumHandClap',\n          default: '(8) Hand Clap',\n          description: 'Sound of two hands clapping together'\n        }),\n        fileName: '8-hand-clap'\n      }, {\n        name: formatMessage({\n          id: 'music.drumClaves',\n          default: '(9) Claves',\n          description: 'Sound of claves being struck together'\n        }),\n        fileName: '9-claves'\n      }, {\n        name: formatMessage({\n          id: 'music.drumWoodBlock',\n          default: '(10) Wood Block',\n          description: 'Sound of a wood block being struck'\n        }),\n        fileName: '10-wood-block'\n      }, {\n        name: formatMessage({\n          id: 'music.drumCowbell',\n          default: '(11) Cowbell',\n          description: 'Sound of a cowbell being struck'\n        }),\n        fileName: '11-cowbell'\n      }, {\n        name: formatMessage({\n          id: 'music.drumTriangle',\n          default: '(12) Triangle',\n          description: 'Sound of a triangle (instrument) being struck'\n        }),\n        fileName: '12-triangle'\n      }, {\n        name: formatMessage({\n          id: 'music.drumBongo',\n          default: '(13) Bongo',\n          description: 'Sound of a bongo being struck'\n        }),\n        fileName: '13-bongo'\n      }, {\n        name: formatMessage({\n          id: 'music.drumConga',\n          default: '(14) Conga',\n          description: 'Sound of a conga being struck'\n        }),\n        fileName: '14-conga'\n      }, {\n        name: formatMessage({\n          id: 'music.drumCabasa',\n          default: '(15) Cabasa',\n          description: 'Sound of a cabasa being shaken'\n        }),\n        fileName: '15-cabasa'\n      }, {\n        name: formatMessage({\n          id: 'music.drumGuiro',\n          default: '(16) Guiro',\n          description: 'Sound of a guiro being played'\n        }),\n        fileName: '16-guiro'\n      }, {\n        name: formatMessage({\n          id: 'music.drumVibraslap',\n          default: '(17) Vibraslap',\n          description: 'Sound of a Vibraslap being played'\n        }),\n        fileName: '17-vibraslap'\n      }, {\n        name: formatMessage({\n          id: 'music.drumCuica',\n          default: '(18) Cuica',\n          description: 'Sound of a cuica being played'\n        }),\n        fileName: '18-cuica'\n      }];\n    }\n    /**\n     * An array of info about each instrument.\n     * @type {object[]}\n     * @param {string} name - the translatable name to display in the instruments menu.\n     * @param {string} dirName - the name of the directory containing audio samples for this instrument.\n     * @param {number} [releaseTime] - an optional duration for the release portion of each note.\n     * @param {number[]} samples - an array of numbers representing the MIDI note number for each\n     *                           sampled sound used to play this instrument.\n     */\n  }, {\n    key: \"INSTRUMENT_INFO\",\n    get: function get() {\n      return [{\n        name: formatMessage({\n          id: 'music.instrumentPiano',\n          default: '(1) Piano',\n          description: 'Sound of a piano'\n        }),\n        dirName: '1-piano',\n        releaseTime: 0.5,\n        samples: [24, 36, 48, 60, 72, 84, 96, 108]\n      }, {\n        name: formatMessage({\n          id: 'music.instrumentElectricPiano',\n          default: '(2) Electric Piano',\n          description: 'Sound of an electric piano'\n        }),\n        dirName: '2-electric-piano',\n        releaseTime: 0.5,\n        samples: [60]\n      }, {\n        name: formatMessage({\n          id: 'music.instrumentOrgan',\n          default: '(3) Organ',\n          description: 'Sound of an organ'\n        }),\n        dirName: '3-organ',\n        releaseTime: 0.5,\n        samples: [60]\n      }, {\n        name: formatMessage({\n          id: 'music.instrumentGuitar',\n          default: '(4) Guitar',\n          description: 'Sound of an accoustic guitar'\n        }),\n        dirName: '4-guitar',\n        releaseTime: 0.5,\n        samples: [60]\n      }, {\n        name: formatMessage({\n          id: 'music.instrumentElectricGuitar',\n          default: '(5) Electric Guitar',\n          description: 'Sound of an electric guitar'\n        }),\n        dirName: '5-electric-guitar',\n        releaseTime: 0.5,\n        samples: [60]\n      }, {\n        name: formatMessage({\n          id: 'music.instrumentBass',\n          default: '(6) Bass',\n          description: 'Sound of an accoustic upright bass'\n        }),\n        dirName: '6-bass',\n        releaseTime: 0.25,\n        samples: [36, 48]\n      }, {\n        name: formatMessage({\n          id: 'music.instrumentPizzicato',\n          default: '(7) Pizzicato',\n          description: 'Sound of a string instrument (e.g. violin) being plucked'\n        }),\n        dirName: '7-pizzicato',\n        releaseTime: 0.25,\n        samples: [60]\n      }, {\n        name: formatMessage({\n          id: 'music.instrumentCello',\n          default: '(8) Cello',\n          description: 'Sound of a cello being played with a bow'\n        }),\n        dirName: '8-cello',\n        releaseTime: 0.1,\n        samples: [36, 48, 60]\n      }, {\n        name: formatMessage({\n          id: 'music.instrumentTrombone',\n          default: '(9) Trombone',\n          description: 'Sound of a trombone being played'\n        }),\n        dirName: '9-trombone',\n        samples: [36, 48, 60]\n      }, {\n        name: formatMessage({\n          id: 'music.instrumentClarinet',\n          default: '(10) Clarinet',\n          description: 'Sound of a clarinet being played'\n        }),\n        dirName: '10-clarinet',\n        samples: [48, 60]\n      }, {\n        name: formatMessage({\n          id: 'music.instrumentSaxophone',\n          default: '(11) Saxophone',\n          description: 'Sound of a saxophone being played'\n        }),\n        dirName: '11-saxophone',\n        samples: [36, 60, 84]\n      }, {\n        name: formatMessage({\n          id: 'music.instrumentFlute',\n          default: '(12) Flute',\n          description: 'Sound of a flute being played'\n        }),\n        dirName: '12-flute',\n        samples: [60, 72]\n      }, {\n        name: formatMessage({\n          id: 'music.instrumentWoodenFlute',\n          default: '(13) Wooden Flute',\n          description: 'Sound of a wooden flute being played'\n        }),\n        dirName: '13-wooden-flute',\n        samples: [60, 72]\n      }, {\n        name: formatMessage({\n          id: 'music.instrumentBassoon',\n          default: '(14) Bassoon',\n          description: 'Sound of a bassoon being played'\n        }),\n        dirName: '14-bassoon',\n        samples: [36, 48, 60]\n      }, {\n        name: formatMessage({\n          id: 'music.instrumentChoir',\n          default: '(15) Choir',\n          description: 'Sound of a choir singing'\n        }),\n        dirName: '15-choir',\n        releaseTime: 0.25,\n        samples: [48, 60, 72]\n      }, {\n        name: formatMessage({\n          id: 'music.instrumentVibraphone',\n          default: '(16) Vibraphone',\n          description: 'Sound of a vibraphone being struck'\n        }),\n        dirName: '16-vibraphone',\n        releaseTime: 0.5,\n        samples: [60, 72]\n      }, {\n        name: formatMessage({\n          id: 'music.instrumentMusicBox',\n          default: '(17) Music Box',\n          description: 'Sound of a music box playing'\n        }),\n        dirName: '17-music-box',\n        releaseTime: 0.25,\n        samples: [60]\n      }, {\n        name: formatMessage({\n          id: 'music.instrumentSteelDrum',\n          default: '(18) Steel Drum',\n          description: 'Sound of a steel drum being struck'\n        }),\n        dirName: '18-steel-drum',\n        releaseTime: 0.5,\n        samples: [60]\n      }, {\n        name: formatMessage({\n          id: 'music.instrumentMarimba',\n          default: '(19) Marimba',\n          description: 'Sound of a marimba being struck'\n        }),\n        dirName: '19-marimba',\n        samples: [60]\n      }, {\n        name: formatMessage({\n          id: 'music.instrumentSynthLead',\n          default: '(20) Synth Lead',\n          description: 'Sound of a \"lead\" synthesizer being played'\n        }),\n        dirName: '20-synth-lead',\n        releaseTime: 0.1,\n        samples: [60]\n      }, {\n        name: formatMessage({\n          id: 'music.instrumentSynthPad',\n          default: '(21) Synth Pad',\n          description: 'Sound of a \"pad\" synthesizer being played'\n        }),\n        dirName: '21-synth-pad',\n        releaseTime: 0.25,\n        samples: [60]\n      }];\n    }\n    /**\n     * An array that is a mapping from MIDI instrument numbers to Scratch instrument numbers.\n     * @type {number[]}\n     */\n  }, {\n    key: \"MIDI_INSTRUMENTS\",\n    get: function get() {\n      return [// Acoustic Grand, Bright Acoustic, Electric Grand, Honky-Tonk\n      1, 1, 1, 1, // Electric Piano 1, Electric Piano 2, Harpsichord, Clavinet\n      2, 2, 4, 4, // Celesta, Glockenspiel, Music Box, Vibraphone\n      17, 17, 17, 16, // Marimba, Xylophone, Tubular Bells, Dulcimer\n      19, 16, 17, 17, // Drawbar Organ, Percussive Organ, Rock Organ, Church Organ\n      3, 3, 3, 3, // Reed Organ, Accordion, Harmonica, Tango Accordion\n      3, 3, 3, 3, // Nylon String Guitar, Steel String Guitar, Electric Jazz Guitar, Electric Clean Guitar\n      4, 4, 5, 5, // Electric Muted Guitar, Overdriven Guitar,Distortion Guitar, Guitar Harmonics\n      5, 5, 5, 5, // Acoustic Bass, Electric Bass (finger), Electric Bass (pick), Fretless Bass\n      6, 6, 6, 6, // Slap Bass 1, Slap Bass 2, Synth Bass 1, Synth Bass 2\n      6, 6, 6, 6, // Violin, Viola, Cello, Contrabass\n      8, 8, 8, 8, // Tremolo Strings, Pizzicato Strings, Orchestral Strings, Timpani\n      8, 7, 8, 19, // String Ensemble 1, String Ensemble 2, SynthStrings 1, SynthStrings 2\n      8, 8, 8, 8, // Choir Aahs, Voice Oohs, Synth Voice, Orchestra Hit\n      15, 15, 15, 19, // Trumpet, Trombone, Tuba, Muted Trumpet\n      9, 9, 9, 9, // French Horn, Brass Section, SynthBrass 1, SynthBrass 2\n      9, 9, 9, 9, // Soprano Sax, Alto Sax, Tenor Sax, Baritone Sax\n      11, 11, 11, 11, // Oboe, English Horn, Bassoon, Clarinet\n      14, 14, 14, 10, // Piccolo, Flute, Recorder, Pan Flute\n      12, 12, 13, 13, // Blown Bottle, Shakuhachi, Whistle, Ocarina\n      13, 13, 12, 12, // Lead 1 (square), Lead 2 (sawtooth), Lead 3 (calliope), Lead 4 (chiff)\n      20, 20, 20, 20, // Lead 5 (charang), Lead 6 (voice), Lead 7 (fifths), Lead 8 (bass+lead)\n      20, 20, 20, 20, // Pad 1 (new age), Pad 2 (warm), Pad 3 (polysynth), Pad 4 (choir)\n      21, 21, 21, 21, // Pad 5 (bowed), Pad 6 (metallic), Pad 7 (halo), Pad 8 (sweep)\n      21, 21, 21, 21, // FX 1 (rain), FX 2 (soundtrack), FX 3 (crystal), FX 4 (atmosphere)\n      21, 21, 21, 21, // FX 5 (brightness), FX 6 (goblins), FX 7 (echoes), FX 8 (sci-fi)\n      21, 21, 21, 21, // Sitar, Banjo, Shamisen, Koto\n      4, 4, 4, 4, // Kalimba, Bagpipe, Fiddle, Shanai\n      17, 14, 8, 10, // Tinkle Bell, Agogo, Steel Drums, Woodblock\n      17, 17, 18, 19, // Taiko Drum, Melodic Tom, Synth Drum, Reverse Cymbal\n      1, 1, 1, 1, // Guitar Fret Noise, Breath Noise, Seashore, Bird Tweet\n      21, 21, 21, 21, // Telephone Ring, Helicopter, Applause, Gunshot\n      21, 21, 21, 21];\n    }\n    /**\n     * An array that is a mapping from MIDI drum numbers in range (35..81) to Scratch drum numbers.\n     * It's in the format [drumNum, pitch, decay].\n     * The pitch and decay properties are not currently being used.\n     * @type {Array[]}\n     */\n  }, {\n    key: \"MIDI_DRUMS\",\n    get: function get() {\n      return [[1, -4], // \"BassDrum\" in 2.0, \"Bass Drum\" in 3.0 (which was \"Tom\" in 2.0)\n      [1, 0], // Same as just above\n      [2, 0], [0, 0], [7, 0], [0, 2], [1, -6, 4], [5, 0], [1, -3, 3.2], [5, 0], // \"HiHatPedal\" in 2.0, \"Closed Hi-Hat\" in 3.0\n      [1, 0, 3], [4, -8], [1, 4, 3], [1, 7, 2.7], [3, -8], [1, 10, 2.7], [4, -2], [3, -11], [4, 2], [6, 0], [3, 0, 3.5], [10, 0], [3, -8, 3.5], [16, -6], [4, 2], [12, 2], [12, 0], [13, 0, 0.2], [13, 0, 2], [13, -5, 2], [12, 12], [12, 5], [10, 19], [10, 12], [14, 0], [14, 0], // \"Maracas\" in 2.0, \"Cabasa\" in 3.0 (TODO: pitch up?)\n      [17, 12], [17, 5], [15, 0], // \"GuiroShort\" in 2.0, \"Guiro\" in 3.0 (which was \"GuiroLong\" in 2.0) (TODO: decay?)\n      [15, 0], [8, 0], [9, 0], [9, -4], [17, -5], [17, 0], [11, -6, 1], [11, -6, 3]];\n    }\n    /**\n     * The key to load & store a target's music-related state.\n     * @type {string}\n     */\n  }], [{\n    key: \"STATE_KEY\",\n    get: function get() {\n      return 'Scratch.music';\n    }\n    /**\n     * The default music-related state, to be used when a target has no existing music state.\n     * @type {MusicState}\n     */\n  }, {\n    key: \"DEFAULT_MUSIC_STATE\",\n    get: function get() {\n      return {\n        currentInstrument: 0\n      };\n    }\n    /**\n     * The minimum and maximum MIDI note numbers, for clamping the input to play note.\n     * @type {{min: number, max: number}}\n     */\n  }, {\n    key: \"MIDI_NOTE_RANGE\",\n    get: function get() {\n      return {\n        min: 0,\n        max: 130\n      };\n    }\n    /**\n     * The minimum and maximum beat values, for clamping the duration of play note, play drum and rest.\n     * 100 beats at the default tempo of 60bpm is 100 seconds.\n     * @type {{min: number, max: number}}\n     */\n  }, {\n    key: \"BEAT_RANGE\",\n    get: function get() {\n      return {\n        min: 0,\n        max: 100\n      };\n    }\n    /** The minimum and maximum tempo values, in bpm.\n     * @type {{min: number, max: number}}\n     */\n  }, {\n    key: \"TEMPO_RANGE\",\n    get: function get() {\n      return {\n        min: 20,\n        max: 500\n      };\n    }\n    /**\n     * The maximum number of sounds to allow to play simultaneously.\n     * @type {number}\n     */\n  }, {\n    key: \"CONCURRENCY_LIMIT\",\n    get: function get() {\n      return 30;\n    }\n  }]);\n  return Scratch3MusicBlocks;\n}();\nmodule.exports = Scratch3MusicBlocks;\n })