/* 1099 */\n (function(module, exports, __webpack_require__) {\nvar _BoostColorIndex;\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nvar ArgumentType = __webpack_require__(63);\nvar BlockType = __webpack_require__(45);\nvar Cast = __webpack_require__(48);\nvar formatMessage = __webpack_require__(71);\nvar color = __webpack_require__(180);\nvar BLE = __webpack_require__(221);\nvar Base64Util = __webpack_require__(182);\nvar MathUtil = __webpack_require__(62);\nvar RateLimiter = __webpack_require__(298);\nvar log = __webpack_require__(39);\n/**\n * The LEGO Wireless Protocol documentation used to create this extension can be found at:\n * https://lego.github.io/lego-ble-wireless-protocol-docs/index.html\n */\n/**\n * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.\n * @type {string}\n */\n// eslint-disable-next-line max-len\nvar iconURI = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAMAAAC5zwKfAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACpQTFRF////fIel5ufolZ62/2YavsPS+YZOkJmy9/j53+Hk6+zs6N/b6dfO////tDhMHAAAAA50Uk5T/////////////////wBFwNzIAAAA6ElEQVR42uzX2w6DIBAEUGDVtlr//3dLaLwgiwUd2z7MJPJg5EQWiGhGcAxBggQJEiT436CIfqXJPTn3MKNYYMSDFpoAmp24OaYgvwKnFgL2zvVTCwHrMoMi+nUQLFthaNCCa0iwclLkDgYVsQp0mzxuqXgK1MRzoCLWgkPXNN2wI/q6Kvt7u/cX0HtejN8x2sXpnpb8J8D3b0Keuhh3X975M+i0xNVbg3s1TIasgK21bQyGO+s2PykaGMYbge8KrNrssvkOWDXkErB8UuBHETjoYLkKBA8ZfuDkbwVBggQJEiR4MC8BBgDTtMZLx2nFCQAAAABJRU5ErkJggg==';\n/**\n * Boost BLE UUIDs.\n * @enum {string}\n */\nvar BoostBLE = {\n  service: '00001623-1212-efde-1623-785feabcd123',\n  characteristic: '00001624-1212-efde-1623-785feabcd123',\n  sendInterval: 100,\n  sendRateMax: 20\n};\n/**\n * Boost Motor Max Power Add. Defines how much more power than the target speed\n * the motors may supply to reach the target speed faster.\n * Lower number == softer, slower reached target speed.\n * Higher number == harder, faster reached target speed.\n * @constant {number}\n */\nvar BoostMotorMaxPowerAdd = 10;\n/**\n * A time interval to wait (in milliseconds) in between battery check calls.\n * @type {number}\n */\nvar BoostPingInterval = 5000;\n/**\n * The number of continuous samples the color-sensor will evaluate color from.\n * @type {number}\n */\nvar BoostColorSampleSize = 5;\n/**\n * Enum for Boost sensor and actuator types.\n * @readonly\n * @enum {number}\n */\nvar BoostIO = {\n  MOTOR_WEDO: 0x01,\n  MOTOR_SYSTEM: 0x02,\n  BUTTON: 0x05,\n  LIGHT: 0x08,\n  VOLTAGE: 0x14,\n  CURRENT: 0x15,\n  PIEZO: 0x16,\n  LED: 0x17,\n  TILT_EXTERNAL: 0x22,\n  MOTION_SENSOR: 0x23,\n  COLOR: 0x25,\n  MOTOREXT: 0x26,\n  MOTORINT: 0x27,\n  TILT: 0x28\n};\n/**\n * Enum for ids for various output command feedback types on the Boost.\n * @readonly\n * @enum {number}\n */\nvar BoostPortFeedback = {\n  IN_PROGRESS: 0x01,\n  COMPLETED: 0x02,\n  DISCARDED: 0x04,\n  IDLE: 0x08,\n  BUSY_OR_FULL: 0x10\n};\n/**\n * Enum for physical Boost Ports\n * @readonly\n * @enum {number}\n */\nvar BoostPort10000223OrOlder = {\n  A: 55,\n  B: 56,\n  C: 1,\n  D: 2\n};\nvar BoostPort10000224OrNewer = {\n  A: 0,\n  B: 1,\n  C: 2,\n  D: 3\n}; // Set default port mapping to support the newer firmware\nvar BoostPort = BoostPort10000224OrNewer;\n/**\n * Ids for each color sensor value used by the extension.\n * @readonly\n * @enum {string}\n */\nvar BoostColor = {\n  ANY: 'any',\n  NONE: 'none',\n  RED: 'red',\n  BLUE: 'blue',\n  GREEN: 'green',\n  YELLOW: 'yellow',\n  WHITE: 'white',\n  BLACK: 'black'\n};\n/**\n * Enum for indices for each color sensed by the Boost vision sensor.\n * @readonly\n * @enum {number}\n */\nvar BoostColorIndex = (_BoostColorIndex = {}, _defineProperty(_BoostColorIndex, BoostColor.NONE, 255), _defineProperty(_BoostColorIndex, BoostColor.RED, 9), _defineProperty(_BoostColorIndex, BoostColor.BLUE, 3), _defineProperty(_BoostColorIndex, BoostColor.GREEN, 5), _defineProperty(_BoostColorIndex, BoostColor.YELLOW, 7), _defineProperty(_BoostColorIndex, BoostColor.WHITE, 10), _defineProperty(_BoostColorIndex, BoostColor.BLACK, 0), _BoostColorIndex);\n/**\n * Enum for Message Types\n * @readonly\n * @enum {number}\n */\nvar BoostMessage = {\n  HUB_PROPERTIES: 0x01,\n  HUB_ACTIONS: 0x02,\n  HUB_ALERTS: 0x03,\n  HUB_ATTACHED_IO: 0x04,\n  ERROR: 0x05,\n  PORT_INPUT_FORMAT_SETUP_SINGLE: 0x41,\n  PORT_INPUT_FORMAT_SETUP_COMBINED: 0x42,\n  PORT_INFORMATION: 0x43,\n  PORT_MODEINFORMATION: 0x44,\n  PORT_VALUE: 0x45,\n  PORT_VALUE_COMBINED: 0x46,\n  PORT_INPUT_FORMAT: 0x47,\n  PORT_INPUT_FORMAT_COMBINED: 0x48,\n  OUTPUT: 0x81,\n  PORT_FEEDBACK: 0x82\n};\n/**\n * Enum for Hub Property Types\n * @readonly\n * @enum {number}\n */\nvar BoostHubProperty = {\n  ADVERTISEMENT_NAME: 0x01,\n  BUTTON: 0x02,\n  FW_VERSION: 0x03,\n  HW_VERSION: 0x04,\n  RSSI: 0x05,\n  BATTERY_VOLTAGE: 0x06,\n  BATTERY_TYPE: 0x07,\n  MANUFACTURER_NAME: 0x08,\n  RADIO_FW_VERSION: 0x09,\n  LEGO_WP_VERSION: 0x0A,\n  SYSTEM_TYPE_ID: 0x0B,\n  HW_NETWORK_ID: 0x0C,\n  PRIMARY_MAC: 0x0D,\n  SECONDARY_MAC: 0x0E,\n  HW_NETWORK_FAMILY: 0x0F\n};\n/**\n * Enum for Hub Property Operations\n * @readonly\n * @enum {number}\n */\nvar BoostHubPropertyOperation = {\n  SET: 0x01,\n  ENABLE_UPDATES: 0x02,\n  DISABLE_UPDATES: 0x03,\n  RESET: 0x04,\n  REQUEST_UPDATE: 0x05,\n  UPDATE: 0x06\n};\n/**\n * Enum for Motor Subcommands (for 0x81)\n * @readonly\n * @enum {number}\n */\nvar BoostOutputSubCommand = {\n  START_POWER: 0x01,\n  START_POWER_PAIR: 0x02,\n  SET_ACC_TIME: 0x05,\n  SET_DEC_TIME: 0x06,\n  START_SPEED: 0x07,\n  START_SPEED_PAIR: 0x08,\n  START_SPEED_FOR_TIME: 0x09,\n  START_SPEED_FOR_TIME_PAIR: 0x0A,\n  START_SPEED_FOR_DEGREES: 0x0B,\n  START_SPEED_FOR_DEGREES_PAIR: 0x0C,\n  GO_TO_ABS_POSITION: 0x0D,\n  GO_TO_ABS_POSITION_PAIR: 0x0E,\n  PRESET_ENCODER: 0x14,\n  WRITE_DIRECT_MODE_DATA: 0x51\n};\n/**\n * Enum for Startup/Completion information for an output command.\n * Startup and completion bytes must be OR'ed to be combined to a single byte.\n * @readonly\n * @enum {number}\n */\nvar BoostOutputExecution = {\n  // Startup information\n  BUFFER_IF_NECESSARY: 0x00,\n  EXECUTE_IMMEDIATELY: 0x10,\n  // Completion information\n  NO_ACTION: 0x00,\n  COMMAND_FEEDBACK: 0x01\n};\n/**\n * Enum for Boost Motor end states\n * @readonly\n * @enum {number}\n */\nvar BoostMotorEndState = {\n  FLOAT: 0,\n  HOLD: 126,\n  BRAKE: 127\n};\n/**\n * Enum for Boost Motor acceleration/deceleration profiles\n * @readyonly\n * @enum {number}\n */\nvar BoostMotorProfile = {\n  DO_NOT_USE: 0x00,\n  ACCELERATION: 0x01,\n  DECELERATION: 0x02\n};\n/**\n * Enum for when Boost IO's are attached/detached\n * @readonly\n * @enum {number}\n */\nvar BoostIOEvent = {\n  ATTACHED: 0x01,\n  DETACHED: 0x00,\n  ATTACHED_VIRTUAL: 0x02\n};\n/**\n * Enum for selected sensor modes.\n * @enum {number}\n */\nvar BoostMode = {\n  TILT: 0,\n  // angle (pitch/yaw)\n  LED: 1,\n  // Set LED to accept RGB values\n  COLOR: 0,\n  // Read indexed colors from Vision Sensor\n  MOTOR_SENSOR: 2,\n  // Set motors to report their position\n  UNKNOWN: 0 // Anything else will use the default mode (mode 0)\n};\n/**\n * Enum for Boost motor states.\n * @param {number}\n */\nvar BoostMotorState = {\n  OFF: 0,\n  ON_FOREVER: 1,\n  ON_FOR_TIME: 2,\n  ON_FOR_ROTATION: 3\n};\n/**\n * Helper function for converting a JavaScript number to an INT32-number\n * @param {number} number - a number\n * @return {array} - a 4-byte array of Int8-values representing an INT32-number\n */\nvar numberToInt32Array = function numberToInt32Array(number) {\n  var buffer = new ArrayBuffer(4);\n  var dataview = new DataView(buffer);\n  dataview.setInt32(0, number);\n  return [dataview.getInt8(3), dataview.getInt8(2), dataview.getInt8(1), dataview.getInt8(0)];\n};\n/**\n * Helper function for converting a regular array to a Little Endian INT32-value\n * @param {Array} array - an array containing UInt8-values\n * @return {number} - a number\n */\nvar int32ArrayToNumber = function int32ArrayToNumber(array) {\n  var i = Uint8Array.from(array);\n  var d = new DataView(i.buffer);\n  return d.getInt32(0, true);\n};\n/**\n * Manage power, direction, position, and timers for one Boost motor.\n */\nvar BoostMotor = function () {\n  /**\n   * Construct a Boost Motor instance.\n   * @param {Boost} parent - the Boost peripheral which owns this motor.\n   * @param {int} index - the zero-based index of this motor on its parent peripheral.\n   */\n  function BoostMotor(parent, index) {\n    _classCallCheck(this, BoostMotor);\n    /**\n     * The Boost peripheral which owns this motor.\n     * @type {Boost}\n     * @private\n     */\n    this._parent = parent;\n    /**\n     * The zero-based index of this motor on its parent peripheral.\n     * @type {int}\n     * @private\n     */\n    this._index = index;\n    /**\n     * This motor's current direction: 1 for \"this way\" or -1 for \"that way\"\n     * @type {number}\n     * @private\n     */\n    this._direction = 1;\n    /**\n     * This motor's current power level, in the range [0,100].\n     * @type {number}\n     * @private\n     */\n    this._power = 50;\n    /**\n     * This motor's current relative position\n     * @type {number}\n     * @private\n     */\n    this._position = 0;\n    /**\n     * Is this motor currently moving?\n     * @type {boolean}\n     * @private\n     */\n    this._status = BoostMotorState.OFF;\n    /**\n     * If the motor has been turned on or is actively braking for a specific duration, this is the timeout ID for\n     * the end-of-action handler. Cancel this when changing plans.\n     * @type {Object}\n     * @private\n     */\n    this._pendingDurationTimeoutId = null;\n    /**\n     * The starting time for the pending duration timeout.\n     * @type {number}\n     * @private\n     */\n    this._pendingDurationTimeoutStartTime = null;\n    /**\n     * The delay/duration of the pending duration timeout.\n     * @type {number}\n     * @private\n     */\n    this._pendingDurationTimeoutDelay = null;\n    /**\n     * The target position of a turn-based command.\n     * @type {number}\n     * @private\n     */\n    this._pendingRotationDestination = null;\n    /**\n     * If the motor has been turned on run for a specific rotation, this is the function\n     * that will be called once Scratch VM gets a notification from the Move Hub.\n     * @type {Object}\n     * @private\n     */\n    this._pendingRotationPromise = null;\n    this.turnOff = this.turnOff.bind(this);\n  }\n  /**\n   * @return {int} - this motor's current direction: 1 for \"this way\" or -1 for \"that way\"\n   */\n  _createClass(BoostMotor, [{\n    key: \"_turnOn\",\n    /**\n     * Turn this motor on indefinitely\n     * @private\n     */\n    value: function _turnOn() {\n      var cmd = this._parent.generateOutputCommand(this._index, BoostOutputExecution.EXECUTE_IMMEDIATELY, BoostOutputSubCommand.START_SPEED, [this.power * this.direction, MathUtil.clamp(this.power + BoostMotorMaxPowerAdd, 0, 100), BoostMotorProfile.DO_NOT_USE]);\n      this._parent.send(BoostBLE.characteristic, cmd);\n    }\n    /**\n     * Turn this motor on indefinitely\n     */\n  }, {\n    key: \"turnOnForever\",\n    value: function turnOnForever() {\n      this.status = BoostMotorState.ON_FOREVER;\n      this._turnOn();\n    }\n    /**\n     * Turn this motor on for a specific duration.\n     * @param {number} milliseconds - run the motor for this long.\n     */\n  }, {\n    key: \"turnOnFor\",\n    value: function turnOnFor(milliseconds) {\n      milliseconds = Math.max(0, milliseconds);\n      this.status = BoostMotorState.ON_FOR_TIME;\n      this._turnOn();\n      this._setNewDurationTimeout(this.turnOff, milliseconds);\n    }\n    /**\n     * Turn this motor on for a specific rotation in degrees.\n     * @param {number} degrees - run the motor for this amount of degrees.\n     * @param {number} direction - rotate in this direction\n     */\n  }, {\n    key: \"turnOnForDegrees\",\n    value: function turnOnForDegrees(degrees, direction) {\n      degrees = Math.max(0, degrees);\n      var cmd = this._parent.generateOutputCommand(this._index, BoostOutputExecution.EXECUTE_IMMEDIATELY ^ BoostOutputExecution.COMMAND_FEEDBACK, BoostOutputSubCommand.START_SPEED_FOR_DEGREES, [].concat(_toConsumableArray(numberToInt32Array(degrees)), [this.power * this.direction * direction, MathUtil.clamp(this.power + BoostMotorMaxPowerAdd, 0, 100), BoostMotorEndState.BRAKE, BoostMotorProfile.DO_NOT_USE]));\n      this.status = BoostMotorState.ON_FOR_ROTATION;\n      this._pendingRotationDestination = this.position + degrees * this.direction * direction;\n      this._parent.send(BoostBLE.characteristic, cmd);\n    }\n    /**\n     * Turn this motor off.\n     * @param {boolean} [useLimiter=true] - if true, use the rate limiter\n     */\n  }, {\n    key: \"turnOff\",\n    value: function turnOff() {\n      var useLimiter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var cmd = this._parent.generateOutputCommand(this._index, BoostOutputExecution.EXECUTE_IMMEDIATELY, BoostOutputSubCommand.START_POWER, [BoostMotorEndState.FLOAT]);\n      this.status = BoostMotorState.OFF;\n      this._parent.send(BoostBLE.characteristic, cmd, useLimiter);\n    }\n    /**\n     * Clear the motor action timeout, if any. Safe to call even when there is no pending timeout.\n     * @private\n     */\n  }, {\n    key: \"_clearDurationTimeout\",\n    value: function _clearDurationTimeout() {\n      if (this._pendingDurationTimeoutId !== null) {\n        clearTimeout(this._pendingDurationTimeoutId);\n        this._pendingDurationTimeoutId = null;\n        this._pendingDurationTimeoutStartTime = null;\n        this._pendingDurationTimeoutDelay = null;\n      }\n    }\n    /**\n     * Set a new motor action timeout, after clearing an existing one if necessary.\n     * @param {Function} callback - to be called at the end of the timeout.\n     * @param {int} delay - wait this many milliseconds before calling the callback.\n     * @private\n     */\n  }, {\n    key: \"_setNewDurationTimeout\",\n    value: function _setNewDurationTimeout(callback, delay) {\n      var _this = this;\n      this._clearDurationTimeout();\n      var timeoutID = setTimeout(function () {\n        if (_this._pendingDurationTimeoutId === timeoutID) {\n          _this._pendingDurationTimeoutId = null;\n          _this._pendingDurationTimeoutStartTime = null;\n          _this._pendingDurationTimeoutDelay = null;\n        }\n        callback();\n      }, delay);\n      this._pendingDurationTimeoutId = timeoutID;\n      this._pendingDurationTimeoutStartTime = Date.now();\n      this._pendingDurationTimeoutDelay = delay;\n    }\n    /**\n     * Clear the motor states related to rotation-based commands, if any.\n     * Safe to call even when there is no pending promise function.\n     * @private\n     */\n  }, {\n    key: \"_clearRotationState\",\n    value: function _clearRotationState() {\n      if (this._pendingRotationPromise !== null) {\n        this._pendingRotationPromise();\n        this._pendingRotationPromise = null;\n      }\n      this._pendingRotationDestination = null;\n    }\n  }, {\n    key: \"direction\",\n    get: function get() {\n      return this._direction;\n    }\n    /**\n     * @param {int} value - this motor's new direction: 1 for \"this way\" or -1 for \"that way\"\n     */\n    ,\n    set: function set(value) {\n      if (value < 0) {\n        this._direction = -1;\n      } else {\n        this._direction = 1;\n      }\n    }\n    /**\n     * @return {int} - this motor's current power level, in the range [0,100].\n     */\n  }, {\n    key: \"power\",\n    get: function get() {\n      return this._power;\n    }\n    /**\n     * @param {int} value - this motor's new power level, in the range [10,100].\n     */\n    ,\n    set: function set(value) {\n      /**\n       * Scale the motor power to a range between 10 and 100,\n       * to make sure the motors will run with something built onto them.\n       */\n      if (value === 0) {\n        this._power = 0;\n      } else {\n        this._power = MathUtil.scale(value, 1, 100, 10, 100);\n      }\n    }\n    /**\n     * @return {int} - this motor's current position, in the range of [-MIN_INT32,MAX_INT32]\n     */\n  }, {\n    key: \"position\",\n    get: function get() {\n      return this._position;\n    }\n    /**\n     * @param {int} value - set this motor's current position.\n     */\n    ,\n    set: function set(value) {\n      this._position = value;\n    }\n    /**\n     * @return {BoostMotorState} - the motor's current state.\n     */\n  }, {\n    key: \"status\",\n    get: function get() {\n      return this._status;\n    }\n    /**\n     * @param {BoostMotorState} value - set this motor's state.\n     */\n    ,\n    set: function set(value) {\n      this._clearRotationState();\n      this._clearDurationTimeout();\n      this._status = value;\n    }\n    /**\n     * @return {number} - time, in milliseconds, of when the pending duration timeout began.\n     */\n  }, {\n    key: \"pendingDurationTimeoutStartTime\",\n    get: function get() {\n      return this._pendingDurationTimeoutStartTime;\n    }\n    /**\n     * @return {number} - delay, in milliseconds, of the pending duration timeout.\n     */\n  }, {\n    key: \"pendingDurationTimeoutDelay\",\n    get: function get() {\n      return this._pendingDurationTimeoutDelay;\n    }\n    /**\n     * @return {number} - target position, in degrees, of the pending rotation.\n     */\n  }, {\n    key: \"pendingRotationDestination\",\n    get: function get() {\n      return this._pendingRotationDestination;\n    }\n    /**\n     * @return {Promise} - the Promise function for the pending rotation.\n     */\n  }, {\n    key: \"pendingRotationPromise\",\n    get: function get() {\n      return this._pendingRotationPromise;\n    }\n    /**\n     * @param {function} func - function to resolve pending rotation Promise\n     */\n    ,\n    set: function set(func) {\n      this._pendingRotationPromise = func;\n    }\n  }]);\n  return BoostMotor;\n}();\n/**\n * Manage communication with a Boost peripheral over a Bluetooth Low Energy client socket.\n */\nvar Boost = function () {\n  function Boost(runtime, extensionId) {\n    _classCallCheck(this, Boost);\n    /**\n     * The Scratch 3.0 runtime used to trigger the green flag button.\n     * @type {Runtime}\n     * @private\n     */\n    this._runtime = runtime;\n    this._runtime.on('PROJECT_STOP_ALL', this.stopAll.bind(this));\n    /**\n     * The id of the extension this peripheral belongs to.\n     */\n    this._extensionId = extensionId;\n    /**\n     * A list of the ids of the physical or virtual sensors.\n     * @type {string[]}\n     * @private\n     */\n    this._ports = [];\n    /**\n     * A list of motors registered by the Boost hardware.\n     * @type {BoostMotor[]}\n     * @private\n     */\n    this._motors = [];\n    /**\n     * The most recently received value for each sensor.\n     * @type {Object.<string, number>}\n     * @private\n     */\n    this._sensors = {\n      tiltX: 0,\n      tiltY: 0,\n      color: BoostColor.NONE,\n      previousColor: BoostColor.NONE\n    };\n    /**\n     * An array of values from the Boost Vision Sensor.\n     * @type {Array}\n     * @private\n     */\n    this._colorSamples = [];\n    /**\n     * The Bluetooth connection socket for reading/writing peripheral data.\n     * @type {BLE}\n     * @private\n     */\n    this._ble = null;\n    this._runtime.registerPeripheralExtension(extensionId, this);\n    /**\n     * A rate limiter utility, to help limit the rate at which we send BLE messages\n     * over the socket to Scratch Link to a maximum number of sends per second.\n     * @type {RateLimiter}\n     * @private\n     */\n    this._rateLimiter = new RateLimiter(BoostBLE.sendRateMax);\n    /**\n     * An interval id for the battery check interval.\n     * @type {number}\n     * @private\n     */\n    this._pingDeviceId = null;\n    this.reset = this.reset.bind(this);\n    this._onConnect = this._onConnect.bind(this);\n    this._onMessage = this._onMessage.bind(this);\n    this._pingDevice = this._pingDevice.bind(this);\n  }\n  /**\n   * @return {number} - the latest value received for the tilt sensor's tilt about the X axis.\n   */\n  _createClass(Boost, [{\n    key: \"boostColorForIndex\",\n    /**\n     * Look up the color id for an index received from the vision sensor.\n     * @param {number} index - the color index to look up.\n     * @return {BoostColor} the color id for this index.\n     */\n    value: function boostColorForIndex(index) {\n      var colorForIndex = Object.keys(BoostColorIndex).find(function (key) {\n        return BoostColorIndex[key] === index;\n      });\n      return colorForIndex || BoostColor.NONE;\n    }\n    /**\n     * Access a particular motor on this peripheral.\n     * @param {int} index - the index of the desired motor.\n     * @return {BoostMotor} - the BoostMotor instance, if any, at that index.\n     */\n  }, {\n    key: \"motor\",\n    value: function motor(index) {\n      return this._motors[index];\n    }\n    /**\n     * Stop all the motors that are currently running.\n     */\n  }, {\n    key: \"stopAllMotors\",\n    value: function stopAllMotors() {\n      this._motors.forEach(function (motor) {\n        if (motor) {\n          // Send the motor off command without using the rate limiter.\n          // This allows the stop button to stop motors even if we are\n          // otherwise flooded with commands.\n          motor.turnOff(false);\n        }\n      });\n    }\n    /**\n     * Set the Boost peripheral's LED to a specific color.\n     * @param {int} inputRGB - a 24-bit RGB color in 0xRRGGBB format.\n     * @return {Promise} - a promise of the completion of the set led send operation.\n     */\n  }, {\n    key: \"setLED\",\n    value: function setLED(inputRGB) {\n      var rgb = [inputRGB >> 16 & 0x000000FF, inputRGB >> 8 & 0x000000FF, inputRGB & 0x000000FF];\n      var cmd = this.generateOutputCommand(this._ports.indexOf(BoostIO.LED), BoostOutputExecution.EXECUTE_IMMEDIATELY ^ BoostOutputExecution.COMMAND_FEEDBACK, BoostOutputSubCommand.WRITE_DIRECT_MODE_DATA, [BoostMode.LED].concat(rgb));\n      return this.send(BoostBLE.characteristic, cmd);\n    }\n    /**\n     * Sets the input mode of the LED to RGB.\n     * @return {Promise} - a promise returned by the send operation.\n     */\n  }, {\n    key: \"setLEDMode\",\n    value: function setLEDMode() {\n      var cmd = this.generateInputCommand(this._ports.indexOf(BoostIO.LED), BoostMode.LED, 0, false);\n      return this.send(BoostBLE.characteristic, cmd);\n    }\n    /**\n     * Stop the motors on the Boost peripheral.\n     */\n  }, {\n    key: \"stopAll\",\n    value: function stopAll() {\n      if (!this.isConnected()) return;\n      this.stopAllMotors();\n    }\n    /**\n     * Called by the runtime when user wants to scan for a Boost peripheral.\n     */\n  }, {\n    key: \"scan\",\n    value: function scan() {\n      if (this._ble) {\n        this._ble.disconnect();\n      }\n      this._ble = new BLE(this._runtime, this._extensionId, {\n        filters: [{\n          services: [BoostBLE.service],\n          manufacturerData: {\n            0x0397: {\n              dataPrefix: [0x00, 0x40],\n              mask: [0x00, 0xFF]\n            }\n          }\n        }],\n        optionalServices: []\n      }, this._onConnect, this.reset);\n    }\n    /**\n     * Called by the runtime when user wants to connect to a certain Boost peripheral.\n     * @param {number} id - the id of the peripheral to connect to.\n     */\n  }, {\n    key: \"connect\",\n    value: function connect(id) {\n      if (this._ble) {\n        this._ble.connectPeripheral(id);\n      }\n    }\n    /**\n     * Disconnects from the current BLE socket and resets state.\n     */\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      if (this._ble) {\n        this._ble.disconnect();\n      }\n      this.reset();\n    }\n    /**\n     * Reset all the state and timeout/interval ids.\n     */\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this._ports = [];\n      this._motors = [];\n      this._sensors = {\n        tiltX: 0,\n        tiltY: 0,\n        color: BoostColor.NONE,\n        previousColor: BoostColor.NONE\n      };\n      if (this._pingDeviceId) {\n        window.clearInterval(this._pingDeviceId);\n        this._pingDeviceId = null;\n      }\n    }\n    /**\n     * Called by the runtime to detect whether the Boost peripheral is connected.\n     * @return {boolean} - the connected state.\n     */\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      var connected = false;\n      if (this._ble) {\n        connected = this._ble.isConnected();\n      }\n      return connected;\n    }\n    /**\n     * Write a message to the Boost peripheral BLE socket.\n     * @param {number} uuid - the UUID of the characteristic to write to\n     * @param {Array} message - the message to write.\n     * @param {boolean} [useLimiter=true] - if true, use the rate limiter\n     * @return {Promise} - a promise result of the write operation\n     */\n  }, {\n    key: \"send\",\n    value: function send(uuid, message) {\n      var useLimiter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      if (!this.isConnected()) return Promise.resolve();\n      if (useLimiter) {\n        if (!this._rateLimiter.okayToSend()) return Promise.resolve();\n      }\n      return this._ble.write(BoostBLE.service, uuid, Base64Util.uint8ArrayToBase64(message), 'base64');\n    }\n    /**\n     * Generate a Boost 'Output Command' in the byte array format\n     * (COMMON HEADER, PORT ID, EXECUTION BYTE, SUBCOMMAND ID, PAYLOAD).\n     *\n     * Payload is accepted as an array since these vary across different subcommands.\n     *\n     * @param  {number} portID - the port (Connect ID) to send a command to.\n     * @param  {number} execution - Byte containing startup/completion information\n     * @param  {number} subCommand - the id of the subcommand byte.\n     * @param  {array}  payload    - the list of bytes to send as subcommand payload\n     * @return {array}            - a generated output command.\n     */\n  }, {\n    key: \"generateOutputCommand\",\n    value: function generateOutputCommand(portID, execution, subCommand, payload) {\n      var hubID = 0x00;\n      var command = [hubID, BoostMessage.OUTPUT, portID, execution, subCommand].concat(_toConsumableArray(payload));\n      command.unshift(command.length + 1); // Prepend payload with length byte;\n      return command;\n    }\n    /**\n     * Generate a Boost 'Input Command' in the byte array format\n     * (COMMAND ID, COMMAND TYPE, CONNECT ID, TYPE ID, MODE, DELTA INTERVAL (4 BYTES),\n     * UNIT, NOTIFICATIONS ENABLED).\n     *\n     * This sends a command to the Boost that sets that input format\n     * of the specified inputs and sets value change notifications.\n     *\n     * @param  {number}  portID           - the port (Connect ID) to send a command to.\n     * @param  {number}  mode                - the mode of the input sensor.\n     * @param  {number}  delta               - the delta change needed to trigger notification.\n     * @param  {boolean} enableNotifications - whether to enable notifications.\n     * @return {array}                       - a generated input command.\n     */\n  }, {\n    key: \"generateInputCommand\",\n    value: function generateInputCommand(portID, mode, delta, enableNotifications) {\n      var command = [0x00, // Hub ID\n      BoostMessage.PORT_INPUT_FORMAT_SETUP_SINGLE, portID, mode].concat(numberToInt32Array(delta)).concat([enableNotifications]);\n      command.unshift(command.length + 1); // Prepend payload with length byte;\n      return command;\n    }\n    /**\n     * Starts reading data from peripheral after BLE has connected.\n     * @private\n     */\n  }, {\n    key: \"_onConnect\",\n    value: function _onConnect() {\n      var _this2 = this;\n      this._ble.startNotifications(BoostBLE.service, BoostBLE.characteristic, this._onMessage);\n      this._pingDeviceId = window.setInterval(this._pingDevice, BoostPingInterval); // Send a request for firmware version.\n      setTimeout(function () {\n        var command = [0x00, // Hub ID\n        BoostMessage.HUB_PROPERTIES, BoostHubProperty.FW_VERSION, BoostHubPropertyOperation.REQUEST_UPDATE];\n        command.unshift(command.length + 1);\n        _this2.send(BoostBLE.characteristic, command, false);\n      }, 500);\n    }\n    /**\n     * Process the sensor data from the incoming BLE characteristic.\n     * @param {object} base64 - the incoming BLE data.\n     * @private\n     */\n  }, {\n    key: \"_onMessage\",\n    value: function _onMessage(base64) {\n      var data = Base64Util.base64ToUint8Array(base64);\n      /**\n       * First three bytes are the common header:\n       * 0: Length of message\n       * 1: Hub ID (always 0x00 at the moment, unused)\n       * 2: Message Type\n       * 3: Port ID\n       * We base our switch-case on Message Type\n       */\n      var messageType = data[2];\n      var portID = data[3];\n      switch (messageType) {\n        case BoostMessage.HUB_PROPERTIES:\n          {\n            var property = data[3];\n            switch (property) {\n              case BoostHubProperty.FW_VERSION:\n                {\n                  // Establish firmware version 1.0.00.0224 as a 32-bit signed integer (little endian)\n                  var fwVersion10000224 = int32ArrayToNumber([0x24, 0x02, 0x00, 0x10]);\n                  var fwHub = int32ArrayToNumber(data.slice(5, data.length));\n                  if (fwHub < fwVersion10000224) {\n                    BoostPort = BoostPort10000223OrOlder;\n                    log.info('Move Hub firmware older than version 1.0.00.0224 detected. Using old port mapping.');\n                  } else {\n                    BoostPort = BoostPort10000224OrNewer;\n                  }\n                  break;\n                }\n            }\n            break;\n          }\n        case BoostMessage.HUB_ATTACHED_IO:\n          {\n            // IO Attach/Detach events\n            var event = data[4];\n            var typeId = data[5];\n            switch (event) {\n              case BoostIOEvent.ATTACHED:\n                this._registerSensorOrMotor(portID, typeId);\n                break;\n              case BoostIOEvent.DETACHED:\n                this._clearPort(portID);\n                break;\n              case BoostIOEvent.ATTACHED_VIRTUAL:\n              default:\n            }\n            break;\n          }\n        case BoostMessage.PORT_VALUE:\n          {\n            var type = this._ports[portID];\n            switch (type) {\n              case BoostIO.TILT:\n                this._sensors.tiltX = data[4];\n                this._sensors.tiltY = data[5];\n                break;\n              case BoostIO.COLOR:\n                this._colorSamples.unshift(data[4]);\n                if (this._colorSamples.length > BoostColorSampleSize) {\n                  this._colorSamples.pop();\n                  if (this._colorSamples.every(function (v, i, arr) {\n                    return v === arr[0];\n                  })) {\n                    this._sensors.previousColor = this._sensors.color;\n                    this._sensors.color = this.boostColorForIndex(this._colorSamples[0]);\n                  } else {\n                    this._sensors.color = BoostColor.NONE;\n                  }\n                } else {\n                  this._sensors.color = BoostColor.NONE;\n                }\n                break;\n              case BoostIO.MOTOREXT:\n              case BoostIO.MOTORINT:\n                this.motor(portID).position = int32ArrayToNumber(data.slice(4, 8));\n                break;\n              case BoostIO.CURRENT:\n              case BoostIO.VOLTAGE:\n              case BoostIO.LED:\n                break;\n              default:\n                log.warn(\"Unknown sensor value! Type: \".concat(type));\n            }\n            break;\n          }\n        case BoostMessage.PORT_FEEDBACK:\n          {\n            var feedback = data[4];\n            var motor = this.motor(portID);\n            if (motor) {\n              // Makes sure that commands resolve both when they actually complete and when they fail\n              var isBusy = feedback & BoostPortFeedback.IN_PROGRESS;\n              var commandCompleted = feedback & (BoostPortFeedback.COMPLETED ^ BoostPortFeedback.DISCARDED);\n              if (!isBusy && commandCompleted) {\n                if (motor.status === BoostMotorState.ON_FOR_ROTATION) {\n                  motor.status = BoostMotorState.OFF;\n                }\n              }\n            }\n            break;\n          }\n        case BoostMessage.ERROR:\n          log.warn(\"Error reported by hub: \".concat(data));\n          break;\n      }\n    }\n    /**\n     * Ping the Boost hub. If the Boost hub has disconnected\n     * for some reason, the BLE socket will get an error back and automatically\n     * close the socket.\n     * @private\n     */\n  }, {\n    key: \"_pingDevice\",\n    value: function _pingDevice() {\n      this._ble.read(BoostBLE.service, BoostBLE.characteristic, false);\n    }\n    /**\n     * Register a new sensor or motor connected at a port.  Store the type of\n     * sensor or motor internally, and then register for notifications on input\n     * values if it is a sensor.\n     * @param {number} portID - the port to register a sensor or motor on.\n     * @param {number} type - the type ID of the sensor or motor\n     * @private\n     */\n  }, {\n    key: \"_registerSensorOrMotor\",\n    value: function _registerSensorOrMotor(portID, type) {\n      // Record which port is connected to what type of device\n      this._ports[portID] = type; // Record motor port\n      if (type === BoostIO.MOTORINT || type === BoostIO.MOTOREXT) {\n        this._motors[portID] = new BoostMotor(this, portID);\n      } // Set input format for tilt or distance sensor\n      var mode = null;\n      var delta = 1;\n      switch (type) {\n        case BoostIO.MOTORINT:\n        case BoostIO.MOTOREXT:\n          mode = BoostMode.MOTOR_SENSOR;\n          break;\n        case BoostIO.COLOR:\n          mode = BoostMode.COLOR;\n          delta = 0;\n          break;\n        case BoostIO.LED:\n          mode = BoostMode.LED;\n          /**\n           * Sets the LED to blue to give an indication on the hub\n           * that it has connected successfully.\n           */\n          this.setLEDMode();\n          this.setLED(0x0000FF);\n          break;\n        case BoostIO.TILT:\n          mode = BoostMode.TILT;\n          break;\n        default:\n          mode = BoostMode.UNKNOWN;\n      }\n      var cmd = this.generateInputCommand(portID, mode, delta, true // Receive feedback\n      );\n      this.send(BoostBLE.characteristic, cmd);\n    }\n    /**\n     * Clear the sensors or motors present on the ports.\n     * @param {number} portID - the port to clear.\n     * @private\n     */\n  }, {\n    key: \"_clearPort\",\n    value: function _clearPort(portID) {\n      var type = this._ports[portID];\n      if (type === BoostIO.TILT) {\n        this._sensors.tiltX = this._sensors.tiltY = 0;\n      }\n      if (type === BoostIO.COLOR) {\n        this._sensors.color = BoostColor.NONE;\n      }\n      this._ports[portID] = 'none';\n      this._motors[portID] = null;\n    }\n  }, {\n    key: \"tiltX\",\n    get: function get() {\n      return this._sensors.tiltX;\n    }\n    /**\n     * @return {number} - the latest value received for the tilt sensor's tilt about the Y axis.\n     */\n  }, {\n    key: \"tiltY\",\n    get: function get() {\n      return this._sensors.tiltY;\n    }\n    /**\n     * @return {number} - the latest color value received from the vision sensor.\n     */\n  }, {\n    key: \"color\",\n    get: function get() {\n      return this._sensors.color;\n    }\n    /**\n     * @return {number} - the previous color value received from the vision sensor.\n     */\n  }, {\n    key: \"previousColor\",\n    get: function get() {\n      return this._sensors.previousColor;\n    }\n  }]);\n  return Boost;\n}();\n/**\n * Enum for motor specification.\n * @readonly\n * @enum {string}\n */\nvar BoostMotorLabel = {\n  A: 'A',\n  B: 'B',\n  C: 'C',\n  D: 'D',\n  AB: 'AB',\n  ALL: 'ABCD'\n};\n/**\n * Enum for motor direction specification.\n * @readonly\n * @enum {string}\n */\nvar BoostMotorDirection = {\n  FORWARD: 'this way',\n  BACKWARD: 'that way',\n  REVERSE: 'reverse'\n};\n/**\n * Enum for tilt sensor direction.\n * @readonly\n * @enum {string}\n */\nvar BoostTiltDirection = {\n  UP: 'up',\n  DOWN: 'down',\n  LEFT: 'left',\n  RIGHT: 'right',\n  ANY: 'any'\n};\n/**\n * Scratch 3.0 blocks to interact with a LEGO Boost peripheral.\n */\nvar Scratch3BoostBlocks = function () {\n  _createClass(Scratch3BoostBlocks, null, [{\n    key: \"EXTENSION_ID\",\n    /**\n     * @return {string} - the ID of this extension.\n     */\n    get: function get() {\n      return 'boost';\n    }\n    /**\n     * @return {number} - the tilt sensor counts as \"tilted\" if its tilt angle meets or exceeds this threshold.\n     */\n  }, {\n    key: \"TILT_THRESHOLD\",\n    get: function get() {\n      return 15;\n    }\n    /**\n     * Construct a set of Boost blocks.\n     * @param {Runtime} runtime - the Scratch 3.0 runtime.\n     */\n  }]);\n  function Scratch3BoostBlocks(runtime) {\n    _classCallCheck(this, Scratch3BoostBlocks);\n    /**\n     * The Scratch 3.0 runtime.\n     * @type {Runtime}\n     */\n    this.runtime = runtime; // Create a new Boost peripheral instance\n    this._peripheral = new Boost(this.runtime, Scratch3BoostBlocks.EXTENSION_ID);\n  }\n  /**\n   * @returns {object} metadata for this extension and its blocks.\n   */\n  _createClass(Scratch3BoostBlocks, [{\n    key: \"getInfo\",\n    value: function getInfo() {\n      return {\n        id: Scratch3BoostBlocks.EXTENSION_ID,\n        name: 'BOOST',\n        blockIconURI: iconURI,\n        showStatusButton: true,\n        blocks: [{\n          opcode: 'motorOnFor',\n          text: formatMessage({\n            id: 'boost.motorOnFor',\n            default: 'turn motor [MOTOR_ID] for [DURATION] seconds',\n            description: 'turn a motor on for some time'\n          }),\n          blockType: BlockType.COMMAND,\n          arguments: {\n            MOTOR_ID: {\n              type: ArgumentType.STRING,\n              menu: 'MOTOR_ID',\n              defaultValue: BoostMotorLabel.A\n            },\n            DURATION: {\n              type: ArgumentType.NUMBER,\n              defaultValue: 1\n            }\n          }\n        }, {\n          opcode: 'motorOnForRotation',\n          text: formatMessage({\n            id: 'boost.motorOnForRotation',\n            default: 'turn motor [MOTOR_ID] for [ROTATION] rotations',\n            description: 'turn a motor on for rotation'\n          }),\n          blockType: BlockType.COMMAND,\n          arguments: {\n            MOTOR_ID: {\n              type: ArgumentType.STRING,\n              menu: 'MOTOR_ID',\n              defaultValue: BoostMotorLabel.A\n            },\n            ROTATION: {\n              type: ArgumentType.NUMBER,\n              defaultValue: 1\n            }\n          }\n        }, {\n          opcode: 'motorOn',\n          text: formatMessage({\n            id: 'boost.motorOn',\n            default: 'turn motor [MOTOR_ID] on',\n            description: 'turn a motor on indefinitely'\n          }),\n          blockType: BlockType.COMMAND,\n          arguments: {\n            MOTOR_ID: {\n              type: ArgumentType.STRING,\n              menu: 'MOTOR_ID',\n              defaultValue: BoostMotorLabel.A\n            }\n          }\n        }, {\n          opcode: 'motorOff',\n          text: formatMessage({\n            id: 'boost.motorOff',\n            default: 'turn motor [MOTOR_ID] off',\n            description: 'turn a motor off'\n          }),\n          blockType: BlockType.COMMAND,\n          arguments: {\n            MOTOR_ID: {\n              type: ArgumentType.STRING,\n              menu: 'MOTOR_ID',\n              defaultValue: BoostMotorLabel.A\n            }\n          }\n        }, {\n          opcode: 'setMotorPower',\n          text: formatMessage({\n            id: 'boost.setMotorPower',\n            default: 'set motor [MOTOR_ID] speed to [POWER] %',\n            description: 'set the motor\\'s speed without turning it on'\n          }),\n          blockType: BlockType.COMMAND,\n          arguments: {\n            MOTOR_ID: {\n              type: ArgumentType.STRING,\n              menu: 'MOTOR_ID',\n              defaultValue: BoostMotorLabel.ALL\n            },\n            POWER: {\n              type: ArgumentType.NUMBER,\n              defaultValue: 100\n            }\n          }\n        }, {\n          opcode: 'setMotorDirection',\n          text: formatMessage({\n            id: 'boost.setMotorDirection',\n            default: 'set motor [MOTOR_ID] direction [MOTOR_DIRECTION]',\n            description: 'set the motor\\'s turn direction without turning it on'\n          }),\n          blockType: BlockType.COMMAND,\n          arguments: {\n            MOTOR_ID: {\n              type: ArgumentType.STRING,\n              menu: 'MOTOR_ID',\n              defaultValue: BoostMotorLabel.A\n            },\n            MOTOR_DIRECTION: {\n              type: ArgumentType.STRING,\n              menu: 'MOTOR_DIRECTION',\n              defaultValue: BoostMotorDirection.FORWARD\n            }\n          }\n        }, {\n          opcode: 'getMotorPosition',\n          text: formatMessage({\n            id: 'boost.getMotorPosition',\n            default: 'motor [MOTOR_REPORTER_ID] position',\n            description: 'the position returned by the motor'\n          }),\n          blockType: BlockType.REPORTER,\n          arguments: {\n            MOTOR_REPORTER_ID: {\n              type: ArgumentType.STRING,\n              menu: 'MOTOR_REPORTER_ID',\n              defaultValue: BoostMotorLabel.A\n            }\n          }\n        }, {\n          opcode: 'whenColor',\n          text: formatMessage({\n            id: 'boost.whenColor',\n            default: 'when [COLOR] brick seen',\n            description: 'check for when color'\n          }),\n          blockType: BlockType.HAT,\n          arguments: {\n            COLOR: {\n              type: ArgumentType.STRING,\n              menu: 'COLOR',\n              defaultValue: BoostColor.ANY\n            }\n          }\n        }, {\n          opcode: 'seeingColor',\n          text: formatMessage({\n            id: 'boost.seeingColor',\n            default: 'seeing [COLOR] brick?',\n            description: 'is the color sensor seeing a certain color?'\n          }),\n          blockType: BlockType.BOOLEAN,\n          arguments: {\n            COLOR: {\n              type: ArgumentType.STRING,\n              menu: 'COLOR',\n              defaultValue: BoostColor.ANY\n            }\n          }\n        }, {\n          opcode: 'whenTilted',\n          text: formatMessage({\n            id: 'boost.whenTilted',\n            default: 'when tilted [TILT_DIRECTION_ANY]',\n            description: 'check when tilted in a certain direction'\n          }),\n          func: 'isTilted',\n          blockType: BlockType.HAT,\n          arguments: {\n            TILT_DIRECTION_ANY: {\n              type: ArgumentType.STRING,\n              menu: 'TILT_DIRECTION_ANY',\n              defaultValue: BoostTiltDirection.ANY\n            }\n          }\n        }, {\n          opcode: 'getTiltAngle',\n          text: formatMessage({\n            id: 'boost.getTiltAngle',\n            default: 'tilt angle [TILT_DIRECTION]',\n            description: 'the angle returned by the tilt sensor'\n          }),\n          blockType: BlockType.REPORTER,\n          arguments: {\n            TILT_DIRECTION: {\n              type: ArgumentType.STRING,\n              menu: 'TILT_DIRECTION',\n              defaultValue: BoostTiltDirection.UP\n            }\n          }\n        }, {\n          opcode: 'setLightHue',\n          text: formatMessage({\n            id: 'boost.setLightHue',\n            default: 'set light color to [HUE]',\n            description: 'set the LED color'\n          }),\n          blockType: BlockType.COMMAND,\n          arguments: {\n            HUE: {\n              type: ArgumentType.NUMBER,\n              defaultValue: 50\n            }\n          }\n        }],\n        menus: {\n          MOTOR_ID: {\n            acceptReporters: true,\n            items: [{\n              text: 'A',\n              value: BoostMotorLabel.A\n            }, {\n              text: 'B',\n              value: BoostMotorLabel.B\n            }, {\n              text: 'C',\n              value: BoostMotorLabel.C\n            }, {\n              text: 'D',\n              value: BoostMotorLabel.D\n            }, {\n              text: 'AB',\n              value: BoostMotorLabel.AB\n            }, {\n              text: 'ABCD',\n              value: BoostMotorLabel.ALL\n            }]\n          },\n          MOTOR_REPORTER_ID: {\n            acceptReporters: true,\n            items: [{\n              text: 'A',\n              value: BoostMotorLabel.A\n            }, {\n              text: 'B',\n              value: BoostMotorLabel.B\n            }, {\n              text: 'C',\n              value: BoostMotorLabel.C\n            }, {\n              text: 'D',\n              value: BoostMotorLabel.D\n            }]\n          },\n          MOTOR_DIRECTION: {\n            acceptReporters: true,\n            items: [{\n              text: formatMessage({\n                id: 'boost.motorDirection.forward',\n                default: 'this way',\n                description: 'label for forward element in motor direction menu for LEGO Boost extension'\n              }),\n              value: BoostMotorDirection.FORWARD\n            }, {\n              text: formatMessage({\n                id: 'boost.motorDirection.backward',\n                default: 'that way',\n                description: 'label for backward element in motor direction menu for LEGO Boost extension'\n              }),\n              value: BoostMotorDirection.BACKWARD\n            }, {\n              text: formatMessage({\n                id: 'boost.motorDirection.reverse',\n                default: 'reverse',\n                description: 'label for reverse element in motor direction menu for LEGO Boost extension'\n              }),\n              value: BoostMotorDirection.REVERSE\n            }]\n          },\n          TILT_DIRECTION: {\n            acceptReporters: true,\n            items: [{\n              text: formatMessage({\n                id: 'boost.tiltDirection.up',\n                default: 'up',\n                description: 'label for up element in tilt direction menu for LEGO Boost extension'\n              }),\n              value: BoostTiltDirection.UP\n            }, {\n              text: formatMessage({\n                id: 'boost.tiltDirection.down',\n                default: 'down',\n                description: 'label for down element in tilt direction menu for LEGO Boost extension'\n              }),\n              value: BoostTiltDirection.DOWN\n            }, {\n              text: formatMessage({\n                id: 'boost.tiltDirection.left',\n                default: 'left',\n                description: 'label for left element in tilt direction menu for LEGO Boost extension'\n              }),\n              value: BoostTiltDirection.LEFT\n            }, {\n              text: formatMessage({\n                id: 'boost.tiltDirection.right',\n                default: 'right',\n                description: 'label for right element in tilt direction menu for LEGO Boost extension'\n              }),\n              value: BoostTiltDirection.RIGHT\n            }]\n          },\n          TILT_DIRECTION_ANY: {\n            acceptReporters: true,\n            items: [{\n              text: formatMessage({\n                id: 'boost.tiltDirection.up',\n                default: 'up'\n              }),\n              value: BoostTiltDirection.UP\n            }, {\n              text: formatMessage({\n                id: 'boost.tiltDirection.down',\n                default: 'down'\n              }),\n              value: BoostTiltDirection.DOWN\n            }, {\n              text: formatMessage({\n                id: 'boost.tiltDirection.left',\n                default: 'left'\n              }),\n              value: BoostTiltDirection.LEFT\n            }, {\n              text: formatMessage({\n                id: 'boost.tiltDirection.right',\n                default: 'right'\n              }),\n              value: BoostTiltDirection.RIGHT\n            }, {\n              text: formatMessage({\n                id: 'boost.tiltDirection.any',\n                default: 'any',\n                description: 'label for any element in tilt direction menu for LEGO Boost extension'\n              }),\n              value: BoostTiltDirection.ANY\n            }]\n          },\n          COLOR: {\n            acceptReporters: true,\n            items: [{\n              text: formatMessage({\n                id: 'boost.color.red',\n                default: 'red',\n                description: 'the color red'\n              }),\n              value: BoostColor.RED\n            }, {\n              text: formatMessage({\n                id: 'boost.color.blue',\n                default: 'blue',\n                description: 'the color blue'\n              }),\n              value: BoostColor.BLUE\n            }, {\n              text: formatMessage({\n                id: 'boost.color.green',\n                default: 'green',\n                description: 'the color green'\n              }),\n              value: BoostColor.GREEN\n            }, {\n              text: formatMessage({\n                id: 'boost.color.yellow',\n                default: 'yellow',\n                description: 'the color yellow'\n              }),\n              value: BoostColor.YELLOW\n            }, {\n              text: formatMessage({\n                id: 'boost.color.white',\n                default: 'white',\n                desription: 'the color white'\n              }),\n              value: BoostColor.WHITE\n            }, {\n              text: formatMessage({\n                id: 'boost.color.black',\n                default: 'black',\n                description: 'the color black'\n              }),\n              value: BoostColor.BLACK\n            }, {\n              text: formatMessage({\n                id: 'boost.color.any',\n                default: 'any color',\n                description: 'any color'\n              }),\n              value: BoostColor.ANY\n            }]\n          }\n        }\n      };\n    }\n    /**\n     * Turn specified motor(s) on for a specified duration.\n     * @param {object} args - the block's arguments.\n     * @property {MotorID} MOTOR_ID - the motor(s) to activate.\n     * @property {int} DURATION - the amount of time to run the motors.\n     * @return {Promise} - a promise which will resolve at the end of the duration.\n     */\n  }, {\n    key: \"motorOnFor\",\n    value: function motorOnFor(args) {\n      var _this3 = this;\n      // TODO: cast args.MOTOR_ID?\n      var durationMS = Cast.toNumber(args.DURATION) * 1000;\n      durationMS = MathUtil.clamp(durationMS, 0, 15000);\n      return new Promise(function (resolve) {\n        _this3._forEachMotor(args.MOTOR_ID, function (motorIndex) {\n          var motor = _this3._peripheral.motor(motorIndex);\n          if (motor) motor.turnOnFor(durationMS);\n        }); // Run for some time even when no motor is connected\n        setTimeout(resolve, durationMS);\n      });\n    }\n    /**\n     * Turn specified motor(s) on for a specified rotation in full rotations.\n     * @param {object} args - the block's arguments.\n     * @property {MotorID} MOTOR_ID - the motor(s) to activate.\n     * @property {int} ROTATION - the amount of full rotations to turn the motors.\n     * @return {Promise} - a promise which will resolve at the end of the duration.\n     */\n  }, {\n    key: \"motorOnForRotation\",\n    value: function motorOnForRotation(args) {\n      var _this4 = this;\n      // TODO: cast args.MOTOR_ID?\n      var degrees = Cast.toNumber(args.ROTATION) * 360; // TODO: Clamps to 100 rotations. Consider changing.\n      var sign = Math.sign(degrees);\n      degrees = Math.abs(MathUtil.clamp(degrees, -360000, 360000));\n      var motors = [];\n      this._forEachMotor(args.MOTOR_ID, function (motorIndex) {\n        motors.push(motorIndex);\n      });\n      /**\n       * Checks that the motors given in args.MOTOR_ID exist,\n       * and maps a promise for each of the motor-commands to an array.\n       */\n      var promises = motors.map(function (portID) {\n        var motor = _this4._peripheral.motor(portID);\n        if (motor) {\n          // to avoid a hanging block if power is 0, return an immediately resolving promise.\n          if (motor.power === 0) return Promise.resolve();\n          return new Promise(function (resolve) {\n            motor.turnOnForDegrees(degrees, sign);\n            motor.pendingRotationPromise = resolve;\n          });\n        }\n        return null;\n      });\n      /**\n       * Make sure all promises are resolved, i.e. all motor-commands have completed.\n       * To prevent the block from returning a value, an empty function is added to the .then\n       */\n      return Promise.all(promises).then(function () {});\n    }\n    /**\n     * Turn specified motor(s) on indefinitely.\n     * @param {object} args - the block's arguments.\n     * @property {MotorID} MOTOR_ID - the motor(s) to activate.\n     * @return {Promise} - a Promise that resolves after some delay.\n     */\n  }, {\n    key: \"motorOn\",\n    value: function motorOn(args) {\n      var _this5 = this;\n      // TODO: cast args.MOTOR_ID?\n      this._forEachMotor(args.MOTOR_ID, function (motorIndex) {\n        var motor = _this5._peripheral.motor(motorIndex);\n        if (motor) motor.turnOnForever();\n      });\n      return new Promise(function (resolve) {\n        window.setTimeout(function () {\n          resolve();\n        }, BoostBLE.sendInterval);\n      });\n    }\n    /**\n     * Turn specified motor(s) off.\n     * @param {object} args - the block's arguments.\n     * @property {MotorID} MOTOR_ID - the motor(s) to deactivate.\n     * @return {Promise} - a Promise that resolves after some delay.\n     */\n  }, {\n    key: \"motorOff\",\n    value: function motorOff(args) {\n      var _this6 = this;\n      // TODO: cast args.MOTOR_ID?\n      this._forEachMotor(args.MOTOR_ID, function (motorIndex) {\n        var motor = _this6._peripheral.motor(motorIndex);\n        if (motor) motor.turnOff();\n      });\n      return new Promise(function (resolve) {\n        window.setTimeout(function () {\n          resolve();\n        }, BoostBLE.sendInterval);\n      });\n    }\n    /**\n     * Set the power level of the specified motor(s).\n     * @param {object} args - the block's arguments.\n     * @property {MotorID} MOTOR_ID - the motor(s) to be affected.\n     * @property {int} POWER - the new power level for the motor(s).\n     * @return {Promise} - returns a promise to make sure the block yields.\n     */\n  }, {\n    key: \"setMotorPower\",\n    value: function setMotorPower(args) {\n      var _this7 = this;\n      // TODO: cast args.MOTOR_ID?\n      this._forEachMotor(args.MOTOR_ID, function (motorIndex) {\n        var motor = _this7._peripheral.motor(motorIndex);\n        if (motor) {\n          motor.power = MathUtil.clamp(Cast.toNumber(args.POWER), 0, 100);\n          switch (motor.status) {\n            case BoostMotorState.ON_FOREVER:\n              motor.turnOnForever();\n              break;\n            case BoostMotorState.ON_FOR_TIME:\n              motor.turnOnFor(motor.pendingDurationTimeoutStartTime + motor.pendingDurationTimeoutDelay - Date.now());\n              break;\n          }\n        }\n      });\n      return new Promise(function (resolve) {\n        window.setTimeout(function () {\n          resolve();\n        }, BoostBLE.sendInterval);\n      });\n    }\n    /**\n     * Set the direction of rotation for specified motor(s).\n     * If the direction is 'reverse' the motor(s) will be reversed individually.\n     * @param {object} args - the block's arguments.\n     * @property {MotorID} MOTOR_ID - the motor(s) to be affected.\n     * @property {MotorDirection} MOTOR_DIRECTION - the new direction for the motor(s).\n     * @return {Promise} - returns a promise to make sure the block yields.\n     */\n  }, {\n    key: \"setMotorDirection\",\n    value: function setMotorDirection(args) {\n      var _this8 = this;\n      // TODO: cast args.MOTOR_ID?\n      this._forEachMotor(args.MOTOR_ID, function (motorIndex) {\n        var motor = _this8._peripheral.motor(motorIndex);\n        if (motor) {\n          switch (args.MOTOR_DIRECTION) {\n            case BoostMotorDirection.FORWARD:\n              motor.direction = 1;\n              break;\n            case BoostMotorDirection.BACKWARD:\n              motor.direction = -1;\n              break;\n            case BoostMotorDirection.REVERSE:\n              motor.direction = -motor.direction;\n              break;\n            default:\n              log.warn(\"Unknown motor direction in setMotorDirection: \".concat(args.DIRECTION));\n              break;\n          } // keep the motor on if it's running, and update the pending timeout if needed\n          if (motor) {\n            switch (motor.status) {\n              case BoostMotorState.ON_FOREVER:\n                motor.turnOnForever();\n                break;\n              case BoostMotorState.ON_FOR_TIME:\n                motor.turnOnFor(motor.pendingDurationTimeoutStartTime + motor.pendingDurationTimeoutDelay - Date.now());\n                break;\n            }\n          }\n        }\n      });\n      return new Promise(function (resolve) {\n        window.setTimeout(function () {\n          resolve();\n        }, BoostBLE.sendInterval);\n      });\n    }\n    /**\n     * @param {object} args - the block's arguments.\n     * @return {number} - returns the motor's position.\n     */\n  }, {\n    key: \"getMotorPosition\",\n    value: function getMotorPosition(args) {\n      var portID = null;\n      switch (args.MOTOR_REPORTER_ID) {\n        case BoostMotorLabel.A:\n          portID = BoostPort.A;\n          break;\n        case BoostMotorLabel.B:\n          portID = BoostPort.B;\n          break;\n        case BoostMotorLabel.C:\n          portID = BoostPort.C;\n          break;\n        case BoostMotorLabel.D:\n          portID = BoostPort.D;\n          break;\n        default:\n          log.warn('Asked for a motor position that doesnt exist!');\n          return false;\n      }\n      if (portID !== null && this._peripheral.motor(portID)) {\n        var val = this._peripheral.motor(portID).position; // Boost motor A position direction is reversed by design\n        // so we have to reverse the position here\n        if (portID === BoostPort.A) {\n          val *= -1;\n        }\n        return MathUtil.wrapClamp(val, 0, 360);\n      }\n      return 0;\n    }\n    /**\n     * Call a callback for each motor indexed by the provided motor ID.\n     * @param {MotorID} motorID - the ID specifier.\n     * @param {Function} callback - the function to call with the numeric motor index for each motor.\n     * @private\n     */\n  }, {\n    key: \"_forEachMotor\",\n    value: function _forEachMotor(motorID, callback) {\n      var motors;\n      switch (motorID) {\n        case BoostMotorLabel.A:\n          motors = [BoostPort.A];\n          break;\n        case BoostMotorLabel.B:\n          motors = [BoostPort.B];\n          break;\n        case BoostMotorLabel.C:\n          motors = [BoostPort.C];\n          break;\n        case BoostMotorLabel.D:\n          motors = [BoostPort.D];\n          break;\n        case BoostMotorLabel.AB:\n          motors = [BoostPort.A, BoostPort.B];\n          break;\n        case BoostMotorLabel.ALL:\n          motors = [BoostPort.A, BoostPort.B, BoostPort.C, BoostPort.D];\n          break;\n        default:\n          log.warn(\"Invalid motor ID: \".concat(motorID));\n          motors = [];\n          break;\n      }\n      var _iterator = _createForOfIteratorHelper(motors),\n          _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var index = _step.value;\n          callback(index);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    /**\n     * Test whether the tilt sensor is currently tilted.\n     * @param {object} args - the block's arguments.\n     * @property {TiltDirection} TILT_DIRECTION_ANY - the tilt direction to test (up, down, left, right, or any).\n     * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.\n     */\n  }, {\n    key: \"whenTilted\",\n    value: function whenTilted(args) {\n      return this._isTilted(args.TILT_DIRECTION_ANY);\n    }\n    /**\n     * Test whether the tilt sensor is currently tilted.\n     * @param {object} args - the block's arguments.\n     * @property {TiltDirection} TILT_DIRECTION_ANY - the tilt direction to test (up, down, left, right, or any).\n     * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.\n     */\n  }, {\n    key: \"isTilted\",\n    value: function isTilted(args) {\n      return this._isTilted(args.TILT_DIRECTION_ANY);\n    }\n    /**\n     * @param {object} args - the block's arguments.\n     * @property {TiltDirection} TILT_DIRECTION - the direction (up, down, left, right) to check.\n     * @return {number} - the tilt sensor's angle in the specified direction.\n     * Note that getTiltAngle(up) = -getTiltAngle(down) and getTiltAngle(left) = -getTiltAngle(right).\n     */\n  }, {\n    key: \"getTiltAngle\",\n    value: function getTiltAngle(args) {\n      return this._getTiltAngle(args.TILT_DIRECTION);\n    }\n    /**\n     * Test whether the tilt sensor is currently tilted.\n     * @param {TiltDirection} direction - the tilt direction to test (up, down, left, right, or any).\n     * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.\n     * @private\n     */\n  }, {\n    key: \"_isTilted\",\n    value: function _isTilted(direction) {\n      switch (direction) {\n        case BoostTiltDirection.ANY:\n          return Math.abs(this._peripheral.tiltX) >= Scratch3BoostBlocks.TILT_THRESHOLD || Math.abs(this._peripheral.tiltY) >= Scratch3BoostBlocks.TILT_THRESHOLD;\n        default:\n          return this._getTiltAngle(direction) >= Scratch3BoostBlocks.TILT_THRESHOLD;\n      }\n    }\n    /**\n     * @param {TiltDirection} direction - the direction (up, down, left, right) to check.\n     * @return {number} - the tilt sensor's angle in the specified direction.\n     * Note that getTiltAngle(up) = -getTiltAngle(down) and getTiltAngle(left) = -getTiltAngle(right).\n     * @private\n     */\n  }, {\n    key: \"_getTiltAngle\",\n    value: function _getTiltAngle(direction) {\n      switch (direction) {\n        case BoostTiltDirection.UP:\n          return this._peripheral.tiltY > 90 ? 256 - this._peripheral.tiltY : -this._peripheral.tiltY;\n        case BoostTiltDirection.DOWN:\n          return this._peripheral.tiltY > 90 ? this._peripheral.tiltY - 256 : this._peripheral.tiltY;\n        case BoostTiltDirection.LEFT:\n          return this._peripheral.tiltX > 90 ? this._peripheral.tiltX - 256 : this._peripheral.tiltX;\n        case BoostTiltDirection.RIGHT:\n          return this._peripheral.tiltX > 90 ? 256 - this._peripheral.tiltX : -this._peripheral.tiltX;\n        default:\n          log.warn(\"Unknown tilt direction in _getTiltAngle: \".concat(direction));\n      }\n    }\n    /**\n     * Edge-triggering hat function, for when the vision sensor is detecting\n     * a certain color.\n     * @param {object} args - the block's arguments.\n     * @return {boolean} - true when the color sensor senses the specified color.\n     */\n  }, {\n    key: \"whenColor\",\n    value: function whenColor(args) {\n      if (args.COLOR === BoostColor.ANY) {\n        // For \"any\" color, return true if the color is not \"none\", and\n        // the color is different from the previous color detected. This\n        // allows the hat to trigger when the color changes from one color\n        // to another.\n        return this._peripheral.color !== BoostColor.NONE && this._peripheral.color !== this._peripheral.previousColor;\n      }\n      return args.COLOR === this._peripheral.color;\n    }\n    /**\n     * A boolean reporter function, for whether the vision sensor is detecting\n     * a certain color.\n     * @param {object} args - the block's arguments.\n     * @return {boolean} - true when the color sensor senses the specified color.\n     */\n  }, {\n    key: \"seeingColor\",\n    value: function seeingColor(args) {\n      if (args.COLOR === BoostColor.ANY) {\n        return this._peripheral.color !== BoostColor.NONE;\n      }\n      return args.COLOR === this._peripheral.color;\n    }\n    /**\n     * Set the LED's hue.\n     * @param {object} args - the block's arguments.\n     * @property {number} HUE - the hue to set, in the range [0,100].\n     * @return {Promise} - a Promise that resolves after some delay.\n     */\n  }, {\n    key: \"setLightHue\",\n    value: function setLightHue(args) {\n      // Convert from [0,100] to [0,360]\n      var inputHue = Cast.toNumber(args.HUE);\n      inputHue = MathUtil.wrapClamp(inputHue, 0, 100);\n      var hue = inputHue * 360 / 100;\n      var rgbObject = color.hsvToRgb({\n        h: hue,\n        s: 1,\n        v: 1\n      });\n      var rgbDecimal = color.rgbToDecimal(rgbObject);\n      this._peripheral._led = inputHue;\n      this._peripheral.setLED(rgbDecimal);\n      return new Promise(function (resolve) {\n        window.setTimeout(function () {\n          resolve();\n        }, BoostBLE.sendInterval);\n      });\n    }\n  }]);\n  return Scratch3BoostBlocks;\n}();\nmodule.exports = Scratch3BoostBlocks;\n })