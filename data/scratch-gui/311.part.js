/* 311 */\n (function(module, exports) {\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n/**\n * An effect on an AudioPlayer and all its SoundPlayers.\n */\nvar Effect = function () {\n  /**\n   * @param {AudioEngine} audioEngine - audio engine this runs with\n   * @param {AudioPlayer} audioPlayer - audio player this affects\n   * @param {Effect} lastEffect - effect in the chain before this one\n   * @constructor\n   */\n  function Effect(audioEngine, audioPlayer, lastEffect) {\n    _classCallCheck(this, Effect);\n    this.audioEngine = audioEngine;\n    this.audioPlayer = audioPlayer;\n    this.lastEffect = lastEffect;\n    this.value = this.DEFAULT_VALUE;\n    this.initialized = false;\n    this.inputNode = null;\n    this.outputNode = null;\n    this.target = null;\n  }\n  /**\n   * Return the name of the effect.\n   * @type {string}\n   */\n  _createClass(Effect, [{\n    key: \"getInputNode\",\n    /**\n     * Get the input node.\n     * @return {AudioNode} - audio node that is the input for this effect\n     */\n    value: function getInputNode() {\n      if (this._isPatch) {\n        return this.inputNode;\n      }\n      return this.target.getInputNode();\n    }\n    /**\n     * Initialize the Effect.\n     * Effects start out uninitialized. Then initialize when they are first set\n     * with some value.\n     * @throws {Error} throws when left unimplemented\n     */\n  }, {\n    key: \"initialize\",\n    value: function initialize() {\n      throw new Error(\"\".concat(this.constructor.name, \".initialize is not implemented.\"));\n    }\n    /**\n     * Set the effects value.\n     * @private\n     * @param {number} value - new value to set effect to\n     */\n  }, {\n    key: \"_set\",\n    value: function _set() {\n      throw new Error(\"\".concat(this.constructor.name, \"._set is not implemented.\"));\n    }\n    /**\n     * Set the effects value.\n     * @param {number} value - new value to set effect to\n     */\n  }, {\n    key: \"set\",\n    value: function set(value) {\n      // Initialize the node on first set.\n      if (!this.initialized) {\n        this.initialize();\n      } // Store whether the graph should currently affected by this effect.\n      var wasPatch = this._isPatch;\n      if (wasPatch) {\n        this._lastPatch = this.audioEngine.currentTime;\n      } // Call the internal implementation per this Effect.\n      this._set(value); // Connect or disconnect from the graph if this now applies or no longer\n      // applies an effect.\n      if (this._isPatch !== wasPatch && this.target !== null) {\n        this.connect(this.target);\n      }\n    }\n    /**\n     * Update the effect for changes in the audioPlayer.\n     */\n  }, {\n    key: \"update\",\n    value: function update() {}\n    /**\n     * Clear the value back to the default.\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.set(this.DEFAULT_VALUE);\n    }\n    /**\n     * Connnect this effect's output to another audio node\n     * @param {object} target - target whose node to should be connected\n     */\n  }, {\n    key: \"connect\",\n    value: function connect(target) {\n      var _this = this;\n      if (target === null) {\n        throw new Error('target may not be null');\n      }\n      var checkForCircularReference = function checkForCircularReference(subtarget) {\n        if (subtarget) {\n          if (subtarget === _this) {\n            return true;\n          }\n          return checkForCircularReference(subtarget.target);\n        }\n      };\n      if (checkForCircularReference(target)) {\n        throw new Error('Effect cannot connect to itself');\n      }\n      this.target = target;\n      if (this.outputNode !== null) {\n        this.outputNode.disconnect();\n      }\n      if (this._isPatch || this._lastPatch + this.audioEngine.DECAY_DURATION < this.audioEngine.currentTime) {\n        this.outputNode.connect(target.getInputNode());\n      }\n      if (this.lastEffect === null) {\n        if (this.audioPlayer !== null) {\n          this.audioPlayer.connect(this);\n        }\n      } else {\n        this.lastEffect.connect(this);\n      }\n    }\n    /**\n     * Clean up and disconnect audio nodes.\n     */\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.inputNode = null;\n      this.outputNode = null;\n      this.target = null;\n      this.initialized = false;\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      throw new Error(\"\".concat(this.constructor.name, \".name is not implemented\"));\n    }\n    /**\n     * Default value to set the Effect to when constructed and when clear'ed.\n     * @const {number}\n     */\n  }, {\n    key: \"DEFAULT_VALUE\",\n    get: function get() {\n      return 0;\n    }\n    /**\n     * Should the effect be connected to the audio graph?\n     * The pitch effect is an example that does not need to be patched in.\n     * Instead of affecting the graph it affects the player directly.\n     * @return {boolean} is the effect affecting the graph?\n     */\n  }, {\n    key: \"_isPatch\",\n    get: function get() {\n      return this.initialized && (this.value !== this.DEFAULT_VALUE || this.audioPlayer === null);\n    }\n  }]);\n  return Effect;\n}();\nmodule.exports = Effect;\n })