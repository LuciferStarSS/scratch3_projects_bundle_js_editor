/* 906 */\n (function(module, exports, __webpack_require__) {\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nvar _TextEncoder;\nif (typeof TextEncoder === 'undefined') {\n  _TextEncoder = __webpack_require__(160).TextEncoder;\n} else {\n  /* global TextEncoder */\n  _TextEncoder = TextEncoder;\n}\nvar EventEmitter = __webpack_require__(91);\nvar JSZip = __webpack_require__(398);\nvar Buffer = __webpack_require__(56).Buffer;\nvar centralDispatch = __webpack_require__(426);\nvar ExtensionManager = __webpack_require__(954);\nvar log = __webpack_require__(39);\nvar MathUtil = __webpack_require__(62);\nvar Runtime = __webpack_require__(450);\nvar StringUtil = __webpack_require__(102);\nvar formatMessage = __webpack_require__(71);\nvar Variable = __webpack_require__(114);\nvar newBlockIds = __webpack_require__(453);\nvar _require = __webpack_require__(225),\n    loadCostume = _require.loadCostume;\nvar _require2 = __webpack_require__(226),\n    loadSound = _require2.loadSound;\nvar _require3 = __webpack_require__(1104),\n    serializeSounds = _require3.serializeSounds,\n    serializeCostumes = _require3.serializeCostumes;\n__webpack_require__(1105);\nvar RESERVED_NAMES = ['_mouse_', '_stage_', '_edge_', '_myself_', '_random_'];\nvar CORE_EXTENSIONS = [// 'motion',\n  // 'looks',\n  // 'sound',\n  // 'events',\n  // 'control',\n  // 'sensing',\n  // 'operators',\n  // 'variables',\n  // 'myBlocks'\n];\n/**\n * Handles connections between blocks, stage, and extensions.\n * @constructor\n */\nvar VirtualMachine = function (_EventEmitter) {\n  _inherits(VirtualMachine, _EventEmitter);\n  var _super = _createSuper(VirtualMachine);\n  function VirtualMachine() {\n    var _this;\n    _classCallCheck(this, VirtualMachine);\n    _this = _super.call(this);\n    /**\n     * VM runtime, to store blocks, I/O devices, sprites/targets, etc.\n     * @type {!Runtime}\n     */\n    _this.runtime = new Runtime();\n    centralDispatch.setService('runtime', _this.runtime).catch(function (e) {\n      log.error(\"Failed to register runtime service: \".concat(JSON.stringify(e)));\n    });\n    /**\n     * The \"currently editing\"/selected target ID for the VM.\n     * Block events from any Blockly workspace are routed to this target.\n     * @type {Target}\n     */\n    _this.editingTarget = null;\n    /**\n     * The currently dragging target, for redirecting IO data.\n     * @type {Target}\n     */\n    _this._dragTarget = null; // Runtime emits are passed along as VM emits.\n    _this.runtime.on(Runtime.SCRIPT_GLOW_ON, function (glowData) {\n      _this.emit(Runtime.SCRIPT_GLOW_ON, glowData);\n    });\n    _this.runtime.on(Runtime.SCRIPT_GLOW_OFF, function (glowData) {\n      _this.emit(Runtime.SCRIPT_GLOW_OFF, glowData);\n    });\n    _this.runtime.on(Runtime.BLOCK_GLOW_ON, function (glowData) {\n      _this.emit(Runtime.BLOCK_GLOW_ON, glowData);\n    });\n    _this.runtime.on(Runtime.BLOCK_GLOW_OFF, function (glowData) {\n      _this.emit(Runtime.BLOCK_GLOW_OFF, glowData);\n    });\n    _this.runtime.on(Runtime.PROJECT_START, function () {\n      _this.emit(Runtime.PROJECT_START);\n    });\n    _this.runtime.on(Runtime.PROJECT_RUN_START, function () {\n      _this.emit(Runtime.PROJECT_RUN_START);\n    });\n    _this.runtime.on(Runtime.PROJECT_RUN_STOP, function () {\n      _this.emit(Runtime.PROJECT_RUN_STOP);\n    });\n    _this.runtime.on(Runtime.PROJECT_CHANGED, function () {\n      _this.emit(Runtime.PROJECT_CHANGED);\n    });\n    _this.runtime.on(Runtime.VISUAL_REPORT, function (visualReport) {\n      _this.emit(Runtime.VISUAL_REPORT, visualReport);\n    });\n    _this.runtime.on(Runtime.TARGETS_UPDATE, function (emitProjectChanged) {\n      _this.emitTargetsUpdate(emitProjectChanged);\n    });\n    _this.runtime.on(Runtime.MONITORS_UPDATE, function (monitorList) {\n      _this.emit(Runtime.MONITORS_UPDATE, monitorList);\n    });\n    _this.runtime.on(Runtime.BLOCK_DRAG_UPDATE, function (areBlocksOverGui) {\n      _this.emit(Runtime.BLOCK_DRAG_UPDATE, areBlocksOverGui);\n    });\n    _this.runtime.on(Runtime.BLOCK_DRAG_END, function (blocks, topBlockId) {\n      _this.emit(Runtime.BLOCK_DRAG_END, blocks, topBlockId);\n    });\n    _this.runtime.on(Runtime.EXTENSION_ADDED, function (categoryInfo) {\n      _this.emit(Runtime.EXTENSION_ADDED, categoryInfo);\n    });\n    _this.runtime.on(Runtime.EXTENSION_FIELD_ADDED, function (fieldName, fieldImplementation) {\n      _this.emit(Runtime.EXTENSION_FIELD_ADDED, fieldName, fieldImplementation);\n    });\n    _this.runtime.on(Runtime.BLOCKSINFO_UPDATE, function (categoryInfo) {\n      _this.emit(Runtime.BLOCKSINFO_UPDATE, categoryInfo);\n    });\n    _this.runtime.on(Runtime.BLOCKS_NEED_UPDATE, function () {\n      _this.emitWorkspaceUpdate();\n    });\n    _this.runtime.on(Runtime.TOOLBOX_EXTENSIONS_NEED_UPDATE, function () {\n      _this.extensionManager.refreshBlocks();\n    });\n    _this.runtime.on(Runtime.PERIPHERAL_LIST_UPDATE, function (info) {\n      _this.emit(Runtime.PERIPHERAL_LIST_UPDATE, info);\n    });\n    _this.runtime.on(Runtime.USER_PICKED_PERIPHERAL, function (info) {\n      _this.emit(Runtime.USER_PICKED_PERIPHERAL, info);\n    });\n    _this.runtime.on(Runtime.PERIPHERAL_CONNECTED, function () {\n      return _this.emit(Runtime.PERIPHERAL_CONNECTED);\n    });\n    _this.runtime.on(Runtime.PERIPHERAL_REQUEST_ERROR, function () {\n      return _this.emit(Runtime.PERIPHERAL_REQUEST_ERROR);\n    });\n    _this.runtime.on(Runtime.PERIPHERAL_DISCONNECTED, function () {\n      return _this.emit(Runtime.PERIPHERAL_DISCONNECTED);\n    });\n    _this.runtime.on(Runtime.PERIPHERAL_CONNECTION_LOST_ERROR, function (data) {\n      return _this.emit(Runtime.PERIPHERAL_CONNECTION_LOST_ERROR, data);\n    });\n    _this.runtime.on(Runtime.PERIPHERAL_SCAN_TIMEOUT, function () {\n      return _this.emit(Runtime.PERIPHERAL_SCAN_TIMEOUT);\n    });\n    _this.runtime.on(Runtime.MIC_LISTENING, function (listening) {\n      _this.emit(Runtime.MIC_LISTENING, listening);\n    });\n    _this.runtime.on(Runtime.RUNTIME_STARTED, function () {\n      _this.emit(Runtime.RUNTIME_STARTED);\n    });\n    _this.runtime.on(Runtime.HAS_CLOUD_DATA_UPDATE, function (hasCloudData) {\n      _this.emit(Runtime.HAS_CLOUD_DATA_UPDATE, hasCloudData);\n    });\n    _this.extensionManager = new ExtensionManager(_this.runtime); // Load core extensions\n    var _iterator = _createForOfIteratorHelper(CORE_EXTENSIONS),\n        _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var id = _step.value;\n        _this.extensionManager.loadExtensionIdSync(id);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    _this.blockListener = _this.blockListener.bind(_assertThisInitialized(_this));\n    _this.flyoutBlockListener = _this.flyoutBlockListener.bind(_assertThisInitialized(_this));\n    _this.monitorBlockListener = _this.monitorBlockListener.bind(_assertThisInitialized(_this));\n    _this.variableListener = _this.variableListener.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n  /**\n   * Start running the VM - do this before anything else.\n   */\n  _createClass(VirtualMachine, [{\n    key: \"start\",\n    value: function start() {\n      this.runtime.start();\n    }\n    /**\n     * \"Green flag\" handler - start all threads starting with a green flag.\n     */\n  }, {\n    key: \"greenFlag\",\n    value: function greenFlag() {\n      this.runtime.greenFlag();\n    }\n    /**\n     * Set whether the VM is in \"turbo mode.\"\n     * When true, loops don't yield to redraw.\n     * @param {boolean} turboModeOn Whether turbo mode should be set.\n     */\n  }, {\n    key: \"setTurboMode\",\n    value: function setTurboMode(turboModeOn) {\n      this.runtime.turboMode = !!turboModeOn;\n      if (this.runtime.turboMode) {\n        this.emit(Runtime.TURBO_MODE_ON);\n      } else {\n        this.emit(Runtime.TURBO_MODE_OFF);\n      }\n    }\n    /**\n     * Set whether the VM is in 2.0 \"compatibility mode.\"\n     * When true, ticks go at 2.0 speed (30 TPS).\n     * @param {boolean} compatibilityModeOn Whether compatibility mode is set.\n     */\n  }, {\n    key: \"setCompatibilityMode\",\n    value: function setCompatibilityMode(compatibilityModeOn) {\n      this.runtime.setCompatibilityMode(!!compatibilityModeOn);\n    }\n    /**\n     * Stop all threads and running activities.\n     */\n  }, {\n    key: \"stopAll\",\n    value: function stopAll() {\n      this.runtime.stopAll();\n    }\n    /**\n     * Clear out current running project data.\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.runtime.dispose();\n      this.editingTarget = null;\n      this.emitTargetsUpdate(false\n      /* Don't emit project change */\n      );\n    }\n    /**\n     * Get data for playground. Data comes back in an emitted event.\n     */\n  }, {\n    key: \"getPlaygroundData\",\n    value: function getPlaygroundData() {\n      var instance = this; // Only send back thread data for the current editingTarget.\n      var threadData = this.runtime.threads.filter(function (thread) {\n        return thread.target === instance.editingTarget;\n      }); // Remove the target key, since it's a circular reference.\n      var filteredThreadData = JSON.stringify(threadData, function (key, value) {\n        if (key === 'target' || key === 'blockContainer') return;\n        return value;\n      }, 2);\n      this.emit('playgroundData', {\n        blocks: this.editingTarget.blocks,\n        threads: filteredThreadData\n      });\n    }\n    /**\n     * Post I/O data to the virtual devices.\n     * @param {?string} device Name of virtual I/O device.\n     * @param {object} data Any data object to post to the I/O device.\n     */\n  }, {\n    key: \"postIOData\",\n    value: function postIOData(device, data) {\n      if (this.runtime.ioDevices[device]) {\n        this.runtime.ioDevices[device].postData(data);\n      }\n    }\n  }, {\n    key: \"setVideoProvider\",\n    value: function setVideoProvider(videoProvider) {\n      this.runtime.ioDevices.video.setProvider(videoProvider);\n    }\n  }, {\n    key: \"setCloudProvider\",\n    value: function setCloudProvider(cloudProvider) {\n      this.runtime.ioDevices.cloud.setProvider(cloudProvider);\n    }\n    /**\n     * Tell the specified extension to scan for a peripheral.\n     * @param {string} extensionId - the id of the extension.\n     */\n  }, {\n    key: \"scanForPeripheral\",\n    value: function scanForPeripheral(extensionId) {\n      this.runtime.scanForPeripheral(extensionId);\n    }\n    /**\n     * Connect to the extension's specified peripheral.\n     * @param {string} extensionId - the id of the extension.\n     * @param {number} peripheralId - the id of the peripheral.\n     */\n  }, {\n    key: \"connectPeripheral\",\n    value: function connectPeripheral(extensionId, peripheralId) {\n      this.runtime.connectPeripheral(extensionId, peripheralId);\n    }\n    /**\n     * Disconnect from the extension's connected peripheral.\n     * @param {string} extensionId - the id of the extension.\n     */\n  }, {\n    key: \"disconnectPeripheral\",\n    value: function disconnectPeripheral(extensionId) {\n      this.runtime.disconnectPeripheral(extensionId);\n    }\n    /**\n     * Returns whether the extension has a currently connected peripheral.\n     * @param {string} extensionId - the id of the extension.\n     * @return {boolean} - whether the extension has a connected peripheral.\n     */\n  }, {\n    key: \"getPeripheralIsConnected\",\n    value: function getPeripheralIsConnected(extensionId) {\n      return this.runtime.getPeripheralIsConnected(extensionId);\n    }\n    /**\n     * Load a Scratch project from a .sb, .sb2, .sb3 or json string.\n     * @param {string | object} input A json string, object, or ArrayBuffer representing the project to load.\n     * @return {!Promise} Promise that resolves after targets are installed.\n     */\n  }, {\n    key: \"loadProject\",\n    value: function loadProject(input) {\n      var _this2 = this;\n      if (_typeof(input) === 'object' && !(input instanceof ArrayBuffer) && !ArrayBuffer.isView(input)) {\n        // If the input is an object and not any ArrayBuffer\n        // or an ArrayBuffer view (this includes all typed arrays and DataViews)\n        // turn the object into a JSON string, because we suspect\n        // this is a project.json as an object\n        // validate expects a string or buffer as input\n        // TODO not sure if we need to check that it also isn't a data view\n        input = JSON.stringify(input);\n      }\n      var validationPromise = new Promise(function (resolve, reject) {\n        var validate = __webpack_require__(454); // The second argument of false below indicates to the validator that the\n        // input should be parsed/validated as an entire project (and not a single sprite)\n        validate(input, false, function (error, res) {\n          if (error) return reject(error);\n          resolve(res);\n        });\n      }).catch(function (error) {\n        var _require4 = __webpack_require__(1481),\n            SB1File = _require4.SB1File,\n            ValidationError = _require4.ValidationError;\n        try {\n          var sb1 = new SB1File(input);\n          var json = sb1.json;\n          json.projectVersion = 2;\n          return Promise.resolve([json, sb1.zip]);\n        } catch (sb1Error) {\n          if (sb1Error instanceof ValidationError) {// The input does not validate as a Scratch 1 file.\n          } else {\n            // The project appears to be a Scratch 1 file but it\n            // could not be successfully translated into a Scratch 2\n            // project.\n            return Promise.reject(sb1Error);\n          }\n        } // Throw original error since the input does not appear to be\n        // an SB1File.\n        return Promise.reject(error);\n      });\n      return validationPromise.then(function (validatedInput) {\n        return _this2.deserializeProject(validatedInput[0], validatedInput[1]);\n      }).then(function () {\n        return _this2.runtime.emitProjectLoaded();\n      }).catch(function (error) {\n        // Intentionally rejecting here (want errors to be handled by caller)\n        if (error.hasOwnProperty('validationError')) {\n       sError(JSON.stringify(error));\n          return Promise.reject(JSON.stringify(error));\n        }\n        return Promise.reject(error);\n      });\n    }\n    /**\n     * Load a project from the Scratch web site, by ID.\n     * @param {string} id - the ID of the project to download, as a string.\n     */\n  }, {\n    key: \"downloadProjectId\",\n    value: function downloadProjectId(id) {\n      var storage = this.runtime.storage;\n      if (!storage) {\n        log.error('No storage module present; cannot load project: ', id);\n        return;\n      }\n      var vm = this;\n      var promise = storage.load(storage.AssetType.Project, id);\n      promise.then(function (projectAsset) {\n        vm.loadProject(projectAsset.data);\n      });\n    }\n    /**\n     * @returns {string} Project in a Scratch 3.0 JSON representation.\n     */\n  }, {\n    key: \"saveProjectSb3\",\n    value: function saveProjectSb3() {\n      var soundDescs = serializeSounds(this.runtime);\n      var costumeDescs = serializeCostumes(this.runtime);\n      var projectJson = this.toJSON(); // TODO want to eventually move zip creation out of here, and perhaps\n      // into scratch-storage\n      var zip = new JSZip(); // Put everything in a zip file\n      zip.file('project.json', projectJson);\n      this._addFileDescsToZip(soundDescs.concat(costumeDescs), zip);\n      return zip.generateAsync({\n        type: 'blob',\n        mimeType: 'application/x.scratch.sb3',\n        compression: 'DEFLATE',\n        compressionOptions: {\n          level: 6 // Tradeoff between best speed (1) and best compression (9)\n        }\n      });\n    }\n    /*\n     * @type {Array<object>} Array of all costumes and sounds currently in the runtime\n     */\n  }, {\n    key: \"saveProjectOnline\",\n    value: function saveProjectOnline(bAutoSave) {\n      var soundDescs = serializeSounds(this.runtime);\n      var costumeDescs = serializeCostumes(this.runtime);\n      var projectJson = this.toJSON(); // TODO want to eventually move zip creation out of here, and perhaps\n      // into scratch-storage\n      var zip = new JSZip(); // Put everything in a zip file\n      zip.file('project.json', projectJson);\n      this._addFileDescsToZip(soundDescs.concat(costumeDescs), zip);\n\t \n \t  zip.generateAsync({type:\"Blob\",compression: \"DEFLATE\"}).then(function(content) {\n\t\tvar file = new File([content],'SCRATCH.zip',{type: \"zip\"});\n\t\tvar formData = new FormData();\n\t\tformData.append(\"SBFILE\",file);\n\t\t\n\t\t $.ajax({\n\t\t\turl:bAutoSave==true?'autosaveProject.php':'saveProject.php',\n\t\t\ttype:'POST',\n\t\t\tdata:formData,\n\t\t\tprocessData:false,\n\t\t\tcontentType:false,\n\t\t\tsuccess:function (data) {\n              saveStatus(data);\n\t\t\t}\n\t\t });\n      });\n    }\n    /*\n     * @type {Array<object>} Array of all costumes and sounds currently in the runtime\n     */\n  }, {\n    key: \"_addFileDescsToZip\",\n    value: function _addFileDescsToZip(fileDescs, zip) {\n      for (var i = 0; i < fileDescs.length; i++) {\n        var currFileDesc = fileDescs[i];\n        zip.file(currFileDesc.fileName, currFileDesc.fileContent);\n      }\n    }\n    /**\n     * Exports a sprite in the sprite3 format.\n     * @param {string} targetId ID of the target to export\n     * @param {string=} optZipType Optional type that the resulting\n     * zip should be outputted in. Options are: base64, binarystring,\n     * array, uint8array, arraybuffer, blob, or nodebuffer. Defaults to\n     * blob if argument not provided.\n     * See https://stuk.github.io/jszip/documentation/api_jszip/generate_async.html#type-option\n     * for more information about these options.\n     * @return {object} A generated zip of the sprite and its assets in the format\n     * specified by optZipType or blob by default.\n     */\n  }, {\n    key: \"exportSprite\",\n    value: function exportSprite(targetId, optZipType) {\n      var sb3 = __webpack_require__(186);\n      var soundDescs = serializeSounds(this.runtime, targetId);\n      var costumeDescs = serializeCostumes(this.runtime, targetId);\n      var spriteJson = StringUtil.stringify(sb3.serialize(this.runtime, targetId));\n      var zip = new JSZip();\n      zip.file('sprite.json', spriteJson);\n      this._addFileDescsToZip(soundDescs.concat(costumeDescs), zip);\n      return zip.generateAsync({\n        type: typeof optZipType === 'string' ? optZipType : 'blob',\n        mimeType: 'application/x.scratch.sprite3',\n        compression: 'DEFLATE',\n        compressionOptions: {\n          level: 6\n        }\n      });\n    }\n    /**\n     * Export project as a Scratch 3.0 JSON representation.\n     * @return {string} Serialized state of the runtime.\n     */\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var sb3 = __webpack_require__(186);\n      return StringUtil.stringify(sb3.serialize(this.runtime));\n    } // TODO do we still need this function? Keeping it here so as not to introduce\n    // a breaking change.\n    /**\n     * Load a project from a Scratch JSON representation.\n     * @param {string} json JSON string representing a project.\n     * @returns {Promise} Promise that resolves after the project has loaded\n     */\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      log.warning('fromJSON is now just a wrapper around loadProject, please use that function instead.');\n      return this.loadProject(json);\n    }\n    /**\n     * Load a project from a Scratch JSON representation.\n     * @param {string} projectJSON JSON string representing a project.\n     * @param {?JSZip} zip Optional zipped project containing assets to be loaded.\n     * @returns {Promise} Promise that resolves after the project has loaded\n     */\n  }, {\n    key: \"deserializeProject\",\n    value: function deserializeProject(projectJSON, zip) {\n      var _this3 = this;\n      // Clear the current runtime\n      this.clear();\n      var runtime = this.runtime;\n      var deserializePromise = function deserializePromise() {\n        var projectVersion = projectJSON.projectVersion;\n        if (projectVersion === 2) {\n          var sb2 = __webpack_require__(481);\n          return sb2.deserialize(projectJSON, runtime, false, zip);\n        }\n        if (projectVersion === 3) {\n          var sb3 = __webpack_require__(186);\n          return sb3.deserialize(projectJSON, runtime, zip);\n        }\n        return Promise.reject('Unable to verify Scratch Project version.');\n      };\n      return deserializePromise().then(function (_ref) {\n        var targets = _ref.targets,\n            extensions = _ref.extensions;\n        return _this3.installTargets(targets, extensions, true);\n      });\n    }\n    /**\n     * Install `deserialize` results: zero or more targets after the extensions (if any) used by those targets.\n     * @param {Array.<Target>} targets - the targets to be installed\n     * @param {ImportedExtensionsInfo} extensions - metadata about extensions used by these targets\n     * @param {boolean} wholeProject - set to true if installing a whole project, as opposed to a single sprite.\n     * @returns {Promise} resolved once targets have been installed\n     */\n  }, {\n    key: \"installTargets\",\n    value: function installTargets(targets, extensions, wholeProject) {\n      var _this4 = this;\n      var extensionPromises = [];\n      extensions.extensionIDs.forEach(function (extensionID) {\n        if (!_this4.extensionManager.isExtensionLoaded(extensionID)) {\n          var extensionURL = extensions.extensionURLs.get(extensionID) || extensionID;\n          extensionPromises.push(_this4.extensionManager.loadExtensionURL(extensionURL));\n        }\n      });\n      targets = targets.filter(function (target) {\n        return !!target;\n      });\n      return Promise.all(extensionPromises).then(function () {\n        targets.forEach(function (target) {\n          _this4.runtime.addTarget(target);\n          /** @type RenderedTarget */\n          target.updateAllDrawableProperties(); // Ensure unique sprite name\n          if (target.isSprite()) _this4.renameSprite(target.id, target.getName());\n        }); // Sort the executable targets by layerOrder.\n        // Remove layerOrder property after use.\n        _this4.runtime.executableTargets.sort(function (a, b) {\n          return a.layerOrder - b.layerOrder;\n        });\n        targets.forEach(function (target) {\n          delete target.layerOrder;\n        }); // Select the first target for editing, e.g., the first sprite.\n        if (wholeProject && targets.length > 1) {\n          _this4.editingTarget = targets[1];\n        } else {\n          _this4.editingTarget = targets[0];\n        }\n        if (!wholeProject) {\n          _this4.editingTarget.fixUpVariableReferences();\n        } // Update the VM user's knowledge of targets and blocks on the workspace.\n        _this4.emitTargetsUpdate(false\n        /* Don't emit project change */\n        );\n        _this4.emitWorkspaceUpdate();\n        _this4.runtime.setEditingTarget(_this4.editingTarget);\n        _this4.runtime.ioDevices.cloud.setStage(_this4.runtime.getTargetForStage());\n      });\n    }\n    /**\n     * Add a sprite, this could be .sprite2 or .sprite3. Unpack and validate\n     * such a file first.\n     * @param {string | object} input A json string, object, or ArrayBuffer representing the project to load.\n     * @return {!Promise} Promise that resolves after targets are installed.\n     */\n  }, {\n    key: \"addSprite\",\n    value: function addSprite(input) {\n      var _this5 = this;\n      var errorPrefix = 'Sprite Upload Error:';\n      if (_typeof(input) === 'object' && !(input instanceof ArrayBuffer) && !ArrayBuffer.isView(input)) {\n        // If the input is an object and not any ArrayBuffer\n        // or an ArrayBuffer view (this includes all typed arrays and DataViews)\n        // turn the object into a JSON string, because we suspect\n        // this is a project.json as an object\n        // validate expects a string or buffer as input\n        // TODO not sure if we need to check that it also isn't a data view\n        input = JSON.stringify(input);\n      }\n      var validationPromise = new Promise(function (resolve, reject) {\n        var validate = __webpack_require__(454); // The second argument of true below indicates to the parser/validator\n        // that the given input should be treated as a single sprite and not\n        // an entire project\n        validate(input, true, function (error, res) {\n          if (error) return reject(error);\n          resolve(res);\n        });\n      });\n      scratchStatus(\"BACKUPNEEDED\");\n      return validationPromise.then(function (validatedInput) {\n        var projectVersion = validatedInput[0].projectVersion;\n        if (projectVersion === 2) {\n          return _this5._addSprite2(validatedInput[0], validatedInput[1]);\n        }\n        if (projectVersion === 3) {\n          return _this5._addSprite3(validatedInput[0], validatedInput[1]);\n        }\n        return Promise.reject(\"\".concat(errorPrefix, \" Unable to verify sprite version.\"));\n      }).then(function () {\n        return _this5.runtime.emitProjectChanged();\n      }).catch(function (error) {\n        // Intentionally rejecting here (want errors to be handled by caller)\n        if (error.hasOwnProperty('validationError')) {\n       sError(JSON.stringify(error));\n          return Promise.reject(JSON.stringify(error));\n        }\n        return Promise.reject(\"\".concat(errorPrefix, \" \").concat(error));\n      });\n    }\n    /**\n     * Add a single sprite from the \"Sprite2\" (i.e., SB2 sprite) format.\n     * @param {object} sprite Object representing 2.0 sprite to be added.\n     * @param {?ArrayBuffer} zip Optional zip of assets being referenced by json\n     * @returns {Promise} Promise that resolves after the sprite is added\n     */\n  }, {\n    key: \"_addSprite2\",\n    value: function _addSprite2(sprite, zip) {\n      var _this6 = this;\n      // Validate & parse\n      var sb2 = __webpack_require__(481);\n      return sb2.deserialize(sprite, this.runtime, true, zip).then(function (_ref2) {\n        var targets = _ref2.targets,\n            extensions = _ref2.extensions;\n        return _this6.installTargets(targets, extensions, false);\n      });\n    }\n    /**\n     * Add a single sb3 sprite.\n     * @param {object} sprite Object rperesenting 3.0 sprite to be added.\n     * @param {?ArrayBuffer} zip Optional zip of assets being referenced by target json\n     * @returns {Promise} Promise that resolves after the sprite is added\n     */\n  }, {\n    key: \"_addSprite3\",\n    value: function _addSprite3(sprite, zip) {\n      var _this7 = this;\n      // Validate & parse\n      var sb3 = __webpack_require__(186);\n      return sb3.deserialize(sprite, this.runtime, zip, true).then(function (_ref3) {\n        var targets = _ref3.targets,\n            extensions = _ref3.extensions;\n        return _this7.installTargets(targets, extensions, false);\n      });\n    }\n    /**\n     * Add a costume to the current editing target.\n     * @param {string} md5ext - the MD5 and extension of the costume to be loaded.\n     * @param {!object} costumeObject Object representing the costume.\n     * @property {int} skinId - the ID of the costume's render skin, once installed.\n     * @property {number} rotationCenterX - the X component of the costume's origin.\n     * @property {number} rotationCenterY - the Y component of the costume's origin.\n     * @property {number} [bitmapResolution] - the resolution scale for a bitmap costume.\n     * @param {string} optTargetId - the id of the target to add to, if not the editing target.\n     * @param {string} optVersion - if this is 2, load costume as sb2, otherwise load costume as sb3.\n     * @returns {?Promise} - a promise that resolves when the costume has been added\n     */\n  }, {\n    key: \"addCostume\",\n    value: function addCostume(md5ext, costumeObject, optTargetId, optVersion) {\n      var _this8 = this;\n      var target = optTargetId ? this.runtime.getTargetById(optTargetId) : this.editingTarget;\n      if (target) {\n      scratchStatus(\"BACKUPNEEDED\");\n        return loadCostume(md5ext, costumeObject, this.runtime, optVersion).then(function () {\n          target.addCostume(costumeObject);\n          target.setCostume(target.getCostumes().length - 1);\n          _this8.runtime.emitProjectChanged();\n        });\n      } // If the target cannot be found by id, return a rejected promise\n      return Promise.reject();\n    }\n    /**\n     * Add a costume loaded from the library to the current editing target.\n     * @param {string} md5ext - the MD5 and extension of the costume to be loaded.\n     * @param {!object} costumeObject Object representing the costume.\n     * @property {int} skinId - the ID of the costume's render skin, once installed.\n     * @property {number} rotationCenterX - the X component of the costume's origin.\n     * @property {number} rotationCenterY - the Y component of the costume's origin.\n     * @property {number} [bitmapResolution] - the resolution scale for a bitmap costume.\n     * @returns {?Promise} - a promise that resolves when the costume has been added\n     */\n  }, {\n    key: \"addCostumeFromLibrary\",\n    value: function addCostumeFromLibrary(md5ext, costumeObject) {\n      if (!this.editingTarget) return Promise.reject();\n      return this.addCostume(md5ext, costumeObject, this.editingTarget.id, 2\n      /* optVersion */\n      );\n    }\n    /**\n     * Duplicate the costume at the given index. Add it at that index + 1.\n     * @param {!int} costumeIndex Index of costume to duplicate\n     * @returns {?Promise} - a promise that resolves when the costume has been decoded and added\n     */\n  }, {\n    key: \"duplicateCostume\",\n    value: function duplicateCostume(costumeIndex) {\n      var _this9 = this;\n      var originalCostume = this.editingTarget.getCostumes()[costumeIndex];\n      var clone = Object.assign({}, originalCostume);\n      var md5ext = \"\".concat(clone.assetId, \".\").concat(clone.dataFormat);\n      return loadCostume(md5ext, clone, this.runtime).then(function () {\n        _this9.editingTarget.addCostume(clone, costumeIndex + 1);\n        _this9.editingTarget.setCostume(costumeIndex + 1);\n        _this9.emitTargetsUpdate();\n      });\n    }\n    /**\n     * Duplicate the sound at the given index. Add it at that index + 1.\n     * @param {!int} soundIndex Index of sound to duplicate\n     * @returns {?Promise} - a promise that resolves when the sound has been decoded and added\n     */\n  }, {\n    key: \"duplicateSound\",\n    value: function duplicateSound(soundIndex) {\n      var _this10 = this;\n      var originalSound = this.editingTarget.getSounds()[soundIndex];\n      var clone = Object.assign({}, originalSound);\n      return loadSound(clone, this.runtime, this.editingTarget.sprite.soundBank).then(function () {\n        _this10.editingTarget.addSound(clone, soundIndex + 1);\n        _this10.emitTargetsUpdate();\n      });\n    }\n    /**\n     * Rename a costume on the current editing target.\n     * @param {int} costumeIndex - the index of the costume to be renamed.\n     * @param {string} newName - the desired new name of the costume (will be modified if already in use).\n     */\n  }, {\n    key: \"renameCostume\",\n    value: function renameCostume(costumeIndex, newName) {\n      this.editingTarget.renameCostume(costumeIndex, newName);\n      this.emitTargetsUpdate();\n    }\n    /**\n     * Delete a costume from the current editing target.\n     * @param {int} costumeIndex - the index of the costume to be removed.\n     * @return {?function} A function to restore the deleted costume, or null,\n     * if no costume was deleted.\n     */\n  }, {\n    key: \"deleteCostume\",\n    value: function deleteCostume(costumeIndex) {\n      var _this11 = this;\n      var deletedCostume = this.editingTarget.deleteCostume(costumeIndex);\n      if (deletedCostume) {\n        var target = this.editingTarget;\n        this.runtime.emitProjectChanged();\n        return function () {\n          target.addCostume(deletedCostume);\n          _this11.emitTargetsUpdate();\n        };\n      }\n      return null;\n    }\n    /**\n     * Add a sound to the current editing target.\n     * @param {!object} soundObject Object representing the costume.\n     * @param {string} optTargetId - the id of the target to add to, if not the editing target.\n     * @returns {?Promise} - a promise that resolves when the sound has been decoded and added\n     */\n  }, {\n    key: \"addSound\",\n    value: function addSound(soundObject, optTargetId) {\n      var _this12 = this;\n      var target = optTargetId ? this.runtime.getTargetById(optTargetId) : this.editingTarget;\n      if (target) {\n        return loadSound(soundObject, this.runtime, target.sprite.soundBank).then(function () {\n          target.addSound(soundObject);\n          _this12.emitTargetsUpdate();\n        });\n      } // If the target cannot be found by id, return a rejected promise\n      return new Promise.reject();\n    }\n    /**\n     * Rename a sound on the current editing target.\n     * @param {int} soundIndex - the index of the sound to be renamed.\n     * @param {string} newName - the desired new name of the sound (will be modified if already in use).\n     */\n  }, {\n    key: \"renameSound\",\n    value: function renameSound(soundIndex, newName) {\n      this.editingTarget.renameSound(soundIndex, newName);\n      this.emitTargetsUpdate();\n    }\n    /**\n     * Get a sound buffer from the audio engine.\n     * @param {int} soundIndex - the index of the sound to be got.\n     * @return {AudioBuffer} the sound's audio buffer.\n     */\n  }, {\n    key: \"getSoundBuffer\",\n    value: function getSoundBuffer(soundIndex) {\n      var id = this.editingTarget.sprite.sounds[soundIndex].soundId;\n      if (id && this.runtime && this.runtime.audioEngine) {\n        return this.editingTarget.sprite.soundBank.getSoundPlayer(id).buffer;\n      }\n      return null;\n    }\n    /**\n     * Update a sound buffer.\n     * @param {int} soundIndex - the index of the sound to be updated.\n     * @param {AudioBuffer} newBuffer - new audio buffer for the audio engine.\n     * @param {ArrayBuffer} soundEncoding - the new (wav) encoded sound to be stored\n     */\n  }, {\n    key: \"updateSoundBuffer\",\n    value: function updateSoundBuffer(soundIndex, newBuffer, soundEncoding) {\n      var sound = this.editingTarget.sprite.sounds[soundIndex];\n      var id = sound ? sound.soundId : null;\n      if (id && this.runtime && this.runtime.audioEngine) {\n        this.editingTarget.sprite.soundBank.getSoundPlayer(id).buffer = newBuffer;\n      } // Update sound in runtime\n      if (soundEncoding) {\n        // Now that we updated the sound, the format should also be updated\n        // so that the sound can eventually be decoded the right way.\n        // Sounds that were formerly 'adpcm', but were updated in sound editor\n        // will not get decoded by the audio engine correctly unless the format\n        // is updated as below.\n        sound.format = '';\n        var storage = this.runtime.storage;\n        sound.asset = storage.createAsset(storage.AssetType.Sound, storage.DataFormat.WAV, soundEncoding, null, true // generate md5\n        );\n        sound.assetId = sound.asset.assetId;\n        sound.dataFormat = storage.DataFormat.WAV;\n        sound.md5 = \"\".concat(sound.assetId, \".\").concat(sound.dataFormat);\n        sound.sampleCount = newBuffer.length;\n        sound.rate = newBuffer.sampleRate;\n      } // If soundEncoding is null, it's because gui had a problem\n      // encoding the updated sound. We don't want to store anything in this\n      // case, and gui should have logged an error.\n      this.emitTargetsUpdate();\n    }\n    /**\n     * Delete a sound from the current editing target.\n     * @param {int} soundIndex - the index of the sound to be removed.\n     * @return {?Function} A function to restore the sound that was deleted,\n     * or null, if no sound was deleted.\n     */\n  }, {\n    key: \"deleteSound\",\n    value: function deleteSound(soundIndex) {\n      var _this13 = this;\n      var target = this.editingTarget;\n      var deletedSound = this.editingTarget.deleteSound(soundIndex);\n      if (deletedSound) {\n        this.runtime.emitProjectChanged();\n        var restoreFun = function restoreFun() {\n          target.addSound(deletedSound);\n          _this13.emitTargetsUpdate();\n        };\n        return restoreFun;\n      }\n      return null;\n    }\n    /**\n     * Get a string representation of the image from storage.\n     * @param {int} costumeIndex - the index of the costume to be got.\n     * @return {string} the costume's SVG string if it's SVG,\n     *     a dataURI if it's a PNG or JPG, or null if it couldn't be found or decoded.\n     */\n  }, {\n    key: \"getCostume\",\n    value: function getCostume(costumeIndex) {\n      var asset = this.editingTarget.getCostumes()[costumeIndex].asset;\n      if (!asset || !this.runtime || !this.runtime.storage) return null;\n      var format = asset.dataFormat;\n      if (format === this.runtime.storage.DataFormat.SVG) {\n        return asset.decodeText();\n      } else if (format === this.runtime.storage.DataFormat.PNG || format === this.runtime.storage.DataFormat.JPG) {\n        return asset.encodeDataURI();\n      }\n      log.error(\"Unhandled format: \".concat(asset.dataFormat));\n      return null;\n    }\n    /**\n     * Update a costume with the given bitmap\n     * @param {!int} costumeIndex - the index of the costume to be updated.\n     * @param {!ImageData} bitmap - new bitmap for the renderer.\n     * @param {!number} rotationCenterX x of point about which the costume rotates, relative to its upper left corner\n     * @param {!number} rotationCenterY y of point about which the costume rotates, relative to its upper left corner\n     * @param {!number} bitmapResolution 1 for bitmaps that have 1 pixel per unit of stage,\n     *     2 for double-resolution bitmaps\n     */\n  }, {\n    key: \"updateBitmap\",\n    value: function updateBitmap(costumeIndex, bitmap, rotationCenterX, rotationCenterY, bitmapResolution) {\n      var _this14 = this;\n      var costume = this.editingTarget.getCostumes()[costumeIndex];\n      if (!(costume && this.runtime && this.runtime.renderer)) return;\n      costume.rotationCenterX = rotationCenterX;\n      costume.rotationCenterY = rotationCenterY; // If the bitmap originally had a zero width or height, use that value\n      var bitmapWidth = bitmap.sourceWidth === 0 ? 0 : bitmap.width;\n      var bitmapHeight = bitmap.sourceHeight === 0 ? 0 : bitmap.height; // @todo: updateBitmapSkin does not take ImageData\n      var canvas = document.createElement('canvas');\n      canvas.width = bitmapWidth;\n      canvas.height = bitmapHeight;\n      var context = canvas.getContext('2d',{willReadFrequently:true});\n      context.putImageData(bitmap, 0, 0); // Divide by resolution because the renderer's definition of the rotation center\n      // is the rotation center divided by the bitmap resolution\n      this.runtime.renderer.updateBitmapSkin(costume.skinId, canvas, bitmapResolution, [rotationCenterX / bitmapResolution, rotationCenterY / bitmapResolution]); // @todo there should be a better way to get from ImageData to a decodable storage format\n      canvas.toBlob(function (blob) {\n        var reader = new FileReader();\n        reader.addEventListener('loadend', function () {\n          var storage = _this14.runtime.storage;\n          costume.dataFormat = storage.DataFormat.PNG;\n          costume.bitmapResolution = bitmapResolution;\n          costume.size = [bitmapWidth, bitmapHeight];\n          costume.asset = storage.createAsset(storage.AssetType.ImageBitmap, costume.dataFormat, Buffer.from(reader.result), null, // id\n          true // generate md5\n          );\n          costume.assetId = costume.asset.assetId;\n          costume.md5 = \"\".concat(costume.assetId, \".\").concat(costume.dataFormat);\n          _this14.emitTargetsUpdate();\n        }); // Bitmaps with a zero width or height return null for their blob\n        if (blob) {\n          reader.readAsArrayBuffer(blob);\n        }\n      });\n    }\n    /**\n     * Update a costume with the given SVG\n     * @param {int} costumeIndex - the index of the costume to be updated.\n     * @param {string} svg - new SVG for the renderer.\n     * @param {number} rotationCenterX x of point about which the costume rotates, relative to its upper left corner\n     * @param {number} rotationCenterY y of point about which the costume rotates, relative to its upper left corner\n     */\n  }, {\n    key: \"updateSvg\",\n    value: function updateSvg(costumeIndex, svg, rotationCenterX, rotationCenterY) {\n      var costume = this.editingTarget.getCostumes()[costumeIndex];\n      if (costume && this.runtime && this.runtime.renderer) {\n        costume.rotationCenterX = rotationCenterX;\n        costume.rotationCenterY = rotationCenterY;\n        this.runtime.renderer.updateSVGSkin(costume.skinId, svg, [rotationCenterX, rotationCenterY]);\n        costume.size = this.runtime.renderer.getSkinSize(costume.skinId);\n      }\n      var storage = this.runtime.storage; // If we're in here, we've edited an svg in the vector editor,\n      // so the dataFormat should be 'svg'\n      costume.dataFormat = storage.DataFormat.SVG;\n      costume.bitmapResolution = 1;\n      costume.asset = storage.createAsset(storage.AssetType.ImageVector, costume.dataFormat, new _TextEncoder().encode(svg), null, true // generate md5\n      );\n      costume.assetId = costume.asset.assetId;\n      costume.md5 = \"\".concat(costume.assetId, \".\").concat(costume.dataFormat);\n      this.emitTargetsUpdate();\n    }\n    /**\n     * Add a backdrop to the stage.\n     * @param {string} md5ext - the MD5 and extension of the backdrop to be loaded.\n     * @param {!object} backdropObject Object representing the backdrop.\n     * @property {int} skinId - the ID of the backdrop's render skin, once installed.\n     * @property {number} rotationCenterX - the X component of the backdrop's origin.\n     * @property {number} rotationCenterY - the Y component of the backdrop's origin.\n     * @property {number} [bitmapResolution] - the resolution scale for a bitmap backdrop.\n     * @returns {?Promise} - a promise that resolves when the backdrop has been added\n     */\n  }, {\n    key: \"addBackdrop\",\n    value: function addBackdrop(md5ext, backdropObject) {\n      var _this15 = this;\n      return loadCostume(md5ext, backdropObject, this.runtime).then(function () {\n        var stage = _this15.runtime.getTargetForStage();\n        stage.addCostume(backdropObject);\n        stage.setCostume(stage.getCostumes().length - 1);\n        _this15.runtime.emitProjectChanged();\n      });\n    }\n    /**\n     * Rename a sprite.\n     * @param {string} targetId ID of a target whose sprite to rename.\n     * @param {string} newName New name of the sprite.\n     */\n  }, {\n    key: \"renameSprite\",\n    value: function renameSprite(targetId, newName) {\n      var target = this.runtime.getTargetById(targetId);\n      if (target) {\n        if (!target.isSprite()) {\n          throw new Error('Cannot rename non-sprite targets.');\n        }\n        var sprite = target.sprite;\n        if (!sprite) {\n          throw new Error('No sprite associated with this target.');\n        }\n        if (newName && RESERVED_NAMES.indexOf(newName) === -1) {\n          var names = this.runtime.targets.filter(function (runtimeTarget) {\n            return runtimeTarget.isSprite() && runtimeTarget.id !== target.id;\n          }).map(function (runtimeTarget) {\n            return runtimeTarget.sprite.name;\n          });\n          var oldName = sprite.name;\n          var newUnusedName = StringUtil.unusedName(newName, names);\n          sprite.name = newUnusedName;\n          var allTargets = this.runtime.targets;\n          for (var i = 0; i < allTargets.length; i++) {\n            var currTarget = allTargets[i];\n            currTarget.blocks.updateAssetName(oldName, newName, 'sprite');\n          }\n          if (newUnusedName !== oldName) this.emitTargetsUpdate();\n        }\n      } else {\n        throw new Error('No target with the provided id.');\n      }\n    }\n    /**\n     * Delete a sprite and all its clones.\n     * @param {string} targetId ID of a target whose sprite to delete.\n     * @return {Function} Returns a function to restore the sprite that was deleted\n     */\n  }, {\n    key: \"deleteSprite\",\n    value: function deleteSprite(targetId) {\n      var _this16 = this;\n      var target = this.runtime.getTargetById(targetId);\n      if (target) {\n        var targetIndexBeforeDelete = this.runtime.targets.map(function (t) {\n          return t.id;\n        }).indexOf(target.id);\n        if (!target.isSprite()) {\n          throw new Error('Cannot delete non-sprite targets.');\n        }\n        var sprite = target.sprite;\n        if (!sprite) {\n          throw new Error('No sprite associated with this target.');\n        }\n        var spritePromise = this.exportSprite(targetId, 'uint8array');\n        var restoreSprite = function restoreSprite() {\n          return spritePromise.then(function (spriteBuffer) {\n            return _this16.addSprite(spriteBuffer);\n          });\n        }; // Remove monitors from the runtime state and remove the\n        // target-specific monitored blocks (e.g. local variables)\n        target.deleteMonitors();\n        var currentEditingTarget = this.editingTarget;\n        for (var i = 0; i < sprite.clones.length; i++) {\n          var clone = sprite.clones[i];\n          this.runtime.stopForTarget(sprite.clones[i]);\n          this.runtime.disposeTarget(sprite.clones[i]); // Ensure editing target is switched if we are deleting it.\n          if (clone === currentEditingTarget) {\n            var nextTargetIndex = Math.min(this.runtime.targets.length - 1, targetIndexBeforeDelete);\n            if (this.runtime.targets.length > 0) {\n              this.setEditingTarget(this.runtime.targets[nextTargetIndex].id);\n            } else {\n              this.editingTarget = null;\n            }\n          }\n        } // Sprite object should be deleted by GC.\n      scratchStatus(\"BACKUPNEEDED\");        this.emitTargetsUpdate();\n        return restoreSprite;\n      }\n      throw new Error('No target with the provided id.');\n    }\n    /**\n     * Duplicate a sprite.\n     * @param {string} targetId ID of a target whose sprite to duplicate.\n     * @returns {Promise} Promise that resolves when duplicated target has\n     *     been added to the runtime.\n     */\n  }, {\n    key: \"duplicateSprite\",\n    value: function duplicateSprite(targetId) {\n      var _this17 = this;\n      var target = this.runtime.getTargetById(targetId);\n      if (!target) {\n        throw new Error('No target with the provided id.');\n      } else if (!target.isSprite()) {\n        throw new Error('Cannot duplicate non-sprite targets.');\n      } else if (!target.sprite) {\n        throw new Error('No sprite associated with this target.');\n      }\n      return target.duplicate().then(function (newTarget) {\n        _this17.runtime.addTarget(newTarget);\n        newTarget.goBehindOther(target);\n        _this17.setEditingTarget(newTarget.id);\n      });\n    }\n    /**\n     * Set the audio engine for the VM/runtime\n     * @param {!AudioEngine} audioEngine The audio engine to attach\n     */\n  }, {\n    key: \"attachAudioEngine\",\n    value: function attachAudioEngine(audioEngine) {\n      this.runtime.attachAudioEngine(audioEngine);\n    }\n    /**\n     * Set the renderer for the VM/runtime\n     * @param {!RenderWebGL} renderer The renderer to attach\n     */\n  }, {\n    key: \"attachRenderer\",\n    value: function attachRenderer(renderer) {\n      this.runtime.attachRenderer(renderer);\n    }\n    /**\n     * @returns {RenderWebGL} The renderer attached to the vm\n     */\n  }, {\n    key: \"attachV2SVGAdapter\",\n    /**\n     * Set the svg adapter for the VM/runtime, which converts scratch 2 svgs to scratch 3 svgs\n     * @param {!SvgRenderer} svgAdapter The adapter to attach\n     */\n    value: function attachV2SVGAdapter(svgAdapter) {\n      this.runtime.attachV2SVGAdapter(svgAdapter);\n    }\n    /**\n     * Set the bitmap adapter for the VM/runtime, which converts scratch 2\n     * bitmaps to scratch 3 bitmaps. (Scratch 3 bitmaps are all bitmap resolution 2)\n     * @param {!function} bitmapAdapter The adapter to attach\n     */\n  }, {\n    key: \"attachV2BitmapAdapter\",\n    value: function attachV2BitmapAdapter(bitmapAdapter) {\n      this.runtime.attachV2BitmapAdapter(bitmapAdapter);\n    }\n    /**\n     * Set the storage module for the VM/runtime\n     * @param {!ScratchStorage} storage The storage module to attach\n     */\n  }, {\n    key: \"attachStorage\",\n    value: function attachStorage(storage) {\n      this.runtime.attachStorage(storage);\n    }\n    /**\n     * set the current locale and builtin messages for the VM\n     * @param {!string} locale       current locale\n     * @param {!object} messages     builtin messages map for current locale\n     * @returns {Promise} Promise that resolves when all the blocks have been\n     *     updated for a new locale (or empty if locale hasn't changed.)\n     */\n  }, {\n    key: \"setLocale\",\n    value: function setLocale(locale, messages) {\n      if (locale !== formatMessage.setup().locale) {\n        formatMessage.setup({\n          locale: locale,\n          translations: _defineProperty({}, locale, messages)\n        });\n      }\n      scratchStatus(\"SETLOCALE\");\n      return this.extensionManager.refreshBlocks();\n    }\n    /**\n     * get the current locale for the VM\n     * @returns {string} the current locale in the VM\n     */\n  }, {\n    key: \"getLocale\",\n    value: function getLocale() {\n      return formatMessage.setup().locale;\n    }\n    /**\n     * Handle a Blockly event for the current editing target.\n     * @param {!Blockly.Event} e Any Blockly event.\n     */\n  }, {\n    key: \"blockListener\",\n    value: function blockListener(e) {\n      if (this.editingTarget) {\n        this.editingTarget.blocks.blocklyListen(e);\n      }\n    }\n    /**\n     * Handle a Blockly event for the flyouut.\n     * @param {!Blockly.Event} e Any Blockly event.\n     */\n  }, {\n    key: \"flyoutBlockListener\",\n    value: function flyoutBlockListener(e) {\n      this.runtime.flyoutBlocks.blocklyListen(e);\n    }\n    /**\n     * Handle a Blockly event for the flyout to be passed to the monitor container.\n     * @param {!Blockly.Event} e Any Blockly event.\n     */\n  }, {\n    key: \"monitorBlockListener\",\n    value: function monitorBlockListener(e) {\n      // Filter events by type, since monitor blocks only need to listen to these events.\n      // Monitor blocks shouldn't be destroyed when flyout blocks are deleted.\n      if (['create', 'change'].indexOf(e.type) !== -1) {\n        this.runtime.monitorBlocks.blocklyListen(e);\n      }\n    }\n    /**\n     * Handle a Blockly event for the variable map.\n     * @param {!Blockly.Event} e Any Blockly event.\n     */\n  }, {\n    key: \"variableListener\",\n    value: function variableListener(e) {\n      // Filter events by type, since blocks only needs to listen to these\n      // var events.\n      if (['var_create', 'var_rename', 'var_delete'].indexOf(e.type) !== -1) {\n        this.runtime.getTargetForStage().blocks.blocklyListen(e);\n      }\n    }\n    /**\n     * Set an editing target. An editor UI can use this function to switch\n     * between editing different targets, sprites, etc.\n     * After switching the editing target, the VM may emit updates\n     * to the list of targets and any attached workspace blocks\n     * (see `emitTargetsUpdate` and `emitWorkspaceUpdate`).\n     * @param {string} targetId Id of target to set as editing.\n     */\n  }, {\n    key: \"setEditingTarget\",\n    value: function setEditingTarget(targetId) {\n      // Has the target id changed? If not, exit.\n      if (this.editingTarget && targetId === this.editingTarget.id) {\n        return;\n      }\n      var target = this.runtime.getTargetById(targetId);\n      if (target) {\n        this.editingTarget = target; // Emit appropriate UI updates.\n        this.emitTargetsUpdate(false\n        /* Don't emit project change */\n        );\n        this.emitWorkspaceUpdate();\n        this.runtime.setEditingTarget(target);\n      }\n    }\n    /**\n     * Called when blocks are dragged from one sprite to another. Adds the blocks to the\n     * workspace of the given target.\n     * @param {!Array<object>} blocks Blocks to add.\n     * @param {!string} targetId Id of target to add blocks to.\n     * @param {?string} optFromTargetId Optional target id indicating that blocks are being\n     * shared from that target. This is needed for resolving any potential variable conflicts.\n     * @return {!Promise} Promise that resolves when the extensions and blocks have been added.\n     */\n  }, {\n    key: \"shareBlocksToTarget\",\n    value: function shareBlocksToTarget(blocks, targetId, optFromTargetId) {\n      var _this18 = this;\n      var sb3 = __webpack_require__(186);\n      var copiedBlocks = JSON.parse(JSON.stringify(blocks));\n      newBlockIds(copiedBlocks);\n      var target = this.runtime.getTargetById(targetId);\n      if (optFromTargetId) {\n        // If the blocks are being shared from another target,\n        // resolve any possible variable conflicts that may arise.\n        var fromTarget = this.runtime.getTargetById(optFromTargetId);\n        fromTarget.resolveVariableSharingConflictsWithTarget(copiedBlocks, target);\n      } // Create a unique set of extensionIds that are not yet loaded\n      var extensionIDs = new Set(copiedBlocks.map(function (b) {\n        return sb3.getExtensionIdForOpcode(b.opcode);\n      }).filter(function (id) {\n        return !!id;\n      }) // Remove ids that do not exist\n      .filter(function (id) {\n        return !_this18.extensionManager.isExtensionLoaded(id);\n      }) // and remove loaded extensions\n      ); // Create an array promises for extensions to load\n      var extensionPromises = Array.from(extensionIDs, function (id) {\n        return _this18.extensionManager.loadExtensionURL(id);\n      });\n      return Promise.all(extensionPromises).then(function () {\n        copiedBlocks.forEach(function (block) {\n          target.blocks.createBlock(block);\n        });\n        target.blocks.updateTargetSpecificBlocks(target.isStage);\n      });\n    }\n    /**\n     * Called when costumes are dragged from editing target to another target.\n     * Sets the newly added costume as the current costume.\n     * @param {!number} costumeIndex Index of the costume of the editing target to share.\n     * @param {!string} targetId Id of target to add the costume.\n     * @return {Promise} Promise that resolves when the new costume has been loaded.\n     */\n  }, {\n    key: \"shareCostumeToTarget\",\n    value: function shareCostumeToTarget(costumeIndex, targetId) {\n      var _this19 = this;\n      var originalCostume = this.editingTarget.getCostumes()[costumeIndex];\n      var clone = Object.assign({}, originalCostume);\n      var md5ext = \"\".concat(clone.assetId, \".\").concat(clone.dataFormat);\n      return loadCostume(md5ext, clone, this.runtime).then(function () {\n        var target = _this19.runtime.getTargetById(targetId);\n        if (target) {\n          target.addCostume(clone);\n          target.setCostume(target.getCostumes().length - 1);\n        }\n      });\n    }\n    /**\n     * Called when sounds are dragged from editing target to another target.\n     * @param {!number} soundIndex Index of the sound of the editing target to share.\n     * @param {!string} targetId Id of target to add the sound.\n     * @return {Promise} Promise that resolves when the new sound has been loaded.\n     */\n  }, {\n    key: \"shareSoundToTarget\",\n    value: function shareSoundToTarget(soundIndex, targetId) {\n      var _this20 = this;\n      var originalSound = this.editingTarget.getSounds()[soundIndex];\n      var clone = Object.assign({}, originalSound);\n      var target = this.runtime.getTargetById(targetId);\n      return loadSound(clone, this.runtime, target.sprite.soundBank).then(function () {\n        if (target) {\n          target.addSound(clone);\n          _this20.emitTargetsUpdate();\n        }\n      });\n    }\n    /**\n     * Repopulate the workspace with the blocks of the current editingTarget. This\n     * allows us to get around bugs like gui#413.\n     */\n  }, {\n    key: \"refreshWorkspace\",\n    value: function refreshWorkspace() {\n      if (this.editingTarget) {\n        this.emitWorkspaceUpdate();\n        this.runtime.setEditingTarget(this.editingTarget);\n        this.emitTargetsUpdate(false\n        /* Don't emit project change */\n        );\n      }\n    }\n    /**\n     * Emit metadata about available targets.\n     * An editor UI could use this to display a list of targets and show\n     * the currently editing one.\n     * @param {bool} triggerProjectChange If true, also emit a project changed event.\n     * Disabled selectively by updates that don't affect project serialization.\n     * Defaults to true.\n     */\n  }, {\n    key: \"emitTargetsUpdate\",\n    value: function emitTargetsUpdate(triggerProjectChange) {\n      if (typeof triggerProjectChange === 'undefined') triggerProjectChange = true;\n      this.emit('targetsUpdate', {\n        // [[target id, human readable target name], ...].\n        targetList: this.runtime.targets.filter( // Don't report clones.\n        function (target) {\n          return !target.hasOwnProperty('isOriginal') || target.isOriginal;\n        }).map(function (target) {\n          return target.toJSON();\n        }),\n        // Currently editing target id.\n        editingTarget: this.editingTarget ? this.editingTarget.id : null\n      });\n      if (triggerProjectChange) {\n        this.runtime.emitProjectChanged();\n      }\n    }\n    /**\n     * Emit an Blockly/scratch-blocks compatible XML representation\n     * of the current editing target's blocks.\n     */\n  }, {\n    key: \"emitWorkspaceUpdate\",\n    value: function emitWorkspaceUpdate() {\n      var _this21 = this;\n      // Create a list of broadcast message Ids according to the stage variables\n      var stageVariables = this.runtime.getTargetForStage().variables;\n      var messageIds = [];\n      for (var varId in stageVariables) {\n        if (stageVariables[varId].type === Variable.BROADCAST_MESSAGE_TYPE) {\n          messageIds.push(varId);\n        }\n      } // Go through all blocks on all targets, removing referenced\n      // broadcast ids from the list.\n      for (var i = 0; i < this.runtime.targets.length; i++) {\n        var currTarget = this.runtime.targets[i];\n        var currBlocks = currTarget.blocks._blocks;\n        for (var blockId in currBlocks) {\n          if (currBlocks[blockId].fields.BROADCAST_OPTION) {\n            var id = currBlocks[blockId].fields.BROADCAST_OPTION.id;\n            var index = messageIds.indexOf(id);\n            if (index !== -1) {\n              messageIds = messageIds.slice(0, index).concat(messageIds.slice(index + 1));\n            }\n          }\n        }\n      } // Anything left in messageIds is not referenced by a block, so delete it.\n      for (var _i = 0; _i < messageIds.length; _i++) {\n        var _id = messageIds[_i];\n        delete this.runtime.getTargetForStage().variables[_id];\n      }\n      var globalVarMap = Object.assign({}, this.runtime.getTargetForStage().variables);\n      var localVarMap = this.editingTarget.isStage ? Object.create(null) : Object.assign({}, this.editingTarget.variables);\n      var globalVariables = Object.keys(globalVarMap).map(function (k) {\n        return globalVarMap[k];\n      });\n      var localVariables = Object.keys(localVarMap).map(function (k) {\n        return localVarMap[k];\n      });\n      var workspaceComments = Object.keys(this.editingTarget.comments).map(function (k) {\n        return _this21.editingTarget.comments[k];\n      }).filter(function (c) {\n        return c.blockId === null;\n      });\n      var xmlString = \"<xml xmlns=\\\"http://www.w3.org/1999/xhtml\\\">\\n                            <variables>\\n                                \".concat(globalVariables.map(function (v) {\n        return v.toXML();\n      }).join(), \"\\n                                \").concat(localVariables.map(function (v) {\n        return v.toXML(true);\n      }).join(), \"\\n                            </variables>\\n                            \").concat(workspaceComments.map(function (c) {\n        return c.toXML();\n      }).join(), \"\\n                            \").concat(this.editingTarget.blocks.toXML(this.editingTarget.comments), \"\\n                        </xml>\");\n      this.emit('workspaceUpdate', {\n        xml: xmlString\n      });\n    }\n    /**\n     * Get a target id for a drawable id. Useful for interacting with the renderer\n     * @param {int} drawableId The drawable id to request the target id for\n     * @returns {?string} The target id, if found. Will also be null if the target found is the stage.\n     */\n  }, {\n    key: \"getTargetIdForDrawableId\",\n    value: function getTargetIdForDrawableId(drawableId) {\n      var target = this.runtime.getTargetByDrawableId(drawableId);\n      if (target && target.hasOwnProperty('id') && target.hasOwnProperty('isStage') && !target.isStage) {\n        return target.id;\n      }\n      return null;\n    }\n    /**\n     * Reorder target by index. Return whether a change was made.\n     * @param {!string} targetIndex Index of the target.\n     * @param {!number} newIndex index that the target should be moved to.\n     * @returns {boolean} Whether a target was reordered.\n     */\n  }, {\n    key: \"reorderTarget\",\n    value: function reorderTarget(targetIndex, newIndex) {\n      var targets = this.runtime.targets;\n      targetIndex = MathUtil.clamp(targetIndex, 0, targets.length - 1);\n      newIndex = MathUtil.clamp(newIndex, 0, targets.length - 1);\n      if (targetIndex === newIndex) return false;\n      var target = targets[targetIndex];\n      targets = targets.slice(0, targetIndex).concat(targets.slice(targetIndex + 1));\n      targets.splice(newIndex, 0, target);\n      this.runtime.targets = targets;\n      this.emitTargetsUpdate();\n      return true;\n    }\n    /**\n     * Reorder the costumes of a target if it exists. Return whether it succeeded.\n     * @param {!string} targetId ID of the target which owns the costumes.\n     * @param {!number} costumeIndex index of the costume to move.\n     * @param {!number} newIndex index that the costume should be moved to.\n     * @returns {boolean} Whether a costume was reordered.\n     */\n  }, {\n    key: \"reorderCostume\",\n    value: function reorderCostume(targetId, costumeIndex, newIndex) {\n      var target = this.runtime.getTargetById(targetId);\n      if (target) {\n        var reorderSuccessful = target.reorderCostume(costumeIndex, newIndex);\n        if (reorderSuccessful) {\n          this.runtime.emitProjectChanged();\n        }\n        return reorderSuccessful;\n      }\n      return false;\n    }\n    /**\n     * Reorder the sounds of a target if it exists. Return whether it occured.\n     * @param {!string} targetId ID of the target which owns the sounds.\n     * @param {!number} soundIndex index of the sound to move.\n     * @param {!number} newIndex index that the sound should be moved to.\n     * @returns {boolean} Whether a sound was reordered.\n     */\n  }, {\n    key: \"reorderSound\",\n    value: function reorderSound(targetId, soundIndex, newIndex) {\n      var target = this.runtime.getTargetById(targetId);\n      if (target) {\n        var reorderSuccessful = target.reorderSound(soundIndex, newIndex);\n        if (reorderSuccessful) {\n          this.runtime.emitProjectChanged();\n        }\n        return reorderSuccessful;\n      }\n      return false;\n    }\n    /**\n     * Put a target into a \"drag\" state, during which its X/Y positions will be unaffected\n     * by blocks.\n     * @param {string} targetId The id for the target to put into a drag state\n     */\n  }, {\n    key: \"startDrag\",\n    value: function startDrag(targetId) {\n      var target = this.runtime.getTargetById(targetId);\n      if (target) {\n        this._dragTarget = target;\n        target.startDrag();\n      }\n    }\n    /**\n     * Remove a target from a drag state, so blocks may begin affecting X/Y position again\n     * @param {string} targetId The id for the target to remove from the drag state\n     */\n  }, {\n    key: \"stopDrag\",\n    value: function stopDrag(targetId) {\n      var target = this.runtime.getTargetById(targetId);\n      if (target) {\n        this._dragTarget = null;\n        target.stopDrag();\n        this.setEditingTarget(target.sprite && target.sprite.clones[0] ? target.sprite.clones[0].id : target.id);\n      }\n    }\n    /**\n     * Post/edit sprite info for the current editing target or the drag target.\n     * @param {object} data An object with sprite info data to set.\n     */\n  }, {\n    key: \"postSpriteInfo\",\n    value: function postSpriteInfo(data) {\n      if (this._dragTarget) {\n        this._dragTarget.postSpriteInfo(data);\n      } else {\n        this.editingTarget.postSpriteInfo(data);\n      } // Post sprite info means the gui has changed something about a sprite,\n      // either through the sprite info pane fields (e.g. direction, size) or\n      // through dragging a sprite on the stage\n      // Emit a project changed event.\n      this.runtime.emitProjectChanged();\n    }\n    /**\n     * Set a target's variable's value. Return whether it succeeded.\n     * @param {!string} targetId ID of the target which owns the variable.\n     * @param {!string} variableId ID of the variable to set.\n     * @param {!*} value The new value of that variable.\n     * @returns {boolean} whether the target and variable were found and updated.\n     */\n  }, {\n    key: \"setVariableValue\",\n    value: function setVariableValue(targetId, variableId, value) {\n      var target = this.runtime.getTargetById(targetId);\n      if (target) {\n        var variable = target.lookupVariableById(variableId);\n        if (variable) {\n          variable.value = value;\n          if (variable.isCloud) {\n            this.runtime.ioDevices.cloud.requestUpdateVariable(variable.name, variable.value);\n          }\n          return true;\n        }\n      }\n      return false;\n    }\n    /**\n     * Get a target's variable's value. Return null if the target or variable does not exist.\n     * @param {!string} targetId ID of the target which owns the variable.\n     * @param {!string} variableId ID of the variable to set.\n     * @returns {?*} The value of the variable, or null if it could not be looked up.\n     */\n  }, {\n    key: \"getVariableValue\",\n    value: function getVariableValue(targetId, variableId) {\n      var target = this.runtime.getTargetById(targetId);\n      if (target) {\n        var variable = target.lookupVariableById(variableId);\n        if (variable) {\n          return variable.value;\n        }\n      }\n      return null;\n    }\n    /**\n     * Allow VM consumer to configure the ScratchLink socket creator.\n     * @param {Function} factory The custom ScratchLink socket factory.\n     */\n  }, {\n    key: \"configureScratchLinkSocketFactory\",\n    value: function configureScratchLinkSocketFactory(factory) {\n      this.runtime.configureScratchLinkSocketFactory(factory);\n    }\n  }, {\n    key: \"assets\",\n    get: function get() {\n      return this.runtime.targets.reduce(function (acc, target) {\n        return acc.concat(target.sprite.sounds.map(function (sound) {\n          return sound.asset;\n        })).concat(target.sprite.costumes.map(function (costume) {\n          return costume.asset;\n        }));\n      }, []);\n    }\n  }, {\n    key: \"renderer\",\n    get: function get() {\n      return this.runtime && this.runtime.renderer;\n    }\n  }]);\n  return VirtualMachine;\n}(EventEmitter);\nmodule.exports = VirtualMachine;\n })