/* 1086 */\n (function(module, exports, __webpack_require__) {\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nvar Cast = __webpack_require__(48);\nvar Scratch3EventBlocks = function () {\n  function Scratch3EventBlocks(runtime) {\n    var _this = this;\n    _classCallCheck(this, Scratch3EventBlocks);\n    /**\n     * The runtime instantiating this block package.\n     * @type {Runtime}\n     */\n    this.runtime = runtime;\n    this.runtime.on('KEY_PRESSED', function (key) {\n      _this.runtime.startHats('event_whenkeypressed', {\n        KEY_OPTION: key\n      });\n      _this.runtime.startHats('event_whenkeypressed', {\n        KEY_OPTION: 'any'\n      });\n    });\n  }\n  /**\n   * Retrieve the block primitives implemented by this package.\n   * @return {object.<string, Function>} Mapping of opcode to Function.\n   */\n  _createClass(Scratch3EventBlocks, [{\n    key: \"getPrimitives\",\n    value: function getPrimitives() {\n      return {\n        event_whentouchingobject: this.touchingObject,\n        event_broadcast: this.broadcast,\n        event_broadcastandwait: this.broadcastAndWait,\n        event_whengreaterthan: this.hatGreaterThanPredicate\n      };\n    }\n  }, {\n    key: \"getHats\",\n    value: function getHats() {\n      return {\n        event_whenflagclicked: {\n          restartExistingThreads: true\n        },\n        event_whenkeypressed: {\n          restartExistingThreads: false\n        },\n        event_whenthisspriteclicked: {\n          restartExistingThreads: true\n        },\n        event_whentouchingobject: {\n          restartExistingThreads: false,\n          edgeActivated: true\n        },\n        event_whenstageclicked: {\n          restartExistingThreads: true\n        },\n        event_whenbackdropswitchesto: {\n          restartExistingThreads: true\n        },\n        event_whengreaterthan: {\n          restartExistingThreads: false,\n          edgeActivated: true\n        },\n        event_whenbroadcastreceived: {\n          restartExistingThreads: true\n        }\n      };\n    }\n  }, {\n    key: \"touchingObject\",\n    value: function touchingObject(args, util) {\n      return util.target.isTouchingObject(args.TOUCHINGOBJECTMENU);\n    }\n  }, {\n    key: \"hatGreaterThanPredicate\",\n    value: function hatGreaterThanPredicate(args, util) {\n      var option = Cast.toString(args.WHENGREATERTHANMENU).toLowerCase();\n      var value = Cast.toNumber(args.VALUE);\n      switch (option) {\n        case 'timer':\n          return util.ioQuery('clock', 'projectTimer') > value;\n        case 'loudness':\n          return this.runtime.audioEngine && this.runtime.audioEngine.getLoudness() > value;\n      }\n      return false;\n    }\n  }, {\n    key: \"broadcast\",\n    value: function broadcast(args, util) {\n      var broadcastVar = util.runtime.getTargetForStage().lookupBroadcastMsg(args.BROADCAST_OPTION.id, args.BROADCAST_OPTION.name);\n      if (broadcastVar) {\n        var broadcastOption = broadcastVar.name;\n        util.startHats('event_whenbroadcastreceived', {\n          BROADCAST_OPTION: broadcastOption\n        });\n      }\n    }\n  }, {\n    key: \"broadcastAndWait\",\n    value: function broadcastAndWait(args, util) {\n      if (!util.stackFrame.broadcastVar) {\n        util.stackFrame.broadcastVar = util.runtime.getTargetForStage().lookupBroadcastMsg(args.BROADCAST_OPTION.id, args.BROADCAST_OPTION.name);\n      }\n      if (util.stackFrame.broadcastVar) {\n        var broadcastOption = util.stackFrame.broadcastVar.name; // Have we run before, starting threads?\n        if (!util.stackFrame.startedThreads) {\n          // No - start hats for this broadcast.\n          util.stackFrame.startedThreads = util.startHats('event_whenbroadcastreceived', {\n            BROADCAST_OPTION: broadcastOption\n          });\n          if (util.stackFrame.startedThreads.length === 0) {\n            // Nothing was started.\n            return;\n          }\n        } // We've run before; check if the wait is still going on.\n        var instance = this; // Scratch 2 considers threads to be waiting if they are still in\n        // runtime.threads. Threads that have run all their blocks, or are\n        // marked done but still in runtime.threads are still considered to\n        // be waiting.\n        var waiting = util.stackFrame.startedThreads.some(function (thread) {\n          return instance.runtime.threads.indexOf(thread) !== -1;\n        });\n        if (waiting) {\n          // If all threads are waiting for the next tick or later yield\n          // for a tick as well. Otherwise yield until the next loop of\n          // the threads.\n          if (util.stackFrame.startedThreads.every(function (thread) {\n            return instance.runtime.isWaitingThread(thread);\n          })) {\n            util.yieldTick();\n          } else {\n            util.yield();\n          }\n        }\n      }\n    }\n  }]);\n  return Scratch3EventBlocks;\n}();\nmodule.exports = Scratch3EventBlocks;\n })