/* 1085 */\n (function(module, exports, __webpack_require__) {\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nvar Cast = __webpack_require__(48);\nvar Scratch3ControlBlocks = function () {\n  function Scratch3ControlBlocks(runtime) {\n    _classCallCheck(this, Scratch3ControlBlocks);\n    /**\n     * The runtime instantiating this block package.\n     * @type {Runtime}\n     */\n    this.runtime = runtime;\n    /**\n     * The \"counter\" block value. For compatibility with 2.0.\n     * @type {number}\n     */\n    this._counter = 0;\n    this.runtime.on('RUNTIME_DISPOSED', this.clearCounter.bind(this));\n  }\n  /**\n   * Retrieve the block primitives implemented by this package.\n   * @return {object.<string, Function>} Mapping of opcode to Function.\n   */\n  _createClass(Scratch3ControlBlocks, [{\n    key: \"getPrimitives\",\n    value: function getPrimitives() {\n      return {\n        control_repeat: this.repeat,\n        control_repeat_until: this.repeatUntil,\n        control_while: this.repeatWhile,\n        control_for_each: this.forEach,\n        control_forever: this.forever,\n        control_wait: this.wait,\n        control_wait_until: this.waitUntil,\n        control_if: this.if,\n        control_if_else: this.ifElse,\n        control_stop: this.stop,\n        control_create_clone_of: this.createClone,\n        control_delete_this_clone: this.deleteClone,\n        control_get_counter: this.getCounter,\n        control_incr_counter: this.incrCounter,\n        control_clear_counter: this.clearCounter,\n        control_all_at_once: this.allAtOnce\n      };\n    }\n  }, {\n    key: \"getHats\",\n    value: function getHats() {\n      return {\n        control_start_as_clone: {\n          restartExistingThreads: false\n        }\n      };\n    }\n  }, {\n    key: \"repeat\",\n    value: function repeat(args, util) {\n      var times = Math.round(Cast.toNumber(args.TIMES)); // Initialize loop\n      if (typeof util.stackFrame.loopCounter === 'undefined') {\n        util.stackFrame.loopCounter = times;\n      } // Only execute once per frame.\n      // When the branch finishes, `repeat` will be executed again and\n      // the second branch will be taken, yielding for the rest of the frame.\n      // Decrease counter\n      util.stackFrame.loopCounter--; // If we still have some left, start the branch.\n      if (util.stackFrame.loopCounter >= 0) {\n        util.startBranch(1, true);\n      }\n    }\n  }, {\n    key: \"repeatUntil\",\n    value: function repeatUntil(args, util) {\n      var condition = Cast.toBoolean(args.CONDITION); // If the condition is false (repeat UNTIL), start the branch.\n      if (!condition) {\n        util.startBranch(1, true);\n      }\n    }\n  }, {\n    key: \"repeatWhile\",\n    value: function repeatWhile(args, util) {\n      var condition = Cast.toBoolean(args.CONDITION); // If the condition is true (repeat WHILE), start the branch.\n      if (condition) {\n        util.startBranch(1, true);\n      }\n    }\n  }, {\n    key: \"forEach\",\n    value: function forEach(args, util) {\n      var variable = util.target.lookupOrCreateVariable(args.VARIABLE.id, args.VARIABLE.name);\n      if (typeof util.stackFrame.index === 'undefined') {\n        util.stackFrame.index = 0;\n      }\n      if (util.stackFrame.index < Number(args.VALUE)) {\n        util.stackFrame.index++;\n        variable.value = util.stackFrame.index;\n        util.startBranch(1, true);\n      }\n    }\n  }, {\n    key: \"waitUntil\",\n    value: function waitUntil(args, util) {\n      var condition = Cast.toBoolean(args.CONDITION);\n      if (!condition) {\n        util.yield();\n      }\n    }\n  }, {\n    key: \"forever\",\n    value: function forever(args, util) {\n      util.startBranch(1, true);\n    }\n  }, {\n    key: \"wait\",\n    value: function wait(args, util) {\n      if (util.stackTimerNeedsInit()) {\n        var duration = Math.max(0, 1000 * Cast.toNumber(args.DURATION));\n        util.startStackTimer(duration);\n        this.runtime.requestRedraw();\n        util.yield();\n      } else if (!util.stackTimerFinished()) {\n        util.yield();\n      }\n    }\n  }, {\n    key: \"if\",\n    value: function _if(args, util) {\n      var condition = Cast.toBoolean(args.CONDITION);\n      if (condition) {\n        util.startBranch(1, false);\n      }\n    }\n  }, {\n    key: \"ifElse\",\n    value: function ifElse(args, util) {\n      var condition = Cast.toBoolean(args.CONDITION);\n      if (condition) {\n        util.startBranch(1, false);\n      } else {\n        util.startBranch(2, false);\n      }\n    }\n  }, {\n    key: \"stop\",\n    value: function stop(args, util) {\n      var option = args.STOP_OPTION;\n      if (option === 'all') {\n        util.stopAll();\n      } else if (option === 'other scripts in sprite' || option === 'other scripts in stage') {\n        util.stopOtherTargetThreads();\n      } else if (option === 'this script') {\n        util.stopThisScript();\n      }\n    }\n  }, {\n    key: \"createClone\",\n    value: function createClone(args, util) {\n      // Cast argument to string\n      args.CLONE_OPTION = Cast.toString(args.CLONE_OPTION); // Set clone target\n      var cloneTarget;\n      if (args.CLONE_OPTION === '_myself_') {\n        cloneTarget = util.target;\n      } else {\n        cloneTarget = this.runtime.getSpriteTargetByName(args.CLONE_OPTION);\n      } // If clone target is not found, return\n      if (!cloneTarget) return; // Create clone\n      var newClone = cloneTarget.makeClone();\n      if (newClone) {\n        this.runtime.addTarget(newClone); // Place behind the original target.\n        newClone.goBehindOther(cloneTarget);\n      }\n    }\n  }, {\n    key: \"deleteClone\",\n    value: function deleteClone(args, util) {\n      if (util.target.isOriginal) return;\n      this.runtime.disposeTarget(util.target);\n      this.runtime.stopForTarget(util.target);\n    }\n  }, {\n    key: \"getCounter\",\n    value: function getCounter() {\n      return this._counter;\n    }\n  }, {\n    key: \"clearCounter\",\n    value: function clearCounter() {\n      this._counter = 0;\n    }\n  }, {\n    key: \"incrCounter\",\n    value: function incrCounter() {\n      this._counter++;\n    }\n  }, {\n    key: \"allAtOnce\",\n    value: function allAtOnce(args, util) {\n      // Since the \"all at once\" block is implemented for compatiblity with\n      // Scratch 2.0 projects, it behaves the same way it did in 2.0, which\n      // is to simply run the contained script (like \"if 1 = 1\").\n      // (In early versions of Scratch 2.0, it would work the same way as\n      // \"run without screen refresh\" custom blocks do now, but this was\n      // removed before the release of 2.0.)\n      util.startBranch(1, false);\n    }\n  }]);\n  return Scratch3ControlBlocks;\n}();\nmodule.exports = Scratch3ControlBlocks;\n })