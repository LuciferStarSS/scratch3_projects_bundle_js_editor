/* 1240 */\n (function(module, exports, __webpack_require__) {\n\"use strict\";\n/*\n (c) 2014-2016, Andrii Heonia\n Hull.js, a JavaScript library for concave hull generation by set of points.\n https://github.com/AndriiHeonia/hull\n*/\nvar intersect = __webpack_require__(1241);\nvar grid = __webpack_require__(1242);\nvar formatUtil = __webpack_require__(1243);\nvar convexHull = __webpack_require__(1244);\nfunction _filterDuplicates(pointset) {\n    return pointset.filter(function(el, idx, arr) {\n        var prevEl = arr[idx - 1];\n        return idx === 0 || !(prevEl[0] === el[0] && prevEl[1] === el[1]);\n    });\n}\nfunction _sortByX(pointset) {\n    return pointset.sort(function(a, b) {\n        if (a[0] == b[0]) {\n            return a[1] - b[1];\n        } else {\n            return a[0] - b[0];\n        }\n    });\n}\nfunction _sqLength(a, b) {\n    return Math.pow(b[0] - a[0], 2) + Math.pow(b[1] - a[1], 2);\n}\nfunction _cos(o, a, b) {\n    var aShifted = [a[0] - o[0], a[1] - o[1]],\n        bShifted = [b[0] - o[0], b[1] - o[1]],\n        sqALen = _sqLength(o, a),\n        sqBLen = _sqLength(o, b),\n        dot = aShifted[0] * bShifted[0] + aShifted[1] * bShifted[1];\n    return dot / Math.sqrt(sqALen * sqBLen);\n}\nfunction _intersect(segment, pointset) {\n    for (var i = 0; i < pointset.length - 1; i++) {\n        var seg = [pointset[i], pointset[i + 1]];\n        if (segment[0][0] === seg[0][0] && segment[0][1] === seg[0][1] ||\n            segment[0][0] === seg[1][0] && segment[0][1] === seg[1][1]) {\n            continue;\n        }\n        if (intersect(segment, seg)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction _occupiedArea(pointset) {\n    var minX = Infinity,\n        minY = Infinity,\n        maxX = -Infinity,\n        maxY = -Infinity;\n    for (var i = pointset.length - 1; i >= 0; i--) {\n        if (pointset[i][0] < minX) {\n            minX = pointset[i][0];\n        }\n        if (pointset[i][1] < minY) {\n            minY = pointset[i][1];\n        }\n        if (pointset[i][0] > maxX) {\n            maxX = pointset[i][0];\n        }\n        if (pointset[i][1] > maxY) {\n            maxY = pointset[i][1];\n        }\n    }\n    return [\n        maxX - minX, // width\n        maxY - minY  // height\n    ];\n}\nfunction _bBoxAround(edge) {\n    return [\n        Math.min(edge[0][0], edge[1][0]), // left\n        Math.min(edge[0][1], edge[1][1]), // top\n        Math.max(edge[0][0], edge[1][0]), // right\n        Math.max(edge[0][1], edge[1][1])  // bottom\n    ];\n}\nfunction _midPoint(edge, innerPoints, convex) {\n    var point = null,\n        angle1Cos = MAX_CONCAVE_ANGLE_COS,\n        angle2Cos = MAX_CONCAVE_ANGLE_COS,\n        a1Cos, a2Cos;\n    for (var i = 0; i < innerPoints.length; i++) {\n        a1Cos = _cos(edge[0], edge[1], innerPoints[i]);\n        a2Cos = _cos(edge[1], edge[0], innerPoints[i]);\n        if (a1Cos > angle1Cos && a2Cos > angle2Cos &&\n            !_intersect([edge[0], innerPoints[i]], convex) &&\n            !_intersect([edge[1], innerPoints[i]], convex)) {\n            angle1Cos = a1Cos;\n            angle2Cos = a2Cos;\n            point = innerPoints[i];\n        }\n    }\n    return point;\n}\nfunction _concave(convex, maxSqEdgeLen, maxSearchArea, grid, edgeSkipList) {\n    var edge,\n        keyInSkipList,\n        scaleFactor,\n        midPoint,\n        bBoxAround,\n        bBoxWidth,\n        bBoxHeight,\n        midPointInserted = false;\n    for (var i = 0; i < convex.length - 1; i++) {\n        edge = [convex[i], convex[i + 1]];\n        keyInSkipList = edge[0].join() + ',' + edge[1].join();\n        if (_sqLength(edge[0], edge[1]) < maxSqEdgeLen ||\n            edgeSkipList[keyInSkipList] === true) { continue; }\n        scaleFactor = 0;\n        bBoxAround = _bBoxAround(edge);\n        do {\n            bBoxAround = grid.extendBbox(bBoxAround, scaleFactor);\n            bBoxWidth = bBoxAround[2] - bBoxAround[0];\n            bBoxHeight = bBoxAround[3] - bBoxAround[1];\n            midPoint = _midPoint(edge, grid.rangePoints(bBoxAround), convex);            \n            scaleFactor++;\n        }  while (midPoint === null && (maxSearchArea[0] > bBoxWidth || maxSearchArea[1] > bBoxHeight));\n        if (bBoxWidth >= maxSearchArea[0] && bBoxHeight >= maxSearchArea[1]) {\n            edgeSkipList[keyInSkipList] = true;\n        }\n        if (midPoint !== null) {\n            convex.splice(i + 1, 0, midPoint);\n            grid.removePoint(midPoint);\n            midPointInserted = true;\n        }\n    }\n    if (midPointInserted) {\n        return _concave(convex, maxSqEdgeLen, maxSearchArea, grid, edgeSkipList);\n    }\n    return convex;\n}\nfunction hull(pointset, concavity, format) {\n    var convex,\n        concave,\n        innerPoints,\n        occupiedArea,\n        maxSearchArea,\n        cellSize,\n        points,\n        maxEdgeLen = concavity || 20;\n    if (pointset.length < 4) {\n        return pointset.slice();\n    }\n    points = _filterDuplicates(_sortByX(formatUtil.toXy(pointset, format)));\n    occupiedArea = _occupiedArea(points);\n    maxSearchArea = [\n        occupiedArea[0] * MAX_SEARCH_BBOX_SIZE_PERCENT,\n        occupiedArea[1] * MAX_SEARCH_BBOX_SIZE_PERCENT\n    ];\n    convex = convexHull(points);\n    innerPoints = points.filter(function(pt) {\n        return convex.indexOf(pt) < 0;\n    });\n    cellSize = Math.ceil(1 / (points.length / (occupiedArea[0] * occupiedArea[1])));\n    concave = _concave(\n        convex, Math.pow(maxEdgeLen, 2),\n        maxSearchArea, grid(innerPoints, cellSize), {});\n \n    return formatUtil.fromXy(concave, format);\n}\nvar MAX_CONCAVE_ANGLE_COS = Math.cos(90 / (180 / Math.PI)); // angle = 90 deg\nvar MAX_SEARCH_BBOX_SIZE_PERCENT = 0.6;\nmodule.exports = hull;\n })