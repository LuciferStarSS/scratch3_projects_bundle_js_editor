/* 480 */\n (function(module, exports, __webpack_require__) {\nvar JSZip = __webpack_require__(398);\nvar log = __webpack_require__(39);\n/**\n * Deserializes sound from file into storage cache so that it can\n * be loaded into the runtime.\n * @param {object} sound Descriptor for sound from sb3 file\n * @param {Runtime} runtime The runtime containing the storage to cache the sounds in\n * @param {JSZip} zip The zip containing the sound file being described by `sound`\n * @param {string} assetFileName Optional file name for the given asset\n * (sb2 files have filenames of the form [int].[ext],\n * sb3 files have filenames of the form [md5].[ext])\n * @return {Promise} Promise that resolves after the described sound has been stored\n * into the runtime storage cache, the sound was already stored, or an error has\n * occurred.\n */\nvar deserializeSound = function deserializeSound(sound, runtime, zip, assetFileName) {\n  var fileName = assetFileName ? assetFileName : sound.md5;\n  var storage = runtime.storage;\n  if (!storage) {\n    log.error('No storage module present; cannot load sound asset: ', fileName);\n    return Promise.resolve(null);\n  }\n  if (!zip) {\n    // Zip will not be provided if loading project json from server\n    return Promise.resolve(null);\n  }\n  var soundFile = zip.file(fileName);\n  if (!soundFile) {\n    // look for assetfile in a flat list of files, or in a folder\n    var fileMatch = new RegExp(\"^([^/]*/)?\".concat(fileName, \"$\"));\n    soundFile = zip.file(fileMatch)[0]; // use first matching file\n  }\n  if (!soundFile) {\n    log.error(\"Could not find sound file associated with the \".concat(sound.name, \" sound.\"));\n    return Promise.resolve(null);\n  }\n  if (!JSZip.support.uint8array) {\n    log.error('JSZip uint8array is not supported in this browser.');\n    return Promise.resolve(null);\n  }\n  var dataFormat = sound.dataFormat.toLowerCase() === 'mp3' ? storage.DataFormat.MP3 : storage.DataFormat.WAV;\n  return soundFile.async('uint8array').then(function (data) {\n    return storage.createAsset(storage.AssetType.Sound, dataFormat, data, null, true);\n  }).then(function (asset) {\n    sound.asset = asset;\n    sound.assetId = asset.assetId;\n    sound.md5 = \"\".concat(asset.assetId, \".\").concat(asset.dataFormat);\n  });\n};\n/**\n * Deserializes costume from file into storage cache so that it can\n * be loaded into the runtime.\n * @param {object} costume Descriptor for costume from sb3 file\n * @param {Runtime} runtime The runtime containing the storage to cache the costumes in\n * @param {JSZip} zip The zip containing the costume file being described by `costume`\n * @param {string} assetFileName Optional file name for the given asset\n * (sb2 files have filenames of the form [int].[ext],\n * sb3 files have filenames of the form [md5].[ext])\n * @param {string} textLayerFileName Optional file name for the given asset's text layer\n * (sb2 only; files have filenames of the form [int].png)\n * @return {Promise} Promise that resolves after the described costume has been stored\n * into the runtime storage cache, the costume was already stored, or an error has\n * occurred.\n */\nvar deserializeCostume = function deserializeCostume(costume, runtime, zip, assetFileName, textLayerFileName) {\n  var storage = runtime.storage;\n  var assetId = costume.assetId;\n  var fileName = assetFileName ? assetFileName : \"\".concat(assetId, \".\").concat(costume.dataFormat);\n  if (!storage) {\n    log.error('No storage module present; cannot load costume asset: ', fileName);\n    return Promise.resolve(null);\n  }\n  if (costume.asset) {\n    // When uploading a sprite from an image file, the asset data will be provided\n    // @todo Cache the asset data somewhere and pull it out here\n    return Promise.resolve(storage.createAsset(costume.asset.assetType, costume.asset.dataFormat, new Uint8Array(Object.keys(costume.asset.data).map(function (key) {\n      return costume.asset.data[key];\n    })), null, true)).then(function (asset) {\n      costume.asset = asset;\n      costume.assetId = asset.assetId;\n      costume.md5 = \"\".concat(asset.assetId, \".\").concat(asset.dataFormat);\n    });\n  }\n  if (!zip) {\n    // Zip will not be provided if loading project json from server\n    return Promise.resolve(null);\n  }\n  var costumeFile = zip.file(fileName);\n  if (!costumeFile) {\n    // look for assetfile in a flat list of files, or in a folder\n    var fileMatch = new RegExp(\"^([^/]*/)?\".concat(fileName, \"$\"));\n    costumeFile = zip.file(fileMatch)[0]; // use the first matched file\n  }\n  if (!costumeFile) {\n    log.error(\"Could not find costume file associated with the \".concat(costume.name, \" costume.\"));\n    return Promise.resolve(null);\n  }\n  var assetType = null;\n  var costumeFormat = costume.dataFormat.toLowerCase();\n  if (costumeFormat === 'svg') {\n    assetType = storage.AssetType.ImageVector;\n  } else if (['png', 'bmp', 'jpeg', 'jpg', 'gif'].indexOf(costumeFormat) >= 0) {\n    assetType = storage.AssetType.ImageBitmap;\n  } else {\n    log.error(\"Unexpected file format for costume: \".concat(costumeFormat));\n  }\n  if (!JSZip.support.uint8array) {\n    log.error('JSZip uint8array is not supported in this browser.');\n    return Promise.resolve(null);\n  } // textLayerMD5 exists if there is a text layer, which is a png of text from Scratch 1.4\n  // that was opened in Scratch 2.0. In this case, set costume.textLayerAsset.\n  var textLayerFilePromise;\n  if (costume.textLayerMD5) {\n    var textLayerFile = zip.file(textLayerFileName);\n    if (!textLayerFile) {\n      log.error(\"Could not find text layer file associated with the \".concat(costume.name, \" costume.\"));\n      return Promise.resolve(null);\n    }\n    textLayerFilePromise = textLayerFile.async('uint8array').then(function (data) {\n      return storage.createAsset(storage.AssetType.ImageBitmap, 'png', data, costume.textLayerMD5);\n    }).then(function (asset) {\n      costume.textLayerAsset = asset;\n    });\n  } else {\n    textLayerFilePromise = Promise.resolve(null);\n  }\n  return Promise.all([textLayerFilePromise, costumeFile.async('uint8array').then(function (data) {\n    return storage.createAsset(assetType, // TODO eventually we want to map non-png's to their actual file types?\n    costumeFormat, data, null, true);\n  }).then(function (asset) {\n    costume.asset = asset;\n    costume.assetId = asset.assetId;\n    costume.md5 = \"\".concat(asset.assetId, \".\").concat(asset.dataFormat);\n  })]);\n};\nmodule.exports = {\n  deserializeSound: deserializeSound,\n  deserializeCostume: deserializeCostume\n};\n })