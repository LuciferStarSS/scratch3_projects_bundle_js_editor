/* 1219 */\n (function(module, exports, __webpack_require__) {\nmodule.exports = function() {\n  return __webpack_require__(1220)(\" (function(modules) { // webpackBootstrap\\n \\t// The module cache\\n \\tvar installedModules = {};\\n\\n \\t// The require function\\n \\tfunction __webpack_require__(moduleId) {\\n\\n \\t\\t// Check if module is in cache\\n \\t\\tif(installedModules[moduleId]) {\\n \\t\\t\\treturn installedModules[moduleId].exports;\\n \\t\\t}\\n \\t\\t// Create a new module (and put it into the cache)\\n \\t\\tvar module = installedModules[moduleId] = {\\n \\t\\t\\ti: moduleId,\\n \\t\\t\\tl: false,\\n \\t\\t\\texports: {}\\n \\t\\t};\\n\\n \\t\\t// Execute the module function\\n \\t\\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n\\n \\t\\t// Flag the module as loaded\\n \\t\\tmodule.l = true;\\n\\n \\t\\t// Return the exports of the module\\n \\t\\treturn module.exports;\\n \\t}\\n\\n\\n \\t// expose the modules object (__webpack_modules__)\\n \\t__webpack_require__.m = modules;\\n\\n \\t// expose the module cache\\n \\t__webpack_require__.c = installedModules;\\n\\n \\t// define getter function for harmony exports\\n \\t__webpack_require__.d = function(exports, name, getter) {\\n \\t\\tif(!__webpack_require__.o(exports, name)) {\\n \\t\\t\\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\\n \\t\\t}\\n \\t};\\n\\n \\t// define __esModule on exports\\n \\t__webpack_require__.r = function(exports) {\\n \\t\\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\\n \\t\\t\\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\\n \\t\\t}\\n \\t\\tObject.defineProperty(exports, '__esModule', { value: true });\\n \\t};\\n\\n \\t// create a fake namespace object\\n \\t// mode & 1: value is a module id, require it\\n \\t// mode & 2: merge all properties of value into the ns\\n \\t// mode & 4: return value when already ns object\\n \\t// mode & 8|1: behave like require\\n \\t__webpack_require__.t = function(value, mode) {\\n \\t\\tif(mode & 1) value = __webpack_require__(value);\\n \\t\\tif(mode & 8) return value;\\n \\t\\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\\n \\t\\tvar ns = Object.create(null);\\n \\t\\t__webpack_require__.r(ns);\\n \\t\\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\\n \\t\\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\\n \\t\\treturn ns;\\n \\t};\\n\\n \\t// getDefaultExport function for compatibility with non-harmony modules\\n \\t__webpack_require__.n = function(module) {\\n \\t\\tvar getter = module && module.__esModule ?\\n \\t\\t\\tfunction getDefault() { return module['default']; } :\\n \\t\\t\\tfunction getModuleExports() { return module; };\\n \\t\\t__webpack_require__.d(getter, 'a', getter);\\n \\t\\treturn getter;\\n \\t};\\n\\n \\t// Object.prototype.hasOwnProperty.call\\n \\t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\\n\\n \\t// __webpack_public_path__\\n \\t__webpack_require__.p = \\\"/static/\\\";\\n\\n\\n \\t// Load entry module and return exports\\n \\treturn __webpack_require__(__webpack_require__.s = 0);\\n })\\n/************************************************************************/\\n ([\\n/* 0*/\\n (function(module, exports) {\\n\\n/* eslint-env worker */\\nvar jobsActive = 0;\\nvar complete = [];\\nvar intervalId = null;\\n/**\\n * Register a step function.\\n *\\n * Step checks if there are completed jobs and if there are sends them to the\\n * parent. Then it checks the jobs count. If there are no further jobs, clear\\n * the step.\\n */\\n\\nvar registerStep = function registerStep() {\\n  intervalId = setInterval(function () {\\n    if (complete.length) {\\n      // Send our chunk of completed requests and instruct postMessage to\\n      // transfer the buffers instead of copying them.\\n      postMessage(complete.slice(), // Instruct postMessage that these buffers in the sent message\\n      // should use their Transferable trait. After the postMessage\\n      // call the \\\"buffers\\\" will still be in complete if you looked,\\n      // but they will all be length 0 as the data they reference has\\n      // been sent to the window. This lets us send a lot of data\\n      // without the normal postMessage behaviour of making a copy of\\n      // all of the data for the window.\\n      complete.map(function (response) {\\n        return response.buffer;\\n      }).filter(Boolean));\\n      complete.length = 0;\\n    }\\n\\n    if (jobsActive === 0) {\\n      clearInterval(intervalId);\\n      intervalId = null;\\n    }\\n  }, 1);\\n};\\n/**\\n * Receive a job from the parent and fetch the requested data.\\n * @param {object} options.job A job id, url, and options descriptor to perform.\\n */\\n\\n\\nvar onMessage = function onMessage(_ref) {\\n  var job = _ref.data;\\n\\n  if (jobsActive === 0 && !intervalId) {\\n    registerStep();\\n  }\\n\\n  jobsActive++;\\n  fetch(job.url, job.options).then(function (response) {\\n    return response.arrayBuffer();\\n  }).then(function (buffer) {\\n    return complete.push({\\n      id: job.id,\\n      buffer: buffer\\n    });\\n  }).catch(function (error) {\\n    return complete.push({\\n      id: job.id,\\n      error: error\\n    });\\n  }).then(function () {\\n    return jobsActive--;\\n  });\\n};\\n\\nif (self.fetch) {\\n  postMessage({\\n    support: {\\n      fetch: true\\n    }\\n  });\\n  self.addEventListener('message', onMessage);\\n} else {\\n  postMessage({\\n    support: {\\n      fetch: false\\n    }\\n  });\\n  self.addEventListener('message', function (_ref2) {\\n    var job = _ref2.data;\\n    postMessage([{\\n      id: job.id,\\n      error: new Error('fetch is unavailable')\\n    }]);\\n  });\\n}\\n\\n })\\n ]);\\n/*# sourceMappingURL=31b932aa68d4f678cc23.worker.js.map*/\", __webpack_require__.p + \"31b932aa68d4f678cc23.worker.js\");\n};\n })