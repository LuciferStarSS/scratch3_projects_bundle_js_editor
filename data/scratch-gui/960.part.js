/* 960 */\n (function(module, exports, __webpack_require__) {\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\nvar mutationAdapter = __webpack_require__(433);\nvar html = __webpack_require__(154);\nvar uid = __webpack_require__(94);\n/**\n * Convert and an individual block DOM to the representation tree.\n * Based on Blockly's `domToBlockHeadless_`.\n * @param {Element} blockDOM DOM tree for an individual block.\n * @param {object} blocks Collection of blocks to add to.\n * @param {boolean} isTopBlock Whether blocks at this level are \"top blocks.\"\n * @param {?string} parent Parent block ID.\n * @return {undefined}\n */\nvar domToBlock = function domToBlock(blockDOM, blocks, isTopBlock, parent) {\n  if (!blockDOM.attribs.id) {\n    blockDOM.attribs.id = uid();\n  } // Block skeleton.\n  var block = {\n    id: blockDOM.attribs.id,\n    // Block ID\n    opcode: blockDOM.attribs.type,\n    // For execution, \"event_whengreenflag\".\n    inputs: {},\n    // Inputs to this block and the blocks they point to.\n    fields: {},\n    // Fields on this block and their values.\n    next: null,\n    // Next block in the stack, if one exists.\n    topLevel: isTopBlock,\n    // If this block starts a stack.\n    parent: parent,\n    // Parent block ID, if available.\n    shadow: blockDOM.name === 'shadow',\n    // If this represents a shadow/slot.\n    x: blockDOM.attribs.x,\n    // X position of script, if top-level.\n    y: blockDOM.attribs.y // Y position of script, if top-level.\n  }; // Add the block to the representation tree.\n  blocks[block.id] = block; // Process XML children and find enclosed blocks, fields, etc.\n  for (var i = 0; i < blockDOM.children.length; i++) {\n    var xmlChild = blockDOM.children[i]; // Enclosed blocks and shadows\n    var childBlockNode = null;\n    var childShadowNode = null;\n    for (var j = 0; j < xmlChild.children.length; j++) {\n      var grandChildNode = xmlChild.children[j];\n      if (!grandChildNode.name) {\n        // Non-XML tag node.\n        continue;\n      }\n      var grandChildNodeName = grandChildNode.name.toLowerCase();\n      if (grandChildNodeName === 'block') {\n        childBlockNode = grandChildNode;\n      } else if (grandChildNodeName === 'shadow') {\n        childShadowNode = grandChildNode;\n      }\n    } // Use shadow block only if there's no real block node.\n    if (!childBlockNode && childShadowNode) {\n      childBlockNode = childShadowNode;\n    } // Not all Blockly-type blocks are handled here,\n    // as we won't be using all of them for Scratch.\n    switch (xmlChild.name.toLowerCase()) {\n      case 'field':\n        {\n          // Add the field to this block.\n          var fieldName = xmlChild.attribs.name; // Add id in case it is a variable field\n          var fieldId = xmlChild.attribs.id;\n          var fieldData = '';\n          if (xmlChild.children.length > 0 && xmlChild.children[0].data) {\n            fieldData = xmlChild.children[0].data;\n          } else {\n            // If the child of the field with a data property\n            // doesn't exist, set the data to an empty string.\n            fieldData = '';\n          }\n          block.fields[fieldName] = {\n            name: fieldName,\n            id: fieldId,\n            value: fieldData\n          };\n          var fieldVarType = xmlChild.attribs.variabletype;\n          if (typeof fieldVarType === 'string') {\n            block.fields[fieldName].variableType = fieldVarType;\n          }\n          break;\n        }\n      case 'comment':\n        {\n          block.comment = xmlChild.attribs.id;\n          break;\n        }\n      case 'value':\n      case 'statement':\n        {\n          // Recursively generate block structure for input block.\n          domToBlock(childBlockNode, blocks, false, block.id);\n          if (childShadowNode && childBlockNode !== childShadowNode) {\n            // Also generate the shadow block.\n            domToBlock(childShadowNode, blocks, false, block.id);\n          } // Link this block's input to the child block.\n          var inputName = xmlChild.attribs.name;\n          block.inputs[inputName] = {\n            name: inputName,\n            block: childBlockNode.attribs.id,\n            shadow: childShadowNode ? childShadowNode.attribs.id : null\n          };\n          break;\n        }\n      case 'next':\n        {\n          if (!childBlockNode || !childBlockNode.attribs) {\n            // Invalid child block.\n            continue;\n          } // Recursively generate block structure for next block.\n          domToBlock(childBlockNode, blocks, false, block.id); // Link next block to this block.\n          block.next = childBlockNode.attribs.id;\n          break;\n        }\n      case 'mutation':\n        {\n          block.mutation = mutationAdapter(xmlChild);\n          break;\n        }\n    }\n  }\n};\n/**\n * Convert outer blocks DOM from a Blockly CREATE event\n * to a usable form for the Scratch runtime.\n * This structure is based on Blockly xml.js:`domToWorkspace` and `domToBlock`.\n * @param {Element} blocksDOM DOM tree for this event.\n * @return {Array.<object>} Usable list of blocks from this CREATE event.\n */\nvar domToBlocks = function domToBlocks(blocksDOM) {\n  // At this level, there could be multiple blocks adjacent in the DOM tree.\n  var blocks = {};\n  for (var i = 0; i < blocksDOM.length; i++) {\n    var block = blocksDOM[i];\n    if (!block.name || !block.attribs) {\n      continue;\n    }\n    var tagName = block.name.toLowerCase();\n    if (tagName === 'block' || tagName === 'shadow') {\n      domToBlock(block, blocks, true, null);\n    }\n  } // Flatten blocks object into a list.\n  var blocksList = [];\n  for (var b in blocks) {\n    if (!blocks.hasOwnProperty(b)) continue;\n    blocksList.push(blocks[b]);\n  }\n  return blocksList;\n};\n/**\n * Adapter between block creation events and block representation which can be\n * used by the Scratch runtime.\n * @param {object} e `Blockly.events.create` or `Blockly.events.endDrag`\n * @return {Array.<object>} List of blocks from this CREATE event.\n */\nvar adapter = function adapter(e) {\n  // Validate input\n  if (_typeof(e) !== 'object') return;\n  if (_typeof(e.xml) !== 'object') return;\n  return domToBlocks(html.parseDOM(e.xml.outerHTML, {\n    decodeEntities: true\n  }));\n};\nmodule.exports = adapter;\n })