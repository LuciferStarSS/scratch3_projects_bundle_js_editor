/* 1267 */\n (function(module, exports, __webpack_require__) {\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nvar LineBreaker = __webpack_require__(1268);\nvar GraphemeBreaker = __webpack_require__(1273);\n/**\n * Tell this text wrapper to use a specific measurement provider.\n * @typedef {object} MeasurementProvider - the new measurement provider.\n * @property {Function} beginMeasurementSession - this will be called before a batch of measurements are made.\n *      Optionally, this function may return an object to be provided to the endMeasurementSession function.\n * @property {Function} measureText - this will be called each time a piece of text must be measured.\n * @property {Function} endMeasurementSession - this will be called after a batch of measurements is finished.\n *      It will be passed whatever value beginMeasurementSession returned, if any.\n */\n/**\n * Utility to wrap text across several lines, respecting Unicode grapheme clusters and, when possible, Unicode line\n * break opportunities.\n * Reference material:\n * - Unicode Standard Annex #14: http://unicode.org/reports/tr14/\n * - Unicode Standard Annex #29: http://unicode.org/reports/tr29/\n * - \"JavaScript has a Unicode problem\" by Mathias Bynens: https://mathiasbynens.be/notes/javascript-unicode\n */\nvar TextWrapper = function () {\n  /**\n   * Construct a text wrapper which will measure text using the specified measurement provider.\n   * @param {MeasurementProvider} measurementProvider - a helper object to provide text measurement services.\n   */\n  function TextWrapper(measurementProvider) {\n    _classCallCheck(this, TextWrapper);\n    this._measurementProvider = measurementProvider;\n    this._cache = {};\n  }\n  /**\n   * Wrap the provided text into lines restricted to a maximum width. See Unicode Standard Annex (UAX) #14.\n   * @param {number} maxWidth - the maximum allowed width of a line.\n   * @param {string} text - the text to be wrapped. Will be split on whitespace.\n   * @returns {Array.<string>} an array containing the wrapped lines of text.\n   */\n  _createClass(TextWrapper, [{\n    key: \"wrapText\",\n    value: function wrapText(maxWidth, text) {\n      // Normalize to canonical composition (see Unicode Standard Annex (UAX) #15)\n      text = text.normalize();\n      var cacheKey = \"\".concat(maxWidth, \"-\").concat(text);\n      if (this._cache[cacheKey]) {\n        return this._cache[cacheKey];\n      }\n      var measurementSession = this._measurementProvider.beginMeasurementSession();\n      var breaker = new LineBreaker(text);\n      var lastPosition = 0;\n      var nextBreak;\n      var currentLine = null;\n      var lines = [];\n      while (nextBreak = breaker.nextBreak()) {\n        var word = text.slice(lastPosition, nextBreak.position).replace(/\\n+$/, '');\n        var proposedLine = (currentLine || '').concat(word);\n        var proposedLineWidth = this._measurementProvider.measureText(proposedLine);\n        if (proposedLineWidth > maxWidth) {\n          // The next word won't fit on this line. Will it fit on a line by itself?\n          var wordWidth = this._measurementProvider.measureText(word);\n          if (wordWidth > maxWidth) {\n            // The next word can't even fit on a line by itself. Consume it one grapheme cluster at a time.\n            var lastCluster = 0;\n            var nextCluster = void 0;\n            while (lastCluster !== (nextCluster = GraphemeBreaker.nextBreak(word, lastCluster))) {\n              var cluster = word.substring(lastCluster, nextCluster);\n              proposedLine = (currentLine || '').concat(cluster);\n              proposedLineWidth = this._measurementProvider.measureText(proposedLine);\n              if (currentLine === null || proposedLineWidth <= maxWidth) {\n                // first cluster of a new line or the cluster fits\n                currentLine = proposedLine;\n              } else {\n                // no more can fit\n                lines.push(currentLine);\n                currentLine = cluster;\n              }\n              lastCluster = nextCluster;\n            }\n          } else {\n            // The next word can fit on the next line. Finish the current line and move on.\n            if (currentLine !== null) lines.push(currentLine);\n            currentLine = word;\n          }\n        } else {\n          // The next word fits on this line. Just keep going.\n          currentLine = proposedLine;\n        } // Did we find a \\n or similar?\n        if (nextBreak.required) {\n          if (currentLine !== null) lines.push(currentLine);\n          currentLine = null;\n        }\n        lastPosition = nextBreak.position;\n      }\n      currentLine = currentLine || '';\n      if (currentLine.length > 0 || lines.length === 0) {\n        lines.push(currentLine);\n      }\n      this._cache[cacheKey] = lines;\n      this._measurementProvider.endMeasurementSession(measurementSession);\n      return lines;\n    }\n  }]);\n  return TextWrapper;\n}();\nmodule.exports = TextWrapper;\n })