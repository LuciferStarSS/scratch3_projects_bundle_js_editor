/* 1088 */\n (function(module, exports, __webpack_require__) {\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nvar Cast = __webpack_require__(48);\nvar MathUtil = __webpack_require__(62);\nvar Timer = __webpack_require__(136);\nvar Scratch3MotionBlocks = function () {\n  function Scratch3MotionBlocks(runtime) {\n    _classCallCheck(this, Scratch3MotionBlocks);\n    /**\n     * The runtime instantiating this block package.\n     * @type {Runtime}\n     */\n    this.runtime = runtime;\n  }\n  /**\n   * Retrieve the block primitives implemented by this package.\n   * @return {object.<string, Function>} Mapping of opcode to Function.\n   */\n  _createClass(Scratch3MotionBlocks, [{\n    key: \"getPrimitives\",\n    value: function getPrimitives() {\n      return {\n        motion_movesteps: this.moveSteps,\n        motion_gotoxy: this.goToXY,\n        motion_goto: this.goTo,\n        motion_turnright: this.turnRight,\n        motion_turnleft: this.turnLeft,\n        motion_pointindirection: this.pointInDirection,\n        motion_pointtowards: this.pointTowards,\n        motion_glidesecstoxy: this.glide,\n        motion_glideto: this.glideTo,\n        motion_ifonedgebounce: this.ifOnEdgeBounce,\n        motion_setrotationstyle: this.setRotationStyle,\n        motion_changexby: this.changeX,\n        motion_setx: this.setX,\n        motion_changeyby: this.changeY,\n        motion_sety: this.setY,\n        motion_xposition: this.getX,\n        motion_yposition: this.getY,\n        motion_direction: this.getDirection,\n        // Legacy no-op blocks:\n        motion_scroll_right: function motion_scroll_right() {},\n        motion_scroll_up: function motion_scroll_up() {},\n        motion_align_scene: function motion_align_scene() {},\n        motion_xscroll: function motion_xscroll() {},\n        motion_yscroll: function motion_yscroll() {}\n      };\n    }\n  }, {\n    key: \"getMonitored\",\n    value: function getMonitored() {\n      return {\n        motion_xposition: {\n          isSpriteSpecific: true,\n          getId: function getId(targetId) {\n            return \"\".concat(targetId, \"_xposition\");\n          }\n        },\n        motion_yposition: {\n          isSpriteSpecific: true,\n          getId: function getId(targetId) {\n            return \"\".concat(targetId, \"_yposition\");\n          }\n        },\n        motion_direction: {\n          isSpriteSpecific: true,\n          getId: function getId(targetId) {\n            return \"\".concat(targetId, \"_direction\");\n          }\n        }\n      };\n    }\n  }, {\n    key: \"moveSteps\",\n    value: function moveSteps(args, util) {\n      var steps = Cast.toNumber(args.STEPS);\n      var radians = MathUtil.degToRad(90 - util.target.direction);\n      var dx = steps * Math.cos(radians);\n      var dy = steps * Math.sin(radians);\n      util.target.setXY(util.target.x + dx, util.target.y + dy);\n    }\n  }, {\n    key: \"goToXY\",\n    value: function goToXY(args, util) {\n      var x = Cast.toNumber(args.X);\n      var y = Cast.toNumber(args.Y);\n      util.target.setXY(x, y);\n    }\n  }, {\n    key: \"getTargetXY\",\n    value: function getTargetXY(targetName, util) {\n      var targetX = 0;\n      var targetY = 0;\n      if (targetName === '_mouse_') {\n        targetX = util.ioQuery('mouse', 'getScratchX');\n        targetY = util.ioQuery('mouse', 'getScratchY');\n      } else if (targetName === '_random_') {\n        var stageWidth = this.runtime.constructor.STAGE_WIDTH;\n        var stageHeight = this.runtime.constructor.STAGE_HEIGHT;\n        targetX = Math.round(stageWidth * (Math.random() - 0.5));\n        targetY = Math.round(stageHeight * (Math.random() - 0.5));\n      } else {\n        targetName = Cast.toString(targetName);\n        var goToTarget = this.runtime.getSpriteTargetByName(targetName);\n        if (!goToTarget) return;\n        targetX = goToTarget.x;\n        targetY = goToTarget.y;\n      }\n      return [targetX, targetY];\n    }\n  }, {\n    key: \"goTo\",\n    value: function goTo(args, util) {\n      var targetXY = this.getTargetXY(args.TO, util);\n      if (targetXY) {\n        util.target.setXY(targetXY[0], targetXY[1]);\n      }\n    }\n  }, {\n    key: \"turnRight\",\n    value: function turnRight(args, util) {\n      var degrees = Cast.toNumber(args.DEGREES);\n      util.target.setDirection(util.target.direction + degrees);\n    }\n  }, {\n    key: \"turnLeft\",\n    value: function turnLeft(args, util) {\n      var degrees = Cast.toNumber(args.DEGREES);\n      util.target.setDirection(util.target.direction - degrees);\n    }\n  }, {\n    key: \"pointInDirection\",\n    value: function pointInDirection(args, util) {\n      var direction = Cast.toNumber(args.DIRECTION);\n      util.target.setDirection(direction);\n    }\n  }, {\n    key: \"pointTowards\",\n    value: function pointTowards(args, util) {\n      var targetX = 0;\n      var targetY = 0;\n      if (args.TOWARDS === '_mouse_') {\n        targetX = util.ioQuery('mouse', 'getScratchX');\n        targetY = util.ioQuery('mouse', 'getScratchY');\n      } else if (args.TOWARDS === '_random_') {\n        util.target.setDirection(Math.round(Math.random() * 360) - 180);\n        return;\n      } else {\n        args.TOWARDS = Cast.toString(args.TOWARDS);\n        var pointTarget = this.runtime.getSpriteTargetByName(args.TOWARDS);\n        if (!pointTarget) return;\n        targetX = pointTarget.x;\n        targetY = pointTarget.y;\n      }\n      var dx = targetX - util.target.x;\n      var dy = targetY - util.target.y;\n      var direction = 90 - MathUtil.radToDeg(Math.atan2(dy, dx));\n      util.target.setDirection(direction);\n    }\n  }, {\n    key: \"glide\",\n    value: function glide(args, util) {\n      if (util.stackFrame.timer) {\n        var timeElapsed = util.stackFrame.timer.timeElapsed();\n        if (timeElapsed < util.stackFrame.duration * 1000) {\n          // In progress: move to intermediate position.\n          var frac = timeElapsed / (util.stackFrame.duration * 1000);\n          var dx = frac * (util.stackFrame.endX - util.stackFrame.startX);\n          var dy = frac * (util.stackFrame.endY - util.stackFrame.startY);\n          util.target.setXY(util.stackFrame.startX + dx, util.stackFrame.startY + dy);\n          util.yield();\n        } else {\n          // Finished: move to final position.\n          util.target.setXY(util.stackFrame.endX, util.stackFrame.endY);\n        }\n      } else {\n        // First time: save data for future use.\n        util.stackFrame.timer = new Timer();\n        util.stackFrame.timer.start();\n        util.stackFrame.duration = Cast.toNumber(args.SECS);\n        util.stackFrame.startX = util.target.x;\n        util.stackFrame.startY = util.target.y;\n        util.stackFrame.endX = Cast.toNumber(args.X);\n        util.stackFrame.endY = Cast.toNumber(args.Y);\n        if (util.stackFrame.duration <= 0) {\n          // Duration too short to glide.\n          util.target.setXY(util.stackFrame.endX, util.stackFrame.endY);\n          return;\n        }\n        util.yield();\n      }\n    }\n  }, {\n    key: \"glideTo\",\n    value: function glideTo(args, util) {\n      var targetXY = this.getTargetXY(args.TO, util);\n      if (targetXY) {\n        this.glide({\n          SECS: args.SECS,\n          X: targetXY[0],\n          Y: targetXY[1]\n        }, util);\n      }\n    }\n  }, {\n    key: \"ifOnEdgeBounce\",\n    value: function ifOnEdgeBounce(args, util) {\n      var bounds = util.target.getBounds();\n      if (!bounds) {\n        return;\n      } // Measure distance to edges.\n      // Values are positive when the sprite is far away,\n      // and clamped to zero when the sprite is beyond.\n      var stageWidth = this.runtime.constructor.STAGE_WIDTH;\n      var stageHeight = this.runtime.constructor.STAGE_HEIGHT;\n      var distLeft = Math.max(0, stageWidth / 2 + bounds.left);\n      var distTop = Math.max(0, stageHeight / 2 - bounds.top);\n      var distRight = Math.max(0, stageWidth / 2 - bounds.right);\n      var distBottom = Math.max(0, stageHeight / 2 + bounds.bottom); // Find the nearest edge.\n      var nearestEdge = '';\n      var minDist = Infinity;\n      if (distLeft < minDist) {\n        minDist = distLeft;\n        nearestEdge = 'left';\n      }\n      if (distTop < minDist) {\n        minDist = distTop;\n        nearestEdge = 'top';\n      }\n      if (distRight < minDist) {\n        minDist = distRight;\n        nearestEdge = 'right';\n      }\n      if (distBottom < minDist) {\n        minDist = distBottom;\n        nearestEdge = 'bottom';\n      }\n      if (minDist > 0) {\n        return; // Not touching any edge.\n      } // Point away from the nearest edge.\n      var radians = MathUtil.degToRad(90 - util.target.direction);\n      var dx = Math.cos(radians);\n      var dy = -Math.sin(radians);\n      if (nearestEdge === 'left') {\n        dx = Math.max(0.2, Math.abs(dx));\n      } else if (nearestEdge === 'top') {\n        dy = Math.max(0.2, Math.abs(dy));\n      } else if (nearestEdge === 'right') {\n        dx = 0 - Math.max(0.2, Math.abs(dx));\n      } else if (nearestEdge === 'bottom') {\n        dy = 0 - Math.max(0.2, Math.abs(dy));\n      }\n      var newDirection = MathUtil.radToDeg(Math.atan2(dy, dx)) + 90;\n      util.target.setDirection(newDirection); // Keep within the stage.\n      var fencedPosition = util.target.keepInFence(util.target.x, util.target.y);\n      util.target.setXY(fencedPosition[0], fencedPosition[1]);\n    }\n  }, {\n    key: \"setRotationStyle\",\n    value: function setRotationStyle(args, util) {\n      util.target.setRotationStyle(args.STYLE);\n    }\n  }, {\n    key: \"changeX\",\n    value: function changeX(args, util) {\n      var dx = Cast.toNumber(args.DX);\n      util.target.setXY(util.target.x + dx, util.target.y);\n    }\n  }, {\n    key: \"setX\",\n    value: function setX(args, util) {\n      var x = Cast.toNumber(args.X);\n      util.target.setXY(x, util.target.y);\n    }\n  }, {\n    key: \"changeY\",\n    value: function changeY(args, util) {\n      var dy = Cast.toNumber(args.DY);\n      util.target.setXY(util.target.x, util.target.y + dy);\n    }\n  }, {\n    key: \"setY\",\n    value: function setY(args, util) {\n      var y = Cast.toNumber(args.Y);\n      util.target.setXY(util.target.x, y);\n    }\n  }, {\n    key: \"getX\",\n    value: function getX(args, util) {\n      return this.limitPrecision(util.target.x);\n    }\n  }, {\n    key: \"getY\",\n    value: function getY(args, util) {\n      return this.limitPrecision(util.target.y);\n    }\n  }, {\n    key: \"getDirection\",\n    value: function getDirection(args, util) {\n      return util.target.direction;\n    } // This corresponds to snapToInteger in Scratch 2\n  }, {\n    key: \"limitPrecision\",\n    value: function limitPrecision(coordinate) {\n      var rounded = Math.round(coordinate);\n      var delta = coordinate - rounded;\n      var limitedCoord = Math.abs(delta) < 1e-9 ? rounded : coordinate;\n      return limitedCoord;\n    }\n  }]);\n  return Scratch3MotionBlocks;\n}();\nmodule.exports = Scratch3MotionBlocks;\n })