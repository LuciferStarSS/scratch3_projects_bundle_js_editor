/* 62 */\n (function(module, exports) {\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nvar MathUtil = function () {\n  function MathUtil() {\n    _classCallCheck(this, MathUtil);\n  }\n  _createClass(MathUtil, null, [{\n    key: \"degToRad\",\n    /**\n     * Convert a value from degrees to radians.\n     * @param {!number} deg Value in degrees.\n     * @return {!number} Equivalent value in radians.\n     */\n    value: function degToRad(deg) {\n      return deg * Math.PI / 180;\n    }\n    /**\n     * Convert a value from radians to degrees.\n     * @param {!number} rad Value in radians.\n     * @return {!number} Equivalent value in degrees.\n     */\n  }, {\n    key: \"radToDeg\",\n    value: function radToDeg(rad) {\n      return rad * 180 / Math.PI;\n    }\n    /**\n     * Clamp a number between two limits.\n     * If n < min, return min. If n > max, return max. Else, return n.\n     * @param {!number} n Number to clamp.\n     * @param {!number} min Minimum limit.\n     * @param {!number} max Maximum limit.\n     * @return {!number} Value of n clamped to min and max.\n     */\n  }, {\n    key: \"clamp\",\n    value: function clamp(n, min, max) {\n      return Math.min(Math.max(n, min), max);\n    }\n    /**\n     * Keep a number between two limits, wrapping \"extra\" into the range.\n     * e.g., wrapClamp(7, 1, 5) == 2\n     * wrapClamp(0, 1, 5) == 5\n     * wrapClamp(-11, -10, 6) == 6, etc.\n     * @param {!number} n Number to wrap.\n     * @param {!number} min Minimum limit.\n     * @param {!number} max Maximum limit.\n     * @return {!number} Value of n wrapped between min and max.\n     */\n  }, {\n    key: \"wrapClamp\",\n    value: function wrapClamp(n, min, max) {\n      var range = max - min + 1;\n      return n - Math.floor((n - min) / range) * range;\n    }\n    /**\n     * Convert a value from tan function in degrees.\n     * @param {!number} angle in degrees\n     * @return {!number} Correct tan value\n     */\n  }, {\n    key: \"tan\",\n    value: function tan(angle) {\n      angle = angle % 360;\n      switch (angle) {\n        case -270:\n        case 90:\n          return Infinity;\n        case -90:\n        case 270:\n          return -Infinity;\n        default:\n          return parseFloat(Math.tan(Math.PI * angle / 180).toFixed(10));\n      }\n    }\n    /**\n     * Given an array of unique numbers,\n     * returns a reduced array such that each element of the reduced array\n     * represents the position of that element in a sorted version of the\n     * original array.\n     * E.g. [5, 19. 13, 1] => [1, 3, 2, 0]\n     * @param {Array<number>} elts The elements to sort and reduce\n     * @return {Array<number>} The array of reduced orderings\n     */\n  }, {\n    key: \"reducedSortOrdering\",\n    value: function reducedSortOrdering(elts) {\n      var sorted = elts.slice(0).sort(function (a, b) {\n        return a - b;\n      });\n      return elts.map(function (e) {\n        return sorted.indexOf(e);\n      });\n    }\n    /**\n     * Return a random number given an inclusive range and a number in that\n     * range that should be excluded.\n     *\n     * For instance, (1, 5, 3) will only pick 1, 2, 4, or 5 (with equal\n     * probability)\n     *\n     * @param {number} lower - The lower bound (inlcusive)\n     * @param {number} upper - The upper bound (inclusive), such that lower <= upper\n     * @param {number} excluded - The number to exclude (MUST be in the range)\n     * @return {number} A random integer in the range [lower, upper] that is not \"excluded\"\n     */\n  }, {\n    key: \"inclusiveRandIntWithout\",\n    value: function inclusiveRandIntWithout(lower, upper, excluded) {\n      // Note that subtraction is the number of items in the\n      // inclusive range [lower, upper] minus 1 already\n      // (e.g. in the set {3, 4, 5}, 5 - 3 = 2).\n      var possibleOptions = upper - lower;\n      var randInt = lower + Math.floor(Math.random() * possibleOptions);\n      if (randInt >= excluded) {\n        return randInt + 1;\n      }\n      return randInt;\n    }\n    /**\n     * Scales a number from one range to another.\n     * @param {number} i number to be scaled\n     * @param {number} iMin input range minimum\n     * @param {number} iMax input range maximum\n     * @param {number} oMin output range minimum\n     * @param {number} oMax output range maximum\n     * @return {number} scaled number\n     */\n  }, {\n    key: \"scale\",\n    value: function scale(i, iMin, iMax, oMin, oMax) {\n      var p = (i - iMin) / (iMax - iMin);\n      return p * (oMax - oMin) + oMin;\n    }\n  }]);\n  return MathUtil;\n}();\nmodule.exports = MathUtil;\n })