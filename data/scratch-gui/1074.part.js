/* 1074 */\n (function(module, exports) {\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n/**\n * @fileoverview\n * A way to profile Scratch internal performance. Like what blocks run during a\n * step? How much time do they take? How much time is spent inbetween blocks?\n *\n * Profiler aims for to spend as little time inside its functions while\n * recording. For this it has a simple internal record structure that records a\n * series of values for each START and STOP event in a single array. This lets\n * all the values be pushed in one call for the array. This simplicity allows\n * the contents of the start() and stop() calls to be inlined in areas that are\n * called frequently enough to want even greater performance from Profiler so\n * what is recorded better reflects on the profiled code and not Profiler\n * itself.\n */\n/**\n * The next id returned for a new profile'd function.\n * @type {number}\n */\nvar nextId = 0;\n/**\n * The mapping of names to ids.\n * @const {Object.<string, number>}\n */\nvar profilerNames = {};\n/**\n * The START event identifier in Profiler records.\n * @const {number}\n */\nvar START = 0;\n/**\n * The STOP event identifier in Profiler records.\n * @const {number}\n */\nvar STOP = 1;\n/**\n * The number of cells used in the records array by a START event.\n * @const {number}\n */\nvar START_SIZE = 4;\n/**\n * The number of cells used in the records array by a STOP event.\n * @const {number}\n */\nvar STOP_SIZE = 2;\n/**\n * Stored reference to Performance instance provided by the Browser.\n * @const {Performance}\n */\nvar performance = (typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === 'object' && window.performance;\n/**\n * Callback handle called by Profiler for each frame it decodes from its\n * records.\n * @callback FrameCallback\n * @param {ProfilerFrame} frame\n */\n/**\n * A set of information about a frame of execution that was recorded.\n */\nvar ProfilerFrame =\n/**\n * @param {number} depth Depth of the frame in the recorded stack.\n */\nfunction ProfilerFrame(depth) {\n  _classCallCheck(this, ProfilerFrame);\n  /**\n   * The numeric id of a record symbol like Runtime._step or\n   * blockFunction.\n   * @type {number}\n   */\n  this.id = -1;\n  /**\n   * The amount of time spent inside the recorded frame and any deeper\n   * frames.\n   * @type {number}\n   */\n  this.totalTime = 0;\n  /**\n   * The amount of time spent only inside this record frame. Not\n   * including time in any deeper frames.\n   * @type {number}\n   */\n  this.selfTime = 0;\n  /**\n   * An arbitrary argument for the recorded frame. For example a block\n   * function might record its opcode as an argument.\n   * @type {*}\n   */\n  this.arg = null;\n  /**\n   * The depth of the recorded frame. This can help compare recursive\n   * funtions that are recorded. Each level of recursion with have a\n   * different depth value.\n   * @type {number}\n   */\n  this.depth = depth;\n  /**\n   * A summarized count of the number of calls to this frame.\n   * @type {number}\n   */\n  this.count = 0;\n};\nvar Profiler = function () {\n  /**\n   * @param {FrameCallback} onFrame a handle called for each recorded frame.\n   * The passed frame value may not be stored as it'll be updated with later\n   * frame information. Any information that is further stored by the handler\n   * should make copies or reduce the information.\n   */\n  function Profiler() {\n    var onFrame = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};\n    _classCallCheck(this, Profiler);\n    /**\n     * A series of START and STOP values followed by arguments. After\n     * recording is complete the full set of records is reported back by\n     * stepping through the series to connect the relative START and STOP\n     * information.\n     * @type {Array.<*>}\n     */\n    this.records = [];\n    /**\n     * An array of frames incremented on demand instead as part of start\n     * and stop.\n     * @type {Array.<ProfilerFrame>}\n     */\n    this.increments = [];\n    /**\n     * An array of profiler frames separated by counter argument. Generally\n     * for Scratch these frames are separated by block function opcode.\n     * This tracks each time an opcode is called.\n     * @type {Array.<ProfilerFrame>}\n     */\n    this.counters = [];\n    /**\n     * A frame with no id or argument.\n     * @type {ProfilerFrame}\n     */\n    this.nullFrame = new ProfilerFrame(-1);\n    /**\n     * A cache of ProfilerFrames to reuse when reporting the recorded\n     * frames in records.\n     * @type {Array.<ProfilerFrame>}\n     */\n    this._stack = [new ProfilerFrame(0)];\n    /**\n     * A callback handle called with each decoded frame when reporting back\n     * all the recorded times.\n     * @type {FrameCallback}\n     */\n    this.onFrame = onFrame;\n    /**\n     * A reference to the START record id constant.\n     * @const {number}\n     */\n    this.START = START;\n    /**\n     * A reference to the STOP record id constant.\n     * @const {number}\n     */\n    this.STOP = STOP;\n  }\n  /**\n   * Start recording a frame of time for an id and optional argument.\n   * @param {number} id The id returned by idByName for a name symbol like\n   * Runtime._step.\n   * @param {?*} arg An arbitrary argument value to store with the frame.\n   */\n  _createClass(Profiler, [{\n    key: \"start\",\n    value: function start(id, arg) {\n      this.records.push(START, id, arg, performance.now());\n    }\n    /**\n     * Stop the current frame.\n     */\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.records.push(STOP, performance.now());\n    }\n    /**\n     * Increment the number of times this symbol is called.\n     * @param {number} id The id returned by idByName for a name symbol.\n     */\n  }, {\n    key: \"increment\",\n    value: function increment(id) {\n      if (!this.increments[id]) {\n        this.increments[id] = new ProfilerFrame(-1);\n        this.increments[id].id = id;\n      }\n      this.increments[id].count += 1;\n    }\n    /**\n     * Find or create a ProfilerFrame-like object whose counter can be\n     * incremented outside of the Profiler.\n     * @param {number} id The id returned by idByName for a name symbol.\n     * @param {*} arg The argument for a frame that identifies it in addition\n     *   to the id.\n     * @return {{count: number}} A ProfilerFrame-like whose count should be\n     *   incremented for each call.\n     */\n  }, {\n    key: \"frame\",\n    value: function frame(id, arg) {\n      for (var i = 0; i < this.counters.length; i++) {\n        if (this.counters[i].id === id && this.counters[i].arg === arg) {\n          return this.counters[i];\n        }\n      }\n      var newCounter = new ProfilerFrame(-1);\n      newCounter.id = id;\n      newCounter.arg = arg;\n      this.counters.push(newCounter);\n      return newCounter;\n    }\n    /**\n     * Decode records and report all frames to `this.onFrame`.\n     */\n  }, {\n    key: \"reportFrames\",\n    value: function reportFrames() {\n      var stack = this._stack;\n      var depth = 1; // Step through the records and initialize Frame instances from the\n      // START and STOP events. START and STOP events are separated by events\n      // for deeper frames run by higher frames. Frames are stored on a stack\n      // and reinitialized for each START event. When a stop event is reach\n      // the Frame for the current depth has its final values stored and its\n      // passed to the current onFrame callback. This way Frames are \"pushed\"\n      // for each START event and \"popped\" for each STOP and handed to an\n      // outside handle to any desired reduction of the collected data.\n      for (var i = 0; i < this.records.length;) {\n        if (this.records[i] === START) {\n          if (depth >= stack.length) {\n            stack.push(new ProfilerFrame(depth));\n          } // Store id, arg, totalTime, and initialize selfTime.\n          var frame = stack[depth++];\n          frame.id = this.records[i + 1];\n          frame.arg = this.records[i + 2]; // totalTime is first set as the time recorded by this START\n          // event. Once the STOP event is reached the stored start time\n          // is subtracted from the recorded stop time. The resulting\n          // difference is the actual totalTime, and replaces the start\n          // time in frame.totalTime.\n          //\n          // totalTime is used this way as a convenient member to store a\n          // value between the two events without needing additional\n          // members on the Frame or in a shadow map.\n          frame.totalTime = this.records[i + 3]; // selfTime is decremented until we reach the STOP event for\n          // this frame. totalTime will be added to it then to get the\n          // time difference.\n          frame.selfTime = 0;\n          i += START_SIZE;\n        } else if (this.records[i] === STOP) {\n          var now = this.records[i + 1];\n          var _frame = stack[--depth]; // totalTime is the difference between the start event time\n          // stored in totalTime and the stop event time pulled from this\n          // record.\n          _frame.totalTime = now - _frame.totalTime; // selfTime is the difference of this frame's totalTime and the\n          // sum of totalTime of deeper frames.\n          _frame.selfTime += _frame.totalTime; // Remove this frames totalTime from the parent's selfTime.\n          stack[depth - 1].selfTime -= _frame.totalTime; // This frame occured once.\n          _frame.count = 1;\n          this.onFrame(_frame);\n          i += STOP_SIZE;\n        } else {\n          this.records.length = 0;\n          throw new Error('Unable to decode Profiler records.');\n        }\n      }\n      for (var j = 0; j < this.increments.length; j++) {\n        if (this.increments[j] && this.increments[j].count > 0) {\n          this.onFrame(this.increments[j]);\n          this.increments[j].count = 0;\n        }\n      }\n      for (var k = 0; k < this.counters.length; k++) {\n        if (this.counters[k].count > 0) {\n          this.onFrame(this.counters[k]);\n          this.counters[k].count = 0;\n        }\n      }\n      this.records.length = 0;\n    }\n    /**\n     * Lookup or create an id for a frame name.\n     * @param {string} name The name to return an id for.\n     * @return {number} The id for the passed name.\n     */\n  }, {\n    key: \"idByName\",\n    value: function idByName(name) {\n      return Profiler.idByName(name);\n    }\n    /**\n     * Reverse lookup the name from a given frame id.\n     * @param {number} id The id to search for.\n     * @return {string} The name for the given id.\n     */\n  }, {\n    key: \"nameById\",\n    value: function nameById(id) {\n      return Profiler.nameById(id);\n    }\n    /**\n     * Lookup or create an id for a frame name.\n     * @static\n     * @param {string} name The name to return an id for.\n     * @return {number} The id for the passed name.\n     */\n  }], [{\n    key: \"idByName\",\n    value: function idByName(name) {\n      if (typeof profilerNames[name] !== 'number') {\n        profilerNames[name] = nextId++;\n      }\n      return profilerNames[name];\n    }\n    /**\n     * Reverse lookup the name from a given frame id.\n     * @static\n     * @param {number} id The id to search for.\n     * @return {string} The name for the given id.\n     */\n  }, {\n    key: \"nameById\",\n    value: function nameById(id) {\n      for (var name in profilerNames) {\n        if (profilerNames[name] === id) {\n          return name;\n        }\n      }\n      return null;\n    }\n    /**\n     * Profiler is only available on platforms with the Performance API.\n     * @return {boolean} Can the Profiler run in this browser?\n     */\n  }, {\n    key: \"available\",\n    value: function available() {\n      return (typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === 'object' && typeof window.performance !== 'undefined';\n    }\n  }]);\n  return Profiler;\n}();\n/**\n * A reference to the START record id constant.\n * @const {number}\n */\nProfiler.START = START;\n/**\n * A reference to the STOP record id constant.\n * @const {number}\n */\nProfiler.STOP = STOP;\nmodule.exports = Profiler;\n })