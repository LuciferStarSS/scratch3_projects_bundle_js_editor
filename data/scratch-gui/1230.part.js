/* 1230 */\n (function(module, exports, __webpack_require__) {\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nvar ArrayBufferStream = __webpack_require__(1231);\nvar log = __webpack_require__(229);\n/**\n * Data used by the decompression algorithm\n * @type {Array}\n */\nvar STEP_TABLE = [7, 8, 9, 10, 11, 12, 13, 14, 16, 17, 19, 21, 23, 25, 28, 31, 34, 37, 41, 45, 50, 55, 60, 66, 73, 80, 88, 97, 107, 118, 130, 143, 157, 173, 190, 209, 230, 253, 279, 307, 337, 371, 408, 449, 494, 544, 598, 658, 724, 796, 876, 963, 1060, 1166, 1282, 1411, 1552, 1707, 1878, 2066, 2272, 2499, 2749, 3024, 3327, 3660, 4026, 4428, 4871, 5358, 5894, 6484, 7132, 7845, 8630, 9493, 10442, 11487, 12635, 13899, 15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794, 32767];\n/**\n * Data used by the decompression algorithm\n * @type {Array}\n */\nvar INDEX_TABLE = [-1, -1, -1, -1, 2, 4, 6, 8, -1, -1, -1, -1, 2, 4, 6, 8];\nvar _deltaTable = null;\n/**\n * Build a table of deltas from the 89 possible steps and 16 codes.\n * @return {Array<number>} computed delta values\n */\nvar deltaTable = function deltaTable() {\n  if (_deltaTable === null) {\n    var NUM_STEPS = STEP_TABLE.length;\n    var NUM_INDICES = INDEX_TABLE.length;\n    _deltaTable = new Array(NUM_STEPS * NUM_INDICES).fill(0);\n    var i = 0;\n    for (var index = 0; index < NUM_STEPS; index++) {\n      for (var code = 0; code < NUM_INDICES; code++) {\n        var step = STEP_TABLE[index];\n        var delta = 0;\n        if (code & 4) delta += step;\n        if (code & 2) delta += step >> 1;\n        if (code & 1) delta += step >> 2;\n        delta += step >> 3;\n        _deltaTable[i++] = code & 8 ? -delta : delta;\n      }\n    }\n  }\n  return _deltaTable;\n};\n/**\n * Decode wav audio files that have been compressed with the ADPCM format.\n * This is necessary because, while web browsers have native decoders for many audio\n * formats, ADPCM is a non-standard format used by Scratch since its early days.\n * This decoder is based on code from Scratch-Flash:\n * https://github.com/LLK/scratch-flash/blob/master/src/sound/WAVFile.as\n */\nvar ADPCMSoundDecoder = function () {\n  /**\n   * @param {AudioContext} audioContext - a webAudio context\n   * @constructor\n   */\n  function ADPCMSoundDecoder(audioContext) {\n    _classCallCheck(this, ADPCMSoundDecoder);\n    this.audioContext = audioContext;\n  }\n  /**\n   * Data used by the decompression algorithm\n   * @type {Array}\n   */\n  _createClass(ADPCMSoundDecoder, [{\n    key: \"decode\",\n    /**\n     * Decode an ADPCM sound stored in an ArrayBuffer and return a promise\n     * with the decoded audio buffer.\n     * @param  {ArrayBuffer} audioData - containing ADPCM encoded wav audio\n     * @return {AudioBuffer} the decoded audio buffer\n     */\n    value: function decode(audioData) {\n      var _this = this;\n      return new Promise(function (resolve, reject) {\n        var stream = new ArrayBufferStream(audioData);\n        var riffStr = stream.readUint8String(4);\n        if (riffStr !== 'RIFF') {\n          log.warn('incorrect adpcm wav header');\n          reject();\n        }\n        var lengthInHeader = stream.readInt32();\n        if (lengthInHeader + 8 !== audioData.byteLength) {\n          log.warn(\"adpcm wav length in header: \".concat(lengthInHeader, \" is incorrect\"));\n        }\n        var wavStr = stream.readUint8String(4);\n        if (wavStr !== 'WAVE') {\n          log.warn('incorrect adpcm wav header');\n          reject();\n        }\n        var formatChunk = _this.extractChunk('fmt ', stream);\n        _this.encoding = formatChunk.readUint16();\n        _this.channels = formatChunk.readUint16();\n        _this.samplesPerSecond = formatChunk.readUint32();\n        _this.bytesPerSecond = formatChunk.readUint32();\n        _this.blockAlignment = formatChunk.readUint16();\n        _this.bitsPerSample = formatChunk.readUint16();\n        formatChunk.position += 2; // skip extra header byte count\n        _this.samplesPerBlock = formatChunk.readUint16();\n        _this.adpcmBlockSize = (_this.samplesPerBlock - 1) / 2 + 4; // block size in bytes\n        var compressedData = _this.extractChunk('data', stream);\n        var sampleCount = _this.numberOfSamples(compressedData, _this.adpcmBlockSize);\n        var buffer = _this.audioContext.createBuffer(1, sampleCount, _this.samplesPerSecond);\n        _this.imaDecompress(compressedData, _this.adpcmBlockSize, buffer.getChannelData(0));\n        resolve(buffer);\n      });\n    }\n    /**\n     * Extract a chunk of audio data from the stream, consisting of a set of audio data bytes\n     * @param  {string} chunkType - the type of chunk to extract. 'data' or 'fmt' (format)\n     * @param  {ArrayBufferStream} stream - an stream containing the audio data\n     * @return {ArrayBufferStream} a stream containing the desired chunk\n     */\n  }, {\n    key: \"extractChunk\",\n    value: function extractChunk(chunkType, stream) {\n      stream.position = 12;\n      while (stream.position < stream.getLength() - 8) {\n        var typeStr = stream.readUint8String(4);\n        var chunkSize = stream.readInt32();\n        if (typeStr === chunkType) {\n          var chunk = stream.extract(chunkSize);\n          return chunk;\n        }\n        stream.position += chunkSize;\n      }\n    }\n    /**\n     * Count the exact number of samples in the compressed data.\n     * @param {ArrayBufferStream} compressedData - the compressed data\n     * @param {number} blockSize - size of each block in the data in bytes\n     * @return {number} number of samples in the compressed data\n     */\n  }, {\n    key: \"numberOfSamples\",\n    value: function numberOfSamples(compressedData, blockSize) {\n      if (!compressedData) return 0;\n      compressedData.position = 0;\n      var available = compressedData.getBytesAvailable();\n      var blocks = available / blockSize | 0; // Number of samples in full blocks.\n      var fullBlocks = blocks * (2 * (blockSize - 4)) + 1; // Number of samples in the last incomplete block. 0 if the last block\n      // is full.\n      var subBlock = Math.max(available % blockSize - 4, 0) * 2; // 1 if the last block is incomplete. 0 if it is complete.\n      var incompleteBlock = Math.min(available % blockSize, 1);\n      return fullBlocks + subBlock + incompleteBlock;\n    }\n    /**\n     * Decompress sample data using the IMA ADPCM algorithm.\n     * Note: Handles only one channel, 4-bits per sample.\n     * @param  {ArrayBufferStream} compressedData - a stream of compressed audio samples\n     * @param  {number} blockSize - the number of bytes in the stream\n     * @param  {Float32Array} out - the uncompressed audio samples\n     */\n  }, {\n    key: \"imaDecompress\",\n    value: function imaDecompress(compressedData, blockSize, out) {\n      var sample;\n      var code;\n      var delta;\n      var index = 0;\n      var lastByte = -1; // -1 indicates that there is no saved lastByte\n      // Bail and return no samples if we have no data\n      if (!compressedData) return;\n      compressedData.position = 0;\n      var size = out.length;\n      var samplesAfterBlockHeader = (blockSize - 4) * 2;\n      var DELTA_TABLE = deltaTable();\n      var i = 0;\n      while (i < size) {\n        // read block header\n        sample = compressedData.readInt16();\n        index = compressedData.readUint8();\n        compressedData.position++; // skip extra header byte\n        if (index > 88) index = 88;\n        out[i++] = sample / 32768;\n        var blockLength = Math.min(samplesAfterBlockHeader, size - i);\n        var blockStart = i;\n        while (i - blockStart < blockLength) {\n          // read 4-bit code and compute delta from previous sample\n          lastByte = compressedData.readUint8();\n          code = lastByte & 0xF;\n          delta = DELTA_TABLE[index * 16 + code]; // compute next index\n          index += INDEX_TABLE[code];\n          if (index > 88) index = 88;else if (index < 0) index = 0; // compute and output sample\n          sample += delta;\n          if (sample > 32767) sample = 32767;else if (sample < -32768) sample = -32768;\n          out[i++] = sample / 32768; // use 4-bit code from lastByte and compute delta from previous\n          // sample\n          code = lastByte >> 4 & 0xF;\n          delta = DELTA_TABLE[index * 16 + code]; // compute next index\n          index += INDEX_TABLE[code];\n          if (index > 88) index = 88;else if (index < 0) index = 0; // compute and output sample\n          sample += delta;\n          if (sample > 32767) sample = 32767;else if (sample < -32768) sample = -32768;\n          out[i++] = sample / 32768;\n        }\n      }\n    }\n  }], [{\n    key: \"STEP_TABLE\",\n    get: function get() {\n      return STEP_TABLE;\n    }\n    /**\n     * Data used by the decompression algorithm\n     * @type {Array}\n     */\n  }, {\n    key: \"INDEX_TABLE\",\n    get: function get() {\n      return INDEX_TABLE;\n    }\n  }]);\n  return ADPCMSoundDecoder;\n}();\nmodule.exports = ADPCMSoundDecoder;\n })