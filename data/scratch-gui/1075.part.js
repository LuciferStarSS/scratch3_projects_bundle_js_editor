/* 1075 */\n (function(module, exports, __webpack_require__) {\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nvar Timer = __webpack_require__(136);\nvar Thread = __webpack_require__(224);\nvar execute = __webpack_require__(451);\n/**\n * Profiler frame name for stepping a single thread.\n * @const {string}\n */\nvar stepThreadProfilerFrame = 'Sequencer.stepThread';\n/**\n * Profiler frame name for the inner loop of stepThreads.\n * @const {string}\n */\nvar stepThreadsInnerProfilerFrame = 'Sequencer.stepThreads#inner';\n/**\n * Profiler frame name for execute.\n * @const {string}\n */\nvar executeProfilerFrame = 'execute';\n/**\n * Profiler frame ID for stepThreadProfilerFrame.\n * @type {number}\n */\nvar stepThreadProfilerId = -1;\n/**\n * Profiler frame ID for stepThreadsInnerProfilerFrame.\n * @type {number}\n */\nvar stepThreadsInnerProfilerId = -1;\n/**\n * Profiler frame ID for executeProfilerFrame.\n * @type {number}\n */\nvar executeProfilerId = -1;\nvar Sequencer = function () {\n  function Sequencer(runtime) {\n    _classCallCheck(this, Sequencer);\n    /**\n     * A utility timer for timing thread sequencing.\n     * @type {!Timer}\n     */\n    this.timer = new Timer();\n    /**\n     * Reference to the runtime owning this sequencer.\n     * @type {!Runtime}\n     */\n    this.runtime = runtime;\n    this.activeThread = null;\n  }\n  /**\n   * Time to run a warp-mode thread, in ms.\n   * @type {number}\n   */\n  _createClass(Sequencer, [{\n    key: \"stepThreads\",\n    /**\n     * Step through all threads in `this.runtime.threads`, running them in order.\n     * @return {Array.<!Thread>} List of inactive threads after stepping.\n     */\n    value: function stepThreads() {\n      // Work time is 75% of the thread stepping interval.\n      var WORK_TIME = 0.75 * this.runtime.currentStepTime; // For compatibility with Scatch 2, update the millisecond clock\n      // on the Runtime once per step (see Interpreter.as in Scratch 2\n      // for original use of `currentMSecs`)\n      this.runtime.updateCurrentMSecs(); // Start counting toward WORK_TIME.\n      this.timer.start(); // Count of active threads.\n      var numActiveThreads = Infinity; // Whether `stepThreads` has run through a full single tick.\n      var ranFirstTick = false;\n      var doneThreads = []; // Conditions for continuing to stepping threads:\n      // 1. We must have threads in the list, and some must be active.\n      // 2. Time elapsed must be less than WORK_TIME.\n      // 3. Either turbo mode, or no redraw has been requested by a primitive.\n      while (this.runtime.threads.length > 0 && numActiveThreads > 0 && this.timer.timeElapsed() < WORK_TIME && (this.runtime.turboMode || !this.runtime.redrawRequested)) {\n        if (this.runtime.profiler !== null) {\n          if (stepThreadsInnerProfilerId === -1) {\n            stepThreadsInnerProfilerId = this.runtime.profiler.idByName(stepThreadsInnerProfilerFrame);\n          }\n          this.runtime.profiler.start(stepThreadsInnerProfilerId);\n        }\n        numActiveThreads = 0;\n        var stoppedThread = false; // Attempt to run each thread one time.\n        var threads = this.runtime.threads;\n        for (var i = 0; i < threads.length; i++) {\n          var activeThread = this.activeThread = threads[i]; // Check if the thread is done so it is not executed.\n          if (activeThread.stack.length === 0 || activeThread.status === Thread.STATUS_DONE) {\n            // Finished with this thread.\n            stoppedThread = true;\n            continue;\n          }\n          if (activeThread.status === Thread.STATUS_YIELD_TICK && !ranFirstTick) {\n            // Clear single-tick yield from the last call of `stepThreads`.\n            activeThread.status = Thread.STATUS_RUNNING;\n          }\n          if (activeThread.status === Thread.STATUS_RUNNING || activeThread.status === Thread.STATUS_YIELD) {\n            // Normal-mode thread: step.\n            if (this.runtime.profiler !== null) {\n              if (stepThreadProfilerId === -1) {\n                stepThreadProfilerId = this.runtime.profiler.idByName(stepThreadProfilerFrame);\n              } // Increment the number of times stepThread is called.\n              this.runtime.profiler.increment(stepThreadProfilerId);\n            }\n            this.stepThread(activeThread);\n            activeThread.warpTimer = null;\n            if (activeThread.isKilled) {\n              i--; // if the thread is removed from the list (killed), do not increase index\n            }\n          }\n          if (activeThread.status === Thread.STATUS_RUNNING) {\n            numActiveThreads++;\n          } // Check if the thread completed while it just stepped to make\n          // sure we remove it before the next iteration of all threads.\n          if (activeThread.stack.length === 0 || activeThread.status === Thread.STATUS_DONE) {\n            // Finished with this thread.\n            stoppedThread = true;\n          }\n        } // We successfully ticked once. Prevents running STATUS_YIELD_TICK\n        // threads on the next tick.\n        ranFirstTick = true;\n        if (this.runtime.profiler !== null) {\n          this.runtime.profiler.stop();\n        } // Filter inactive threads from `this.runtime.threads`.\n        if (stoppedThread) {\n          var nextActiveThread = 0;\n          for (var _i = 0; _i < this.runtime.threads.length; _i++) {\n            var thread = this.runtime.threads[_i];\n            if (thread.stack.length !== 0 && thread.status !== Thread.STATUS_DONE) {\n              this.runtime.threads[nextActiveThread] = thread;\n              nextActiveThread++;\n            } else {\n              doneThreads.push(thread);\n            }\n          }\n          this.runtime.threads.length = nextActiveThread;\n        }\n      }\n      this.activeThread = null;\n      return doneThreads;\n    }\n    /**\n     * Step the requested thread for as long as necessary.\n     * @param {!Thread} thread Thread object to step.\n     */\n  }, {\n    key: \"stepThread\",\n    value: function stepThread(thread) {\n      var currentBlockId = thread.peekStack();\n      if (!currentBlockId) {\n        // A \"null block\" - empty branch.\n        thread.popStack(); // Did the null follow a hat block?\n        if (thread.stack.length === 0) {\n          thread.status = Thread.STATUS_DONE;\n          return;\n        }\n      } // Save the current block ID to notice if we did control flow.\n      while (currentBlockId = thread.peekStack()) {\n        var isWarpMode = thread.peekStackFrame().warpMode;\n        if (isWarpMode && !thread.warpTimer) {\n          // Initialize warp-mode timer if it hasn't been already.\n          // This will start counting the thread toward `Sequencer.WARP_TIME`.\n          thread.warpTimer = new Timer();\n          thread.warpTimer.start();\n        } // Execute the current block.\n        if (this.runtime.profiler !== null) {\n          if (executeProfilerId === -1) {\n            executeProfilerId = this.runtime.profiler.idByName(executeProfilerFrame);\n          } // Increment the number of times execute is called.\n          this.runtime.profiler.increment(executeProfilerId);\n        }\n        if (thread.target === null) {\n          this.retireThread(thread);\n        } else {\n          execute(this, thread);\n        }\n        thread.blockGlowInFrame = currentBlockId; // If the thread has yielded or is waiting, yield to other threads.\n        if (thread.status === Thread.STATUS_YIELD) {\n          // Mark as running for next iteration.\n          thread.status = Thread.STATUS_RUNNING; // In warp mode, yielded blocks are re-executed immediately.\n          if (isWarpMode && thread.warpTimer.timeElapsed() <= Sequencer.WARP_TIME) {\n            continue;\n          }\n          return;\n        } else if (thread.status === Thread.STATUS_PROMISE_WAIT) {\n          // A promise was returned by the primitive. Yield the thread\n          // until the promise resolves. Promise resolution should reset\n          // thread.status to Thread.STATUS_RUNNING.\n          return;\n        } else if (thread.status === Thread.STATUS_YIELD_TICK) {\n          // stepThreads will reset the thread to Thread.STATUS_RUNNING\n          return;\n        } // If no control flow has happened, switch to next block.\n        if (thread.peekStack() === currentBlockId) {\n          thread.goToNextBlock();\n        } // If no next block has been found at this point, look on the stack.\n        while (!thread.peekStack()) {\n          thread.popStack();\n          if (thread.stack.length === 0) {\n            // No more stack to run!\n            thread.status = Thread.STATUS_DONE;\n            return;\n          }\n          var stackFrame = thread.peekStackFrame();\n          isWarpMode = stackFrame.warpMode;\n          if (stackFrame.isLoop) {\n            // The current level of the stack is marked as a loop.\n            // Return to yield for the frame/tick in general.\n            // Unless we're in warp mode - then only return if the\n            // warp timer is up.\n            if (!isWarpMode || thread.warpTimer.timeElapsed() > Sequencer.WARP_TIME) {\n              // Don't do anything to the stack, since loops need\n              // to be re-executed.\n              return;\n            } // Don't go to the next block for this level of the stack,\n            // since loops need to be re-executed.\n            continue;\n          } else if (stackFrame.waitingReporter) {\n            // This level of the stack was waiting for a value.\n            // This means a reporter has just returned - so don't go\n            // to the next block for this level of the stack.\n            return;\n          } // Get next block of existing block on the stack.\n          thread.goToNextBlock();\n        }\n      }\n    }\n    /**\n     * Step a thread into a block's branch.\n     * @param {!Thread} thread Thread object to step to branch.\n     * @param {number} branchNum Which branch to step to (i.e., 1, 2).\n     * @param {boolean} isLoop Whether this block is a loop.\n     */\n  }, {\n    key: \"stepToBranch\",\n    value: function stepToBranch(thread, branchNum, isLoop) {\n      if (!branchNum) {\n        branchNum = 1;\n      }\n      var currentBlockId = thread.peekStack();\n      var branchId = thread.target.blocks.getBranch(currentBlockId, branchNum);\n      thread.peekStackFrame().isLoop = isLoop;\n      if (branchId) {\n        // Push branch ID to the thread's stack.\n        thread.pushStack(branchId);\n      } else {\n        thread.pushStack(null);\n      }\n    }\n    /**\n     * Step a procedure.\n     * @param {!Thread} thread Thread object to step to procedure.\n     * @param {!string} procedureCode Procedure code of procedure to step to.\n     */\n  }, {\n    key: \"stepToProcedure\",\n    value: function stepToProcedure(thread, procedureCode) {\n      var definition = thread.target.blocks.getProcedureDefinition(procedureCode);\n      if (!definition) {\n        return;\n      } // Check if the call is recursive.\n      // If so, set the thread to yield after pushing.\n      var isRecursive = thread.isRecursiveCall(procedureCode); // To step to a procedure, we put its definition on the stack.\n      // Execution for the thread will proceed through the definition hat\n      // and on to the main definition of the procedure.\n      // When that set of blocks finishes executing, it will be popped\n      // from the stack by the sequencer, returning control to the caller.\n      thread.pushStack(definition); // In known warp-mode threads, only yield when time is up.\n      if (thread.peekStackFrame().warpMode && thread.warpTimer.timeElapsed() > Sequencer.WARP_TIME) {\n        thread.status = Thread.STATUS_YIELD;\n      } else {\n        // Look for warp-mode flag on definition, and set the thread\n        // to warp-mode if needed.\n        var definitionBlock = thread.target.blocks.getBlock(definition);\n        var innerBlock = thread.target.blocks.getBlock(definitionBlock.inputs.custom_block.block);\n        var doWarp = false;\n        if (innerBlock && innerBlock.mutation) {\n          var warp = innerBlock.mutation.warp;\n          if (typeof warp === 'boolean') {\n            doWarp = warp;\n          } else if (typeof warp === 'string') {\n            doWarp = JSON.parse(warp);\n          }\n        }\n        if (doWarp) {\n          thread.peekStackFrame().warpMode = true;\n        } else if (isRecursive) {\n          // In normal-mode threads, yield any time we have a recursive call.\n          thread.status = Thread.STATUS_YIELD;\n        }\n      }\n    }\n    /**\n     * Retire a thread in the middle, without considering further blocks.\n     * @param {!Thread} thread Thread object to retire.\n     */\n  }, {\n    key: \"retireThread\",\n    value: function retireThread(thread) {\n      thread.stack = [];\n      thread.stackFrame = [];\n      thread.requestScriptGlowInFrame = false;\n      thread.status = Thread.STATUS_DONE;\n    }\n  }], [{\n    key: \"WARP_TIME\",\n    get: function get() {\n      return 500;\n    }\n  }]);\n  return Sequencer;\n}();\nmodule.exports = Sequencer;\n })