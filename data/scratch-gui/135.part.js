/* 135 */\n (function(module, exports, __webpack_require__) {\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nvar adapter = __webpack_require__(960);\nvar mutationAdapter = __webpack_require__(433);\nvar xmlEscape = __webpack_require__(220);\nvar MonitorRecord = __webpack_require__(295);\nvar Clone = __webpack_require__(113);\nvar _require = __webpack_require__(181),\n    Map = _require.Map;\nvar BlocksExecuteCache = __webpack_require__(440);\nvar BlocksRuntimeCache = __webpack_require__(441);\nvar log = __webpack_require__(39);\nvar Variable = __webpack_require__(114);\nvar getMonitorIdForBlockWithArgs = __webpack_require__(296);\n/**\n * @fileoverview\n * Store and mutate the VM block representation,\n * and handle updates from Scratch Blocks events.\n */\n/**\n * Create a block container.\n * @param {Runtime} runtime The runtime this block container operates within\n * @param {boolean} optNoGlow Optional flag to indicate that blocks in this container\n * should not request glows. This does not affect glows when clicking on a block to execute it.\n */\nvar Blocks = function () {\n  function Blocks(runtime, optNoGlow) {\n    _classCallCheck(this, Blocks);\n    oBC=this;\n    this.runtime = runtime;\n    /**\n     * All blocks in the workspace.\n     * Keys are block IDs, values are metadata about the block.\n     * @type {Object.<string, Object>}\n     */\n    this._blocks = {};\n    /**\n     * All top-level scripts in the workspace.\n     * A list of block IDs that represent scripts (i.e., first block in script).\n     * @type {Array.<String>}\n     */\n    this._scripts = [];\n    /**\n     * Runtime Cache\n     * @type {{inputs: {}, procedureParamNames: {}, procedureDefinitions: {}}}\n     * @private\n     */\n    Object.defineProperty(this, '_cache', {\n      writable: true,\n      enumerable: false\n    });\n    this._cache = {\n      /**\n       * Cache block inputs by block id\n       * @type {object.<string, !Array.<object>>}\n       */\n      inputs: {},\n      /**\n       * Cache procedure Param Names by block id\n       * @type {object.<string, ?Array.<string>>}\n       */\n      procedureParamNames: {},\n      /**\n       * Cache procedure definitions by block id\n       * @type {object.<string, ?string>}\n       */\n      procedureDefinitions: {},\n      /**\n       * A cache for execute to use and store on. Only available to\n       * execute.\n       * @type {object.<string, object>}\n       */\n      _executeCached: {},\n      /**\n       * A cache of block IDs and targets to start threads on as they are\n       * actively monitored.\n       * @type {Array<{blockId: string, target: Target}>}\n       */\n      _monitored: null,\n      /**\n       * A cache of hat opcodes to collection of theads to execute.\n       * @type {object.<string, object>}\n       */\n      scripts: {}\n    };\n    /**\n     * Flag which indicates that blocks in this container should not glow.\n     * Blocks will still glow when clicked on, but this flag is used to control\n     * whether the blocks in this container can request a glow as part of\n     * a running stack. E.g. the flyout block container and the monitor block container\n     * should not be able to request a glow, but blocks containers belonging to\n     * sprites should.\n     * @type {boolean}\n     */\n    this.forceNoGlow = optNoGlow || false;\n  }\n  /**\n   * Blockly inputs that represent statements/branch.\n   * are prefixed with this string.\n   * @const{string}\n   */\n  _createClass(Blocks, [{\n    key: \"getBlock\",\n    /**\n     * Provide an object with metadata for the requested block ID.\n     * @param {!string} blockId ID of block we have stored.\n     * @return {?object} Metadata about the block, if it exists.\n     */\n    value: function getBlock(blockId) {\n      return this._blocks[blockId];\n    }\n    /**\n     * Get all known top-level blocks that start scripts.\n     * @return {Array.<string>} List of block IDs.\n     */\n  }, {\n    key: \"getScripts\",\n    value: function getScripts() {\n      return this._scripts;\n    }\n    /**\n      * Get the next block for a particular block\n      * @param {?string} id ID of block to get the next block for\n      * @return {?string} ID of next block in the sequence\n      */\n  }, {\n    key: \"getNextBlock\",\n    value: function getNextBlock(id) {\n      var block = this._blocks[id];\n      return typeof block === 'undefined' ? null : block.next;\n    }\n    /**\n     * Get the branch for a particular C-shaped block.\n     * @param {?string} id ID for block to get the branch for.\n     * @param {?number} branchNum Which branch to select (e.g. for if-else).\n     * @return {?string} ID of block in the branch.\n     */\n  }, {\n    key: \"getBranch\",\n    value: function getBranch(id, branchNum) {\n      var block = this._blocks[id];\n      if (typeof block === 'undefined') return null;\n      if (!branchNum) branchNum = 1;\n      var inputName = Blocks.BRANCH_INPUT_PREFIX;\n      if (branchNum > 1) {\n        inputName += branchNum;\n      } // Empty C-block?\n      var input = block.inputs[inputName];\n      return typeof input === 'undefined' ? null : input.block;\n    }\n    /**\n     * Get the opcode for a particular block\n     * @param {?object} block The block to query\n     * @return {?string} the opcode corresponding to that block\n     */\n  }, {\n    key: \"getOpcode\",\n    value: function getOpcode(block) {\n      return typeof block === 'undefined' ? null : block.opcode;\n    }\n    /**\n     * Get all fields and their values for a block.\n     * @param {?object} block The block to query.\n     * @return {?object} All fields and their values.\n     */\n  }, {\n    key: \"getFields\",\n    value: function getFields(block) {\n      return typeof block === 'undefined' ? null : block.fields;\n    }\n    /**\n     * Get all non-branch inputs for a block.\n     * @param {?object} block the block to query.\n     * @return {?Array.<object>} All non-branch inputs and their associated blocks.\n     */\n  }, {\n    key: \"getInputs\",\n    value: function getInputs(block) {\n      if (typeof block === 'undefined') return null;\n      var inputs = this._cache.inputs[block.id];\n      if (typeof inputs !== 'undefined') {\n        return inputs;\n      }\n      inputs = {};\n      for (var input in block.inputs) {\n        // Ignore blocks prefixed with branch prefix.\n        if (input.substring(0, Blocks.BRANCH_INPUT_PREFIX.length) !== Blocks.BRANCH_INPUT_PREFIX) {\n          inputs[input] = block.inputs[input];\n        }\n      }\n      this._cache.inputs[block.id] = inputs;\n      return inputs;\n    }\n    /**\n     * Get mutation data for a block.\n     * @param {?object} block The block to query.\n     * @return {?object} Mutation for the block.\n     */\n  }, {\n    key: \"getMutation\",\n    value: function getMutation(block) {\n      return typeof block === 'undefined' ? null : block.mutation;\n    }\n    /**\n     * Get the top-level script for a given block.\n     * @param {?string} id ID of block to query.\n     * @return {?string} ID of top-level script block.\n     */\n  }, {\n    key: \"getTopLevelScript\",\n    value: function getTopLevelScript(id) {\n      var block = this._blocks[id];\n      if (typeof block === 'undefined') return null;\n      while (block.parent !== null) {\n        block = this._blocks[block.parent];\n      }\n      return block.id;\n    }\n    /**\n     * Get the procedure definition for a given name.\n     * @param {?string} name Name of procedure to query.\n     * @return {?string} ID of procedure definition.\n     */\n  }, {\n    key: \"getProcedureDefinition\",\n    value: function getProcedureDefinition(name) {\n      var blockID = this._cache.procedureDefinitions[name];\n      if (typeof blockID !== 'undefined') {\n        return blockID;\n      }\n      for (var id in this._blocks) {\n        if (!this._blocks.hasOwnProperty(id)) continue;\n        var block = this._blocks[id];\n        if (block.opcode === 'procedures_definition') {\n          var internal = this._getCustomBlockInternal(block);\n          if (internal && internal.mutation.proccode === name) {\n            this._cache.procedureDefinitions[name] = id; // The outer define block id\n            return id;\n          }\n        }\n      }\n      this._cache.procedureDefinitions[name] = null;\n      return null;\n    }\n    /**\n     * Get names and ids of parameters for the given procedure.\n     * @param {?string} name Name of procedure to query.\n     * @return {?Array.<string>} List of param names for a procedure.\n     */\n  }, {\n    key: \"getProcedureParamNamesAndIds\",\n    value: function getProcedureParamNamesAndIds(name) {\n      return this.getProcedureParamNamesIdsAndDefaults(name).slice(0, 2);\n    }\n    /**\n     * Get names, ids, and defaults of parameters for the given procedure.\n     * @param {?string} name Name of procedure to query.\n     * @return {?Array.<string>} List of param names for a procedure.\n     */\n  }, {\n    key: \"getProcedureParamNamesIdsAndDefaults\",\n    value: function getProcedureParamNamesIdsAndDefaults(name) {\n      var cachedNames = this._cache.procedureParamNames[name];\n      if (typeof cachedNames !== 'undefined') {\n        return cachedNames;\n      }\n      for (var id in this._blocks) {\n        if (!this._blocks.hasOwnProperty(id)) continue;\n        var block = this._blocks[id];\n        if (block.opcode === 'procedures_prototype' && block.mutation.proccode === name) {\n          var names = JSON.parse(block.mutation.argumentnames);\n          var ids = JSON.parse(block.mutation.argumentids);\n          var defaults = JSON.parse(block.mutation.argumentdefaults);\n          this._cache.procedureParamNames[name] = [names, ids, defaults];\n          return this._cache.procedureParamNames[name];\n        }\n      }\n      this._cache.procedureParamNames[name] = null;\n      return null;\n    }\n  }, {\n    key: \"duplicate\",\n    value: function duplicate() {\n      var newBlocks = new Blocks(this.runtime, this.forceNoGlow);\n      newBlocks._blocks = Clone.simple(this._blocks);\n      newBlocks._scripts = Clone.simple(this._scripts);\n      return newBlocks;\n    } // ---------------------------------------------------------------------\n    /**\n     * Create event listener for blocks, variables, and comments. Handles validation and\n     * serves as a generic adapter between the blocks, variables, and the\n     * runtime interface.\n     * @param {object} e Blockly \"block\" or \"variable\" event\n     */\n  }, {\n    key: \"blocklyListen\",\n    value: function blocklyListen(e) {\n      // Validate event\n      if (_typeof(e) !== 'object') return;\n      if (typeof e.blockId !== 'string' && typeof e.varId !== 'string' && typeof e.commentId !== 'string') {\n        return;\n      }\n      var stage = this.runtime.getTargetForStage();\n      var editingTarget = this.runtime.getEditingTarget(); // UI event: clicked scripts toggle in the runtime.\n      if (e.element === 'stackclick') {\n        this.runtime.toggleScript(e.blockId, {\n          stackClick: true\n        });\n        return;\n      } // Block create/update/destroy\n      switch (e.type) {\n        case 'create':\n          {\n            var newBlocks = adapter(e); // A create event can create many blocks. Add them all.\n            for (var i = 0; i < newBlocks.length; i++) {\n              this.createBlock(newBlocks[i]);\n            }\n            break;\n          }\n        case 'change':\n          this.changeBlock({\n            id: e.blockId,\n            element: e.element,\n            name: e.name,\n            value: e.newValue\n          });\n          break;\n        case 'move':\n          this.moveBlock({\n            id: e.blockId,\n            oldParent: e.oldParentId,\n            oldInput: e.oldInputName,\n            newParent: e.newParentId,\n            newInput: e.newInputName,\n            newCoordinate: e.newCoordinate\n          });\n          break;\n        case 'dragOutside':\n          this.runtime.emitBlockDragUpdate(e.isOutside);\n          break;\n        case 'endDrag':\n          this.runtime.emitBlockDragUpdate(false\n          /* areBlocksOverGui */\n          ); // Drag blocks onto another sprite\n          if (e.isOutside) {\n            var _newBlocks = adapter(e);\n            this.runtime.emitBlockEndDrag(_newBlocks, e.blockId);\n          }\n          break;\n        case 'delete':\n          // Don't accept delete events for missing blocks,\n          // or shadow blocks being obscured.\n          if (!this._blocks.hasOwnProperty(e.blockId) || this._blocks[e.blockId].shadow) {\n            return;\n          } // Inform any runtime to forget about glows on this script.\n          if (this._blocks[e.blockId].topLevel) {\n            this.runtime.quietGlow(e.blockId);\n          }\n          this.deleteBlock(e.blockId);\n          break;\n        case 'var_create':\n          // Check if the variable being created is global or local\n          // If local, create a local var on the current editing target, as long\n          // as there are no conflicts, and the current target is actually a sprite\n          // If global or if the editing target is not present or we somehow got\n          // into a state where a local var was requested for the stage,\n          // create a stage (global) var after checking for name conflicts\n          // on all the sprites.\n          if (e.isLocal && editingTarget && !editingTarget.isStage && !e.isCloud) {\n            if (!editingTarget.lookupVariableById(e.varId)) {\n              editingTarget.createVariable(e.varId, e.varName, e.varType);\n              this.emitProjectChanged();\n            }\n          } else {\n            if (stage.lookupVariableById(e.varId)) {\n              // Do not re-create a variable if it already exists\n              return;\n            } // Check for name conflicts in all of the targets\n            var allTargets = this.runtime.targets.filter(function (t) {\n              return t.isOriginal;\n            });\n            var _iterator = _createForOfIteratorHelper(allTargets),\n                _step;\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                var target = _step.value;\n                if (target.lookupVariableByNameAndType(e.varName, e.varType, true)) {\n                  return;\n                }\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n            stage.createVariable(e.varId, e.varName, e.varType, e.isCloud);\n            this.emitProjectChanged();\n          }\n          break;\n        case 'var_rename':\n          if (editingTarget && editingTarget.variables.hasOwnProperty(e.varId)) {\n            // This is a local variable, rename on the current target\n            editingTarget.renameVariable(e.varId, e.newName); // Update all the blocks on the current target that use\n            // this variable\n            editingTarget.blocks.updateBlocksAfterVarRename(e.varId, e.newName);\n          } else {\n            // This is a global variable\n            stage.renameVariable(e.varId, e.newName); // Update all blocks on all targets that use the renamed variable\n            var targets = this.runtime.targets;\n            for (var _i = 0; _i < targets.length; _i++) {\n              var currTarget = targets[_i];\n              currTarget.blocks.updateBlocksAfterVarRename(e.varId, e.newName);\n            }\n          }\n          this.emitProjectChanged();\n          break;\n        case 'var_delete':\n          {\n            var _target = editingTarget && editingTarget.variables.hasOwnProperty(e.varId) ? editingTarget : stage;\n            _target.deleteVariable(e.varId);\n            this.emitProjectChanged();\n            break;\n          }\n        case 'comment_create':\n          if (this.runtime.getEditingTarget()) {\n            var _currTarget = this.runtime.getEditingTarget();\n            _currTarget.createComment(e.commentId, e.blockId, e.text, e.xy.x, e.xy.y, e.width, e.height, e.minimized);\n            if (_currTarget.comments[e.commentId].x === null && _currTarget.comments[e.commentId].y === null) {\n              // Block comments imported from 2.0 projects are imported with their\n              // x and y coordinates set to null so that scratch-blocks can\n              // auto-position them. If we are receiving a create event for these\n              // comments, then the auto positioning should have taken place.\n              // Update the x and y position of these comments to match the\n              // one from the event.\n              _currTarget.comments[e.commentId].x = e.xy.x;\n              _currTarget.comments[e.commentId].y = e.xy.y;\n            }\n          }\n          this.emitProjectChanged();\n          break;\n        case 'comment_change':\n          if (this.runtime.getEditingTarget()) {\n            var _currTarget2 = this.runtime.getEditingTarget();\n            if (!_currTarget2.comments.hasOwnProperty(e.commentId)) {\n              log.warn(\"Cannot change comment with id \".concat(e.commentId, \" because it does not exist.\"));\n              return;\n            }\n            var comment = _currTarget2.comments[e.commentId];\n            var change = e.newContents_;\n            if (change.hasOwnProperty('minimized')) {\n              comment.minimized = change.minimized;\n            }\n            if (change.hasOwnProperty('width') && change.hasOwnProperty('height')) {\n              comment.width = change.width;\n              comment.height = change.height;\n            }\n            if (change.hasOwnProperty('text')) {\n              comment.text = change.text;\n            }\n            this.emitProjectChanged();\n          }\n          break;\n        case 'comment_move':\n          if (this.runtime.getEditingTarget()) {\n            var _currTarget3 = this.runtime.getEditingTarget();\n            if (_currTarget3 && !_currTarget3.comments.hasOwnProperty(e.commentId)) {\n              log.warn(\"Cannot change comment with id \".concat(e.commentId, \" because it does not exist.\"));\n              return;\n            }\n            var _comment = _currTarget3.comments[e.commentId];\n            var newCoord = e.newCoordinate_;\n            _comment.x = newCoord.x;\n            _comment.y = newCoord.y;\n            this.emitProjectChanged();\n          }\n          break;\n        case 'comment_delete':\n          if (this.runtime.getEditingTarget()) {\n            var _currTarget4 = this.runtime.getEditingTarget();\n            if (!_currTarget4.comments.hasOwnProperty(e.commentId)) {\n              // If we're in this state, we have probably received\n              // a delete event from a workspace that we switched from\n              // (e.g. a delete event for a comment on sprite a's workspace\n              // when switching from sprite a to sprite b)\n              return;\n            }\n            delete _currTarget4.comments[e.commentId];\n            if (e.blockId) {\n              var block = _currTarget4.blocks.getBlock(e.blockId);\n              if (!block) {\n                log.warn(\"Could not find block referenced by comment with id: \".concat(e.commentId));\n                return;\n              }\n              delete block.comment;\n            }\n            this.emitProjectChanged();\n          }\n          break;\n      }\n    } // ---------------------------------------------------------------------\n    /**\n     * Reset all runtime caches.\n     */\n  }, {\n    key: \"resetCache\",\n    value: function resetCache() {\n      this._cache.inputs = {};\n      this._cache.procedureParamNames = {};\n      this._cache.procedureDefinitions = {};\n      this._cache._executeCached = {};\n      this._cache._monitored = null;\n      this._cache.scripts = {};\n    }\n    /**\n     * Emit a project changed event if this is a block container\n     * that can affect the project state.\n     */\n  }, {\n    key: \"emitProjectChanged\",\n    value: function emitProjectChanged() {\n      if (!this.forceNoGlow) {\n        this.runtime.emitProjectChanged();\n      scratchStatus(\"CHANGED\");\n      }\n    }\n    /**\n     * Block management: create blocks and scripts from a `create` event\n     * @param {!object} block Blockly create event to be processed\n     */\n  }, {\n    key: \"createBlock\",\n    value: function createBlock(block) {\n      // Does the block already exist?\n      // Could happen, e.g., for an unobscured shadow.\n      if (this._blocks.hasOwnProperty(block.id)) {\n        return;\n      } // Create new block.\n      this._blocks[block.id] = block; // Push block id to scripts array.\n      // Blocks are added as a top-level stack if they are marked as a top-block\n      // (if they were top-level XML in the event).\n      if (block.topLevel) {\n        this._addScript(block.id);\n      }\n      this.resetCache(); // A new block was actually added to the block container,\n      // emit a project changed event\n      this.emitProjectChanged();\n    }\n    /**\n     * Block management: change block field values\n     * @param {!object} args Blockly change event to be processed\n     */\n  }, {\n    key: \"changeBlock\",\n    value: function changeBlock(args) {\n      // Validate\n      if (['field', 'mutation', 'checkbox'].indexOf(args.element) === -1) return;\n      var block = this._blocks[args.id];\n      if (typeof block === 'undefined') return;\n      switch (args.element) {\n        case 'field':\n          // TODO when the field of a monitored block changes,\n          // update the checkbox in the flyout based on whether\n          // a monitor for that current combination of selected parameters exists\n          // e.g.\n          // 1. check (current [v year])\n          // 2. switch dropdown in flyout block to (current [v minute])\n          // 3. the checkbox should become unchecked if we're not already\n          //    monitoring current minute\n          // Update block value\n          if (!block.fields[args.name]) return;\n          if (args.name === 'VARIABLE' || args.name === 'LIST' || args.name === 'BROADCAST_OPTION') {\n            // Get variable name using the id in args.value.\n            var variable = this.runtime.getEditingTarget().lookupVariableById(args.value);\n            if (variable) {\n              block.fields[args.name].value = variable.name;\n              block.fields[args.name].id = args.value;\n            }\n          } else {\n            // Changing the value in a dropdown\n            block.fields[args.name].value = args.value; // The selected item in the sensing of block menu needs to change based on the\n            // selected target.  Set it to the first item in the menu list.\n            // TODO: (#1787)\n            if (block.opcode === 'sensing_of_object_menu') {\n              if (block.fields.OBJECT.value === '_stage_') {\n                this._blocks[block.parent].fields.PROPERTY.value = 'backdrop #';\n              } else {\n                this._blocks[block.parent].fields.PROPERTY.value = 'x position';\n              }\n              this.runtime.requestBlocksUpdate();\n            }\n            var flyoutBlock = block.shadow && block.parent ? this._blocks[block.parent] : block;\n            if (flyoutBlock.isMonitored) {\n              this.runtime.requestUpdateMonitor(Map({\n                id: flyoutBlock.id,\n                params: this._getBlockParams(flyoutBlock)\n              }));\n            }\n          }\n          break;\n        case 'mutation':\n          block.mutation = mutationAdapter(args.value);\n          break;\n        case 'checkbox':\n          {\n            // A checkbox usually has a one to one correspondence with the monitor\n            // block but in the case of monitored reporters that have arguments,\n            // map the old id to a new id, creating a new monitor block if necessary\n            if (block.fields && Object.keys(block.fields).length > 0 && block.opcode !== 'data_variable' && block.opcode !== 'data_listcontents') {\n              // This block has an argument which needs to get separated out into\n              // multiple monitor blocks with ids based on the selected argument\n              var newId = getMonitorIdForBlockWithArgs(block.id, block.fields); // Note: we're not just constantly creating a longer and longer id everytime we check\n              // the checkbox because we're using the id of the block in the flyout as the base\n              // check if a block with the new id already exists, otherwise create\n              var newBlock = this.runtime.monitorBlocks.getBlock(newId);\n              if (!newBlock) {\n                newBlock = JSON.parse(JSON.stringify(block));\n                newBlock.id = newId;\n                this.runtime.monitorBlocks.createBlock(newBlock);\n              }\n              block = newBlock; // Carry on through the rest of this code with newBlock\n            }\n            var wasMonitored = block.isMonitored;\n            block.isMonitored = args.value; // Variable blocks may be sprite specific depending on the owner of the variable\n            var isSpriteLocalVariable = false;\n            if (block.opcode === 'data_variable') {\n              isSpriteLocalVariable = !this.runtime.getTargetForStage().variables[block.fields.VARIABLE.id];\n            } else if (block.opcode === 'data_listcontents') {\n              isSpriteLocalVariable = !this.runtime.getTargetForStage().variables[block.fields.LIST.id];\n            }\n            var isSpriteSpecific = isSpriteLocalVariable || this.runtime.monitorBlockInfo.hasOwnProperty(block.opcode) && this.runtime.monitorBlockInfo[block.opcode].isSpriteSpecific;\n            if (isSpriteSpecific) {\n              // If creating a new sprite specific monitor, the only possible target is\n              // the current editing one b/c you cannot dynamically create monitors.\n              // Also, do not change the targetId if it has already been assigned\n              block.targetId = block.targetId || this.runtime.getEditingTarget().id;\n            } else {\n              block.targetId = null;\n            }\n            if (wasMonitored && !block.isMonitored) {\n              this.runtime.requestHideMonitor(block.id);\n            } else if (!wasMonitored && block.isMonitored) {\n              // Tries to show the monitor for specified block. If it doesn't exist, add the monitor.\n              if (!this.runtime.requestShowMonitor(block.id)) {\n                this.runtime.requestAddMonitor(MonitorRecord({\n                  id: block.id,\n                  targetId: block.targetId,\n                  spriteName: block.targetId ? this.runtime.getTargetById(block.targetId).getName() : null,\n                  opcode: block.opcode,\n                  params: this._getBlockParams(block),\n                  // @todo(vm#565) for numerical values with decimals, some countries use comma\n                  value: '',\n                  mode: block.opcode === 'data_listcontents' ? 'list' : 'default'\n                }));\n              }\n            }\n            break;\n          }\n      }\n      this.emitProjectChanged();\n      this.resetCache();\n    }\n    /**\n     * Block management: move blocks from parent to parent\n     * @param {!object} e Blockly move event to be processed\n     */\n  }, {\n    key: \"moveBlock\",\n    value: function moveBlock(e) {\n      if (!this._blocks.hasOwnProperty(e.id)) {\n        return;\n      }\n      var block = this._blocks[e.id]; // Track whether a change actually occurred\n      // ignoring changes like routine re-positioning\n      // of a block when loading a workspace\n      var didChange = false; // Move coordinate changes.\n      if (e.newCoordinate) {\n        didChange = block.x !== e.newCoordinate.x || block.y !== e.newCoordinate.y;\n        block.x = e.newCoordinate.x;\n        block.y = e.newCoordinate.y;\n      } // Remove from any old parent.\n      if (typeof e.oldParent !== 'undefined') {\n        var oldParent = this._blocks[e.oldParent];\n        if (typeof e.oldInput !== 'undefined' && oldParent.inputs[e.oldInput].block === e.id) {\n          // This block was connected to the old parent's input.\n          oldParent.inputs[e.oldInput].block = null;\n        } else if (oldParent.next === e.id) {\n          // This block was connected to the old parent's next connection.\n          oldParent.next = null;\n        }\n        this._blocks[e.id].parent = null;\n        didChange = true;\n      } // Is this block a top-level block?\n      if (typeof e.newParent === 'undefined') {\n        this._addScript(e.id);\n      } else {\n        // Remove script, if one exists.\n        this._deleteScript(e.id); // Otherwise, try to connect it in its new place.\n        if (typeof e.newInput === 'undefined') {\n          // Moved to the new parent's next connection.\n          this._blocks[e.newParent].next = e.id;\n        } else {\n          // Moved to the new parent's input.\n          // Don't obscure the shadow block.\n          var oldShadow = null;\n          if (this._blocks[e.newParent].inputs.hasOwnProperty(e.newInput)) {\n            oldShadow = this._blocks[e.newParent].inputs[e.newInput].shadow;\n          } // If the block being attached is itself a shadow, make sure to set\n          // both block and shadow to that blocks ID. This happens when adding\n          // inputs to a custom procedure.\n          if (this._blocks[e.id].shadow) oldShadow = e.id;\n          this._blocks[e.newParent].inputs[e.newInput] = {\n            name: e.newInput,\n            block: e.id,\n            shadow: oldShadow\n          };\n        }\n        this._blocks[e.id].parent = e.newParent;\n        didChange = true;\n      }\n      this.resetCache();\n      if (didChange) this.emitProjectChanged();\n    }\n    /**\n     * Block management: run all blocks.\n     * @param {!object} runtime Runtime to run all blocks in.\n     */\n  }, {\n    key: \"runAllMonitored\",\n    value: function runAllMonitored(runtime) {\n      var _this = this;\n      if (this._cache._monitored === null) {\n        this._cache._monitored = Object.keys(this._blocks).filter(function (blockId) {\n          return _this.getBlock(blockId).isMonitored;\n        }).map(function (blockId) {\n          var targetId = _this.getBlock(blockId).targetId;\n          return {\n            blockId: blockId,\n            target: targetId ? runtime.getTargetById(targetId) : null\n          };\n        });\n      }\n      var monitored = this._cache._monitored;\n      for (var i = 0; i < monitored.length; i++) {\n        var _monitored$i = monitored[i],\n            blockId = _monitored$i.blockId,\n            target = _monitored$i.target;\n        runtime.addMonitorScript(blockId, target);\n      }\n    }\n    /**\n     * Block management: delete blocks and their associated scripts. Does nothing if a block\n     * with the given ID does not exist.\n     * @param {!string} blockId Id of block to delete\n     */\n  }, {\n    key: \"deleteBlock\",\n    value: function deleteBlock(blockId) {\n      // @todo In runtime, stop threads running on this script.\n      // Get block\n      var block = this._blocks[blockId];\n      if (!block) {\n        // No block with the given ID exists\n        return;\n      } // Delete children\n      if (block.next !== null) {\n        this.deleteBlock(block.next);\n      } // Delete inputs (including branches)\n      for (var input in block.inputs) {\n        // If it's null, the block in this input moved away.\n        if (block.inputs[input].block !== null) {\n          this.deleteBlock(block.inputs[input].block);\n        } // Delete obscured shadow blocks.\n        if (block.inputs[input].shadow !== null && block.inputs[input].shadow !== block.inputs[input].block) {\n          this.deleteBlock(block.inputs[input].shadow);\n        }\n      } // Delete any script starting with this block.\n      this._deleteScript(blockId); // Delete block itself.\n      delete this._blocks[blockId];\n      this.resetCache();\n      this.emitProjectChanged();\n    }\n    /**\n     * Returns a map of all references to variables or lists from blocks\n     * in this block container.\n     * @param {Array<object>} optBlocks Optional list of blocks to constrain the search to.\n     * This is useful for getting variable/list references for a stack of blocks instead\n     * of all blocks on the workspace\n     * @param {?boolean} optIncludeBroadcast Optional whether to include broadcast fields.\n     * @return {object} A map of variable ID to a list of all variable references\n     * for that ID. A variable reference contains the field referencing that variable\n     * and also the type of the variable being referenced.\n     */\n  }, {\n    key: \"getAllVariableAndListReferences\",\n    value: function getAllVariableAndListReferences(optBlocks, optIncludeBroadcast) {\n      var blocks = optBlocks ? optBlocks : this._blocks;\n      var allReferences = Object.create(null);\n      for (var blockId in blocks) {\n        var varOrListField = null;\n        var varType = null;\n        if (blocks[blockId].fields.VARIABLE) {\n          varOrListField = blocks[blockId].fields.VARIABLE;\n          varType = Variable.SCALAR_TYPE;\n        } else if (blocks[blockId].fields.LIST) {\n          varOrListField = blocks[blockId].fields.LIST;\n          varType = Variable.LIST_TYPE;\n        } else if (optIncludeBroadcast && blocks[blockId].fields.BROADCAST_OPTION) {\n          varOrListField = blocks[blockId].fields.BROADCAST_OPTION;\n          varType = Variable.BROADCAST_MESSAGE_TYPE;\n        }\n        if (varOrListField) {\n          var currVarId = varOrListField.id;\n          if (allReferences[currVarId]) {\n            allReferences[currVarId].push({\n              referencingField: varOrListField,\n              type: varType\n            });\n          } else {\n            allReferences[currVarId] = [{\n              referencingField: varOrListField,\n              type: varType\n            }];\n          }\n        }\n      }\n      return allReferences;\n    }\n    /**\n     * Keep blocks up to date after a variable gets renamed.\n     * @param {string} varId The id of the variable that was renamed\n     * @param {string} newName The new name of the variable that was renamed\n     */\n  }, {\n    key: \"updateBlocksAfterVarRename\",\n    value: function updateBlocksAfterVarRename(varId, newName) {\n      var blocks = this._blocks;\n      for (var blockId in blocks) {\n        var varOrListField = null;\n        if (blocks[blockId].fields.VARIABLE) {\n          varOrListField = blocks[blockId].fields.VARIABLE;\n        } else if (blocks[blockId].fields.LIST) {\n          varOrListField = blocks[blockId].fields.LIST;\n        }\n        if (varOrListField) {\n          var currFieldId = varOrListField.id;\n          if (varId === currFieldId) {\n            varOrListField.value = newName;\n          }\n        }\n      }\n    }\n    /**\n     * Keep blocks up to date after they are shared between targets.\n     * @param {boolean} isStage If the new target is a stage.\n     */\n  }, {\n    key: \"updateTargetSpecificBlocks\",\n    value: function updateTargetSpecificBlocks(isStage) {\n      var blocks = this._blocks;\n      for (var blockId in blocks) {\n        if (isStage && blocks[blockId].opcode === 'event_whenthisspriteclicked') {\n          blocks[blockId].opcode = 'event_whenstageclicked';\n        } else if (!isStage && blocks[blockId].opcode === 'event_whenstageclicked') {\n          blocks[blockId].opcode = 'event_whenthisspriteclicked';\n        }\n      }\n    }\n    /**\n     * Update blocks after a sound, costume, or backdrop gets renamed.\n     * Any block referring to the old name of the asset should get updated\n     * to refer to the new name.\n     * @param {string} oldName The old name of the asset that was renamed.\n     * @param {string} newName The new name of the asset that was renamed.\n     * @param {string} assetType String representation of the kind of asset\n     * that was renamed. This can be one of 'sprite','costume', 'sound', or\n     * 'backdrop'.\n     */\n  }, {\n    key: \"updateAssetName\",\n    value: function updateAssetName(oldName, newName, assetType) {\n      var getAssetField;\n      if (assetType === 'costume') {\n        getAssetField = this._getCostumeField.bind(this);\n      } else if (assetType === 'sound') {\n        getAssetField = this._getSoundField.bind(this);\n      } else if (assetType === 'backdrop') {\n        getAssetField = this._getBackdropField.bind(this);\n      } else if (assetType === 'sprite') {\n        getAssetField = this._getSpriteField.bind(this);\n      } else {\n        return;\n      }\n      var blocks = this._blocks;\n      for (var blockId in blocks) {\n        var assetField = getAssetField(blockId);\n        if (assetField && assetField.value === oldName) {\n          assetField.value = newName;\n        }\n      }\n    }\n    /**\n     * Update sensing_of blocks after a variable gets renamed.\n     * @param {string} oldName The old name of the variable that was renamed.\n     * @param {string} newName The new name of the variable that was renamed.\n     * @param {string} targetName The name of the target the variable belongs to.\n     * @return {boolean} Returns true if any of the blocks were updated.\n     */\n  }, {\n    key: \"updateSensingOfReference\",\n    value: function updateSensingOfReference(oldName, newName, targetName) {\n      var blocks = this._blocks;\n      var blockUpdated = false;\n      for (var blockId in blocks) {\n        var block = blocks[blockId];\n        if (block.opcode === 'sensing_of' && block.fields.PROPERTY.value === oldName && // If block and shadow are different, it means a block is inserted to OBJECT, and should be ignored.\n        block.inputs.OBJECT.block === block.inputs.OBJECT.shadow) {\n          var inputBlock = this.getBlock(block.inputs.OBJECT.block);\n          if (inputBlock.fields.OBJECT.value === targetName) {\n            block.fields.PROPERTY.value = newName;\n            blockUpdated = true;\n          }\n        }\n      }\n      if (blockUpdated) this.resetCache();\n      return blockUpdated;\n    }\n    /**\n     * Helper function to retrieve a costume menu field from a block given its id.\n     * @param {string} blockId A unique identifier for a block\n     * @return {?object} The costume menu field of the block with the given block id.\n     * Null if either a block with the given id doesn't exist or if a costume menu field\n     * does not exist on the block with the given id.\n     */\n  }, {\n    key: \"_getCostumeField\",\n    value: function _getCostumeField(blockId) {\n      var block = this.getBlock(blockId);\n      if (block && block.fields.hasOwnProperty('COSTUME')) {\n        return block.fields.COSTUME;\n      }\n      return null;\n    }\n    /**\n     * Helper function to retrieve a sound menu field from a block given its id.\n     * @param {string} blockId A unique identifier for a block\n     * @return {?object} The sound menu field of the block with the given block id.\n     * Null, if either a block with the given id doesn't exist or if a sound menu field\n     * does not exist on the block with the given id.\n     */\n  }, {\n    key: \"_getSoundField\",\n    value: function _getSoundField(blockId) {\n      var block = this.getBlock(blockId);\n      if (block && block.fields.hasOwnProperty('SOUND_MENU')) {\n        return block.fields.SOUND_MENU;\n      }\n      return null;\n    }\n    /**\n     * Helper function to retrieve a backdrop menu field from a block given its id.\n     * @param {string} blockId A unique identifier for a block\n     * @return {?object} The backdrop menu field of the block with the given block id.\n     * Null, if either a block with the given id doesn't exist or if a backdrop menu field\n     * does not exist on the block with the given id.\n     */\n  }, {\n    key: \"_getBackdropField\",\n    value: function _getBackdropField(blockId) {\n      var block = this.getBlock(blockId);\n      if (block && block.fields.hasOwnProperty('BACKDROP')) {\n        return block.fields.BACKDROP;\n      }\n      return null;\n    }\n    /**\n     * Helper function to retrieve a sprite menu field from a block given its id.\n     * @param {string} blockId A unique identifier for a block\n     * @return {?object} The sprite menu field of the block with the given block id.\n     * Null, if either a block with the given id doesn't exist or if a sprite menu field\n     * does not exist on the block with the given id.\n     */\n  }, {\n    key: \"_getSpriteField\",\n    value: function _getSpriteField(blockId) {\n      var block = this.getBlock(blockId);\n      if (!block) {\n        return null;\n      }\n      var spriteMenuNames = ['TOWARDS', 'TO', 'OBJECT', 'VIDEOONMENU2', 'DISTANCETOMENU', 'TOUCHINGOBJECTMENU', 'CLONE_OPTION'];\n      for (var i = 0; i < spriteMenuNames.length; i++) {\n        var menuName = spriteMenuNames[i];\n        if (block.fields.hasOwnProperty(menuName)) {\n          return block.fields[menuName];\n        }\n      }\n      return null;\n    } // ---------------------------------------------------------------------\n    /**\n     * Encode all of `this._blocks` as an XML string usable\n     * by a Blockly/scratch-blocks workspace.\n     * @param {object<string, Comment>} comments Map of comments referenced by id\n     * @return {string} String of XML representing this object's blocks.\n     */\n  }, {\n    key: \"toXML\",\n    value: function toXML(comments) {\n      var _this2 = this;\n      return this._scripts.map(function (script) {\n        return _this2.blockToXML(script, comments);\n      }).join();\n    }\n    /**\n     * Recursively encode an individual block and its children\n     * into a Blockly/scratch-blocks XML string.\n     * @param {!string} blockId ID of block to encode.\n     * @param {object<string, Comment>} comments Map of comments referenced by id\n     * @return {string} String of XML representing this block and any children.\n     */\n  }, {\n    key: \"blockToXML\",\n    value: function blockToXML(blockId, comments) {\n      var block = this._blocks[blockId]; // block should exist, but currently some blocks' next property point\n      // to a blockId for non-existent blocks. Until we track down that behavior,\n      // this early exit allows the project to load.\n      if (!block) return; // Encode properties of this block.\n      var tagName = block.shadow ? 'shadow' : 'block';\n      var xmlString = \"<\".concat(tagName, \"\\n                id=\\\"\").concat(block.id, \"\\\"\\n                type=\\\"\").concat(block.opcode, \"\\\"\\n                \").concat(block.topLevel ? \"x=\\\"\".concat(block.x, \"\\\" y=\\\"\").concat(block.y, \"\\\"\") : '', \"\\n            >\");\n      var commentId = block.comment;\n      if (commentId) {\n        if (comments) {\n          if (comments.hasOwnProperty(commentId)) {\n            xmlString += comments[commentId].toXML();\n          } else {\n            log.warn(\"Could not find comment with id: \".concat(commentId, \" in provided comment descriptions.\"));\n          }\n        } else {\n          log.warn(\"Cannot serialize comment with id: \".concat(commentId, \"; no comment descriptions provided.\"));\n        }\n      } // Add any mutation. Must come before inputs.\n      if (block.mutation) {\n        xmlString += this.mutationToXML(block.mutation);\n      } // Add any inputs on this block.\n      for (var input in block.inputs) {\n        if (!block.inputs.hasOwnProperty(input)) continue;\n        var blockInput = block.inputs[input]; // Only encode a value tag if the value input is occupied.\n        if (blockInput.block || blockInput.shadow) {\n          xmlString += \"<value name=\\\"\".concat(blockInput.name, \"\\\">\");\n          if (blockInput.block) {\n            xmlString += this.blockToXML(blockInput.block, comments);\n          }\n          if (blockInput.shadow && blockInput.shadow !== blockInput.block) {\n            // Obscured shadow.\n            xmlString += this.blockToXML(blockInput.shadow, comments);\n          }\n          xmlString += '</value>';\n        }\n      } // Add any fields on this block.\n      for (var field in block.fields) {\n        if (!block.fields.hasOwnProperty(field)) continue;\n        var blockField = block.fields[field];\n        xmlString += \"<field name=\\\"\".concat(blockField.name, \"\\\"\");\n        var fieldId = blockField.id;\n        if (fieldId) {\n          xmlString += \" id=\\\"\".concat(fieldId, \"\\\"\");\n        }\n        var varType = blockField.variableType;\n        if (typeof varType === 'string') {\n          xmlString += \" variabletype=\\\"\".concat(varType, \"\\\"\");\n        }\n        var value = blockField.value;\n        if (typeof value === 'string') {\n          value = xmlEscape(blockField.value);\n        }\n        xmlString += \">\".concat(value, \"</field>\");\n      } // Add blocks connected to the next connection.\n      if (block.next) {\n        xmlString += \"<next>\".concat(this.blockToXML(block.next, comments), \"</next>\");\n      }\n      xmlString += \"</\".concat(tagName, \">\");\n      return xmlString;\n    }\n    /**\n     * Recursively encode a mutation object to XML.\n     * @param {!object} mutation Object representing a mutation.\n     * @return {string} XML string representing a mutation.\n     */\n  }, {\n    key: \"mutationToXML\",\n    value: function mutationToXML(mutation) {\n      var mutationString = \"<\".concat(mutation.tagName);\n      for (var prop in mutation) {\n        if (prop === 'children' || prop === 'tagName') continue;\n        var mutationValue = typeof mutation[prop] === 'string' ? xmlEscape(mutation[prop]) : mutation[prop]; // Handle dynamic extension blocks\n        if (prop === 'blockInfo') {\n          mutationValue = xmlEscape(JSON.stringify(mutation[prop]));\n        }\n        mutationString += \" \".concat(prop, \"=\\\"\").concat(mutationValue, \"\\\"\");\n      }\n      mutationString += '>';\n      for (var i = 0; i < mutation.children.length; i++) {\n        mutationString += this.mutationToXML(mutation.children[i]);\n      }\n      mutationString += \"</\".concat(mutation.tagName, \">\");\n      return mutationString;\n    } // ---------------------------------------------------------------------\n    /**\n     * Helper to serialize block fields and input fields for reporting new monitors\n     * @param {!object} block Block to be paramified.\n     * @return {!object} object of param key/values.\n     */\n  }, {\n    key: \"_getBlockParams\",\n    value: function _getBlockParams(block) {\n      var params = {};\n      for (var key in block.fields) {\n        params[key] = block.fields[key].value;\n      }\n      for (var inputKey in block.inputs) {\n        var inputBlock = this._blocks[block.inputs[inputKey].block];\n        for (var _key in inputBlock.fields) {\n          params[_key] = inputBlock.fields[_key].value;\n        }\n      }\n      return params;\n    }\n    /**\n     * Helper to get the corresponding internal procedure definition block\n     * @param {!object} defineBlock Outer define block.\n     * @return {!object} internal definition block which has the mutation.\n     */\n  }, {\n    key: \"_getCustomBlockInternal\",\n    value: function _getCustomBlockInternal(defineBlock) {\n      if (defineBlock.inputs && defineBlock.inputs.custom_block) {\n        return this._blocks[defineBlock.inputs.custom_block.block];\n      }\n    }\n    /**\n     * Helper to add a stack to `this._scripts`.\n     * @param {?string} topBlockId ID of block that starts the script.\n     */\n  }, {\n    key: \"_addScript\",\n    value: function _addScript(topBlockId) {\n      var i = this._scripts.indexOf(topBlockId);\n      if (i > -1) return; // Already in scripts.\n      this._scripts.push(topBlockId); // Update `topLevel` property on the top block.\n      this._blocks[topBlockId].topLevel = true;\n    }\n    /**\n     * Helper to remove a script from `this._scripts`.\n     * @param {?string} topBlockId ID of block that starts the script.\n     */\n  }, {\n    key: \"_deleteScript\",\n    value: function _deleteScript(topBlockId) {\n      var i = this._scripts.indexOf(topBlockId);\n      if (i > -1) this._scripts.splice(i, 1); // Update `topLevel` property on the top block.\n      if (this._blocks[topBlockId]) this._blocks[topBlockId].topLevel = false;\n    }\n  }], [{\n    key: \"BRANCH_INPUT_PREFIX\",\n    get: function get() {\n      return 'SUBSTACK';\n    }\n  }]);\n  return Blocks;\n}();\n/**\n * A private method shared with execute to build an object containing the block\n * information execute needs and that is reset when other cached Blocks info is\n * reset.\n * @param {Blocks} blocks Blocks containing the expected blockId\n * @param {string} blockId blockId for the desired execute cache\n * @param {function} CacheType constructor for cached block information\n * @return {object} execute cache object\n */\nBlocksExecuteCache.getCached = function (blocks, blockId, CacheType) {\n  var cached = blocks._cache._executeCached[blockId];\n  if (typeof cached !== 'undefined') {\n    return cached;\n  }\n  var block = blocks.getBlock(blockId);\n  if (typeof block === 'undefined') return null;\n  if (typeof CacheType === 'undefined') {\n    cached = {\n      id: blockId,\n      opcode: blocks.getOpcode(block),\n      fields: blocks.getFields(block),\n      inputs: blocks.getInputs(block),\n      mutation: blocks.getMutation(block)\n    };\n  } else {\n    cached = new CacheType(blocks, {\n      id: blockId,\n      opcode: blocks.getOpcode(block),\n      fields: blocks.getFields(block),\n      inputs: blocks.getInputs(block),\n      mutation: blocks.getMutation(block)\n    });\n  }\n  blocks._cache._executeCached[blockId] = cached;\n  return cached;\n};\n/**\n * Cache class constructor for runtime. Used to consider what threads should\n * start based on hat data.\n * @type {function}\n */\nvar RuntimeScriptCache = BlocksRuntimeCache._RuntimeScriptCache;\n/**\n * Get an array of scripts from a block container prefiltered to match opcode.\n * @param {Blocks} blocks - Container of blocks\n * @param {string} opcode - Opcode to filter top blocks by\n * @returns {Array.<RuntimeScriptCache>} - Array of RuntimeScriptCache cache\n *   objects\n */\nBlocksRuntimeCache.getScripts = function (blocks, opcode) {\n  var scripts = blocks._cache.scripts[opcode];\n  if (!scripts) {\n    scripts = blocks._cache.scripts[opcode] = [];\n    var allScripts = blocks._scripts;\n    for (var i = 0; i < allScripts.length; i++) {\n      var topBlockId = allScripts[i];\n      var block = blocks.getBlock(topBlockId);\n      if (block.opcode === opcode) {\n        scripts.push(new RuntimeScriptCache(blocks, topBlockId));\n      }\n    }\n  }\n  return scripts;\n};\nmodule.exports = Blocks;\n })