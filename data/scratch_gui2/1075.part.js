/* 1075 */\n (function(module, exports, __webpack_require__) {\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nvar Timer = __webpack_require__(136);\nvar Thread = __webpack_require__(224);\nvar execute = __webpack_require__(451);\n/**\n * Profiler frame name for stepping a single thread.\n * @const {string}\n */\nvar stepThreadProfilerFrame = 'Sequencer.stepThread';\n/**\n * Profiler frame name for the inner loop of stepThreads.\n * @const {string}\n */\nvar stepThreadsInnerProfilerFrame = 'Sequencer.stepThreads#inner';\n/**\n * Profiler frame name for execute.\n * @const {string}\n */\nvar executeProfilerFrame = 'execute';\n/**\n * Profiler frame ID for stepThreadProfilerFrame.\n * @type {number}\n */\nvar stepThreadProfilerId = -1;\n/**\n * Profiler frame ID for stepThreadsInnerProfilerFrame.\n * @type {number}\n */\nvar stepThreadsInnerProfilerId = -1;\n/**\n * Profiler frame ID for executeProfilerFrame.\n * @type {number}\n */\nvar executeProfilerId = -1;\nvar Sequencer = function () {\n  function Sequencer(runtime) {\n    _classCallCheck(this, Sequencer);\n   \n    this.timer = new Timer();\n   \n    this.runtime = runtime;\n    this.activeThread = null;\n  }\n \n  _createClass(Sequencer, [{\n    key: \"stepThreads\",\n   \n    value: function stepThreads() {\n      \n      var WORK_TIME = 0.75 * this.runtime.currentStepTime; \n      \n      \n      this.runtime.updateCurrentMSecs(); \n      this.timer.start(); \n      var numActiveThreads = Infinity; \n      var ranFirstTick = false;\n      var doneThreads = []; \n      \n      \n      \n      while (this.runtime.threads.length > 0 && numActiveThreads > 0 && this.timer.timeElapsed() < WORK_TIME && (this.runtime.turboMode || !this.runtime.redrawRequested)) {\n        if (this.runtime.profiler !== null) {\n          if (stepThreadsInnerProfilerId === -1) {\n            stepThreadsInnerProfilerId = this.runtime.profiler.idByName(stepThreadsInnerProfilerFrame);\n          }\n          this.runtime.profiler.start(stepThreadsInnerProfilerId);\n        }\n        numActiveThreads = 0;\n        var stoppedThread = false; \n        var threads = this.runtime.threads;\n        for (var i = 0; i < threads.length; i++) {\n          var activeThread = this.activeThread = threads[i]; \n          if (activeThread.stack.length === 0 || activeThread.status === Thread.STATUS_DONE) {\n            \n            stoppedThread = true;\n            continue;\n          }\n          if (activeThread.status === Thread.STATUS_YIELD_TICK && !ranFirstTick) {\n            \n            activeThread.status = Thread.STATUS_RUNNING;\n          }\n          if (activeThread.status === Thread.STATUS_RUNNING || activeThread.status === Thread.STATUS_YIELD) {\n            \n            if (this.runtime.profiler !== null) {\n              if (stepThreadProfilerId === -1) {\n                stepThreadProfilerId = this.runtime.profiler.idByName(stepThreadProfilerFrame);\n              } \n              this.runtime.profiler.increment(stepThreadProfilerId);\n            }\n            this.stepThread(activeThread);\n            activeThread.warpTimer = null;\n            if (activeThread.isKilled) {\n              i--; \n            }\n          }\n          if (activeThread.status === Thread.STATUS_RUNNING) {\n            numActiveThreads++;\n          } \n          \n          if (activeThread.stack.length === 0 || activeThread.status === Thread.STATUS_DONE) {\n            \n            stoppedThread = true;\n          }\n        } \n        \n        ranFirstTick = true;\n        if (this.runtime.profiler !== null) {\n          this.runtime.profiler.stop();\n        } \n        if (stoppedThread) {\n          var nextActiveThread = 0;\n          for (var _i = 0; _i < this.runtime.threads.length; _i++) {\n            var thread = this.runtime.threads[_i];\n            if (thread.stack.length !== 0 && thread.status !== Thread.STATUS_DONE) {\n              this.runtime.threads[nextActiveThread] = thread;\n              nextActiveThread++;\n            } else {\n              doneThreads.push(thread);\n            }\n          }\n          this.runtime.threads.length = nextActiveThread;\n        }\n      }\n      this.activeThread = null;\n      return doneThreads;\n    }\n   \n  }, {\n    key: \"stepThread\",\n    value: function stepThread(thread) {\n      var currentBlockId = thread.peekStack();\n      if (!currentBlockId) {\n        \n        thread.popStack(); \n        if (thread.stack.length === 0) {\n          thread.status = Thread.STATUS_DONE;\n          return;\n        }\n      } \n      while (currentBlockId = thread.peekStack()) {\n        var isWarpMode = thread.peekStackFrame().warpMode;\n        if (isWarpMode && !thread.warpTimer) {\n          \n          \n          thread.warpTimer = new Timer();\n          thread.warpTimer.start();\n        } \n        if (this.runtime.profiler !== null) {\n          if (executeProfilerId === -1) {\n            executeProfilerId = this.runtime.profiler.idByName(executeProfilerFrame);\n          } \n          this.runtime.profiler.increment(executeProfilerId);\n        }\n        if (thread.target === null) {\n          this.retireThread(thread);\n        } else {\n          execute(this, thread);\n        }\n        thread.blockGlowInFrame = currentBlockId; \n        if (thread.status === Thread.STATUS_YIELD) {\n          \n          thread.status = Thread.STATUS_RUNNING; \n          if (isWarpMode && thread.warpTimer.timeElapsed() <= Sequencer.WARP_TIME) {\n            continue;\n          }\n          return;\n        } else if (thread.status === Thread.STATUS_PROMISE_WAIT) {\n          \n          \n          \n          return;\n        } else if (thread.status === Thread.STATUS_YIELD_TICK) {\n          \n          return;\n        } \n        if (thread.peekStack() === currentBlockId) {\n          thread.goToNextBlock();\n        } \n        while (!thread.peekStack()) {\n          thread.popStack();\n          if (thread.stack.length === 0) {\n            \n            thread.status = Thread.STATUS_DONE;\n            return;\n          }\n          var stackFrame = thread.peekStackFrame();\n          isWarpMode = stackFrame.warpMode;\n          if (stackFrame.isLoop) {\n            \n            \n            \n            \n            if (!isWarpMode || thread.warpTimer.timeElapsed() > Sequencer.WARP_TIME) {\n              \n              \n              return;\n            } \n            \n            continue;\n          } else if (stackFrame.waitingReporter) {\n            \n            \n            \n            return;\n          } \n          thread.goToNextBlock();\n        }\n      }\n    }\n   \n  }, {\n    key: \"stepToBranch\",\n    value: function stepToBranch(thread, branchNum, isLoop) {\n      if (!branchNum) {\n        branchNum = 1;\n      }\n      var currentBlockId = thread.peekStack();\n      var branchId = thread.target.blocks.getBranch(currentBlockId, branchNum);\n      thread.peekStackFrame().isLoop = isLoop;\n      if (branchId) {\n        \n        thread.pushStack(branchId);\n      } else {\n        thread.pushStack(null);\n      }\n    }\n   \n  }, {\n    key: \"stepToProcedure\",\n    value: function stepToProcedure(thread, procedureCode) {\n      var definition = thread.target.blocks.getProcedureDefinition(procedureCode);\n      if (!definition) {\n        return;\n      } \n      \n      var isRecursive = thread.isRecursiveCall(procedureCode); \n      \n      \n      \n      \n      thread.pushStack(definition); \n      if (thread.peekStackFrame().warpMode && thread.warpTimer.timeElapsed() > Sequencer.WARP_TIME) {\n        thread.status = Thread.STATUS_YIELD;\n      } else {\n        \n        \n        var definitionBlock = thread.target.blocks.getBlock(definition);\n        var innerBlock = thread.target.blocks.getBlock(definitionBlock.inputs.custom_block.block);\n        var doWarp = false;\n        if (innerBlock && innerBlock.mutation) {\n          var warp = innerBlock.mutation.warp;\n          if (typeof warp === 'boolean') {\n            doWarp = warp;\n          } else if (typeof warp === 'string') {\n            doWarp = JSON.parse(warp);\n          }\n        }\n        if (doWarp) {\n          thread.peekStackFrame().warpMode = true;\n        } else if (isRecursive) {\n          \n          thread.status = Thread.STATUS_YIELD;\n        }\n      }\n    }\n   \n  }, {\n    key: \"retireThread\",\n    value: function retireThread(thread) {\n      thread.stack = [];\n      thread.stackFrame = [];\n      thread.requestScriptGlowInFrame = false;\n      thread.status = Thread.STATUS_DONE;\n    }\n  }], [{\n    key: \"WARP_TIME\",\n    get: function get() {\n      return 500;\n    }\n  }]);\n  return Sequencer;\n}();\nmodule.exports = Sequencer;\n })