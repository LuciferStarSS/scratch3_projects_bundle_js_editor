/* 1094 */\n (function(module, exports, __webpack_require__) {\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n/**\n * @file library.js\n *\n * Tony Hwang and John Maloney, January 2011\n * Michael \"Z\" Goddard, March 2018\n *\n * Video motion sensing primitives.\n */\nvar _require = __webpack_require__(1095),\n    motionVector = _require.motionVector,\n    scratchAtan2 = _require.scratchAtan2;\n/**\n * The width of the intended resolution to analyze for motion.\n * @type {number}\n */\nvar WIDTH = 480;\n/**\n * The height of the intended resolution to analyze for motion.\n * @type {number}\n */\nvar HEIGHT = 360;\n/**\n * A constant value to scale the magnitude of the x and y components called u\n * and v. This creates the motionAmount value.\n *\n * Old note: chosen empirically to give a range of roughly 0-100\n *\n * @type {number}\n */\nvar AMOUNT_SCALE = 100;\n/**\n * A constant value to scale the magnitude of the x and y components called u\n * and v in the local motion derivative. This creates the motionAmount value on\n * a target's motion state.\n *\n * Old note: note 2e-4 * activePixelNum is an experimentally tuned threshold\n * for my logitech Pro 9000 webcam - TTH\n *\n * @type {number}\n */\nvar LOCAL_AMOUNT_SCALE = AMOUNT_SCALE * 2e-4;\n/**\n * The motion amount must be higher than the THRESHOLD to calculate a new\n * direction value.\n * @type {number}\n */\nvar THRESHOLD = 10;\n/**\n * The size of the radius of the window of summarized values when considering\n * the motion inside the full resolution of the sample.\n * @type {number}\n */\nvar WINSIZE = 8;\n/**\n * A ceiling for the motionAmount stored to a local target's motion state. The\n * motionAmount is not allowed to be larger than LOCAL_MAX_AMOUNT.\n * @type {number}\n */\nvar LOCAL_MAX_AMOUNT = 100;\n/**\n * The motion amount for a target's local motion must be higher than the\n * LOCAL_THRESHOLD to calculate a new direction value.\n * @type {number}\n */\nvar LOCAL_THRESHOLD = THRESHOLD / 3;\n/**\n * Store the necessary image pixel data to compares frames of a video and\n * detect an amount and direction of motion in the full sample or in a\n * specified area.\n * @constructor\n */\nvar VideoMotion = function () {\n  function VideoMotion() {\n    _classCallCheck(this, VideoMotion);\n   \n    this.frameNumber = 0;\n   \n    this.lastAnalyzedFrame = 0;\n   \n    this.motionAmount = 0;\n   \n    this.motionDirection = 0;\n   \n    this.curr = null;\n   \n    this.prev = null;\n   \n    this._arrays = new ArrayBuffer(WIDTH * HEIGHT * 2 * 1);\n   \n    this._curr = new Uint8ClampedArray(this._arrays, WIDTH * HEIGHT * 0 * 1, WIDTH * HEIGHT);\n   \n    this._prev = new Uint8ClampedArray(this._arrays, WIDTH * HEIGHT * 1 * 1, WIDTH * HEIGHT);\n  }\n \n  _createClass(VideoMotion, [{\n    key: \"reset\",\n    value: function reset() {\n      this.frameNumber = 0;\n      this.lastAnalyzedFrame = 0;\n      this.motionAmount = this.motionDirection = 0;\n      this.prev = this.curr = null;\n    }\n   \n  }, {\n    key: \"addFrame\",\n    value: function addFrame(source) {\n      this.frameNumber++; \n      this.prev = this.curr; \n      \n      this.curr = new Uint32Array(source.buffer.slice(0)); \n      \n      var _tmp = this._prev;\n      this._prev = this._curr;\n      this._curr = _tmp;\n      for (var i = 0; i < this.curr.length; i++) {\n        this._curr[i] = this.curr[i] & 0xff;\n      }\n    }\n   \n  }, {\n    key: \"analyzeFrame\",\n    value: function analyzeFrame() {\n      if (!this.curr || !this.prev) {\n        this.motionAmount = this.motionDirection = -1; \n        return;\n      } \n      if (this.lastAnalyzedFrame === this.frameNumber) {\n        return;\n      }\n      this.lastAnalyzedFrame = this.frameNumber;\n      var curr = this._curr,\n          prev = this._prev;\n      var winStep = WINSIZE * 2 + 1;\n      var wmax = WIDTH - WINSIZE - 1;\n      var hmax = HEIGHT - WINSIZE - 1; \n      \n      var uu = 0;\n      var vv = 0;\n      var n = 0; \n      \n      \n      for (var i = WINSIZE + 1; i < hmax; i += winStep) {\n        for (var j = WINSIZE + 1; j < wmax; j += winStep) {\n          var A2 = 0;\n          var A1B2 = 0;\n          var B1 = 0;\n          var C1 = 0;\n          var C2 = 0; \n          var address = (i - WINSIZE) * WIDTH + j - WINSIZE;\n          var nextAddress = address + winStep;\n          var maxAddress = (i + WINSIZE) * WIDTH + j + WINSIZE;\n          for (; address <= maxAddress; address += WIDTH - winStep, nextAddress += WIDTH) {\n            for (; address <= nextAddress; address += 1) {\n              \n              \n              var gradT = prev[address] - curr[address]; \n              \n              var gradX = curr[address - 1] - curr[address + 1]; \n              \n              var gradY = curr[address - WIDTH] - curr[address + WIDTH]; \n              \n              A2 += gradX * gradX;\n              A1B2 += gradX * gradY;\n              B1 += gradY * gradY;\n              C2 += gradX * gradT;\n              C1 += gradY * gradT;\n            }\n          } \n          \n          var _motionVector = motionVector(A2, A1B2, B1, C2, C1),\n              u = _motionVector.u,\n              v = _motionVector.v; \n          \n          if (-winStep < u && u < winStep && -winStep < v && v < winStep) {\n            uu += u;\n            vv += v;\n            n++;\n          }\n        }\n      } \n      uu /= n;\n      vv /= n; \n      this.motionAmount = Math.round(AMOUNT_SCALE * Math.hypot(uu, vv));\n      if (this.motionAmount > THRESHOLD) {\n        \n        this.motionDirection = scratchAtan2(vv, uu);\n      }\n    }\n   \n  }, {\n    key: \"getLocalMotion\",\n    value: function getLocalMotion(drawable, state) {\n      if (!this.curr || !this.prev) {\n        state.motionAmount = state.motionDirection = -1; \n        return;\n      } \n      if (state.motionFrameNumber !== this.frameNumber) {\n        var prev = this._prev,\n            curr = this._curr; \n        \n        drawable.updateCPURenderAttributes(); \n        \n        \n        var boundingRect = drawable.getFastBounds(); \n        \n        var xmin = Math.max(Math.floor(boundingRect.left + WIDTH / 2), 1);\n        var xmax = Math.min(Math.floor(boundingRect.right + WIDTH / 2), WIDTH - 1);\n        var ymin = Math.max(Math.floor(HEIGHT / 2 - boundingRect.top), 1);\n        var ymax = Math.min(Math.floor(HEIGHT / 2 - boundingRect.bottom), HEIGHT - 1);\n        var A2 = 0;\n        var A1B2 = 0;\n        var B1 = 0;\n        var C1 = 0;\n        var C2 = 0;\n        var scaleFactor = 0;\n        var position = [0, 0, 0]; \n        for (var i = ymin; i < ymax; i++) {\n          for (var j = xmin; j < xmax; j++) {\n            \n            \n            \n            \n            position[0] = j - WIDTH / 2;\n            position[1] = HEIGHT / 2 - i; \n            \n            \n            if (drawable.isTouching(position)) {\n              var address = i * WIDTH + j; \n              \n              var gradT = prev[address] - curr[address]; \n              \n              var gradX = curr[address - 1] - curr[address + 1]; \n              \n              var gradY = curr[address - WIDTH] - curr[address + WIDTH]; \n              \n              A2 += gradX * gradX;\n              A1B2 += gradX * gradY;\n              B1 += gradY * gradY;\n              C2 += gradX * gradT;\n              C1 += gradY * gradT;\n              scaleFactor++;\n            }\n          }\n        } \n        \n        var _motionVector2 = motionVector(A2, A1B2, B1, C2, C1),\n            u = _motionVector2.u,\n            v = _motionVector2.v;\n        var activePixelNum = 0;\n        if (scaleFactor) {\n          \n          activePixelNum = scaleFactor;\n          scaleFactor /= 2 * WINSIZE * 2 * WINSIZE;\n          u = u / scaleFactor;\n          v = v / scaleFactor;\n        } \n        \n        state.motionAmount = Math.round(LOCAL_AMOUNT_SCALE * activePixelNum * Math.hypot(u, v));\n        if (state.motionAmount > LOCAL_MAX_AMOUNT) {\n          \n          state.motionAmount = LOCAL_MAX_AMOUNT;\n        }\n        if (state.motionAmount > LOCAL_THRESHOLD) {\n          \n          state.motionDirection = scratchAtan2(v, u);\n        } \n        state.motionFrameNumber = this.frameNumber;\n      }\n    }\n  }]);\n  return VideoMotion;\n}();\nmodule.exports = VideoMotion;\n })