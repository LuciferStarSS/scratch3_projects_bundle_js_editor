/* 944 */\n (function(module, exports, __webpack_require__) {\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nvar log = __webpack_require__(39);\n/**\n * @typedef {object} DispatchCallMessage - a message to the dispatch system representing a service method call\n * @property {*} responseId - send a response message with this response ID. See {@link DispatchResponseMessage}\n * @property {string} service - the name of the service to be called\n * @property {string} method - the name of the method to be called\n * @property {Array|undefined} args - the arguments to be passed to the method\n */\n/**\n * @typedef {object} DispatchResponseMessage - a message to the dispatch system representing the results of a call\n * @property {*} responseId - a copy of the response ID from the call which generated this response\n * @property {*|undefined} error - if this is truthy, then it contains results from a failed call (such as an exception)\n * @property {*|undefined} result - if error is not truthy, then this contains the return value of the call (if any)\n */\n/**\n * @typedef {DispatchCallMessage|DispatchResponseMessage} DispatchMessage\n * Any message to the dispatch system.\n */\n/**\n * The SharedDispatch class is responsible for dispatch features shared by\n * {@link CentralDispatch} and {@link WorkerDispatch}.\n */\nvar SharedDispatch = function () {\n  function SharedDispatch() {\n    _classCallCheck(this, SharedDispatch);\n   \n    this.callbacks = [];\n   \n    this.nextResponseId = 0;\n  }\n \n  _createClass(SharedDispatch, [{\n    key: \"call\",\n    value: function call(service, method) {\n      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        args[_key - 2] = arguments[_key];\n      }\n      return this.transferCall.apply(this, [service, method, null].concat(args));\n    }\n   \n  }, {\n    key: \"transferCall\",\n    value: function transferCall(service, method, transfer) {\n      try {\n        var _this$_getServiceProv = this._getServiceProvider(service),\n            provider = _this$_getServiceProv.provider,\n            isRemote = _this$_getServiceProv.isRemote;\n        if (provider) {\n          for (var _len2 = arguments.length, args = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n            args[_key2 - 3] = arguments[_key2];\n          }\n          if (isRemote) {\n            return this._remoteTransferCall.apply(this, [provider, service, method, transfer].concat(args));\n          }\n          var result = provider[method].apply(provider, args);\n          return Promise.resolve(result);\n        }\n        return Promise.reject(new Error(\"Service not found: \".concat(service)));\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }\n   \n  }, {\n    key: \"_isRemoteService\",\n    value: function _isRemoteService(service) {\n      return this._getServiceProvider(service).isRemote;\n    }\n   \n  }, {\n    key: \"_remoteCall\",\n    value: function _remoteCall(provider, service, method) {\n      for (var _len3 = arguments.length, args = new Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {\n        args[_key3 - 3] = arguments[_key3];\n      }\n      return this._remoteTransferCall.apply(this, [provider, service, method, null].concat(args));\n    }\n   \n  }, {\n    key: \"_remoteTransferCall\",\n    value: function _remoteTransferCall(provider, service, method, transfer) {\n      var _this = this;\n      for (var _len4 = arguments.length, args = new Array(_len4 > 4 ? _len4 - 4 : 0), _key4 = 4; _key4 < _len4; _key4++) {\n        args[_key4 - 4] = arguments[_key4];\n      }\n      return new Promise(function (resolve, reject) {\n        var responseId = _this._storeCallbacks(resolve, reject);\n       \n        if (args.length > 0 && typeof args[args.length - 1].yield === 'function') {\n          args.pop();\n        }\n        if (transfer) {\n          provider.postMessage({\n            service: service,\n            method: method,\n            responseId: responseId,\n            args: args\n          }, transfer);\n        } else {\n          provider.postMessage({\n            service: service,\n            method: method,\n            responseId: responseId,\n            args: args\n          });\n        }\n      });\n    }\n   \n  }, {\n    key: \"_storeCallbacks\",\n    value: function _storeCallbacks(resolve, reject) {\n      var responseId = this.nextResponseId++;\n      this.callbacks[responseId] = [resolve, reject];\n      return responseId;\n    }\n   \n  }, {\n    key: \"_deliverResponse\",\n    value: function _deliverResponse(responseId, message) {\n      try {\n        var _this$callbacks$respo = _slicedToArray(this.callbacks[responseId], 2),\n            resolve = _this$callbacks$respo[0],\n            reject = _this$callbacks$respo[1];\n        delete this.callbacks[responseId];\n        if (message.error) {\n          reject(message.error);\n        } else {\n          resolve(message.result);\n        }\n      } catch (e) {\n        log.error(\"Dispatch callback failed: \".concat(JSON.stringify(e)));\n      }\n    }\n   \n  }, {\n    key: \"_onMessage\",\n    value: function _onMessage(worker, event) {\n     \n      var message = event.data;\n      message.args = message.args || [];\n      var promise;\n      if (message.service) {\n        if (message.service === 'dispatch') {\n          promise = this._onDispatchMessage(worker, message);\n        } else {\n          promise = this.call.apply(this, [message.service, message.method].concat(_toConsumableArray(message.args)));\n        }\n      } else if (typeof message.responseId === 'undefined') {\n        log.error(\"Dispatch caught malformed message from a worker: \".concat(JSON.stringify(event)));\n      } else {\n        this._deliverResponse(message.responseId, message);\n      }\n      if (promise) {\n        if (typeof message.responseId === 'undefined') {\n          log.error(\"Dispatch message missing required response ID: \".concat(JSON.stringify(event)));\n        } else {\n          promise.then(function (result) {\n            return worker.postMessage({\n              responseId: message.responseId,\n              result: result\n            });\n          }, function (error) {\n            return worker.postMessage({\n              responseId: message.responseId,\n              error: error\n            });\n          });\n        }\n      }\n    }\n   \n  }, {\n    key: \"_getServiceProvider\",\n    value: function _getServiceProvider(service) {\n      throw new Error(\"Could not get provider for \".concat(service, \": _getServiceProvider not implemented\"));\n    }\n   \n  }, {\n    key: \"_onDispatchMessage\",\n    value: function _onDispatchMessage(worker, message) {\n      throw new Error(\"Unimplemented dispatch message handler cannot handle \".concat(message.method, \" method\"));\n    }\n  }]);\n  return SharedDispatch;\n}();\nmodule.exports = SharedDispatch;\n })