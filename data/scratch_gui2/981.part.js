/* 981 */\n (function(module, exports, __webpack_require__) {\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nvar ArgumentType = __webpack_require__(63);\nvar BlockType = __webpack_require__(45);\nvar Cast = __webpack_require__(48);\nvar formatMessage = __webpack_require__(71);\nvar color = __webpack_require__(180);\nvar BLE = __webpack_require__(221);\nvar Base64Util = __webpack_require__(182);\nvar MathUtil = __webpack_require__(62);\nvar RateLimiter = __webpack_require__(298);\nvar log = __webpack_require__(39);\n/**\n * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.\n * @type {string}\n */\n\nvar iconURI = 'data:image/png;base64,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';\n/**\n * A list of WeDo 2.0 BLE service UUIDs.\n * @enum\n */\nvar BLEService = {\n  DEVICE_SERVICE: '00001523-1212-efde-1523-785feabcd123',\n  IO_SERVICE: '00004f0e-1212-efde-1523-785feabcd123'\n};\n/**\n * A list of WeDo 2.0 BLE characteristic UUIDs.\n *\n * Characteristics on DEVICE_SERVICE:\n * - ATTACHED_IO\n *\n * Characteristics on IO_SERVICE:\n * - INPUT_VALUES\n * - INPUT_COMMAND\n * - OUTPUT_COMMAND\n *\n * @enum\n */\nvar BLECharacteristic = {\n  ATTACHED_IO: '00001527-1212-efde-1523-785feabcd123',\n  LOW_VOLTAGE_ALERT: '00001528-1212-efde-1523-785feabcd123',\n  INPUT_VALUES: '00001560-1212-efde-1523-785feabcd123',\n  INPUT_COMMAND: '00001563-1212-efde-1523-785feabcd123',\n  OUTPUT_COMMAND: '00001565-1212-efde-1523-785feabcd123'\n};\n/**\n * A time interval to wait (in milliseconds) in between battery check calls.\n * @type {number}\n */\nvar BLEBatteryCheckInterval = 5000;\n/**\n * A time interval to wait (in milliseconds) while a block that sends a BLE message is running.\n * @type {number}\n */\nvar BLESendInterval = 100;\n/**\n * A maximum number of BLE message sends per second, to be enforced by the rate limiter.\n * @type {number}\n */\nvar BLESendRateMax = 20;\n/**\n * Enum for WeDo 2.0 sensor and output types.\n * @readonly\n * @enum {number}\n */\nvar WeDo2Device = {\n  MOTOR: 1,\n  PIEZO: 22,\n  LED: 23,\n  TILT: 34,\n  DISTANCE: 35\n};\n/**\n * Enum for connection/port ids assigned to internal WeDo 2.0 output devices.\n * @readonly\n * @enum {number}\n */\n\nvar WeDo2ConnectID = {\n  LED: 6,\n  PIEZO: 5\n};\n/**\n * Enum for ids for various output commands on the WeDo 2.0.\n * @readonly\n * @enum {number}\n */\nvar WeDo2Command = {\n  MOTOR_POWER: 1,\n  PLAY_TONE: 2,\n  STOP_TONE: 3,\n  WRITE_RGB: 4,\n  SET_VOLUME: 255\n};\n/**\n * Enum for modes for input sensors on the WeDo 2.0.\n * @enum {number}\n */\nvar WeDo2Mode = {\n  TILT: 0,\n  \n  DISTANCE: 0,\n  \n  LED: 1 \n};\n/**\n * Enum for units for input sensors on the WeDo 2.0.\n *\n * 0 = raw\n * 1 = percent\n *\n * @enum {number}\n */\nvar WeDo2Unit = {\n  TILT: 0,\n  DISTANCE: 1,\n  LED: 0\n};\n/**\n * Manage power, direction, and timers for one WeDo 2.0 motor.\n */\nvar WeDo2Motor = function () {\n \n  function WeDo2Motor(parent, index) {\n    _classCallCheck(this, WeDo2Motor);\n   \n    this._parent = parent;\n   \n    this._index = index;\n   \n    this._direction = 1;\n   \n    this._power = 100;\n   \n    this._isOn = false;\n   \n    this._pendingTimeoutId = null;\n   \n    this._pendingTimeoutStartTime = null;\n   \n    this._pendingTimeoutDelay = null;\n    this.startBraking = this.startBraking.bind(this);\n    this.turnOff = this.turnOff.bind(this);\n  }\n \n  _createClass(WeDo2Motor, [{\n    key: \"turnOn\",\n   \n    value: function turnOn() {\n      if (this._power === 0) return;\n      var cmd = this._parent.generateOutputCommand(this._index + 1, WeDo2Command.MOTOR_POWER, [this._power * this._direction] \n      );\n      this._parent.send(BLECharacteristic.OUTPUT_COMMAND, cmd);\n      this._isOn = true;\n      this._clearTimeout();\n    }\n   \n  }, {\n    key: \"turnOnFor\",\n    value: function turnOnFor(milliseconds) {\n      if (this._power === 0) return;\n      milliseconds = Math.max(0, milliseconds);\n      this.turnOn();\n      this._setNewTimeout(this.startBraking, milliseconds);\n    }\n   \n  }, {\n    key: \"startBraking\",\n    value: function startBraking() {\n      if (this._power === 0) return;\n      var cmd = this._parent.generateOutputCommand(this._index + 1, WeDo2Command.MOTOR_POWER, [127] \n      );\n      this._parent.send(BLECharacteristic.OUTPUT_COMMAND, cmd);\n      this._isOn = false;\n      this._setNewTimeout(this.turnOff, WeDo2Motor.BRAKE_TIME_MS);\n    }\n   \n  }, {\n    key: \"turnOff\",\n    value: function turnOff() {\n      var useLimiter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      if (this._power === 0) return;\n      var cmd = this._parent.generateOutputCommand(this._index + 1, WeDo2Command.MOTOR_POWER, [0] \n      );\n      this._parent.send(BLECharacteristic.OUTPUT_COMMAND, cmd, useLimiter);\n      this._isOn = false;\n    }\n   \n  }, {\n    key: \"_clearTimeout\",\n    value: function _clearTimeout() {\n      if (this._pendingTimeoutId !== null) {\n        clearTimeout(this._pendingTimeoutId);\n        this._pendingTimeoutId = null;\n        this._pendingTimeoutStartTime = null;\n        this._pendingTimeoutDelay = null;\n      }\n    }\n   \n  }, {\n    key: \"_setNewTimeout\",\n    value: function _setNewTimeout(callback, delay) {\n      var _this = this;\n      this._clearTimeout();\n      var timeoutID = setTimeout(function () {\n        if (_this._pendingTimeoutId === timeoutID) {\n          _this._pendingTimeoutId = null;\n          _this._pendingTimeoutStartTime = null;\n          _this._pendingTimeoutDelay = null;\n        }\n        callback();\n      }, delay);\n      this._pendingTimeoutId = timeoutID;\n      this._pendingTimeoutStartTime = Date.now();\n      this._pendingTimeoutDelay = delay;\n    }\n  }, {\n    key: \"direction\",\n   \n    get: function get() {\n      return this._direction;\n    }\n   \n    ,\n    set: function set(value) {\n      if (value < 0) {\n        this._direction = -1;\n      } else {\n        this._direction = 1;\n      }\n    }\n   \n  }, {\n    key: \"power\",\n    get: function get() {\n      return this._power;\n    }\n   \n    ,\n    set: function set(value) {\n      var p = Math.max(0, Math.min(value, 100)); \n      \n      if (p === 0) {\n        this._power = 0;\n      } else {\n        var delta = 100 / p;\n        this._power = 30 + 70 / delta;\n      }\n    }\n   \n  }, {\n    key: \"isOn\",\n    get: function get() {\n      return this._isOn;\n    }\n   \n  }, {\n    key: \"pendingTimeoutStartTime\",\n    get: function get() {\n      return this._pendingTimeoutStartTime;\n    }\n   \n  }, {\n    key: \"pendingTimeoutDelay\",\n    get: function get() {\n      return this._pendingTimeoutDelay;\n    }\n  }], [{\n    key: \"BRAKE_TIME_MS\",\n    get: function get() {\n      return 1000;\n    }\n  }]);\n  return WeDo2Motor;\n}();\n/**\n * Manage communication with a WeDo 2.0 peripheral over a Bluetooth Low Energy client socket.\n */\nvar WeDo2 = function () {\n  function WeDo2(runtime, extensionId) {\n    _classCallCheck(this, WeDo2);\n   \n    this._runtime = runtime;\n    this._runtime.on('PROJECT_STOP_ALL', this.stopAll.bind(this));\n   \n    this._extensionId = extensionId;\n   \n    this._ports = ['none', 'none'];\n   \n    this._motors = [null, null];\n   \n    this._sensors = {\n      tiltX: 0,\n      tiltY: 0,\n      distance: 0\n    };\n   \n    this._ble = null;\n    this._runtime.registerPeripheralExtension(extensionId, this);\n   \n    this._rateLimiter = new RateLimiter(BLESendRateMax);\n   \n    this._batteryLevelIntervalId = null;\n    this.reset = this.reset.bind(this);\n    this._onConnect = this._onConnect.bind(this);\n    this._onMessage = this._onMessage.bind(this);\n    this._checkBatteryLevel = this._checkBatteryLevel.bind(this);\n  }\n \n  _createClass(WeDo2, [{\n    key: \"motor\",\n   \n    value: function motor(index) {\n      return this._motors[index];\n    }\n   \n  }, {\n    key: \"stopAllMotors\",\n    value: function stopAllMotors() {\n      this._motors.forEach(function (motor) {\n        if (motor) {\n          \n          \n          \n          motor.turnOff(false);\n        }\n      });\n    }\n   \n  }, {\n    key: \"setLED\",\n    value: function setLED(inputRGB) {\n      var rgb = [inputRGB >> 16 & 0x000000FF, inputRGB >> 8 & 0x000000FF, inputRGB & 0x000000FF];\n      var cmd = this.generateOutputCommand(WeDo2ConnectID.LED, WeDo2Command.WRITE_RGB, rgb);\n      return this.send(BLECharacteristic.OUTPUT_COMMAND, cmd);\n    }\n   \n  }, {\n    key: \"setLEDMode\",\n    value: function setLEDMode() {\n      var cmd = this.generateInputCommand(WeDo2ConnectID.LED, WeDo2Device.LED, WeDo2Mode.LED, 0, WeDo2Unit.LED, false);\n      return this.send(BLECharacteristic.INPUT_COMMAND, cmd);\n    }\n   \n  }, {\n    key: \"stopLED\",\n    value: function stopLED() {\n      var cmd = this.generateOutputCommand(WeDo2ConnectID.LED, WeDo2Command.WRITE_RGB, [0, 0, 0]);\n      return this.send(BLECharacteristic.OUTPUT_COMMAND, cmd);\n    }\n   \n  }, {\n    key: \"playTone\",\n    value: function playTone(tone, milliseconds) {\n      var cmd = this.generateOutputCommand(WeDo2ConnectID.PIEZO, WeDo2Command.PLAY_TONE, [tone, tone >> 8, milliseconds, milliseconds >> 8]);\n      return this.send(BLECharacteristic.OUTPUT_COMMAND, cmd);\n    }\n   \n  }, {\n    key: \"stopTone\",\n    value: function stopTone() {\n      var cmd = this.generateOutputCommand(WeDo2ConnectID.PIEZO, WeDo2Command.STOP_TONE); \n      \n      return this.send(BLECharacteristic.OUTPUT_COMMAND, cmd, false);\n    }\n   \n  }, {\n    key: \"stopAll\",\n    value: function stopAll() {\n      if (!this.isConnected()) return;\n      this.stopTone();\n      this.stopAllMotors();\n    }\n   \n  }, {\n    key: \"scan\",\n    value: function scan() {\n      if (this._ble) {\n        this._ble.disconnect();\n      }\n      this._ble = new BLE(this._runtime, this._extensionId, {\n        filters: [{\n          services: [BLEService.DEVICE_SERVICE]\n        }],\n        optionalServices: [BLEService.IO_SERVICE]\n      }, this._onConnect, this.reset);\n    }\n   \n  }, {\n    key: \"connect\",\n    value: function connect(id) {\n      if (this._ble) {\n        this._ble.connectPeripheral(id);\n      }\n    }\n   \n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      if (this._ble) {\n        this._ble.disconnect();\n      }\n      this.reset();\n    }\n   \n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this._ports = ['none', 'none'];\n      this._motors = [null, null];\n      this._sensors = {\n        tiltX: 0,\n        tiltY: 0,\n        distance: 0\n      };\n      if (this._batteryLevelIntervalId) {\n        window.clearInterval(this._batteryLevelIntervalId);\n        this._batteryLevelIntervalId = null;\n      }\n    }\n   \n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      var connected = false;\n      if (this._ble) {\n        connected = this._ble.isConnected();\n      }\n      return connected;\n    }\n   \n  }, {\n    key: \"send\",\n    value: function send(uuid, message) {\n      var useLimiter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      if (!this.isConnected()) return Promise.resolve();\n      if (useLimiter) {\n        if (!this._rateLimiter.okayToSend()) return Promise.resolve();\n      }\n      return this._ble.write(BLEService.IO_SERVICE, uuid, Base64Util.uint8ArrayToBase64(message), 'base64');\n    }\n   \n  }, {\n    key: \"generateOutputCommand\",\n    value: function generateOutputCommand(connectID, commandID) {\n      var values = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var command = [connectID, commandID];\n      if (values) {\n        command = command.concat(values.length).concat(values);\n      }\n      return command;\n    }\n   \n  }, {\n    key: \"generateInputCommand\",\n    value: function generateInputCommand(connectID, type, mode, delta, units, enableNotifications) {\n      var command = [1, \n      2, \n      connectID, type, mode, delta, 0, \n      0, \n      0, \n      units, enableNotifications ? 1 : 0];\n      return command;\n    }\n   \n  }, {\n    key: \"_onConnect\",\n    value: function _onConnect() {\n      this.setLEDMode();\n      this.setLED(0x0000FF);\n      this._ble.startNotifications(BLEService.DEVICE_SERVICE, BLECharacteristic.ATTACHED_IO, this._onMessage);\n      this._batteryLevelIntervalId = window.setInterval(this._checkBatteryLevel, BLEBatteryCheckInterval);\n    }\n   \n  }, {\n    key: \"_onMessage\",\n    value: function _onMessage(base64) {\n      var data = Base64Util.base64ToUint8Array(base64); \n     \n      switch (data[0]) {\n        case 1:\n        case 2:\n          {\n            var connectID = data[0];\n            if (data[1] === 0) {\n              \n              this._clearPort(connectID);\n            } else {\n              \n              this._registerSensorOrMotor(connectID, data[3]);\n            }\n            break;\n          }\n        default:\n          {\n            \n            var _connectID = data[1];\n            var type = this._ports[_connectID - 1];\n            if (type === WeDo2Device.DISTANCE) {\n              this._sensors.distance = data[2];\n            }\n            if (type === WeDo2Device.TILT) {\n              this._sensors.tiltX = data[2];\n              this._sensors.tiltY = data[3];\n            }\n            break;\n          }\n      }\n    }\n   \n  }, {\n    key: \"_checkBatteryLevel\",\n    value: function _checkBatteryLevel() {\n      this._ble.read(BLEService.DEVICE_SERVICE, BLECharacteristic.LOW_VOLTAGE_ALERT, false);\n    }\n   \n  }, {\n    key: \"_registerSensorOrMotor\",\n    value: function _registerSensorOrMotor(connectID, type) {\n      \n      this._ports[connectID - 1] = type; \n      if (type === WeDo2Device.MOTOR) {\n        this._motors[connectID - 1] = new WeDo2Motor(this, connectID - 1);\n      } else {\n        \n        var typeString = type === WeDo2Device.DISTANCE ? 'DISTANCE' : 'TILT';\n        var cmd = this.generateInputCommand(connectID, type, WeDo2Mode[typeString], 1, WeDo2Unit[typeString], true);\n        this.send(BLECharacteristic.INPUT_COMMAND, cmd);\n        this._ble.startNotifications(BLEService.IO_SERVICE, BLECharacteristic.INPUT_VALUES, this._onMessage);\n      }\n    }\n   \n  }, {\n    key: \"_clearPort\",\n    value: function _clearPort(connectID) {\n      var type = this._ports[connectID - 1];\n      if (type === WeDo2Device.TILT) {\n        this._sensors.tiltX = this._sensors.tiltY = 0;\n      }\n      if (type === WeDo2Device.DISTANCE) {\n        this._sensors.distance = 0;\n      }\n      this._ports[connectID - 1] = 'none';\n      this._motors[connectID - 1] = null;\n    }\n  }, {\n    key: \"tiltX\",\n    get: function get() {\n      return this._sensors.tiltX;\n    }\n   \n  }, {\n    key: \"tiltY\",\n    get: function get() {\n      return this._sensors.tiltY;\n    }\n   \n  }, {\n    key: \"distance\",\n    get: function get() {\n      return this._sensors.distance;\n    }\n  }]);\n  return WeDo2;\n}();\n/**\n * Enum for motor specification.\n * @readonly\n * @enum {string}\n */\nvar WeDo2MotorLabel = {\n  DEFAULT: 'motor',\n  A: 'motor A',\n  B: 'motor B',\n  ALL: 'all motors'\n};\n/**\n * Enum for motor direction specification.\n * @readonly\n * @enum {string}\n */\nvar WeDo2MotorDirection = {\n  FORWARD: 'this way',\n  BACKWARD: 'that way',\n  REVERSE: 'reverse'\n};\n/**\n * Enum for tilt sensor direction.\n * @readonly\n * @enum {string}\n */\nvar WeDo2TiltDirection = {\n  UP: 'up',\n  DOWN: 'down',\n  LEFT: 'left',\n  RIGHT: 'right',\n  ANY: 'any'\n};\n/**\n * Scratch 3.0 blocks to interact with a LEGO WeDo 2.0 peripheral.\n */\nvar Scratch3WeDo2Blocks = function () {\n  _createClass(Scratch3WeDo2Blocks, null, [{\n    key: \"EXTENSION_ID\",\n   \n    get: function get() {\n      return 'wedo2';\n    }\n   \n  }, {\n    key: \"TILT_THRESHOLD\",\n    get: function get() {\n      return 15;\n    }\n   \n  }]);\n  function Scratch3WeDo2Blocks(runtime) {\n    _classCallCheck(this, Scratch3WeDo2Blocks);\n   \n    this.runtime = runtime; \n    this._peripheral = new WeDo2(this.runtime, Scratch3WeDo2Blocks.EXTENSION_ID);\n  }\n \n  _createClass(Scratch3WeDo2Blocks, [{\n    key: \"getInfo\",\n    value: function getInfo() {\n      return {\n        id: Scratch3WeDo2Blocks.EXTENSION_ID,\n        name: 'WeDo 2.0',\n        blockIconURI: iconURI,\n        showStatusButton: true,\n        blocks: [{\n          opcode: 'motorOnFor',\n          text: formatMessage({\n            id: 'wedo2.motorOnFor',\n            default: 'turn [MOTOR_ID] on for [DURATION] seconds',\n            description: 'turn a motor on for some time'\n          }),\n          blockType: BlockType.COMMAND,\n          arguments: {\n            MOTOR_ID: {\n              type: ArgumentType.STRING,\n              menu: 'MOTOR_ID',\n              defaultValue: WeDo2MotorLabel.DEFAULT\n            },\n            DURATION: {\n              type: ArgumentType.NUMBER,\n              defaultValue: 1\n            }\n          }\n        }, {\n          opcode: 'motorOn',\n          text: formatMessage({\n            id: 'wedo2.motorOn',\n            default: 'turn [MOTOR_ID] on',\n            description: 'turn a motor on indefinitely'\n          }),\n          blockType: BlockType.COMMAND,\n          arguments: {\n            MOTOR_ID: {\n              type: ArgumentType.STRING,\n              menu: 'MOTOR_ID',\n              defaultValue: WeDo2MotorLabel.DEFAULT\n            }\n          }\n        }, {\n          opcode: 'motorOff',\n          text: formatMessage({\n            id: 'wedo2.motorOff',\n            default: 'turn [MOTOR_ID] off',\n            description: 'turn a motor off'\n          }),\n          blockType: BlockType.COMMAND,\n          arguments: {\n            MOTOR_ID: {\n              type: ArgumentType.STRING,\n              menu: 'MOTOR_ID',\n              defaultValue: WeDo2MotorLabel.DEFAULT\n            }\n          }\n        }, {\n          opcode: 'startMotorPower',\n          text: formatMessage({\n            id: 'wedo2.startMotorPower',\n            default: 'set [MOTOR_ID] power to [POWER]',\n            description: 'set the motor\\'s power and turn it on'\n          }),\n          blockType: BlockType.COMMAND,\n          arguments: {\n            MOTOR_ID: {\n              type: ArgumentType.STRING,\n              menu: 'MOTOR_ID',\n              defaultValue: WeDo2MotorLabel.DEFAULT\n            },\n            POWER: {\n              type: ArgumentType.NUMBER,\n              defaultValue: 100\n            }\n          }\n        }, {\n          opcode: 'setMotorDirection',\n          text: formatMessage({\n            id: 'wedo2.setMotorDirection',\n            default: 'set [MOTOR_ID] direction to [MOTOR_DIRECTION]',\n            description: 'set the motor\\'s turn direction'\n          }),\n          blockType: BlockType.COMMAND,\n          arguments: {\n            MOTOR_ID: {\n              type: ArgumentType.STRING,\n              menu: 'MOTOR_ID',\n              defaultValue: WeDo2MotorLabel.DEFAULT\n            },\n            MOTOR_DIRECTION: {\n              type: ArgumentType.STRING,\n              menu: 'MOTOR_DIRECTION',\n              defaultValue: WeDo2MotorDirection.FORWARD\n            }\n          }\n        }, {\n          opcode: 'setLightHue',\n          text: formatMessage({\n            id: 'wedo2.setLightHue',\n            default: 'set light color to [HUE]',\n            description: 'set the LED color'\n          }),\n          blockType: BlockType.COMMAND,\n          arguments: {\n            HUE: {\n              type: ArgumentType.NUMBER,\n              defaultValue: 50\n            }\n          }\n        }, {\n          opcode: 'playNoteFor',\n          text: formatMessage({\n            id: 'wedo2.playNoteFor',\n            default: 'play note [NOTE] for [DURATION] seconds',\n            description: 'play a certain note for some time'\n          }),\n          blockType: BlockType.COMMAND,\n          arguments: {\n            NOTE: {\n              type: ArgumentType.NUMBER,\n              \n              defaultValue: 60\n            },\n            DURATION: {\n              type: ArgumentType.NUMBER,\n              defaultValue: 0.5\n            }\n          },\n          hideFromPalette: true\n        }, {\n          opcode: 'whenDistance',\n          text: formatMessage({\n            id: 'wedo2.whenDistance',\n            default: 'when distance [OP] [REFERENCE]',\n            description: 'check for when distance is < or > than reference'\n          }),\n          blockType: BlockType.HAT,\n          arguments: {\n            OP: {\n              type: ArgumentType.STRING,\n              menu: 'OP',\n              defaultValue: '<'\n            },\n            REFERENCE: {\n              type: ArgumentType.NUMBER,\n              defaultValue: 50\n            }\n          }\n        }, {\n          opcode: 'whenTilted',\n          text: formatMessage({\n            id: 'wedo2.whenTilted',\n            default: 'when tilted [TILT_DIRECTION_ANY]',\n            description: 'check when tilted in a certain direction'\n          }),\n          func: 'isTilted',\n          blockType: BlockType.HAT,\n          arguments: {\n            TILT_DIRECTION_ANY: {\n              type: ArgumentType.STRING,\n              menu: 'TILT_DIRECTION_ANY',\n              defaultValue: WeDo2TiltDirection.ANY\n            }\n          }\n        }, {\n          opcode: 'getDistance',\n          text: formatMessage({\n            id: 'wedo2.getDistance',\n            default: 'distance',\n            description: 'the value returned by the distance sensor'\n          }),\n          blockType: BlockType.REPORTER\n        }, {\n          opcode: 'isTilted',\n          text: formatMessage({\n            id: 'wedo2.isTilted',\n            default: 'tilted [TILT_DIRECTION_ANY]?',\n            description: 'whether the tilt sensor is tilted'\n          }),\n          blockType: BlockType.BOOLEAN,\n          arguments: {\n            TILT_DIRECTION_ANY: {\n              type: ArgumentType.STRING,\n              menu: 'TILT_DIRECTION_ANY',\n              defaultValue: WeDo2TiltDirection.ANY\n            }\n          }\n        }, {\n          opcode: 'getTiltAngle',\n          text: formatMessage({\n            id: 'wedo2.getTiltAngle',\n            default: 'tilt angle [TILT_DIRECTION]',\n            description: 'the angle returned by the tilt sensor'\n          }),\n          blockType: BlockType.REPORTER,\n          arguments: {\n            TILT_DIRECTION: {\n              type: ArgumentType.STRING,\n              menu: 'TILT_DIRECTION',\n              defaultValue: WeDo2TiltDirection.UP\n            }\n          }\n        }],\n        menus: {\n          MOTOR_ID: {\n            acceptReporters: true,\n            items: [{\n              text: formatMessage({\n                id: 'wedo2.motorId.default',\n                default: 'motor',\n                description: 'label for motor element in motor menu for LEGO WeDo 2 extension'\n              }),\n              value: WeDo2MotorLabel.DEFAULT\n            }, {\n              text: formatMessage({\n                id: 'wedo2.motorId.a',\n                default: 'motor A',\n                description: 'label for motor A element in motor menu for LEGO WeDo 2 extension'\n              }),\n              value: WeDo2MotorLabel.A\n            }, {\n              text: formatMessage({\n                id: 'wedo2.motorId.b',\n                default: 'motor B',\n                description: 'label for motor B element in motor menu for LEGO WeDo 2 extension'\n              }),\n              value: WeDo2MotorLabel.B\n            }, {\n              text: formatMessage({\n                id: 'wedo2.motorId.all',\n                default: 'all motors',\n                description: 'label for all motors element in motor menu for LEGO WeDo 2 extension'\n              }),\n              value: WeDo2MotorLabel.ALL\n            }]\n          },\n          MOTOR_DIRECTION: {\n            acceptReporters: true,\n            items: [{\n              text: formatMessage({\n                id: 'wedo2.motorDirection.forward',\n                default: 'this way',\n                description: 'label for forward element in motor direction menu for LEGO WeDo 2 extension'\n              }),\n              value: WeDo2MotorDirection.FORWARD\n            }, {\n              text: formatMessage({\n                id: 'wedo2.motorDirection.backward',\n                default: 'that way',\n                description: 'label for backward element in motor direction menu for LEGO WeDo 2 extension'\n              }),\n              value: WeDo2MotorDirection.BACKWARD\n            }, {\n              text: formatMessage({\n                id: 'wedo2.motorDirection.reverse',\n                default: 'reverse',\n                description: 'label for reverse element in motor direction menu for LEGO WeDo 2 extension'\n              }),\n              value: WeDo2MotorDirection.REVERSE\n            }]\n          },\n          TILT_DIRECTION: {\n            acceptReporters: true,\n            items: [{\n              text: formatMessage({\n                id: 'wedo2.tiltDirection.up',\n                default: 'up',\n                description: 'label for up element in tilt direction menu for LEGO WeDo 2 extension'\n              }),\n              value: WeDo2TiltDirection.UP\n            }, {\n              text: formatMessage({\n                id: 'wedo2.tiltDirection.down',\n                default: 'down',\n                description: 'label for down element in tilt direction menu for LEGO WeDo 2 extension'\n              }),\n              value: WeDo2TiltDirection.DOWN\n            }, {\n              text: formatMessage({\n                id: 'wedo2.tiltDirection.left',\n                default: 'left',\n                description: 'label for left element in tilt direction menu for LEGO WeDo 2 extension'\n              }),\n              value: WeDo2TiltDirection.LEFT\n            }, {\n              text: formatMessage({\n                id: 'wedo2.tiltDirection.right',\n                default: 'right',\n                description: 'label for right element in tilt direction menu for LEGO WeDo 2 extension'\n              }),\n              value: WeDo2TiltDirection.RIGHT\n            }]\n          },\n          TILT_DIRECTION_ANY: {\n            acceptReporters: true,\n            items: [{\n              text: formatMessage({\n                id: 'wedo2.tiltDirection.up',\n                default: 'up'\n              }),\n              value: WeDo2TiltDirection.UP\n            }, {\n              text: formatMessage({\n                id: 'wedo2.tiltDirection.down',\n                default: 'down'\n              }),\n              value: WeDo2TiltDirection.DOWN\n            }, {\n              text: formatMessage({\n                id: 'wedo2.tiltDirection.left',\n                default: 'left'\n              }),\n              value: WeDo2TiltDirection.LEFT\n            }, {\n              text: formatMessage({\n                id: 'wedo2.tiltDirection.right',\n                default: 'right'\n              }),\n              value: WeDo2TiltDirection.RIGHT\n            }, {\n              text: formatMessage({\n                id: 'wedo2.tiltDirection.any',\n                default: 'any',\n                description: 'label for any element in tilt direction menu for LEGO WeDo 2 extension'\n              }),\n              value: WeDo2TiltDirection.ANY\n            }]\n          },\n          OP: {\n            acceptReporters: true,\n            items: ['<', '>']\n          }\n        }\n      };\n    }\n   \n  }, {\n    key: \"motorOnFor\",\n    value: function motorOnFor(args) {\n      var _this2 = this;\n      \n      var durationMS = Cast.toNumber(args.DURATION) * 1000;\n      durationMS = MathUtil.clamp(durationMS, 0, 15000);\n      return new Promise(function (resolve) {\n        _this2._forEachMotor(args.MOTOR_ID, function (motorIndex) {\n          var motor = _this2._peripheral.motor(motorIndex);\n          if (motor) {\n            motor.turnOnFor(durationMS);\n          }\n        }); \n        setTimeout(resolve, durationMS);\n      });\n    }\n   \n  }, {\n    key: \"motorOn\",\n    value: function motorOn(args) {\n      var _this3 = this;\n      \n      this._forEachMotor(args.MOTOR_ID, function (motorIndex) {\n        var motor = _this3._peripheral.motor(motorIndex);\n        if (motor) {\n          motor.turnOn();\n        }\n      });\n      return new Promise(function (resolve) {\n        window.setTimeout(function () {\n          resolve();\n        }, BLESendInterval);\n      });\n    }\n   \n  }, {\n    key: \"motorOff\",\n    value: function motorOff(args) {\n      var _this4 = this;\n      \n      this._forEachMotor(args.MOTOR_ID, function (motorIndex) {\n        var motor = _this4._peripheral.motor(motorIndex);\n        if (motor) {\n          motor.turnOff();\n        }\n      });\n      return new Promise(function (resolve) {\n        window.setTimeout(function () {\n          resolve();\n        }, BLESendInterval);\n      });\n    }\n   \n  }, {\n    key: \"startMotorPower\",\n    value: function startMotorPower(args) {\n      var _this5 = this;\n      \n      this._forEachMotor(args.MOTOR_ID, function (motorIndex) {\n        var motor = _this5._peripheral.motor(motorIndex);\n        if (motor) {\n          motor.power = MathUtil.clamp(Cast.toNumber(args.POWER), 0, 100);\n          motor.turnOn();\n        }\n      });\n      return new Promise(function (resolve) {\n        window.setTimeout(function () {\n          resolve();\n        }, BLESendInterval);\n      });\n    }\n   \n  }, {\n    key: \"setMotorDirection\",\n    value: function setMotorDirection(args) {\n      var _this6 = this;\n      \n      this._forEachMotor(args.MOTOR_ID, function (motorIndex) {\n        var motor = _this6._peripheral.motor(motorIndex);\n        if (motor) {\n          switch (args.MOTOR_DIRECTION) {\n            case WeDo2MotorDirection.FORWARD:\n              motor.direction = 1;\n              break;\n            case WeDo2MotorDirection.BACKWARD:\n              motor.direction = -1;\n              break;\n            case WeDo2MotorDirection.REVERSE:\n              motor.direction = -motor.direction;\n              break;\n            default:\n              log.warn(\"Unknown motor direction in setMotorDirection: \".concat(args.DIRECTION));\n              break;\n          } \n          if (motor.isOn) {\n            if (motor.pendingTimeoutDelay) {\n              motor.turnOnFor(motor.pendingTimeoutStartTime + motor.pendingTimeoutDelay - Date.now());\n            } else {\n              motor.turnOn();\n            }\n          }\n        }\n      });\n      return new Promise(function (resolve) {\n        window.setTimeout(function () {\n          resolve();\n        }, BLESendInterval);\n      });\n    }\n   \n  }, {\n    key: \"setLightHue\",\n    value: function setLightHue(args) {\n      \n      var inputHue = Cast.toNumber(args.HUE);\n      inputHue = MathUtil.wrapClamp(inputHue, 0, 100);\n      var hue = inputHue * 360 / 100;\n      var rgbObject = color.hsvToRgb({\n        h: hue,\n        s: 1,\n        v: 1\n      });\n      var rgbDecimal = color.rgbToDecimal(rgbObject);\n      this._peripheral.setLED(rgbDecimal);\n      return new Promise(function (resolve) {\n        window.setTimeout(function () {\n          resolve();\n        }, BLESendInterval);\n      });\n    }\n   \n  }, {\n    key: \"playNoteFor\",\n    value: function playNoteFor(args) {\n      var _this7 = this;\n      var durationMS = Cast.toNumber(args.DURATION) * 1000;\n      durationMS = MathUtil.clamp(durationMS, 0, 3000);\n      var note = MathUtil.clamp(Cast.toNumber(args.NOTE), 25, 125); \n      if (durationMS === 0) return; \n      return new Promise(function (resolve) {\n        var tone = _this7._noteToTone(note);\n        _this7._peripheral.playTone(tone, durationMS); \n        setTimeout(resolve, durationMS);\n      });\n    }\n   \n  }, {\n    key: \"whenDistance\",\n    value: function whenDistance(args) {\n      switch (args.OP) {\n        case '<':\n          return this._peripheral.distance < Cast.toNumber(args.REFERENCE);\n        case '>':\n          return this._peripheral.distance > Cast.toNumber(args.REFERENCE);\n        default:\n          log.warn(\"Unknown comparison operator in whenDistance: \".concat(args.OP));\n          return false;\n      }\n    }\n   \n  }, {\n    key: \"whenTilted\",\n    value: function whenTilted(args) {\n      return this._isTilted(args.TILT_DIRECTION_ANY);\n    }\n   \n  }, {\n    key: \"getDistance\",\n    value: function getDistance() {\n      return this._peripheral.distance;\n    }\n   \n  }, {\n    key: \"isTilted\",\n    value: function isTilted(args) {\n      return this._isTilted(args.TILT_DIRECTION_ANY);\n    }\n   \n  }, {\n    key: \"getTiltAngle\",\n    value: function getTiltAngle(args) {\n      return this._getTiltAngle(args.TILT_DIRECTION);\n    }\n   \n  }, {\n    key: \"_isTilted\",\n    value: function _isTilted(direction) {\n      switch (direction) {\n        case WeDo2TiltDirection.ANY:\n          return this._getTiltAngle(WeDo2TiltDirection.UP) >= Scratch3WeDo2Blocks.TILT_THRESHOLD || this._getTiltAngle(WeDo2TiltDirection.DOWN) >= Scratch3WeDo2Blocks.TILT_THRESHOLD || this._getTiltAngle(WeDo2TiltDirection.LEFT) >= Scratch3WeDo2Blocks.TILT_THRESHOLD || this._getTiltAngle(WeDo2TiltDirection.RIGHT) >= Scratch3WeDo2Blocks.TILT_THRESHOLD;\n        default:\n          return this._getTiltAngle(direction) >= Scratch3WeDo2Blocks.TILT_THRESHOLD;\n      }\n    }\n   \n  }, {\n    key: \"_getTiltAngle\",\n    value: function _getTiltAngle(direction) {\n      switch (direction) {\n        case WeDo2TiltDirection.UP:\n          return this._peripheral.tiltY > 45 ? 256 - this._peripheral.tiltY : -this._peripheral.tiltY;\n        case WeDo2TiltDirection.DOWN:\n          return this._peripheral.tiltY > 45 ? this._peripheral.tiltY - 256 : this._peripheral.tiltY;\n        case WeDo2TiltDirection.LEFT:\n          return this._peripheral.tiltX > 45 ? 256 - this._peripheral.tiltX : -this._peripheral.tiltX;\n        case WeDo2TiltDirection.RIGHT:\n          return this._peripheral.tiltX > 45 ? this._peripheral.tiltX - 256 : this._peripheral.tiltX;\n        default:\n          log.warn(\"Unknown tilt direction in _getTiltAngle: \".concat(direction));\n      }\n    }\n   \n  }, {\n    key: \"_forEachMotor\",\n    value: function _forEachMotor(motorID, callback) {\n      var motors;\n      switch (motorID) {\n        case WeDo2MotorLabel.A:\n          motors = [0];\n          break;\n        case WeDo2MotorLabel.B:\n          motors = [1];\n          break;\n        case WeDo2MotorLabel.ALL:\n        case WeDo2MotorLabel.DEFAULT:\n          motors = [0, 1];\n          break;\n        default:\n          log.warn(\"Invalid motor ID: \".concat(motorID));\n          motors = [];\n          break;\n      }\n      var _iterator = _createForOfIteratorHelper(motors),\n          _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var index = _step.value;\n          callback(index);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n   \n  }, {\n    key: \"_noteToTone\",\n    value: function _noteToTone(midiNote) {\n      \n      return 440 * Math.pow(2, (midiNote - 69) / 12);\n    }\n  }]);\n  return Scratch3WeDo2Blocks;\n}();\nmodule.exports = Scratch3WeDo2Blocks;\n })