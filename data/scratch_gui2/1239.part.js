/* 1239 */\n (function(module, exports, __webpack_require__) {\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nvar EventEmitter = __webpack_require__(91);\nvar hull = __webpack_require__(1240);\nvar twgl = __webpack_require__(103);\nvar BitmapSkin = __webpack_require__(1245);\nvar Drawable = __webpack_require__(1247);\nvar Rectangle = __webpack_require__(486);\nvar PenSkin = __webpack_require__(1250);\nvar RenderConstants = __webpack_require__(230);\nvar ShaderManager = __webpack_require__(188);\nvar SVGSkin = __webpack_require__(1251);\nvar TextBubbleSkin = __webpack_require__(1266);\nvar EffectTransform = __webpack_require__(487);\nvar log = __webpack_require__(488);\nvar __isTouchingDrawablesPoint = twgl.v3.create();\nvar __candidatesBounds = new Rectangle();\nvar __fenceBounds = new Rectangle();\nvar __touchingColor = new Uint8ClampedArray(4);\nvar __blendColor = new Uint8ClampedArray(4); \n\nvar __cpuTouchingColorPixelCount = 4e4;\n/**\n * @callback RenderWebGL#idFilterFunc\n * @param {int} drawableID The ID to filter.\n * @return {bool} True if the ID passes the filter, otherwise false.\n */\n/**\n * Maximum touch size for a picking check.\n * @todo Figure out a reasonable max size. Maybe this should be configurable?\n * @type {Array<int>}\n * @memberof RenderWebGL\n */\nvar MAX_TOUCH_SIZE = [3, 3];\n/**\n * Passed to the uniforms for mask in touching color\n */\nvar MASK_TOUCHING_COLOR_TOLERANCE = 2;\n/**\n * Maximum number of pixels in either dimension of \"extracted drawable\" data\n * @type {int}\n */\nvar MAX_EXTRACTED_DRAWABLE_DIMENSION = 2048;\n/**\n * Determines if the mask color is \"close enough\" (only test the 6 top bits for\n * each color).  These bit masks are what scratch 2 used to use, so we do the same.\n * @param {Uint8Array} a A color3b or color4b value.\n * @param {Uint8Array} b A color3b or color4b value.\n * @returns {boolean} If the colors match within the parameters.\n */\nvar maskMatches = function maskMatches(a, b) {\n  return (\n    a[3] > 0 && (a[0] & 252) === (b[0] & 252) && (a[1] & 252) === (b[1] & 252) && (a[2] & 252) === (b[2] & 252)\n  );\n};\n/**\n * Determines if the given color is \"close enough\" (only test the 5 top bits for\n * red and green, 4 bits for blue).  These bit masks are what scratch 2 used to use,\n * so we do the same.\n * @param {Uint8Array} a A color3b or color4b value.\n * @param {Uint8Array} b A color3b or color4b value / or a larger array when used with offsets\n * @param {number} offset An offset into the `b` array, which lets you use a larger array to test\n *                  multiple values at the same time.\n * @returns {boolean} If the colors match within the parameters.\n */\nvar colorMatches = function colorMatches(a, b, offset) {\n  return (a[0] & 248) === (b[offset + 0] & 248) && (a[1] & 248) === (b[offset + 1] & 248) && (a[2] & 240) === (b[offset + 2] & 240);\n};\n/**\n * Sprite Fencing - The number of pixels a sprite is required to leave remaining\n * onscreen around the edge of the staging area.\n * @type {number}\n */\nvar FENCE_WIDTH = 15;\nvar RenderWebGL = function (_EventEmitter) {\n  _inherits(RenderWebGL, _EventEmitter);\n  var _super = _createSuper(RenderWebGL);\n  _createClass(RenderWebGL, null, [{\n    key: \"isSupported\",\n   \n    value: function isSupported(optCanvas) {\n      try {\n        \n        return !!RenderWebGL._getContext(optCanvas || document.createElement('canvas'));\n      } catch (e) {\n        return false;\n      }\n    }\n   \n  }, {\n    key: \"_getContext\",\n    value: function _getContext(canvas) {\n      return twgl.getWebGLContext(canvas, {\n        alpha: false,\n        stencil: true,\n        antialias: false\n      });\n    }\n   \n  }]);\n  function RenderWebGL(canvas, xLeft, xRight, yBottom, yTop) {\n    var _this;\n    _classCallCheck(this, RenderWebGL);\n    _this = _super.call(this);\n   \n    var gl = _this._gl = RenderWebGL._getContext(canvas);\n    if (!gl) {\n      throw new Error('Could not get WebGL context: this browser or environment may not support WebGL.');\n    }\n   \n    _this._useGpuMode = RenderWebGL.UseGpuModes.Automatic;\n   \n    _this._allDrawables = [];\n   \n    _this._allSkins = [];\n   \n    _this._drawList = []; \n    \n   \n    _this._groupOrdering = [];\n   \n    \n   \n    _this._layerGroups = {};\n   \n    _this._nextDrawableId = RenderConstants.ID_NONE + 1;\n   \n    _this._nextSkinId = RenderConstants.ID_NONE + 1;\n   \n    _this._projection = twgl.m4.identity();\n   \n    _this._shaderManager = new ShaderManager(gl);\n   \n    _this._tempCanvas = document.createElement('canvas');\n   \n    _this._regionId = null;\n   \n    _this._exitRegion = null;\n   \n    _this._backgroundDrawRegionId = {\n      enter: function enter() {\n        return _this._enterDrawBackground();\n      },\n      exit: function exit() {\n        return _this._exitDrawBackground();\n      }\n    };\n   \n    _this._snapshotCallbacks = [];\n   \n    \n    _this._backgroundColor4f = [0, 0, 0, 1];\n   \n    \n    _this._backgroundColor3b = new Uint8ClampedArray(3);\n    _this._createGeometry();\n    _this.on(RenderConstants.Events.NativeSizeChanged, _this.onNativeSizeChanged);\n    _this.setBackgroundColor(1, 1, 1);\n    _this.setStageSize(xLeft || -240, xRight || 240, yBottom || -180, yTop || 180);\n    _this.resize(_this._nativeSize[0], _this._nativeSize[1]);\n    gl.disable(gl.DEPTH_TEST);\n   \n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n    return _this;\n  }\n \n  _createClass(RenderWebGL, [{\n    key: \"resize\",\n   \n    value: function resize(pixelsWide, pixelsTall) {\n      var canvas = this._gl.canvas;\n      var pixelRatio = window.devicePixelRatio || 1;\n      var newWidth = pixelsWide * pixelRatio;\n      var newHeight = pixelsTall * pixelRatio; \n      \n      if (canvas.width !== newWidth || canvas.height !== newHeight) {\n        canvas.width = newWidth;\n        canvas.height = newHeight; \n        this.draw();\n      }\n    }\n   \n  }, {\n    key: \"setBackgroundColor\",\n    value: function setBackgroundColor(red, green, blue) {\n      this._backgroundColor4f[0] = red;\n      this._backgroundColor4f[1] = green;\n      this._backgroundColor4f[2] = blue;\n      this._backgroundColor3b[0] = red * 255;\n      this._backgroundColor3b[1] = green * 255;\n      this._backgroundColor3b[2] = blue * 255;\n    }\n   \n  }, {\n    key: \"setDebugCanvas\",\n    value: function setDebugCanvas(canvas) {\n      this._debugCanvas = canvas;\n    }\n   \n  }, {\n    key: \"setUseGpuMode\",\n    value: function setUseGpuMode(useGpuMode) {\n      this._useGpuMode = useGpuMode;\n    }\n   \n  }, {\n    key: \"setStageSize\",\n    value: function setStageSize(xLeft, xRight, yBottom, yTop) {\n      this._xLeft = xLeft;\n      this._xRight = xRight;\n      this._yBottom = yBottom;\n      this._yTop = yTop; \n      this._projection = twgl.m4.ortho(xLeft, xRight, yBottom, yTop, -1, 1);\n      this._setNativeSize(Math.abs(xRight - xLeft), Math.abs(yBottom - yTop));\n    }\n   \n  }, {\n    key: \"getNativeSize\",\n    value: function getNativeSize() {\n      return [this._nativeSize[0], this._nativeSize[1]];\n    }\n   \n  }, {\n    key: \"_setNativeSize\",\n    value: function _setNativeSize(width, height) {\n      this._nativeSize = [width, height];\n      this.emit(RenderConstants.Events.NativeSizeChanged, {\n        newSize: this._nativeSize\n      });\n    }\n   \n  }, {\n    key: \"createBitmapSkin\",\n    value: function createBitmapSkin(bitmapData, costumeResolution, rotationCenter) {\n      var skinId = this._nextSkinId++;\n      var newSkin = new BitmapSkin(skinId, this);\n      newSkin.setBitmap(bitmapData, costumeResolution, rotationCenter);\n      this._allSkins[skinId] = newSkin;\n      return skinId;\n    }\n   \n  }, {\n    key: \"createSVGSkin\",\n    value: function createSVGSkin(svgData, rotationCenter) {\n      var skinId = this._nextSkinId++;\n      var newSkin = new SVGSkin(skinId, this);\n      newSkin.setSVG(svgData, rotationCenter);\n      this._allSkins[skinId] = newSkin;\n      return skinId;\n    }\n   \n  }, {\n    key: \"createPenSkin\",\n    value: function createPenSkin() {\n      var skinId = this._nextSkinId++;\n      var newSkin = new PenSkin(skinId, this);\n      this._allSkins[skinId] = newSkin;\n      return skinId;\n    }\n   \n  }, {\n    key: \"createTextSkin\",\n    value: function createTextSkin(type, text, pointsLeft) {\n      var skinId = this._nextSkinId++;\n      var newSkin = new TextBubbleSkin(skinId, this);\n      newSkin.setTextBubble(type, text, pointsLeft);\n      this._allSkins[skinId] = newSkin;\n      return skinId;\n    }\n   \n  }, {\n    key: \"updateSVGSkin\",\n    value: function updateSVGSkin(skinId, svgData, rotationCenter) {\n      if (this._allSkins[skinId] instanceof SVGSkin) {\n        this._allSkins[skinId].setSVG(svgData, rotationCenter);\n        return;\n      }\n      var newSkin = new SVGSkin(skinId, this);\n      newSkin.setSVG(svgData, rotationCenter);\n      this._reskin(skinId, newSkin);\n    }\n   \n  }, {\n    key: \"updateBitmapSkin\",\n    value: function updateBitmapSkin(skinId, imgData, bitmapResolution, rotationCenter) {\n      if (this._allSkins[skinId] instanceof BitmapSkin) {\n        this._allSkins[skinId].setBitmap(imgData, bitmapResolution, rotationCenter);\n        return;\n      }\n      var newSkin = new BitmapSkin(skinId, this);\n      newSkin.setBitmap(imgData, bitmapResolution, rotationCenter);\n      this._reskin(skinId, newSkin);\n    }\n  }, {\n    key: \"_reskin\",\n    value: function _reskin(skinId, newSkin) {\n      var oldSkin = this._allSkins[skinId];\n      this._allSkins[skinId] = newSkin; \n      var _iterator = _createForOfIteratorHelper(this._allDrawables),\n          _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var drawable = _step.value;\n          if (drawable && drawable.skin === oldSkin) {\n            drawable.skin = newSkin;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      oldSkin.dispose();\n    }\n   \n  }, {\n    key: \"updateTextSkin\",\n    value: function updateTextSkin(skinId, type, text, pointsLeft) {\n      if (this._allSkins[skinId] instanceof TextBubbleSkin) {\n        this._allSkins[skinId].setTextBubble(type, text, pointsLeft);\n        return;\n      }\n      var newSkin = new TextBubbleSkin(skinId, this);\n      newSkin.setTextBubble(type, text, pointsLeft);\n      this._reskin(skinId, newSkin);\n    }\n   \n  }, {\n    key: \"destroySkin\",\n    value: function destroySkin(skinId) {\n      var oldSkin = this._allSkins[skinId];\n      oldSkin.dispose();\n      delete this._allSkins[skinId];\n    }\n   \n  }, {\n    key: \"createDrawable\",\n    value: function createDrawable(group) {\n      if (!group || !Object.prototype.hasOwnProperty.call(this._layerGroups, group)) {\n        log.warn('Cannot create a drawable without a known layer group');\n        return;\n      }\n      var drawableID = this._nextDrawableId++;\n      var drawable = new Drawable(drawableID);\n      this._allDrawables[drawableID] = drawable;\n      this._addToDrawList(drawableID, group);\n      drawable.skin = null;\n      return drawableID;\n    }\n   \n  }, {\n    key: \"setLayerGroupOrdering\",\n    value: function setLayerGroupOrdering(groupOrdering) {\n      this._groupOrdering = groupOrdering;\n      for (var i = 0; i < this._groupOrdering.length; i++) {\n        this._layerGroups[this._groupOrdering[i]] = {\n          groupIndex: i,\n          drawListOffset: 0\n        };\n      }\n    }\n  }, {\n    key: \"_addToDrawList\",\n    value: function _addToDrawList(drawableID, group) {\n      var currentLayerGroup = this._layerGroups[group];\n      var currentGroupOrderingIndex = currentLayerGroup.groupIndex;\n      var drawListOffset = this._endIndexForKnownLayerGroup(currentLayerGroup);\n      this._drawList.splice(drawListOffset, 0, drawableID);\n      this._updateOffsets('add', currentGroupOrderingIndex);\n    }\n  }, {\n    key: \"_updateOffsets\",\n    value: function _updateOffsets(updateType, currentGroupOrderingIndex) {\n      for (var i = currentGroupOrderingIndex + 1; i < this._groupOrdering.length; i++) {\n        var laterGroupName = this._groupOrdering[i];\n        if (updateType === 'add') {\n          this._layerGroups[laterGroupName].drawListOffset++;\n        } else if (updateType === 'delete') {\n          this._layerGroups[laterGroupName].drawListOffset--;\n        }\n      }\n    }\n  }, {\n    key: \"_endIndexForKnownLayerGroup\",\n    \n    \n    value: function _endIndexForKnownLayerGroup(layerGroup) {\n      var groupIndex = layerGroup.groupIndex;\n      if (groupIndex === this._groupOrdering.length - 1) {\n        return this._drawList.length;\n      }\n      return this._layerGroups[this._groupOrdering[groupIndex + 1]].drawListOffset;\n    }\n   \n  }, {\n    key: \"destroyDrawable\",\n    value: function destroyDrawable(drawableID, group) {\n      if (!group || !Object.prototype.hasOwnProperty.call(this._layerGroups, group)) {\n        log.warn('Cannot destroy drawable without known layer group.');\n        return;\n      }\n      var drawable = this._allDrawables[drawableID];\n      drawable.dispose();\n      delete this._allDrawables[drawableID];\n      var currentLayerGroup = this._layerGroups[group];\n      var endIndex = this._endIndexForKnownLayerGroup(currentLayerGroup);\n      var index = currentLayerGroup.drawListOffset;\n      while (index < endIndex) {\n        if (this._drawList[index] === drawableID) {\n          break;\n        }\n        index++;\n      }\n      if (index < endIndex) {\n        this._drawList.splice(index, 1);\n        this._updateOffsets('delete', currentLayerGroup.groupIndex);\n      } else {\n        log.warn('Could not destroy drawable that could not be found in layer group.');\n        return;\n      }\n    }\n   \n  }, {\n    key: \"getDrawableOrder\",\n    value: function getDrawableOrder(drawableID) {\n      return this._drawList.indexOf(drawableID);\n    }\n   \n  }, {\n    key: \"setDrawableOrder\",\n    value: function setDrawableOrder(drawableID, order, group, optIsRelative, optMin) {\n      if (!group || !Object.prototype.hasOwnProperty.call(this._layerGroups, group)) {\n        log.warn('Cannot set the order of a drawable without a known layer group.');\n        return;\n      }\n      var currentLayerGroup = this._layerGroups[group];\n      var startIndex = currentLayerGroup.drawListOffset;\n      var endIndex = this._endIndexForKnownLayerGroup(currentLayerGroup);\n      var oldIndex = startIndex;\n      while (oldIndex < endIndex) {\n        if (this._drawList[oldIndex] === drawableID) {\n          break;\n        }\n        oldIndex++;\n      }\n      if (oldIndex < endIndex) {\n        \n        if (order === 0) {\n          return oldIndex;\n        }\n        var _ = this._drawList.splice(oldIndex, 1)[0]; \n        var newIndex = order;\n        if (optIsRelative) {\n          newIndex += oldIndex;\n        }\n        var possibleMin = (optMin || 0) + startIndex;\n        var min = possibleMin >= startIndex && possibleMin < endIndex ? possibleMin : startIndex;\n        newIndex = Math.max(newIndex, min);\n        newIndex = Math.min(newIndex, endIndex); \n        this._drawList.splice(newIndex, 0, drawableID);\n        return newIndex;\n      }\n      return null;\n    }\n   \n  }, {\n    key: \"draw\",\n    value: function draw() {\n      this._doExitDrawRegion();\n      var gl = this._gl;\n      twgl.bindFramebufferInfo(gl, null);\n      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n      gl.clearColor.apply(gl, _toConsumableArray(this._backgroundColor4f));\n      gl.clear(gl.COLOR_BUFFER_BIT);\n      this._drawThese(this._drawList, ShaderManager.DRAW_MODE.default, this._projection);\n      if (this._snapshotCallbacks.length > 0) {\n       var snapshot = gl.canvas.toDataURL();\n       $.ajax({\n          url:'saveScreenshot.php',\n             type:'POST',\n             data:snapshot,\n             processData:false,\n             contentType:false,\n             success:function (data) {\n                autosaveStatus(data);\n             }\n         });\n         this._snapshotCallbacks.length=0;\n        \/\/this._snapshotCallbacks.forEach(function (cb) {\n       \/\/  return cb(snapshot);\n        \/\/});\n        \/\/this._snapshotCallbacks = [];\n      }\n    }\n   \n  }, {\n    key: \"getBounds\",\n    value: function getBounds(drawableID) {\n      var drawable = this._allDrawables[drawableID]; \n      if (drawable.needsConvexHullPoints()) {\n        var points = this._getConvexHullPointsForDrawable(drawableID);\n        drawable.setConvexHullPoints(points);\n      }\n      var bounds = drawable.getFastBounds(); \n      if (this._debugCanvas) {\n        var gl = this._gl;\n        this._debugCanvas.width = gl.canvas.width;\n        this._debugCanvas.height = gl.canvas.height;\n        var context = this._debugCanvas.getContext('2d',{willReadFrequently:true});\n        context.drawImage(gl.canvas, 0, 0);\n        context.strokeStyle = '#FF0000';\n        var pr = window.devicePixelRatio;\n        context.strokeRect(pr * (bounds.left + this._nativeSize[0] / 2), pr * (-bounds.top + this._nativeSize[1] / 2), pr * (bounds.right - bounds.left), pr * (-bounds.bottom + bounds.top));\n      }\n      return bounds;\n    }\n   \n  }, {\n    key: \"getBoundsForBubble\",\n    value: function getBoundsForBubble(drawableID) {\n      var drawable = this._allDrawables[drawableID]; \n      if (drawable.needsConvexHullPoints()) {\n        var points = this._getConvexHullPointsForDrawable(drawableID);\n        drawable.setConvexHullPoints(points);\n      }\n      var bounds = drawable.getBoundsForBubble(); \n      if (this._debugCanvas) {\n        var gl = this._gl;\n        this._debugCanvas.width = gl.canvas.width;\n        this._debugCanvas.height = gl.canvas.height;\n        var context = this._debugCanvas.getContext('2d',{willReadFrequently:true});\n        context.drawImage(gl.canvas, 0, 0);\n        context.strokeStyle = '#FF0000';\n        var pr = window.devicePixelRatio;\n        context.strokeRect(pr * (bounds.left + this._nativeSize[0] / 2), pr * (-bounds.top + this._nativeSize[1] / 2), pr * (bounds.right - bounds.left), pr * (-bounds.bottom + bounds.top));\n      }\n      return bounds;\n    }\n   \n  }, {\n    key: \"getCurrentSkinSize\",\n    value: function getCurrentSkinSize(drawableID) {\n      var drawable = this._allDrawables[drawableID];\n      return this.getSkinSize(drawable.skin.id);\n    }\n   \n  }, {\n    key: \"getSkinSize\",\n    value: function getSkinSize(skinID) {\n      var skin = this._allSkins[skinID];\n      return skin.size;\n    }\n   \n  }, {\n    key: \"getSkinRotationCenter\",\n    value: function getSkinRotationCenter(skinID) {\n      var skin = this._allSkins[skinID];\n      return skin.calculateRotationCenter();\n    }\n   \n  }, {\n    key: \"isTouchingColor\",\n    value: function isTouchingColor(drawableID, color3b, mask3b) {\n      var candidates = this._candidatesTouching(drawableID, this._visibleDrawList);\n      var bounds;\n      if (colorMatches(color3b, this._backgroundColor3b, 0)) {\n        \n        \n        \n        bounds = this._touchingBounds(drawableID); \n        if (bounds === null) return false;\n      } else if (candidates.length === 0) {\n        \n        return false;\n      } else {\n        bounds = this._candidatesBounds(candidates);\n      }\n      var maxPixelsForCPU = this._getMaxPixelsForCPU();\n      var debugCanvasContext = this._debugCanvas && this._debugCanvas.getContext('2d',{willReadFrequently:true});\n      if (debugCanvasContext) {\n        this._debugCanvas.width = bounds.width;\n        this._debugCanvas.height = bounds.height;\n      } \n      if (bounds.width * bounds.height * (candidates.length + 1) >= maxPixelsForCPU) {\n        this._isTouchingColorGpuStart(drawableID, candidates.map(function (_ref) {\n          var id = _ref.id;\n          return id;\n        }).reverse(), bounds, color3b, mask3b);\n      }\n      var drawable = this._allDrawables[drawableID];\n      var point = __isTouchingDrawablesPoint;\n      var color = __touchingColor;\n      var hasMask = Boolean(mask3b);\n      drawable.updateCPURenderAttributes(); \n      var effectMask = ~ShaderManager.EFFECT_INFO.ghost.mask; \n      for (var y = bounds.bottom; y <= bounds.top; y++) {\n        if (bounds.width * (y - bounds.bottom) * (candidates.length + 1) >= maxPixelsForCPU) {\n          return this._isTouchingColorGpuFin(bounds, color3b, y - bounds.bottom);\n        }\n        for (var x = bounds.left; x <= bounds.right; x++) {\n          point[1] = y;\n          point[0] = x; \n          if (hasMask ? maskMatches(Drawable.sampleColor4b(point, drawable, color, effectMask), mask3b) : drawable.isTouching(point)) {\n            RenderWebGL.sampleColor3b(point, candidates, color);\n            if (debugCanvasContext) {\n              debugCanvasContext.fillStyle = \"rgb(\".concat(color[0], \",\").concat(color[1], \",\").concat(color[2], \")\");\n              debugCanvasContext.fillRect(x - bounds.left, bounds.bottom - y, 1, 1);\n            } \n            if (colorMatches(color, color3b, 0)) {\n              return true;\n            }\n          }\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"_getMaxPixelsForCPU\",\n    value: function _getMaxPixelsForCPU() {\n      switch (this._useGpuMode) {\n        case RenderWebGL.UseGpuModes.ForceCPU:\n          return Infinity;\n        case RenderWebGL.UseGpuModes.ForceGPU:\n          return 0;\n        case RenderWebGL.UseGpuModes.Automatic:\n        default:\n          return __cpuTouchingColorPixelCount;\n      }\n    }\n  }, {\n    key: \"_enterDrawBackground\",\n    value: function _enterDrawBackground() {\n      var gl = this.gl;\n      var currentShader = this._shaderManager.getShader(ShaderManager.DRAW_MODE.background, 0);\n      gl.disable(gl.BLEND);\n      gl.useProgram(currentShader.program);\n      twgl.setBuffersAndAttributes(gl, currentShader, this._bufferInfo);\n    }\n  }, {\n    key: \"_exitDrawBackground\",\n    value: function _exitDrawBackground() {\n      var gl = this.gl;\n      gl.enable(gl.BLEND);\n    }\n  }, {\n    key: \"_isTouchingColorGpuStart\",\n    value: function _isTouchingColorGpuStart(drawableID, candidateIDs, bounds, color3b, mask3b) {\n      this._doExitDrawRegion();\n      var gl = this._gl;\n      twgl.bindFramebufferInfo(gl, this._queryBufferInfo); \n      \n      gl.viewport(0, 0, bounds.width, bounds.height);\n      var projection = twgl.m4.ortho(bounds.left, bounds.right, bounds.top, bounds.bottom, -1, 1); \n      gl.clearColor(0, 0, 0, 0);\n      gl.clear(gl.COLOR_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);\n      var extraUniforms;\n      if (mask3b) {\n        extraUniforms = {\n          u_colorMask: [mask3b[0] / 255, mask3b[1] / 255, mask3b[2] / 255],\n          u_colorMaskTolerance: MASK_TOUCHING_COLOR_TOLERANCE / 255\n        };\n      }\n      try {\n        \n        \n        \n        gl.enable(gl.STENCIL_TEST);\n        gl.stencilFunc(gl.ALWAYS, 1, 1);\n        gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);\n        gl.colorMask(false, false, false, false);\n        this._drawThese([drawableID], mask3b ? ShaderManager.DRAW_MODE.colorMask : ShaderManager.DRAW_MODE.silhouette, projection, {\n          extraUniforms: extraUniforms,\n          ignoreVisibility: true,\n          \n          effectMask: ~ShaderManager.EFFECT_INFO.ghost.mask\n        });\n        gl.stencilFunc(gl.EQUAL, 1, 1);\n        gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);\n        gl.colorMask(true, true, true, true); \n        this.enterDrawRegion(this._backgroundDrawRegionId);\n        var uniforms = {\n          u_backgroundColor: this._backgroundColor4f\n        };\n        var currentShader = this._shaderManager.getShader(ShaderManager.DRAW_MODE.background, 0);\n        twgl.setUniforms(currentShader, uniforms);\n        twgl.drawBufferInfo(gl, this._bufferInfo, gl.TRIANGLES); \n        this._drawThese(candidateIDs, ShaderManager.DRAW_MODE.default, projection, {\n          idFilterFunc: function idFilterFunc(testID) {\n            return testID !== drawableID;\n          }\n        });\n      } finally {\n        gl.colorMask(true, true, true, true);\n        gl.disable(gl.STENCIL_TEST);\n        this._doExitDrawRegion();\n      }\n    }\n  }, {\n    key: \"_isTouchingColorGpuFin\",\n    value: function _isTouchingColorGpuFin(bounds, color3b, stop) {\n      var gl = this._gl;\n      var pixels = new Uint8Array(Math.floor(bounds.width * (bounds.height - stop) * 4));\n      gl.readPixels(0, 0, bounds.width, bounds.height - stop, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n      if (this._debugCanvas) {\n        this._debugCanvas.width = bounds.width;\n        this._debugCanvas.height = bounds.height;\n        var context = this._debugCanvas.getContext('2d',{willReadFrequently:true});\n        var imageData = context.getImageData(0, 0, bounds.width, bounds.height - stop);\n        imageData.data.set(pixels);\n        context.putImageData(imageData, 0, 0);\n      }\n      for (var pixelBase = 0; pixelBase < pixels.length; pixelBase += 4) {\n        \n        if (pixels[pixelBase + 3] !== 0 && colorMatches(color3b, pixels, pixelBase)) {\n          return true;\n        }\n      }\n      return false;\n    }\n   \n  }, {\n    key: \"isTouchingDrawables\",\n    value: function isTouchingDrawables(drawableID) {\n      var _this2 = this;\n      var candidateIDs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._drawList;\n      var candidates = this._candidatesTouching(drawableID, \n      candidateIDs.filter(function (id) {\n        return _this2._allDrawables[id]._visible;\n      })); \n      if (candidates.length === 0 || !this._allDrawables[drawableID]._visible) {\n        return false;\n      } \n      var bounds = this._candidatesBounds(candidates);\n      var drawable = this._allDrawables[drawableID];\n      var point = __isTouchingDrawablesPoint;\n      drawable.updateCPURenderAttributes(); \n      \n      for (var x = bounds.left; x <= bounds.right; x++) {\n        \n        point[0] = x;\n        for (var y = bounds.bottom; y <= bounds.top; y++) {\n          point[1] = y;\n          if (drawable.isTouching(point)) {\n            for (var index = 0; index < candidates.length; index++) {\n              if (candidates[index].drawable.isTouching(point)) {\n                return true;\n              }\n            }\n          }\n        }\n      }\n      return false;\n    }\n   \n  }, {\n    key: \"clientSpaceToScratchBounds\",\n    value: function clientSpaceToScratchBounds(centerX, centerY) {\n      var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n      var gl = this._gl;\n      var clientToScratchX = this._nativeSize[0] / gl.canvas.clientWidth;\n      var clientToScratchY = this._nativeSize[1] / gl.canvas.clientHeight;\n      width *= clientToScratchX;\n      height *= clientToScratchY;\n      width = Math.max(1, Math.min(Math.round(width), MAX_TOUCH_SIZE[0]));\n      height = Math.max(1, Math.min(Math.round(height), MAX_TOUCH_SIZE[1]));\n      var x = centerX * clientToScratchX - (width - 1) / 2; \n      var y = centerY * clientToScratchY + (height - 1) / 2;\n      var xOfs = width % 2 ? 0 : -0.5; \n      var yOfs = height % 2 ? 0 : -0.5;\n      var bounds = new Rectangle();\n      bounds.initFromBounds(Math.floor(this._xLeft + x + xOfs), Math.floor(this._xLeft + x + xOfs + width - 1), Math.ceil(this._yTop - y + yOfs), Math.ceil(this._yTop - y + yOfs + height - 1));\n      return bounds;\n    }\n   \n  }, {\n    key: \"drawableTouching\",\n    value: function drawableTouching(drawableID, centerX, centerY, touchWidth, touchHeight) {\n      var drawable = this._allDrawables[drawableID];\n      if (!drawable) {\n        return false;\n      }\n      var bounds = this.clientSpaceToScratchBounds(centerX, centerY, touchWidth, touchHeight);\n      var worldPos = twgl.v3.create();\n      drawable.updateCPURenderAttributes();\n      for (worldPos[1] = bounds.bottom; worldPos[1] <= bounds.top; worldPos[1]++) {\n        for (worldPos[0] = bounds.left; worldPos[0] <= bounds.right; worldPos[0]++) {\n          if (drawable.isTouching(worldPos)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n   \n  }, {\n    key: \"pick\",\n    value: function pick(centerX, centerY, touchWidth, touchHeight, candidateIDs) {\n      var _this3 = this;\n      var bounds = this.clientSpaceToScratchBounds(centerX, centerY, touchWidth, touchHeight);\n      if (bounds.left === -Infinity || bounds.bottom === -Infinity) {\n        return false;\n      }\n      candidateIDs = (candidateIDs || this._drawList).filter(function (id) {\n        var drawable = _this3._allDrawables[id]; \n        if (drawable.getVisible() && drawable.getUniforms().u_ghost !== 0) {\n          var drawableBounds = drawable.getFastBounds();\n          var inRange = bounds.intersects(drawableBounds);\n          if (!inRange) return false;\n          drawable.updateCPURenderAttributes();\n          return true;\n        }\n        return false;\n      });\n      if (candidateIDs.length === 0) {\n        return false;\n      }\n      var hits = [];\n      var worldPos = twgl.v3.create(0, 0, 0); \n      \n      for (worldPos[1] = bounds.bottom; worldPos[1] <= bounds.top; worldPos[1]++) {\n        for (worldPos[0] = bounds.left; worldPos[0] <= bounds.right; worldPos[0]++) {\n          \n          \n          \n          for (var d = candidateIDs.length - 1; d >= 0; d--) {\n            var id = candidateIDs[d];\n            var drawable = this._allDrawables[id];\n            if (drawable.isTouching(worldPos)) {\n              hits[id] = (hits[id] || 0) + 1;\n              break;\n            }\n          }\n        }\n      } \n      hits[RenderConstants.ID_NONE] = 0;\n      var hit = RenderConstants.ID_NONE;\n      for (var hitID in hits) {\n        if (Object.prototype.hasOwnProperty.call(hits, hitID) && hits[hitID] > hits[hit]) {\n          hit = hitID;\n        }\n      }\n      return Number(hit);\n    }\n   \n   \n  }, {\n    key: \"extractDrawable\",\n    value: function extractDrawable(drawableID, x, y) {\n      this._doExitDrawRegion();\n      var drawable = this._allDrawables[drawableID];\n      if (!drawable) return null; \n      var scratchX = this._nativeSize[0] * (x / this._gl.canvas.clientWidth - 0.5);\n      var scratchY = this._nativeSize[1] * (y / this._gl.canvas.clientHeight - 0.5);\n      var gl = this._gl;\n      var bounds = drawable.getFastBounds();\n      bounds.snapToInt(); \n      var maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n      var clampedWidth = Math.min(2048, bounds.width, maxTextureSize);\n      var clampedHeight = Math.min(2048, bounds.height, maxTextureSize); \n      var attachments = [{\n        format: gl.RGBA\n      }, {\n        format: gl.DEPTH_STENCIL\n      }];\n      var bufferInfo = twgl.createFramebufferInfo(gl, attachments, clampedWidth, clampedHeight);\n      try {\n        \n        twgl.bindFramebufferInfo(gl, bufferInfo);\n        if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {\n          twgl.bindFramebufferInfo(gl, this._queryBufferInfo);\n        } \n        var pickX = scratchX - bounds.left;\n        var pickY = scratchY + bounds.top; \n        \n        gl.viewport(0, 0, bounds.width, bounds.height);\n        var projection = twgl.m4.ortho(bounds.left, bounds.right, bounds.top, bounds.bottom, -1, 1);\n        gl.clearColor(0, 0, 0, 0);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n        try {\n          gl.disable(gl.BLEND); \n          this._drawThese([drawableID], ShaderManager.DRAW_MODE.straightAlpha, projection, {\n            effectMask: ~ShaderManager.EFFECT_INFO.ghost.mask\n          });\n        } finally {\n          gl.enable(gl.BLEND);\n        }\n        var data = new Uint8Array(Math.floor(bounds.width * bounds.height * 4));\n        gl.readPixels(0, 0, bounds.width, bounds.height, gl.RGBA, gl.UNSIGNED_BYTE, data);\n        if (this._debugCanvas) {\n          this._debugCanvas.width = bounds.width;\n          this._debugCanvas.height = bounds.height;\n          var ctx = this._debugCanvas.getContext('2d',{willReadFrequently:true});\n          var imageData = ctx.createImageData(bounds.width, bounds.height);\n          imageData.data.set(data);\n          ctx.putImageData(imageData, 0, 0);\n          ctx.beginPath();\n          ctx.arc(pickX, pickY, 3, 0, 2 * Math.PI, false);\n          ctx.fillStyle = 'white';\n          ctx.fill();\n          ctx.lineWidth = 1;\n          ctx.strokeStyle = 'black';\n          ctx.stroke();\n        }\n        return {\n          data: data,\n          width: bounds.width,\n          height: bounds.height,\n          scratchOffset: [-scratchX + drawable._position[0], -scratchY - drawable._position[1]],\n          x: pickX,\n          y: pickY\n        };\n      } finally {\n        gl.deleteFramebuffer(bufferInfo.framebuffer);\n      }\n    }\n   \n   \n  }, {\n    key: \"extractDrawableScreenSpace\",\n    value: function extractDrawableScreenSpace(drawableID) {\n      var drawable = this._allDrawables[drawableID];\n      if (!drawable) throw new Error(\"Could not extract drawable with ID \".concat(drawableID, \"; it does not exist\"));\n      this._doExitDrawRegion();\n      var nativeCenterX = this._nativeSize[0] * 0.5;\n      var nativeCenterY = this._nativeSize[1] * 0.5;\n      var scratchBounds = drawable.getFastBounds();\n      var canvas = this.canvas; \n      var scaleFactor = canvas.width / this._nativeSize[0]; \n      \n      var canvasSpaceBounds = new Rectangle();\n      canvasSpaceBounds.initFromBounds((scratchBounds.left + nativeCenterX) * scaleFactor, (scratchBounds.right + nativeCenterX) * scaleFactor, \n      (nativeCenterY - scratchBounds.top) * scaleFactor, (nativeCenterY - scratchBounds.bottom) * scaleFactor);\n      canvasSpaceBounds.snapToInt(); \n      \n      \n      scratchBounds.initFromBounds(canvasSpaceBounds.left / scaleFactor - nativeCenterX, canvasSpaceBounds.right / scaleFactor - nativeCenterX, nativeCenterY - canvasSpaceBounds.top / scaleFactor, nativeCenterY - canvasSpaceBounds.bottom / scaleFactor);\n      var gl = this._gl; \n      var maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n      var clampedWidth = Math.min(MAX_EXTRACTED_DRAWABLE_DIMENSION, canvasSpaceBounds.width, maxTextureSize);\n      var clampedHeight = Math.min(MAX_EXTRACTED_DRAWABLE_DIMENSION, canvasSpaceBounds.height, maxTextureSize); \n      var bufferInfo = twgl.createFramebufferInfo(gl, [{\n        format: gl.RGBA\n      }], clampedWidth, clampedHeight);\n      try {\n        twgl.bindFramebufferInfo(gl, bufferInfo); \n        \n        gl.viewport(0, 0, clampedWidth, clampedHeight);\n        var projection = twgl.m4.ortho(scratchBounds.left, scratchBounds.right, scratchBounds.top, scratchBounds.bottom, -1, 1);\n        gl.clearColor(0, 0, 0, 0);\n        gl.clear(gl.COLOR_BUFFER_BIT); \n        this._drawThese([drawableID], ShaderManager.DRAW_MODE.straightAlpha, projection, {\n          effectMask: ~ShaderManager.EFFECT_INFO.ghost.mask\n        });\n        var data = new Uint8Array(Math.floor(clampedWidth * clampedHeight * 4));\n        gl.readPixels(0, 0, clampedWidth, clampedHeight, gl.RGBA, gl.UNSIGNED_BYTE, data); \n        \n        var imageData = new ImageData(new Uint8ClampedArray(data.buffer), clampedWidth, clampedHeight); \n        \n        \n        \n        \n        var ratio = canvas.getBoundingClientRect().width / canvas.width;\n        return {\n          imageData: imageData,\n          x: canvasSpaceBounds.left * ratio,\n          y: canvasSpaceBounds.bottom * ratio,\n          width: canvasSpaceBounds.width * ratio,\n          height: canvasSpaceBounds.height * ratio\n        };\n      } finally {\n        gl.deleteFramebuffer(bufferInfo.framebuffer);\n      }\n    }\n   \n   \n  }, {\n    key: \"extractColor\",\n    value: function extractColor(x, y, radius) {\n      this._doExitDrawRegion();\n      var scratchX = Math.round(this._nativeSize[0] * (x / this._gl.canvas.clientWidth - 0.5));\n      var scratchY = Math.round(-this._nativeSize[1] * (y / this._gl.canvas.clientHeight - 0.5));\n      var gl = this._gl;\n      twgl.bindFramebufferInfo(gl, this._queryBufferInfo);\n      var bounds = new Rectangle();\n      bounds.initFromBounds(scratchX - radius, scratchX + radius, scratchY - radius, scratchY + radius);\n      var pickX = scratchX - bounds.left;\n      var pickY = bounds.top - scratchY;\n      gl.viewport(0, 0, bounds.width, bounds.height);\n      var projection = twgl.m4.ortho(bounds.left, bounds.right, bounds.top, bounds.bottom, -1, 1);\n      gl.clearColor.apply(gl, _toConsumableArray(this._backgroundColor4f));\n      gl.clear(gl.COLOR_BUFFER_BIT);\n      this._drawThese(this._drawList, ShaderManager.DRAW_MODE.default, projection);\n      var data = new Uint8Array(Math.floor(bounds.width * bounds.height * 4));\n      gl.readPixels(0, 0, bounds.width, bounds.height, gl.RGBA, gl.UNSIGNED_BYTE, data);\n      var pixelBase = Math.floor(4 * (pickY * bounds.width + pickX));\n      var color = {\n        r: data[pixelBase],\n        g: data[pixelBase + 1],\n        b: data[pixelBase + 2],\n        a: data[pixelBase + 3]\n      };\n      if (this._debugCanvas) {\n        this._debugCanvas.width = bounds.width;\n        this._debugCanvas.height = bounds.height;\n        var ctx = this._debugCanvas.getContext('2d',{willReadFrequently:true});\n        var imageData = ctx.createImageData(bounds.width, bounds.height);\n        imageData.data.set(data);\n        ctx.putImageData(imageData, 0, 0);\n        ctx.strokeStyle = 'black';\n        ctx.fillStyle = \"rgba(\".concat(color.r, \", \").concat(color.g, \", \").concat(color.b, \", \").concat(color.a, \")\");\n        ctx.rect(pickX - 4, pickY - 4, 8, 8);\n        ctx.fill();\n        ctx.stroke();\n      }\n      return {\n        data: data,\n        width: bounds.width,\n        height: bounds.height,\n        color: color\n      };\n    }\n   \n  }, {\n    key: \"_touchingBounds\",\n    value: function _touchingBounds(drawableID) {\n      var drawable = this._allDrawables[drawableID];\n     \n      if (!drawable.skin || !drawable.skin.getTexture([100, 100])) return null;\n      var bounds = drawable.getFastBounds(); \n      bounds.clamp(this._xLeft, this._xRight, this._yBottom, this._yTop); \n      \n      bounds.snapToInt();\n      if (bounds.width === 0 || bounds.height === 0) {\n        \n        return null;\n      }\n      return bounds;\n    }\n   \n  }, {\n    key: \"_candidatesTouching\",\n    value: function _candidatesTouching(drawableID, candidateIDs) {\n      var bounds = this._touchingBounds(drawableID);\n      var result = [];\n      if (bounds === null) {\n        return result;\n      } \n      for (var index = candidateIDs.length - 1; index >= 0; index--) {\n        var id = candidateIDs[index];\n        if (id !== drawableID) {\n          var drawable = this._allDrawables[id]; \n          if (drawable.skin instanceof TextBubbleSkin) continue;\n          if (drawable.skin && drawable._visible) {\n            \n            drawable.updateCPURenderAttributes();\n            var candidateBounds = drawable.getFastBounds(); \n            \n            \n            \n            candidateBounds.snapToInt();\n            if (bounds.intersects(candidateBounds)) {\n              result.push({\n                id: id,\n                drawable: drawable,\n                intersection: Rectangle.intersect(bounds, candidateBounds)\n              });\n            }\n          }\n        }\n      }\n      return result;\n    }\n   \n  }, {\n    key: \"_candidatesBounds\",\n    value: function _candidatesBounds(candidates) {\n      return candidates.reduce(function (memo, _ref2) {\n        var intersection = _ref2.intersection;\n        if (!memo) {\n          return intersection;\n        } \n        return Rectangle.union(memo, intersection, __candidatesBounds);\n      }, null);\n    }\n   \n  }, {\n    key: \"updateDrawableSkinId\",\n    value: function updateDrawableSkinId(drawableID, skinId) {\n      var drawable = this._allDrawables[drawableID]; \n      if (!drawable) return;\n      drawable.skin = this._allSkins[skinId];\n    }\n   \n  }, {\n    key: \"updateDrawablePosition\",\n    value: function updateDrawablePosition(drawableID, position) {\n      var drawable = this._allDrawables[drawableID]; \n      if (!drawable) return;\n      drawable.updatePosition(position);\n    }\n   \n  }, {\n    key: \"updateDrawableDirection\",\n    value: function updateDrawableDirection(drawableID, direction) {\n      var drawable = this._allDrawables[drawableID]; \n      if (!drawable) return;\n      drawable.updateDirection(direction);\n    }\n   \n  }, {\n    key: \"updateDrawableScale\",\n    value: function updateDrawableScale(drawableID, scale) {\n      var drawable = this._allDrawables[drawableID]; \n      if (!drawable) return;\n      drawable.updateScale(scale);\n    }\n   \n  }, {\n    key: \"updateDrawableDirectionScale\",\n    value: function updateDrawableDirectionScale(drawableID, direction, scale) {\n      var drawable = this._allDrawables[drawableID]; \n      if (!drawable) return;\n      drawable.updateDirection(direction);\n      drawable.updateScale(scale);\n    }\n   \n  }, {\n    key: \"updateDrawableVisible\",\n    value: function updateDrawableVisible(drawableID, visible) {\n      var drawable = this._allDrawables[drawableID]; \n      if (!drawable) return;\n      drawable.updateVisible(visible);\n    }\n   \n  }, {\n    key: \"updateDrawableEffect\",\n    value: function updateDrawableEffect(drawableID, effectName, value) {\n      var drawable = this._allDrawables[drawableID]; \n      if (!drawable) return;\n      drawable.updateEffect(effectName, value);\n    }\n   \n  }, {\n    key: \"updateDrawableProperties\",\n    value: function updateDrawableProperties(drawableID, properties) {\n      var drawable = this._allDrawables[drawableID];\n      if (!drawable) {\n       \n        return;\n      }\n      if ('skinId' in properties) {\n        this.updateDrawableSkinId(drawableID, properties.skinId);\n      }\n      drawable.updateProperties(properties);\n    }\n   \n  }, {\n    key: \"getFencedPositionOfDrawable\",\n    value: function getFencedPositionOfDrawable(drawableID, position) {\n      var x = position[0];\n      var y = position[1];\n      var drawable = this._allDrawables[drawableID];\n      if (!drawable) {\n        \n        \n        return [x, y];\n      }\n      var dx = x - drawable._position[0];\n      var dy = y - drawable._position[1];\n      var aabb = drawable._skin.getFenceBounds(drawable, __fenceBounds);\n      var inset = Math.floor(Math.min(aabb.width, aabb.height) / 2);\n      var sx = this._xRight - Math.min(FENCE_WIDTH, inset);\n      if (aabb.right + dx < -sx) {\n        x = Math.ceil(drawable._position[0] - (sx + aabb.right));\n      } else if (aabb.left + dx > sx) {\n        x = Math.floor(drawable._position[0] + (sx - aabb.left));\n      }\n      var sy = this._yTop - Math.min(FENCE_WIDTH, inset);\n      if (aabb.top + dy < -sy) {\n        y = Math.ceil(drawable._position[1] - (sy + aabb.top));\n      } else if (aabb.bottom + dy > sy) {\n        y = Math.floor(drawable._position[1] + (sy - aabb.bottom));\n      }\n      return [x, y];\n    }\n   \n  }, {\n    key: \"penClear\",\n    value: function penClear(penSkinID) {\n      var skin =\n     \n      this._allSkins[penSkinID];\n      skin.clear();\n    }\n   \n  }, {\n    key: \"penPoint\",\n    value: function penPoint(penSkinID, penAttributes, x, y) {\n      var skin =\n     \n      this._allSkins[penSkinID];\n      skin.drawPoint(penAttributes, x, y);\n    }\n   \n  }, {\n    key: \"penLine\",\n    value: function penLine(penSkinID, penAttributes, x0, y0, x1, y1) {\n      var skin =\n     \n      this._allSkins[penSkinID];\n      skin.drawLine(penAttributes, x0, y0, x1, y1);\n    }\n   \n  }, {\n    key: \"penStamp\",\n    value: function penStamp(penSkinID, stampID) {\n      var stampDrawable = this._allDrawables[stampID];\n      if (!stampDrawable) {\n        return;\n      }\n      var bounds = this._touchingBounds(stampID);\n      if (!bounds) {\n        return;\n      }\n      this._doExitDrawRegion();\n      var skin =\n     \n      this._allSkins[penSkinID];\n      var gl = this._gl;\n      twgl.bindFramebufferInfo(gl, skin._framebuffer); \n      gl.viewport(this._nativeSize[0] * 0.5 + bounds.left, this._nativeSize[1] * 0.5 - bounds.top, bounds.width, bounds.height);\n      var projection = twgl.m4.ortho(bounds.left, bounds.right, bounds.top, bounds.bottom, -1, 1); \n      this._drawThese([stampID], ShaderManager.DRAW_MODE.default, projection, {\n        ignoreVisibility: true\n      });\n      skin._silhouetteDirty = true;\n    }\n   \n   \n  }, {\n    key: \"_createGeometry\",\n    value: function _createGeometry() {\n      var quad = {\n        a_position: {\n          numComponents: 2,\n          data: [-0.5, -0.5, 0.5, -0.5, -0.5, 0.5, -0.5, 0.5, 0.5, -0.5, 0.5, 0.5]\n        },\n        a_texCoord: {\n          numComponents: 2,\n          data: [1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1]\n        }\n      };\n      this._bufferInfo = twgl.createBufferInfoFromArrays(this._gl, quad);\n    }\n   \n  }, {\n    key: \"onNativeSizeChanged\",\n    value: function onNativeSizeChanged(event) {\n      var _event$newSize = _slicedToArray(event.newSize, 2),\n          width = _event$newSize[0],\n          height = _event$newSize[1];\n      var gl = this._gl;\n      var attachments = [{\n        format: gl.RGBA\n      }, {\n        format: gl.DEPTH_STENCIL\n      }];\n      if (!this._pickBufferInfo) {\n        this._pickBufferInfo = twgl.createFramebufferInfo(gl, attachments, MAX_TOUCH_SIZE[0], MAX_TOUCH_SIZE[1]);\n      }\n     \n      \n      if (this._queryBufferInfo) {\n        twgl.resizeFramebufferInfo(gl, this._queryBufferInfo, attachments, width, height);\n      } else {\n        this._queryBufferInfo = twgl.createFramebufferInfo(gl, attachments, width, height);\n      }\n    }\n   \n  }, {\n    key: \"enterDrawRegion\",\n    value: function enterDrawRegion(regionId) {\n      var enter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : regionId.enter;\n      var exit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : regionId.exit;\n      if (this._regionId !== regionId) {\n        this._doExitDrawRegion();\n        this._regionId = regionId;\n        enter();\n        this._exitRegion = exit;\n      }\n    }\n   \n  }, {\n    key: \"_doExitDrawRegion\",\n    value: function _doExitDrawRegion() {\n      if (this._exitRegion !== null) {\n        this._exitRegion();\n      }\n      this._exitRegion = null;\n      this._regionId = null;\n    }\n   \n  }, {\n    key: \"_getDrawableScreenSpaceScale\",\n    value: function _getDrawableScreenSpaceScale(drawable) {\n      return [drawable.scale[0] * this._gl.canvas.width / this._nativeSize[0], drawable.scale[1] * this._gl.canvas.height / this._nativeSize[1]];\n    }\n   \n  }, {\n    key: \"_drawThese\",\n    value: function _drawThese(drawables, drawMode, projection) {\n      var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var gl = this._gl;\n      var currentShader = null;\n      var numDrawables = drawables.length;\n      for (var drawableIndex = 0; drawableIndex < numDrawables; ++drawableIndex) {\n        var drawableID = drawables[drawableIndex]; \n        if (opts.filter && !opts.filter(drawableID)) continue;\n        var drawable = this._allDrawables[drawableID];\n       \n        \n        \n        if (!drawable.getVisible() && !opts.ignoreVisibility) continue; \n        var drawableScale = this._getDrawableScreenSpaceScale(drawable); \n        if (!drawable.skin || !drawable.skin.getTexture(drawableScale)) continue;\n        var uniforms = {};\n        var effectBits = drawable.enabledEffects;\n        effectBits &= Object.prototype.hasOwnProperty.call(opts, 'effectMask') ? opts.effectMask : effectBits;\n        var newShader = this._shaderManager.getShader(drawMode, effectBits); \n        \n        if (this._regionId !== newShader) {\n          this._doExitDrawRegion();\n          this._regionId = newShader;\n          currentShader = newShader;\n          gl.useProgram(currentShader.program);\n          twgl.setBuffersAndAttributes(gl, currentShader, this._bufferInfo);\n          Object.assign(uniforms, {\n            u_projectionMatrix: projection\n          });\n        }\n        Object.assign(uniforms, drawable.skin.getUniforms(drawableScale), drawable.getUniforms()); \n        if (opts.extraUniforms) {\n          Object.assign(uniforms, opts.extraUniforms);\n        }\n        if (uniforms.u_skin) {\n          twgl.setTextureParameters(gl, uniforms.u_skin, {\n            minMag: drawable.skin.useNearest(drawableScale, drawable) ? gl.NEAREST : gl.LINEAR\n          });\n        }\n        twgl.setUniforms(currentShader, uniforms);\n        twgl.drawBufferInfo(gl, this._bufferInfo, gl.TRIANGLES);\n      }\n      this._regionId = null;\n    }\n   \n  }, {\n    key: \"_getConvexHullPointsForDrawable\",\n    value: function _getConvexHullPointsForDrawable(drawableID) {\n      var drawable = this._allDrawables[drawableID];\n      var _drawable$skin$size = _slicedToArray(drawable.skin.size, 2),\n          width = _drawable$skin$size[0],\n          height = _drawable$skin$size[1]; \n      if (!drawable.getVisible() || width === 0 || height === 0) {\n        return [];\n      }\n      drawable.updateCPURenderAttributes();\n     \n      var determinant = function determinant(A, B, C) {\n        \n        \n        \n        return (B[0] - A[0]) * (C[1] - A[1]) - (B[1] - A[1]) * (C[0] - A[0]);\n      }; \n      \n      \n      \n      \n      var leftHull = [];\n      var rightHull = []; \n      \n      \n      var leftEndPointIndex = -1;\n      var rightEndPointIndex = -1;\n      var _pixelPos = twgl.v3.create();\n      var _effectPos = twgl.v3.create();\n      var currentPoint; \n      \n      for (var y = 0; y < height; y++) {\n        _pixelPos[1] = y / height; \n        var x = 0;\n        for (; x < width; x++) {\n          _pixelPos[0] = x / width;\n          EffectTransform.transformPoint(drawable, _pixelPos, _effectPos);\n          if (drawable.skin.isTouchingLinear(_effectPos)) {\n            currentPoint = [x, y];\n            break;\n          }\n        } \n        if (x >= width) {\n          continue;\n        } \n        \n        \n        \n        \n        \n        while (leftEndPointIndex > 0) {\n          if (determinant(leftHull[leftEndPointIndex], leftHull[leftEndPointIndex - 1], currentPoint) > 0) {\n            break;\n          } else {\n            \n            --leftEndPointIndex;\n          }\n        } \n        \n        \n        \n        leftHull[++leftEndPointIndex] = currentPoint; \n        for (x = width - 1; x >= 0; x--) {\n          _pixelPos[0] = x / width;\n          EffectTransform.transformPoint(drawable, _pixelPos, _effectPos);\n          if (drawable.skin.isTouchingLinear(_effectPos)) {\n            currentPoint = [x, y];\n            break;\n          }\n        } \n        while (rightEndPointIndex > 0) {\n          if (determinant(rightHull[rightEndPointIndex], rightHull[rightEndPointIndex - 1], currentPoint) < 0) {\n            break;\n          } else {\n            --rightEndPointIndex;\n          }\n        }\n        rightHull[++rightEndPointIndex] = currentPoint;\n      } \n      var hullPoints = leftHull; \n      hullPoints.length = leftEndPointIndex + 1; \n      for (var j = rightEndPointIndex; j >= 0; --j) {\n        hullPoints.push(rightHull[j]);\n      } \n      \n      return hull(hullPoints, Infinity);\n    }\n   \n  }, {\n    key: \"requestSnapshot\",\n   \n   \n    value: function requestSnapshot(callback) {\n      this._snapshotCallbacks.push(callback);\n    }\n  }, {\n    key: \"gl\",\n    get: function get() {\n      return this._gl;\n    }\n   \n  }, {\n    key: \"canvas\",\n    get: function get() {\n      return this._gl && this._gl.canvas;\n    }\n  }, {\n    key: \"_visibleDrawList\",\n    get: function get() {\n      var _this4 = this;\n      return this._drawList.filter(function (id) {\n        return _this4._allDrawables[id]._visible;\n      });\n    }\n  }], [{\n    key: \"sampleColor3b\",\n    value: function sampleColor3b(vec, drawables, dst) {\n      dst = dst || new Uint8ClampedArray(3);\n      dst.fill(0);\n      var blendAlpha = 1;\n      for (var index = 0; blendAlpha !== 0 && index < drawables.length; index++) {\n       \n        Drawable.sampleColor4b(vec, drawables[index].drawable, __blendColor); \n        dst[0] += __blendColor[0] * blendAlpha;\n        dst[1] += __blendColor[1] * blendAlpha;\n        dst[2] += __blendColor[2] * blendAlpha;\n        blendAlpha *= 1 - __blendColor[3] / 255;\n      } \n      \n      dst[0] += blendAlpha * 255;\n      dst[1] += blendAlpha * 255;\n      dst[2] += blendAlpha * 255;\n      return dst;\n    }\n  }]);\n  return RenderWebGL;\n}(EventEmitter); \nRenderWebGL.prototype.canHazPixels = RenderWebGL.prototype.extractDrawable;\n/**\n * Values for setUseGPU()\n * @enum {string}\n */\nRenderWebGL.UseGpuModes = {\n \n  Automatic: 'Automatic',\n \n  ForceGPU: 'ForceGPU',\n \n  ForceCPU: 'ForceCPU'\n};\nmodule.exports = RenderWebGL;\n })