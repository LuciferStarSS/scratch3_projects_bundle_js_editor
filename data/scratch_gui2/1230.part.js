/* 1230 */\n (function(module, exports, __webpack_require__) {\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nvar ArrayBufferStream = __webpack_require__(1231);\nvar log = __webpack_require__(229);\n/**\n * Data used by the decompression algorithm\n * @type {Array}\n */\nvar STEP_TABLE = [7, 8, 9, 10, 11, 12, 13, 14, 16, 17, 19, 21, 23, 25, 28, 31, 34, 37, 41, 45, 50, 55, 60, 66, 73, 80, 88, 97, 107, 118, 130, 143, 157, 173, 190, 209, 230, 253, 279, 307, 337, 371, 408, 449, 494, 544, 598, 658, 724, 796, 876, 963, 1060, 1166, 1282, 1411, 1552, 1707, 1878, 2066, 2272, 2499, 2749, 3024, 3327, 3660, 4026, 4428, 4871, 5358, 5894, 6484, 7132, 7845, 8630, 9493, 10442, 11487, 12635, 13899, 15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794, 32767];\n/**\n * Data used by the decompression algorithm\n * @type {Array}\n */\nvar INDEX_TABLE = [-1, -1, -1, -1, 2, 4, 6, 8, -1, -1, -1, -1, 2, 4, 6, 8];\nvar _deltaTable = null;\n/**\n * Build a table of deltas from the 89 possible steps and 16 codes.\n * @return {Array<number>} computed delta values\n */\nvar deltaTable = function deltaTable() {\n  if (_deltaTable === null) {\n    var NUM_STEPS = STEP_TABLE.length;\n    var NUM_INDICES = INDEX_TABLE.length;\n    _deltaTable = new Array(NUM_STEPS * NUM_INDICES).fill(0);\n    var i = 0;\n    for (var index = 0; index < NUM_STEPS; index++) {\n      for (var code = 0; code < NUM_INDICES; code++) {\n        var step = STEP_TABLE[index];\n        var delta = 0;\n        if (code & 4) delta += step;\n        if (code & 2) delta += step >> 1;\n        if (code & 1) delta += step >> 2;\n        delta += step >> 3;\n        _deltaTable[i++] = code & 8 ? -delta : delta;\n      }\n    }\n  }\n  return _deltaTable;\n};\n/**\n * Decode wav audio files that have been compressed with the ADPCM format.\n * This is necessary because, while web browsers have native decoders for many audio\n * formats, ADPCM is a non-standard format used by Scratch since its early days.\n * This decoder is based on code from Scratch-Flash:\n * https://github.com/LLK/scratch-flash/blob/master/src/sound/WAVFile.as\n */\nvar ADPCMSoundDecoder = function () {\n \n  function ADPCMSoundDecoder(audioContext) {\n    _classCallCheck(this, ADPCMSoundDecoder);\n    this.audioContext = audioContext;\n  }\n \n  _createClass(ADPCMSoundDecoder, [{\n    key: \"decode\",\n   \n    value: function decode(audioData) {\n      var _this = this;\n      return new Promise(function (resolve, reject) {\n        var stream = new ArrayBufferStream(audioData);\n        var riffStr = stream.readUint8String(4);\n        if (riffStr !== 'RIFF') {\n          log.warn('incorrect adpcm wav header');\n          reject();\n        }\n        var lengthInHeader = stream.readInt32();\n        if (lengthInHeader + 8 !== audioData.byteLength) {\n          log.warn(\"adpcm wav length in header: \".concat(lengthInHeader, \" is incorrect\"));\n        }\n        var wavStr = stream.readUint8String(4);\n        if (wavStr !== 'WAVE') {\n          log.warn('incorrect adpcm wav header');\n          reject();\n        }\n        var formatChunk = _this.extractChunk('fmt ', stream);\n        _this.encoding = formatChunk.readUint16();\n        _this.channels = formatChunk.readUint16();\n        _this.samplesPerSecond = formatChunk.readUint32();\n        _this.bytesPerSecond = formatChunk.readUint32();\n        _this.blockAlignment = formatChunk.readUint16();\n        _this.bitsPerSample = formatChunk.readUint16();\n        formatChunk.position += 2; \n        _this.samplesPerBlock = formatChunk.readUint16();\n        _this.adpcmBlockSize = (_this.samplesPerBlock - 1) / 2 + 4; \n        var compressedData = _this.extractChunk('data', stream);\n        var sampleCount = _this.numberOfSamples(compressedData, _this.adpcmBlockSize);\n        var buffer = _this.audioContext.createBuffer(1, sampleCount, _this.samplesPerSecond);\n        _this.imaDecompress(compressedData, _this.adpcmBlockSize, buffer.getChannelData(0));\n        resolve(buffer);\n      });\n    }\n   \n  }, {\n    key: \"extractChunk\",\n    value: function extractChunk(chunkType, stream) {\n      stream.position = 12;\n      while (stream.position < stream.getLength() - 8) {\n        var typeStr = stream.readUint8String(4);\n        var chunkSize = stream.readInt32();\n        if (typeStr === chunkType) {\n          var chunk = stream.extract(chunkSize);\n          return chunk;\n        }\n        stream.position += chunkSize;\n      }\n    }\n   \n  }, {\n    key: \"numberOfSamples\",\n    value: function numberOfSamples(compressedData, blockSize) {\n      if (!compressedData) return 0;\n      compressedData.position = 0;\n      var available = compressedData.getBytesAvailable();\n      var blocks = available / blockSize | 0; \n      var fullBlocks = blocks * (2 * (blockSize - 4)) + 1; \n      \n      var subBlock = Math.max(available % blockSize - 4, 0) * 2; \n      var incompleteBlock = Math.min(available % blockSize, 1);\n      return fullBlocks + subBlock + incompleteBlock;\n    }\n   \n  }, {\n    key: \"imaDecompress\",\n    value: function imaDecompress(compressedData, blockSize, out) {\n      var sample;\n      var code;\n      var delta;\n      var index = 0;\n      var lastByte = -1; \n      \n      if (!compressedData) return;\n      compressedData.position = 0;\n      var size = out.length;\n      var samplesAfterBlockHeader = (blockSize - 4) * 2;\n      var DELTA_TABLE = deltaTable();\n      var i = 0;\n      while (i < size) {\n        \n        sample = compressedData.readInt16();\n        index = compressedData.readUint8();\n        compressedData.position++; \n        if (index > 88) index = 88;\n        out[i++] = sample / 32768;\n        var blockLength = Math.min(samplesAfterBlockHeader, size - i);\n        var blockStart = i;\n        while (i - blockStart < blockLength) {\n          \n          lastByte = compressedData.readUint8();\n          code = lastByte & 0xF;\n          delta = DELTA_TABLE[index * 16 + code]; \n          index += INDEX_TABLE[code];\n          if (index > 88) index = 88;else if (index < 0) index = 0; \n          sample += delta;\n          if (sample > 32767) sample = 32767;else if (sample < -32768) sample = -32768;\n          out[i++] = sample / 32768; \n          \n          code = lastByte >> 4 & 0xF;\n          delta = DELTA_TABLE[index * 16 + code]; \n          index += INDEX_TABLE[code];\n          if (index > 88) index = 88;else if (index < 0) index = 0; \n          sample += delta;\n          if (sample > 32767) sample = 32767;else if (sample < -32768) sample = -32768;\n          out[i++] = sample / 32768;\n        }\n      }\n    }\n  }], [{\n    key: \"STEP_TABLE\",\n    get: function get() {\n      return STEP_TABLE;\n    }\n   \n  }, {\n    key: \"INDEX_TABLE\",\n    get: function get() {\n      return INDEX_TABLE;\n    }\n  }]);\n  return ADPCMSoundDecoder;\n}();\nmodule.exports = ADPCMSoundDecoder;\n })