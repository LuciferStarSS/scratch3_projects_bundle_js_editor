/* 960 */\n (function(module, exports, __webpack_require__) {\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\nvar mutationAdapter = __webpack_require__(433);\nvar html = __webpack_require__(154);\nvar uid = __webpack_require__(94);\n/**\n * Convert and an individual block DOM to the representation tree.\n * Based on Blockly's `domToBlockHeadless_`.\n * @param {Element} blockDOM DOM tree for an individual block.\n * @param {object} blocks Collection of blocks to add to.\n * @param {boolean} isTopBlock Whether blocks at this level are \"top blocks.\"\n * @param {?string} parent Parent block ID.\n * @return {undefined}\n */\nvar domToBlock = function domToBlock(blockDOM, blocks, isTopBlock, parent) {\n  if (!blockDOM.attribs.id) {\n    blockDOM.attribs.id = uid();\n  } \n  var block = {\n    id: blockDOM.attribs.id,\n    \n    opcode: blockDOM.attribs.type,\n    \n    inputs: {},\n    \n    fields: {},\n    \n    next: null,\n    \n    topLevel: isTopBlock,\n    \n    parent: parent,\n    \n    shadow: blockDOM.name === 'shadow',\n    \n    x: blockDOM.attribs.x,\n    \n    y: blockDOM.attribs.y \n  }; \n  blocks[block.id] = block; \n  for (var i = 0; i < blockDOM.children.length; i++) {\n    var xmlChild = blockDOM.children[i]; \n    var childBlockNode = null;\n    var childShadowNode = null;\n    for (var j = 0; j < xmlChild.children.length; j++) {\n      var grandChildNode = xmlChild.children[j];\n      if (!grandChildNode.name) {\n        \n        continue;\n      }\n      var grandChildNodeName = grandChildNode.name.toLowerCase();\n      if (grandChildNodeName === 'block') {\n        childBlockNode = grandChildNode;\n      } else if (grandChildNodeName === 'shadow') {\n        childShadowNode = grandChildNode;\n      }\n    } \n    if (!childBlockNode && childShadowNode) {\n      childBlockNode = childShadowNode;\n    } \n    \n    switch (xmlChild.name.toLowerCase()) {\n      case 'field':\n        {\n          \n          var fieldName = xmlChild.attribs.name; \n          var fieldId = xmlChild.attribs.id;\n          var fieldData = '';\n          if (xmlChild.children.length > 0 && xmlChild.children[0].data) {\n            fieldData = xmlChild.children[0].data;\n          } else {\n            \n            \n            fieldData = '';\n          }\n          block.fields[fieldName] = {\n            name: fieldName,\n            id: fieldId,\n            value: fieldData\n          };\n          var fieldVarType = xmlChild.attribs.variabletype;\n          if (typeof fieldVarType === 'string') {\n            block.fields[fieldName].variableType = fieldVarType;\n          }\n          break;\n        }\n      case 'comment':\n        {\n          block.comment = xmlChild.attribs.id;\n          break;\n        }\n      case 'value':\n      case 'statement':\n        {\n          \n          domToBlock(childBlockNode, blocks, false, block.id);\n          if (childShadowNode && childBlockNode !== childShadowNode) {\n            \n            domToBlock(childShadowNode, blocks, false, block.id);\n          } \n          var inputName = xmlChild.attribs.name;\n          block.inputs[inputName] = {\n            name: inputName,\n            block: childBlockNode.attribs.id,\n            shadow: childShadowNode ? childShadowNode.attribs.id : null\n          };\n          break;\n        }\n      case 'next':\n        {\n          if (!childBlockNode || !childBlockNode.attribs) {\n            \n            continue;\n          } \n          domToBlock(childBlockNode, blocks, false, block.id); \n          block.next = childBlockNode.attribs.id;\n          break;\n        }\n      case 'mutation':\n        {\n          block.mutation = mutationAdapter(xmlChild);\n          break;\n        }\n    }\n  }\n};\n/**\n * Convert outer blocks DOM from a Blockly CREATE event\n * to a usable form for the Scratch runtime.\n * This structure is based on Blockly xml.js:`domToWorkspace` and `domToBlock`.\n * @param {Element} blocksDOM DOM tree for this event.\n * @return {Array.<object>} Usable list of blocks from this CREATE event.\n */\nvar domToBlocks = function domToBlocks(blocksDOM) {\n  \n  var blocks = {};\n  for (var i = 0; i < blocksDOM.length; i++) {\n    var block = blocksDOM[i];\n    if (!block.name || !block.attribs) {\n      continue;\n    }\n    var tagName = block.name.toLowerCase();\n    if (tagName === 'block' || tagName === 'shadow') {\n      domToBlock(block, blocks, true, null);\n    }\n  } \n  var blocksList = [];\n  for (var b in blocks) {\n    if (!blocks.hasOwnProperty(b)) continue;\n    blocksList.push(blocks[b]);\n  }\n  return blocksList;\n};\n/**\n * Adapter between block creation events and block representation which can be\n * used by the Scratch runtime.\n * @param {object} e `Blockly.events.create` or `Blockly.events.endDrag`\n * @return {Array.<object>} List of blocks from this CREATE event.\n */\nvar adapter = function adapter(e) {\n  \n  if (_typeof(e) !== 'object') return;\n  if (_typeof(e.xml) !== 'object') return;\n  return domToBlocks(html.parseDOM(e.xml.outerHTML, {\n    decodeEntities: true\n  }));\n};\nmodule.exports = adapter;\n })