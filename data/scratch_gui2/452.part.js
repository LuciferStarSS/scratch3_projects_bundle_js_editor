/* 452 */\n (function(module, exports, __webpack_require__) {\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nvar StageLayering = __webpack_require__(115);\nvar Video = function () {\n  function Video(runtime) {\n    _classCallCheck(this, Video);\n    this.runtime = runtime;\n   \n    this.provider = null;\n   \n    this._skinId = -1;\n   \n    this._drawable = -1;\n   \n    this._ghost = 0;\n   \n    this._forceTransparentPreview = false;\n  }\n  _createClass(Video, [{\n    key: \"setProvider\",\n   \n    value: function setProvider(provider) {\n      this.provider = provider;\n    }\n   \n  }, {\n    key: \"enableVideo\",\n    value: function enableVideo() {\n      var _this = this;\n      if (!this.provider) return null;\n      return this.provider.enableVideo().then(function () {\n        return _this._setupPreview();\n      });\n    }\n   \n  }, {\n    key: \"disableVideo\",\n    value: function disableVideo() {\n      this._disablePreview();\n      if (!this.provider) return null;\n      this.provider.disableVideo();\n    }\n   \n  }, {\n    key: \"getFrame\",\n    value: function getFrame(_ref) {\n      var _ref$dimensions = _ref.dimensions,\n          dimensions = _ref$dimensions === void 0 ? Video.DIMENSIONS : _ref$dimensions,\n          _ref$mirror = _ref.mirror,\n          mirror = _ref$mirror === void 0 ? this.mirror : _ref$mirror,\n          _ref$format = _ref.format,\n          format = _ref$format === void 0 ? Video.FORMAT_IMAGE_DATA : _ref$format,\n          _ref$cacheTimeout = _ref.cacheTimeout,\n          cacheTimeout = _ref$cacheTimeout === void 0 ? this._frameCacheTimeout : _ref$cacheTimeout;\n      if (this.provider) return this.provider.getFrame({\n        dimensions: dimensions,\n        mirror: mirror,\n        format: format,\n        cacheTimeout: cacheTimeout\n      });\n      return null;\n    }\n   \n  }, {\n    key: \"setPreviewGhost\",\n    value: function setPreviewGhost(ghost) {\n      this._ghost = ghost; \n      if (this._drawable !== -1) {\n        this.runtime.renderer.updateDrawableEffect(this._drawable, 'ghost', this._forceTransparentPreview ? 100 : ghost);\n      }\n    }\n  }, {\n    key: \"_disablePreview\",\n    value: function _disablePreview() {\n      if (this._skinId !== -1) {\n        this.runtime.renderer.updateBitmapSkin(this._skinId, _construct(ImageData, _toConsumableArray(Video.DIMENSIONS)), 1);\n        this.runtime.renderer.updateDrawableVisible(this._drawable, false);\n      }\n      this._renderPreviewFrame = null;\n    }\n  }, {\n    key: \"_setupPreview\",\n    value: function _setupPreview() {\n      var _this2 = this;\n      var renderer = this.runtime.renderer;\n      if (!renderer) return;\n      if (this._skinId === -1 && this._drawable === -1) {\n        this._skinId = renderer.createBitmapSkin(_construct(ImageData, _toConsumableArray(Video.DIMENSIONS)), 1);\n        this._drawable = renderer.createDrawable(StageLayering.VIDEO_LAYER);\n        renderer.updateDrawableSkinId(this._drawable, this._skinId);\n      } \n      if (!this._renderPreviewFrame) {\n        renderer.updateDrawableEffect(this._drawable, 'ghost', this._forceTransparentPreview ? 100 : this._ghost);\n        renderer.updateDrawableVisible(this._drawable, true);\n        this._renderPreviewFrame = function () {\n          clearTimeout(_this2._renderPreviewTimeout);\n          if (!_this2._renderPreviewFrame) {\n            return;\n          }\n          _this2._renderPreviewTimeout = setTimeout(_this2._renderPreviewFrame, _this2.runtime.currentStepTime);\n          var imageData = _this2.getFrame({\n            format: Video.FORMAT_IMAGE_DATA,\n            cacheTimeout: _this2.runtime.currentStepTime\n          });\n          if (!imageData) {\n            renderer.updateBitmapSkin(_this2._skinId, _construct(ImageData, _toConsumableArray(Video.DIMENSIONS)), 1);\n            return;\n          }\n          renderer.updateBitmapSkin(_this2._skinId, imageData, 1);\n          _this2.runtime.requestRedraw();\n        };\n        this._renderPreviewFrame();\n      }\n    }\n  }, {\n    key: \"postData\",\n   \n    value: function postData(_ref2) {\n      var forceTransparentPreview = _ref2.forceTransparentPreview;\n      this._forceTransparentPreview = forceTransparentPreview; \n      \n      \n      this.setPreviewGhost(this._ghost);\n    }\n  }, {\n    key: \"videoReady\",\n    get: function get() {\n      if (this.provider) return this.provider.videoReady;\n      return false;\n    }\n  }], [{\n    key: \"FORMAT_IMAGE_DATA\",\n    get: function get() {\n      return 'image-data';\n    }\n  }, {\n    key: \"FORMAT_CANVAS\",\n    get: function get() {\n      return 'canvas';\n    }\n   \n  }, {\n    key: \"DIMENSIONS\",\n    get: function get() {\n      return [480, 360];\n    }\n   \n  }, {\n    key: \"ORDER\",\n    get: function get() {\n      return 1;\n    }\n  }]);\n  return Video;\n}();\nmodule.exports = Video;\n })