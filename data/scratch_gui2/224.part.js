/* 224 */\n (function(module, exports) {\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n/**\n * Recycle bin for empty stackFrame objects\n * @type Array<_StackFrame>\n */\nvar _stackFrameFreeList = [];\n/**\n * A frame used for each level of the stack. A general purpose\n * place to store a bunch of execution context and parameters\n * @param {boolean} warpMode Whether this level of the stack is warping\n * @constructor\n * @private\n */\nvar _StackFrame = function () {\n  function _StackFrame(warpMode) {\n    _classCallCheck(this, _StackFrame);\n   \n    this.isLoop = false;\n   \n    this.warpMode = warpMode;\n   \n    this.justReported = null;\n   \n    this.reporting = '';\n   \n    this.reported = null;\n   \n    this.waitingReporter = null;\n   \n    this.params = null;\n   \n    this.executionContext = null;\n  }\n \n  _createClass(_StackFrame, [{\n    key: \"reset\",\n    value: function reset() {\n      this.isLoop = false;\n      this.warpMode = false;\n      this.justReported = null;\n      this.reported = null;\n      this.waitingReporter = null;\n      this.params = null;\n      this.executionContext = null;\n      return this;\n    }\n   \n  }, {\n    key: \"reuse\",\n    value: function reuse() {\n      var warpMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.warpMode;\n      this.reset();\n      this.warpMode = Boolean(warpMode);\n      return this;\n    }\n   \n  }], [{\n    key: \"create\",\n    value: function create(warpMode) {\n      var stackFrame = _stackFrameFreeList.pop();\n      if (typeof stackFrame !== 'undefined') {\n        stackFrame.warpMode = Boolean(warpMode);\n        return stackFrame;\n      }\n      return new _StackFrame(warpMode);\n    }\n   \n  }, {\n    key: \"release\",\n    value: function release(stackFrame) {\n      if (typeof stackFrame !== 'undefined') {\n        _stackFrameFreeList.push(stackFrame.reset());\n      }\n    }\n  }]);\n  return _StackFrame;\n}();\n/**\n * A thread is a running stack context and all the metadata needed.\n * @param {?string} firstBlock First block to execute in the thread.\n * @constructor\n */\nvar Thread = function () {\n  function Thread(firstBlock) {\n    _classCallCheck(this, Thread);\n   \n    this.topBlock = firstBlock;\n   \n    this.stack = [];\n   \n    this.stackFrames = [];\n   \n    this.status = 0;\n   \n   \n    this.isKilled = false;\n   \n    this.target = null;\n   \n    this.blockContainer = null;\n   \n    this.requestScriptGlowInFrame = false;\n   \n    this.blockGlowInFrame = null;\n   \n    this.warpTimer = null;\n    this.justReported = null;\n  }\n \n  _createClass(Thread, [{\n    key: \"pushStack\",\n   \n    value: function pushStack(blockId) {\n      this.stack.push(blockId); \n      \n      if (this.stack.length > this.stackFrames.length) {\n        var parent = this.stackFrames[this.stackFrames.length - 1];\n        this.stackFrames.push(_StackFrame.create(typeof parent !== 'undefined' && parent.warpMode));\n      }\n    }\n   \n  }, {\n    key: \"reuseStackForNextBlock\",\n    value: function reuseStackForNextBlock(blockId) {\n      this.stack[this.stack.length - 1] = blockId;\n      this.stackFrames[this.stackFrames.length - 1].reuse();\n    }\n   \n  }, {\n    key: \"popStack\",\n    value: function popStack() {\n      _StackFrame.release(this.stackFrames.pop());\n      return this.stack.pop();\n    }\n   \n  }, {\n    key: \"stopThisScript\",\n    value: function stopThisScript() {\n      var blockID = this.peekStack();\n      while (blockID !== null) {\n        var block = this.target.blocks.getBlock(blockID);\n        if (typeof block !== 'undefined' && block.opcode === 'procedures_call') {\n          break;\n        }\n        this.popStack();\n        blockID = this.peekStack();\n      }\n      if (this.stack.length === 0) {\n        \n        this.requestScriptGlowInFrame = false;\n        this.status = Thread.STATUS_DONE;\n      }\n    }\n   \n  }, {\n    key: \"peekStack\",\n    value: function peekStack() {\n      return this.stack.length > 0 ? this.stack[this.stack.length - 1] : null;\n    }\n   \n  }, {\n    key: \"peekStackFrame\",\n    value: function peekStackFrame() {\n      return this.stackFrames.length > 0 ? this.stackFrames[this.stackFrames.length - 1] : null;\n    }\n   \n  }, {\n    key: \"peekParentStackFrame\",\n    value: function peekParentStackFrame() {\n      return this.stackFrames.length > 1 ? this.stackFrames[this.stackFrames.length - 2] : null;\n    }\n   \n  }, {\n    key: \"pushReportedValue\",\n    value: function pushReportedValue(value) {\n      this.justReported = typeof value === 'undefined' ? null : value;\n    }\n   \n  }, {\n    key: \"initParams\",\n    value: function initParams() {\n      var stackFrame = this.peekStackFrame();\n      if (stackFrame.params === null) {\n        stackFrame.params = {};\n      }\n    }\n   \n  }, {\n    key: \"pushParam\",\n    value: function pushParam(paramName, value) {\n      var stackFrame = this.peekStackFrame();\n      stackFrame.params[paramName] = value;\n    }\n   \n  }, {\n    key: \"getParam\",\n    value: function getParam(paramName) {\n      for (var i = this.stackFrames.length - 1; i >= 0; i--) {\n        var frame = this.stackFrames[i];\n        if (frame.params === null) {\n          continue;\n        }\n        if (frame.params.hasOwnProperty(paramName)) {\n          return frame.params[paramName];\n        }\n        return null;\n      }\n      return null;\n    }\n   \n  }, {\n    key: \"atStackTop\",\n    value: function atStackTop() {\n      return this.peekStack() === this.topBlock;\n    }\n   \n  }, {\n    key: \"goToNextBlock\",\n    value: function goToNextBlock() {\n      var nextBlockId = this.target.blocks.getNextBlock(this.peekStack());\n      this.reuseStackForNextBlock(nextBlockId);\n    }\n   \n  }, {\n    key: \"isRecursiveCall\",\n    value: function isRecursiveCall(procedureCode) {\n      var callCount = 5; \n      var sp = this.stack.length - 1;\n      for (var i = sp - 1; i >= 0; i--) {\n        var block = this.target.blocks.getBlock(this.stack[i]);\n        if (block.opcode === 'procedures_call' && block.mutation.proccode === procedureCode) {\n          return true;\n        }\n        if (--callCount < 0) return false;\n      }\n      return false;\n    }\n  }], [{\n    key: \"STATUS_RUNNING\",\n    get: function get() {\n      return 0;\n    }\n   \n  }, {\n    key: \"STATUS_PROMISE_WAIT\",\n    get: function get() {\n      return 1;\n    }\n   \n  }, {\n    key: \"STATUS_YIELD\",\n    get: function get() {\n      return 2;\n    }\n   \n  }, {\n    key: \"STATUS_YIELD_TICK\",\n    get: function get() {\n      return 3;\n    }\n   \n  }, {\n    key: \"STATUS_DONE\",\n    get: function get() {\n      return 4;\n    }\n  }]);\n  return Thread;\n}();\nmodule.exports = Thread;\n })