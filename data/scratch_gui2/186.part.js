/* 186 */\n (function(module, exports, __webpack_require__) {\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n/**\n * @fileoverview\n * An SB3 serializer and deserializer. Parses provided\n * JSON and then generates all needed scratch-vm runtime structures.\n */\nvar vmPackage = __webpack_require__(1186);\nvar Blocks = __webpack_require__(135);\nvar Sprite = __webpack_require__(479);\nvar Variable = __webpack_require__(114);\nvar Comment = __webpack_require__(297);\nvar MonitorRecord = __webpack_require__(295);\nvar StageLayering = __webpack_require__(115);\nvar log = __webpack_require__(39);\nvar uid = __webpack_require__(94);\nvar MathUtil = __webpack_require__(62);\nvar StringUtil = __webpack_require__(102);\nvar VariableUtil = __webpack_require__(442);\nvar _require = __webpack_require__(225),\n    loadCostume = _require.loadCostume;\nvar _require2 = __webpack_require__(226),\n    loadSound = _require2.loadSound;\nvar _require3 = __webpack_require__(480),\n    deserializeCostume = _require3.deserializeCostume,\n    deserializeSound = _require3.deserializeSound;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\n * @typedef {object} ImportedProject\n * @property {Array.<Target>} targets - the imported Scratch 3.0 target objects.\n * @property {ImportedExtensionsInfo} extensionsInfo - the ID of each extension actually used by this project.\n */\n/**\n * @typedef {object} ImportedExtensionsInfo\n * @property {Set.<string>} extensionIDs - the ID of each extension actually in use by blocks in this project.\n * @property {Map.<string, string>} extensionURLs - map of ID => URL from project metadata. May not match extensionIDs.\n */\n\nvar INPUT_SAME_BLOCK_SHADOW = 1; \nvar INPUT_BLOCK_NO_SHADOW = 2; \nvar INPUT_DIFF_BLOCK_SHADOW = 3; \n\n\nvar CORE_EXTENSIONS = ['argument', 'colour', 'control', 'data', 'event', 'looks', 'math', 'motion', 'operator', 'procedures', 'sensing', 'sound']; \n\n\nvar MATH_NUM_PRIMITIVE = 4; \n\nvar POSITIVE_NUM_PRIMITIVE = 5; \n\nvar WHOLE_NUM_PRIMITIVE = 6; \nvar INTEGER_NUM_PRIMITIVE = 7; \nvar ANGLE_NUM_PRIMITIVE = 8; \nvar COLOR_PICKER_PRIMITIVE = 9; \nvar TEXT_PRIMITIVE = 10; \nvar BROADCAST_PRIMITIVE = 11; \nvar VAR_PRIMITIVE = 12; \nvar LIST_PRIMITIVE = 13; \n\nvar primitiveOpcodeInfoMap = {\n  math_number: [MATH_NUM_PRIMITIVE, 'NUM'],\n  math_positive_number: [POSITIVE_NUM_PRIMITIVE, 'NUM'],\n  math_whole_number: [WHOLE_NUM_PRIMITIVE, 'NUM'],\n  math_integer: [INTEGER_NUM_PRIMITIVE, 'NUM'],\n  math_angle: [ANGLE_NUM_PRIMITIVE, 'NUM'],\n  colour_picker: [COLOR_PICKER_PRIMITIVE, 'COLOUR'],\n  text: [TEXT_PRIMITIVE, 'TEXT'],\n  event_broadcast_menu: [BROADCAST_PRIMITIVE, 'BROADCAST_OPTION'],\n  data_variable: [VAR_PRIMITIVE, 'VARIABLE'],\n  data_listcontents: [LIST_PRIMITIVE, 'LIST']\n};\n/**\n * Serializes primitives described above into a more compact format\n * @param {object} block the block to serialize\n * @return {array} An array representing the information in the block,\n * or null if the given block is not one of the primitives described above.\n */\nvar serializePrimitiveBlock = function serializePrimitiveBlock(block) {\n  \n  \n  if (hasOwnProperty.call(primitiveOpcodeInfoMap, block.opcode)) {\n    var primitiveInfo = primitiveOpcodeInfoMap[block.opcode];\n    var primitiveConstant = primitiveInfo[0];\n    var fieldName = primitiveInfo[1];\n    var field = block.fields[fieldName];\n    var primitiveDesc = [primitiveConstant, field.value];\n    if (block.opcode === 'event_broadcast_menu') {\n      primitiveDesc.push(field.id);\n    } else if (block.opcode === 'data_variable' || block.opcode === 'data_listcontents') {\n      primitiveDesc.push(field.id);\n      if (block.topLevel) {\n        primitiveDesc.push(block.x ? Math.round(block.x) : 0);\n        primitiveDesc.push(block.y ? Math.round(block.y) : 0);\n      }\n    }\n    return primitiveDesc;\n  }\n  return null;\n};\n/**\n * Serializes the inputs field of a block in a compact form using\n * constants described above to represent the relationship between the\n * inputs of this block (e.g. if there is an unobscured shadow, an obscured shadow\n * -- a block plugged into a droppable input -- or, if there is just a block).\n * Based on this relationship, serializes the ids of the block and shadow (if present)\n *\n * @param {object} inputs The inputs to serialize\n * @return {object} An object representing the serialized inputs\n */\nvar serializeInputs = function serializeInputs(inputs) {\n  var obj = Object.create(null);\n  for (var inputName in inputs) {\n    if (!hasOwnProperty.call(inputs, inputName)) continue; \n    if (inputs[inputName].block === inputs[inputName].shadow) {\n      \n      obj[inputName] = [INPUT_SAME_BLOCK_SHADOW, inputs[inputName].block];\n    } else if (inputs[inputName].shadow === null) {\n      \n      obj[inputName] = [INPUT_BLOCK_NO_SHADOW, inputs[inputName].block];\n    } else {\n      \n      obj[inputName] = [INPUT_DIFF_BLOCK_SHADOW, inputs[inputName].block, inputs[inputName].shadow];\n    }\n  }\n  return obj;\n};\n/**\n * Serialize the fields of a block in a more compact form.\n * @param {object} fields The fields object to serialize\n * @return {object} An object representing the serialized fields\n */\nvar serializeFields = function serializeFields(fields) {\n  var obj = Object.create(null);\n  for (var fieldName in fields) {\n    if (!hasOwnProperty.call(fields, fieldName)) continue;\n    obj[fieldName] = [fields[fieldName].value];\n    if (fields[fieldName].hasOwnProperty('id')) {\n      obj[fieldName].push(fields[fieldName].id);\n    }\n  }\n  return obj;\n};\n/**\n * Serialize the given block in the SB3 format with some compression of inputs,\n * fields, and primitives.\n * @param {object} block The block to serialize\n * @return {object | array} A serialized representation of the block. This is an\n * array if the block is one of the primitive types described above or an object,\n * if not.\n */\nvar serializeBlock = function serializeBlock(block) {\n  var serializedPrimitive = serializePrimitiveBlock(block);\n  if (serializedPrimitive) return serializedPrimitive; \n  var obj = Object.create(null);\n  obj.opcode = block.opcode; \n  \n  \n  obj.next = block.next;\n  obj.parent = block.parent;\n  obj.inputs = serializeInputs(block.inputs);\n  obj.fields = serializeFields(block.fields);\n  obj.shadow = block.shadow;\n  if (block.topLevel) {\n    obj.topLevel = true;\n    obj.x = block.x ? Math.round(block.x) : 0;\n    obj.y = block.y ? Math.round(block.y) : 0;\n  } else {\n    obj.topLevel = false;\n  }\n  if (block.mutation) {\n    obj.mutation = block.mutation;\n  }\n  if (block.comment) {\n    obj.comment = block.comment;\n  }\n  return obj;\n};\n/**\n * Compresses the serialized inputs replacing block/shadow ids that refer to\n * one of the primitives with the primitive itself. E.g.\n *\n * blocks: {\n *      aUidForMyBlock: {\n *          inputs: {\n *               MYINPUT: [1, 'aUidForAnUnobscuredShadowPrimitive']\n *          }\n *      },\n *      aUidForAnUnobscuredShadowPrimitive: [4, 10]\n *      \n * }\n *\n * becomes:\n *\n * blocks: {\n *      aUidForMyBlock: {\n *          inputs: {\n *               MYINPUT: [1, [4, 10]]\n *          }\n *      }\n * }\n * Note: this function modifies the given blocks object in place\n * @param {object} block The block with inputs to compress\n * @param {objec} blocks The object containing all the blocks currently getting serialized\n * @return {object} The serialized block with compressed inputs\n */\nvar compressInputTree = function compressInputTree(block, blocks) {\n  \n  \n  var serializedInputs = block.inputs;\n  for (var inputName in serializedInputs) {\n    \n    \n    var currInput = serializedInputs[inputName]; \n    \n    for (var i = 1; i < currInput.length; i++) {\n      if (!currInput[i]) continue; \n      var blockOrShadowID = currInput[i]; \n      \n      var blockOrShadow = blocks[blockOrShadowID];\n      if (Array.isArray(blockOrShadow)) {\n        currInput[i] = blockOrShadow; \n        delete blocks[blockOrShadowID];\n      }\n    }\n  }\n  return block;\n};\n/**\n * Get sanitized non-core extension ID for a given sb3 opcode.\n * Note that this should never return a URL. If in the future the SB3 loader supports loading extensions by URL, this\n * ID should be used to (for example) look up the extension's full URL from a table in the SB3's JSON.\n * @param {!string} opcode The opcode to examine for extension.\n * @return {?string} The extension ID, if it exists and is not a core extension.\n */\nvar getExtensionIdForOpcode = function getExtensionIdForOpcode(opcode) {\n  \n  var index = opcode.indexOf('_');\n  var forbiddenSymbols = /[^\\w-]/g;\n  var prefix = opcode.substring(0, index).replace(forbiddenSymbols, '-');\n  if (CORE_EXTENSIONS.indexOf(prefix) === -1) {\n    if (prefix !== '') return prefix;\n  }\n};\n/**\n * Serialize the given blocks object (representing all the blocks for the target\n * currently being serialized.)\n * @param {object} blocks The blocks to be serialized\n * @return {Array} An array of the serialized blocks with compressed inputs and\n * compressed primitives and the list of all extension IDs present\n * in the serialized blocks.\n */\nvar serializeBlocks = function serializeBlocks(blocks) {\n  var obj = Object.create(null);\n  var extensionIDs = new Set();\n  for (var blockID in blocks) {\n    if (!blocks.hasOwnProperty(blockID)) continue;\n    obj[blockID] = serializeBlock(blocks[blockID], blocks);\n    var extensionID = getExtensionIdForOpcode(blocks[blockID].opcode);\n    if (extensionID) {\n      extensionIDs.add(extensionID);\n    }\n  } \n  for (var _blockID in obj) {\n    \n    \n    var serializedBlock = obj[_blockID]; \n    \n    obj[_blockID] = compressInputTree(serializedBlock, obj); \n  } \n  \n  \n  for (var _blockID2 in obj) {\n    var _serializedBlock = obj[_blockID2]; \n    \n    \n    \n    \n    if (Array.isArray(_serializedBlock) && [VAR_PRIMITIVE, LIST_PRIMITIVE].indexOf(_serializedBlock[0]) < 0) {\n      log.warn(\"Found an unexpected top level primitive with block ID: \".concat(_blockID2, \"; deleting it from serialized blocks.\"));\n      delete obj[_blockID2];\n    }\n  }\n  return [obj, Array.from(extensionIDs)];\n};\n/**\n * Serialize the given costume.\n * @param {object} costume The costume to be serialized.\n * @return {object} A serialized representation of the costume.\n */\nvar serializeCostume = function serializeCostume(costume) {\n  var obj = Object.create(null);\n  obj.assetId = costume.assetId;\n  obj.name = costume.name;\n  obj.bitmapResolution = costume.bitmapResolution; \n  \n  \n  \n  \n  obj.md5ext = costume.md5;\n  obj.dataFormat = costume.dataFormat.toLowerCase();\n  obj.rotationCenterX = costume.rotationCenterX;\n  obj.rotationCenterY = costume.rotationCenterY;\n  return obj;\n};\n/**\n * Serialize the given sound.\n * @param {object} sound The sound to be serialized.\n * @return {object} A serialized representation of the sound.\n */\nvar serializeSound = function serializeSound(sound) {\n  var obj = Object.create(null);\n  obj.assetId = sound.assetId;\n  obj.name = sound.name;\n  obj.dataFormat = sound.dataFormat.toLowerCase();\n  obj.format = sound.format;\n  obj.rate = sound.rate;\n  obj.sampleCount = sound.sampleCount; \n  \n  \n  \n  \n  obj.md5ext = sound.md5;\n  return obj;\n};\n/**\n * Serialize the given variables object.\n * @param {object} variables The variables to be serialized.\n * @return {object} A serialized representation of the variables. They get\n * separated by type to compress the representation of each given variable and\n * reduce duplicate information.\n */\nvar serializeVariables = function serializeVariables(variables) {\n  var obj = Object.create(null); \n  \n  obj.variables = Object.create(null);\n  obj.lists = Object.create(null);\n  obj.broadcasts = Object.create(null);\n  for (var varId in variables) {\n    var v = variables[varId];\n    if (v.type === Variable.BROADCAST_MESSAGE_TYPE) {\n      obj.broadcasts[varId] = v.value; \n      continue;\n    }\n    if (v.type === Variable.LIST_TYPE) {\n      obj.lists[varId] = [v.name, v.value];\n      continue;\n    } \n    obj.variables[varId] = [v.name, v.value]; \n    if (v.isCloud) obj.variables[varId].push(true);\n  }\n  return obj;\n};\nvar serializeComments = function serializeComments(comments) {\n  var obj = Object.create(null);\n  for (var commentId in comments) {\n    if (!comments.hasOwnProperty(commentId)) continue;\n    var comment = comments[commentId];\n    var serializedComment = Object.create(null);\n    serializedComment.blockId = comment.blockId;\n    serializedComment.x = comment.x;\n    serializedComment.y = comment.y;\n    serializedComment.width = comment.width;\n    serializedComment.height = comment.height;\n    serializedComment.minimized = comment.minimized;\n    serializedComment.text = comment.text;\n    obj[commentId] = serializedComment;\n  }\n  return obj;\n};\n/**\n * Serialize the given target. Only serialize properties that are necessary\n * for saving and loading this target.\n * @param {object} target The target to be serialized.\n * @param {Set} extensions A set of extensions to add extension IDs to\n * @return {object} A serialized representation of the given target.\n */\nvar serializeTarget = function serializeTarget(target, extensions) {\n  var obj = Object.create(null);\n  var targetExtensions = [];\n  obj.isStage = target.isStage;\n  obj.name = obj.isStage ? 'Stage' : target.name;\n  var vars = serializeVariables(target.variables);\n  obj.variables = vars.variables;\n  obj.lists = vars.lists;\n  obj.broadcasts = vars.broadcasts;\n  var _serializeBlocks = serializeBlocks(target.blocks);\n  var _serializeBlocks2 = _slicedToArray(_serializeBlocks, 2);\n  obj.blocks = _serializeBlocks2[0];\n  targetExtensions = _serializeBlocks2[1];\n  obj.comments = serializeComments(target.comments); \n  if (target.currentCostume < 0 || target.currentCostume >= target.costumes.length) {\n    log.warn(\"currentCostume property for target \".concat(target.name, \" is out of range\"));\n    target.currentCostume = MathUtil.clamp(target.currentCostume, 0, target.costumes.length - 1);\n  }\n  obj.currentCostume = target.currentCostume;\n  obj.costumes = target.costumes.map(serializeCostume);\n  obj.sounds = target.sounds.map(serializeSound);\n  if (target.hasOwnProperty('volume')) obj.volume = target.volume;\n  if (target.hasOwnProperty('layerOrder')) obj.layerOrder = target.layerOrder;\n  if (obj.isStage) {\n    \n    if (target.hasOwnProperty('tempo')) obj.tempo = target.tempo;\n    if (target.hasOwnProperty('videoTransparency')) obj.videoTransparency = target.videoTransparency;\n    if (target.hasOwnProperty('videoState')) obj.videoState = target.videoState;\n    if (target.hasOwnProperty('textToSpeechLanguage')) obj.textToSpeechLanguage = target.textToSpeechLanguage;\n  } else {\n    \n    obj.visible = target.visible;\n    obj.x = target.x;\n    obj.y = target.y;\n    obj.size = target.size;\n    obj.direction = target.direction;\n    obj.draggable = target.draggable;\n    obj.rotationStyle = target.rotationStyle;\n  } \n  targetExtensions.forEach(function (extensionId) {\n    extensions.add(extensionId);\n  });\n  return obj;\n};\nvar getSimplifiedLayerOrdering = function getSimplifiedLayerOrdering(targets) {\n  var layerOrders = targets.map(function (t) {\n    return t.getLayerOrder();\n  });\n  return MathUtil.reducedSortOrdering(layerOrders);\n};\nvar serializeMonitors = function serializeMonitors(monitors) {\n  return monitors.valueSeq().map(function (monitorData) {\n    var serializedMonitor = {\n      id: monitorData.id,\n      mode: monitorData.mode,\n      opcode: monitorData.opcode,\n      params: monitorData.params,\n      spriteName: monitorData.spriteName,\n      value: monitorData.value,\n      width: monitorData.width,\n      height: monitorData.height,\n      x: monitorData.x,\n      y: monitorData.y,\n      visible: monitorData.visible\n    };\n    if (monitorData.mode !== 'list') {\n      serializedMonitor.sliderMin = monitorData.sliderMin;\n      serializedMonitor.sliderMax = monitorData.sliderMax;\n      serializedMonitor.isDiscrete = monitorData.isDiscrete;\n    }\n    return serializedMonitor;\n  });\n};\n/**\n * Serializes the specified VM runtime.\n * @param {!Runtime} runtime VM runtime instance to be serialized.\n * @param {string=} targetId Optional target id if serializing only a single target\n * @return {object} Serialized runtime instance.\n */\nvar serialize = function serialize(runtime, targetId) {\n  \n  var obj = Object.create(null); \n  var extensions = new Set();\n  var originalTargetsToSerialize = targetId ? [runtime.getTargetById(targetId)] : runtime.targets.filter(function (target) {\n    return target.isOriginal;\n  });\n  var layerOrdering = getSimplifiedLayerOrdering(originalTargetsToSerialize);\n  var flattenedOriginalTargets = originalTargetsToSerialize.map(function (t) {\n    return t.toJSON();\n  }); \n  \n  if (runtime.renderer && !targetId) {\n    flattenedOriginalTargets.forEach(function (t, index) {\n      t.layerOrder = layerOrdering[index];\n    });\n  }\n  var serializedTargets = flattenedOriginalTargets.map(function (t) {\n    return serializeTarget(t, extensions);\n  });\n  if (targetId) {\n    return serializedTargets[0];\n  }\n  obj.targets = serializedTargets;\n  obj.monitors = serializeMonitors(runtime.getMonitorState()); \n  obj.extensions = Array.from(extensions); \n  var meta = Object.create(null);\n  meta.semver = '3.0.0';\n  meta.vm = vmPackage.version; \n  meta.agent = 'none';\n  if (typeof navigator !== 'undefined') meta.agent = navigator.userAgent; \n  obj.meta = meta;\n  return obj;\n};\n/**\n * Deserialize a block input descriptors. This is either a\n * block id or a serialized primitive, e.g. an array\n * (see serializePrimitiveBlock function).\n * @param {string | array} inputDescOrId The block input descriptor to be serialized.\n * @param {string} parentId The id of the parent block for this input block.\n * @param {boolean} isShadow Whether or not this input block is a shadow.\n * @param {object} blocks The entire blocks object currently in the process of getting serialized.\n * @return {object} The deserialized input descriptor.\n */\nvar deserializeInputDesc = function deserializeInputDesc(inputDescOrId, parentId, isShadow, blocks) {\n  if (!Array.isArray(inputDescOrId)) return inputDescOrId;\n  var primitiveObj = Object.create(null);\n  var newId = uid();\n  primitiveObj.id = newId;\n  primitiveObj.next = null;\n  primitiveObj.parent = parentId;\n  primitiveObj.shadow = isShadow;\n  primitiveObj.inputs = Object.create(null); \n  switch (inputDescOrId[0]) {\n    case MATH_NUM_PRIMITIVE:\n      {\n        primitiveObj.opcode = 'math_number';\n        primitiveObj.fields = {\n          NUM: {\n            name: 'NUM',\n            value: inputDescOrId[1]\n          }\n        };\n        primitiveObj.topLevel = false;\n        break;\n      }\n    case POSITIVE_NUM_PRIMITIVE:\n      {\n        primitiveObj.opcode = 'math_positive_number';\n        primitiveObj.fields = {\n          NUM: {\n            name: 'NUM',\n            value: inputDescOrId[1]\n          }\n        };\n        primitiveObj.topLevel = false;\n        break;\n      }\n    case WHOLE_NUM_PRIMITIVE:\n      {\n        primitiveObj.opcode = 'math_whole_number';\n        primitiveObj.fields = {\n          NUM: {\n            name: 'NUM',\n            value: inputDescOrId[1]\n          }\n        };\n        primitiveObj.topLevel = false;\n        break;\n      }\n    case INTEGER_NUM_PRIMITIVE:\n      {\n        primitiveObj.opcode = 'math_integer';\n        primitiveObj.fields = {\n          NUM: {\n            name: 'NUM',\n            value: inputDescOrId[1]\n          }\n        };\n        primitiveObj.topLevel = false;\n        break;\n      }\n    case ANGLE_NUM_PRIMITIVE:\n      {\n        primitiveObj.opcode = 'math_angle';\n        primitiveObj.fields = {\n          NUM: {\n            name: 'NUM',\n            value: inputDescOrId[1]\n          }\n        };\n        primitiveObj.topLevel = false;\n        break;\n      }\n    case COLOR_PICKER_PRIMITIVE:\n      {\n        primitiveObj.opcode = 'colour_picker';\n        primitiveObj.fields = {\n          COLOUR: {\n            name: 'COLOUR',\n            value: inputDescOrId[1]\n          }\n        };\n        primitiveObj.topLevel = false;\n        break;\n      }\n    case TEXT_PRIMITIVE:\n      {\n        primitiveObj.opcode = 'text';\n        primitiveObj.fields = {\n          TEXT: {\n            name: 'TEXT',\n            value: inputDescOrId[1]\n          }\n        };\n        primitiveObj.topLevel = false;\n        break;\n      }\n    case BROADCAST_PRIMITIVE:\n      {\n        primitiveObj.opcode = 'event_broadcast_menu';\n        primitiveObj.fields = {\n          BROADCAST_OPTION: {\n            name: 'BROADCAST_OPTION',\n            value: inputDescOrId[1],\n            id: inputDescOrId[2],\n            variableType: Variable.BROADCAST_MESSAGE_TYPE\n          }\n        };\n        primitiveObj.topLevel = false;\n        break;\n      }\n    case VAR_PRIMITIVE:\n      {\n        primitiveObj.opcode = 'data_variable';\n        primitiveObj.fields = {\n          VARIABLE: {\n            name: 'VARIABLE',\n            value: inputDescOrId[1],\n            id: inputDescOrId[2],\n            variableType: Variable.SCALAR_TYPE\n          }\n        };\n        if (inputDescOrId.length > 3) {\n          primitiveObj.topLevel = true;\n          primitiveObj.x = inputDescOrId[3];\n          primitiveObj.y = inputDescOrId[4];\n        }\n        break;\n      }\n    case LIST_PRIMITIVE:\n      {\n        primitiveObj.opcode = 'data_listcontents';\n        primitiveObj.fields = {\n          LIST: {\n            name: 'LIST',\n            value: inputDescOrId[1],\n            id: inputDescOrId[2],\n            variableType: Variable.LIST_TYPE\n          }\n        };\n        if (inputDescOrId.length > 3) {\n          primitiveObj.topLevel = true;\n          primitiveObj.x = inputDescOrId[3];\n          primitiveObj.y = inputDescOrId[4];\n        }\n        break;\n      }\n    default:\n      {\n        log.error(\"Found unknown primitive type during deserialization: \".concat(JSON.stringify(inputDescOrId)));\n        return null;\n      }\n  }\n  blocks[newId] = primitiveObj;\n  return newId;\n};\n/**\n * Deserialize the given block inputs.\n * @param {object} inputs The inputs to deserialize.\n * @param {string} parentId The block id of the parent block\n * @param {object} blocks The object representing the entire set of blocks currently\n * in the process of getting deserialized.\n * @return {object} The deserialized and uncompressed inputs.\n */\nvar deserializeInputs = function deserializeInputs(inputs, parentId, blocks) {\n  \n  \n  var obj = {};\n  for (var inputName in inputs) {\n    if (!hasOwnProperty.call(inputs, inputName)) continue;\n    var inputDescArr = inputs[inputName]; \n    if (!Array.isArray(inputDescArr)) continue;\n    var block = null;\n    var shadow = null;\n    var blockShadowInfo = inputDescArr[0];\n    if (blockShadowInfo === INPUT_SAME_BLOCK_SHADOW) {\n      \n      block = shadow = deserializeInputDesc(inputDescArr[1], parentId, true, blocks);\n    } else if (blockShadowInfo === INPUT_BLOCK_NO_SHADOW) {\n      block = deserializeInputDesc(inputDescArr[1], parentId, false, blocks);\n    } else {\n      \n      block = deserializeInputDesc(inputDescArr[1], parentId, false, blocks);\n      shadow = deserializeInputDesc(inputDescArr[2], parentId, true, blocks);\n    }\n    obj[inputName] = {\n      name: inputName,\n      block: block,\n      shadow: shadow\n    };\n  }\n  return obj;\n};\n/**\n * Deserialize the given block fields.\n * @param {object} fields The fields to be deserialized\n * @return {object} The deserialized and uncompressed block fields.\n */\nvar deserializeFields = function deserializeFields(fields) {\n  \n  \n  var obj = {};\n  for (var fieldName in fields) {\n    if (!hasOwnProperty.call(fields, fieldName)) continue;\n    var fieldDescArr = fields[fieldName]; \n    if (!Array.isArray(fieldDescArr)) continue;\n    obj[fieldName] = {\n      name: fieldName,\n      value: fieldDescArr[0]\n    };\n    if (fieldDescArr.length > 1) {\n      obj[fieldName].id = fieldDescArr[1];\n    }\n    if (fieldName === 'BROADCAST_OPTION') {\n      obj[fieldName].variableType = Variable.BROADCAST_MESSAGE_TYPE;\n    } else if (fieldName === 'VARIABLE') {\n      obj[fieldName].variableType = Variable.SCALAR_TYPE;\n    } else if (fieldName === 'LIST') {\n      obj[fieldName].variableType = Variable.LIST_TYPE;\n    }\n  }\n  return obj;\n};\n/**\n * Covnert serialized INPUT and FIELD primitives back to hydrated block templates.\n * Should be able to deserialize a format that has already been deserialized.  The only\n * \"east\" path to adding new targets/code requires going through deserialize, so it should\n * work with pre-parsed deserialized blocks.\n *\n * @param {object} blocks Serialized SB3 \"blocks\" property of a target. Will be mutated.\n * @return {object} input is modified and returned\n */\nvar deserializeBlocks = function deserializeBlocks(blocks) {\n  for (var blockId in blocks) {\n    if (!Object.prototype.hasOwnProperty.call(blocks, blockId)) {\n      continue;\n    }\n    var block = blocks[blockId];\n    if (Array.isArray(block)) {\n      \n      \n      \n      delete blocks[blockId];\n      deserializeInputDesc(block, null, false, blocks);\n      continue;\n    }\n    block.id = blockId; \n    block.inputs = deserializeInputs(block.inputs, blockId, blocks);\n    block.fields = deserializeFields(block.fields);\n  }\n  return blocks;\n};\n/**\n * Parse the assets of a single \"Scratch object\" and load them. This\n * preprocesses objects to support loading the data for those assets over a\n * network while the objects are further processed into Blocks, Sprites, and a\n * list of needed Extensions.\n * @param {!object} object From-JSON \"Scratch object:\" sprite, stage, watcher.\n * @param {!Runtime} runtime Runtime object to load all structures into.\n * @param {JSZip} zip Sb3 file describing this project (to load assets from)\n * @return {?{costumePromises:Array.<Promise>,soundPromises:Array.<Promise>,soundBank:SoundBank}}\n * Object of arrays of promises for asset objects used in Sprites. As well as a\n * SoundBank for the sound assets. null for unsupported objects.\n */\nvar parseScratchAssets = function parseScratchAssets(object, runtime, zip) {\n  if (!object.hasOwnProperty('name')) {\n    \n    \n    return Promise.resolve(null);\n  }\n  var assets = {\n    costumePromises: null,\n    soundPromises: null,\n    soundBank: runtime.audioEngine && runtime.audioEngine.createBank()\n  }; \n  assets.costumePromises = (object.costumes || []).map(function (costumeSource) {\n    \n    var costume = {\n      \n      \n      asset: costumeSource.asset,\n      assetId: costumeSource.assetId,\n      skinId: null,\n      name: costumeSource.name,\n      bitmapResolution: costumeSource.bitmapResolution,\n      rotationCenterX: costumeSource.rotationCenterX,\n      rotationCenterY: costumeSource.rotationCenterY\n    };\n    var dataFormat = costumeSource.dataFormat || costumeSource.assetType && costumeSource.assetType.runtimeFormat || \n    'png'; \n    var costumeMd5Ext = costumeSource.hasOwnProperty('md5ext') ? costumeSource.md5ext : \"\".concat(costumeSource.assetId, \".\").concat(dataFormat);\n    costume.md5 = costumeMd5Ext;\n    costume.dataFormat = dataFormat; \n    \n    \n    \n    \n    return deserializeCostume(costume, runtime, zip).then(function () {\n      return loadCostume(costumeMd5Ext, costume, runtime);\n    }); \n    \n  }); \n  assets.soundPromises = (object.sounds || []).map(function (soundSource) {\n    var sound = {\n      assetId: soundSource.assetId,\n      format: soundSource.format,\n      rate: soundSource.rate,\n      sampleCount: soundSource.sampleCount,\n      name: soundSource.name,\n      \n      \n      \n      md5: soundSource.md5ext,\n      dataFormat: soundSource.dataFormat,\n      data: null\n    }; \n    \n    \n    \n    \n    return deserializeSound(sound, runtime, zip).then(function () {\n      return loadSound(sound, runtime, assets.soundBank);\n    }); \n    \n  });\n  return assets;\n};\n/**\n * Parse a single \"Scratch object\" and create all its in-memory VM objects.\n * @param {!object} object From-JSON \"Scratch object:\" sprite, stage, watcher.\n * @param {!Runtime} runtime Runtime object to load all structures into.\n * @param {ImportedExtensionsInfo} extensions - (in/out) parsed extension information will be stored here.\n * @param {JSZip} zip Sb3 file describing this project (to load assets from)\n * @param {object} assets - Promises for assets of this scratch object grouped\n *   into costumes and sounds\n * @return {!Promise.<Target>} Promise for the target created (stage or sprite), or null for unsupported objects.\n */\nvar parseScratchObject = function parseScratchObject(object, runtime, extensions, zip, assets) {\n  if (!object.hasOwnProperty('name')) {\n    \n    \n    return Promise.resolve(null);\n  } \n  var blocks = new Blocks(runtime); \n  var sprite = new Sprite(blocks, runtime); \n  if (object.hasOwnProperty('name')) {\n    sprite.name = object.name;\n  }\n  if (object.hasOwnProperty('blocks')) {\n    deserializeBlocks(object.blocks); \n    for (var blockId in object.blocks) {\n      if (!object.blocks.hasOwnProperty(blockId)) continue;\n      var blockJSON = object.blocks[blockId];\n      blocks.createBlock(blockJSON); \n      var extensionID = getExtensionIdForOpcode(blockJSON.opcode);\n      if (extensionID) {\n        extensions.extensionIDs.add(extensionID);\n      }\n    }\n  } \n  var costumePromises = assets.costumePromises; \n  var soundBank = assets.soundBank,\n      soundPromises = assets.soundPromises; \n  var target = sprite.createClone(object.isStage ? StageLayering.BACKGROUND_LAYER : StageLayering.SPRITE_LAYER); \n  if (object.hasOwnProperty('tempo')) {\n    target.tempo = object.tempo;\n  }\n  if (object.hasOwnProperty('volume')) {\n    target.volume = object.volume;\n  }\n  if (object.hasOwnProperty('videoTransparency')) {\n    target.videoTransparency = object.videoTransparency;\n  }\n  if (object.hasOwnProperty('videoState')) {\n    target.videoState = object.videoState;\n  }\n  if (object.hasOwnProperty('textToSpeechLanguage')) {\n    target.textToSpeechLanguage = object.textToSpeechLanguage;\n  }\n  if (object.hasOwnProperty('variables')) {\n    for (var varId in object.variables) {\n      var variable = object.variables[varId]; \n      \n      \n      \n      var isCloud = variable.length === 3 && variable[2] && object.isStage && runtime.canAddCloudVariable();\n      var newVariable = new Variable(varId, \n      variable[0], \n      Variable.SCALAR_TYPE, \n      isCloud);\n      if (isCloud) runtime.addCloudVariable();\n      newVariable.value = variable[1];\n      target.variables[newVariable.id] = newVariable;\n    }\n  }\n  if (object.hasOwnProperty('lists')) {\n    for (var listId in object.lists) {\n      var list = object.lists[listId];\n      var newList = new Variable(listId, list[0], Variable.LIST_TYPE, false);\n      newList.value = list[1];\n      target.variables[newList.id] = newList;\n    }\n  }\n  if (object.hasOwnProperty('broadcasts')) {\n    for (var broadcastId in object.broadcasts) {\n      var broadcast = object.broadcasts[broadcastId];\n      var newBroadcast = new Variable(broadcastId, broadcast, Variable.BROADCAST_MESSAGE_TYPE, false); \n      \n      target.variables[newBroadcast.id] = newBroadcast;\n    }\n  }\n  if (object.hasOwnProperty('comments')) {\n    for (var commentId in object.comments) {\n      var comment = object.comments[commentId];\n      var newComment = new Comment(commentId, comment.text, comment.x, comment.y, comment.width, comment.height, comment.minimized);\n      if (comment.blockId) {\n        newComment.blockId = comment.blockId;\n      }\n      target.comments[newComment.id] = newComment;\n    }\n  }\n  if (object.hasOwnProperty('x')) {\n    target.x = object.x;\n  }\n  if (object.hasOwnProperty('y')) {\n    target.y = object.y;\n  }\n  if (object.hasOwnProperty('direction')) {\n    target.direction = object.direction;\n  }\n  if (object.hasOwnProperty('size')) {\n    target.size = object.size;\n  }\n  if (object.hasOwnProperty('visible')) {\n    target.visible = object.visible;\n  }\n  if (object.hasOwnProperty('currentCostume')) {\n    target.currentCostume = MathUtil.clamp(object.currentCostume, 0, object.costumes.length - 1);\n  }\n  if (object.hasOwnProperty('rotationStyle')) {\n    target.rotationStyle = object.rotationStyle;\n  }\n  if (object.hasOwnProperty('isStage')) {\n    target.isStage = object.isStage;\n  }\n  if (object.hasOwnProperty('targetPaneOrder')) {\n    \n    \n    \n    target.targetPaneOrder = object.targetPaneOrder;\n  }\n  if (object.hasOwnProperty('draggable')) {\n    target.draggable = object.draggable;\n  }\n  Promise.all(costumePromises).then(function (costumes) {\n    sprite.costumes = costumes;\n  });\n  Promise.all(soundPromises).then(function (sounds) {\n    sprite.sounds = sounds; \n    sprite.soundBank = soundBank || null;\n  });\n  return Promise.all(costumePromises.concat(soundPromises)).then(function () {\n    return target;\n  });\n};\nvar deserializeMonitor = function deserializeMonitor(monitorData, runtime, targets, extensions) {\n  \n  \n  \n  if (monitorData.spriteName) {\n    var filteredTargets = targets.filter(function (t) {\n      return t.sprite.name === monitorData.spriteName;\n    });\n    if (filteredTargets && filteredTargets.length > 0) {\n      monitorData.targetId = filteredTargets[0].id;\n    } else {\n      log.warn(\"Tried to deserialize sprite specific monitor \".concat(monitorData.opcode, \" but could not find sprite \").concat(monitorData.spriteName, \".\"));\n    }\n  } \n  \n  var monitorBlockInfo = runtime.monitorBlockInfo[monitorData.opcode]; \n  \n  if (monitorData.opcode === 'data_listcontents') {\n    var listTarget = monitorData.targetId ? targets.find(function (t) {\n      return t.id === monitorData.targetId;\n    }) : targets.find(function (t) {\n      return t.isStage;\n    });\n    if (listTarget && Object.prototype.hasOwnProperty.call(listTarget.variables, monitorData.id)) {\n      monitorData.params.LIST = listTarget.variables[monitorData.id].name;\n    }\n  } \n  var fields = {};\n  for (var paramKey in monitorData.params) {\n    var field = {\n      name: paramKey,\n      value: monitorData.params[paramKey]\n    };\n    fields[paramKey] = field;\n  } \n  \n  \n  if (monitorData.opcode !== 'data_variable' && monitorData.opcode !== 'data_listcontents' && monitorBlockInfo && monitorBlockInfo.isSpriteSpecific) {\n    monitorData.id = monitorBlockInfo.getId(monitorData.targetId, fields);\n  } else {\n    \n    \n    \n    \n    monitorData.id = StringUtil.replaceUnsafeChars(monitorData.id);\n  } \n  \n  var existingMonitorBlock = runtime.monitorBlocks._blocks[monitorData.id];\n  if (existingMonitorBlock) {\n    \n    \n    existingMonitorBlock.isMonitored = monitorData.visible;\n    existingMonitorBlock.targetId = monitorData.targetId;\n  } else {\n    \n    \n    var monitorBlock = {\n      id: monitorData.id,\n      opcode: monitorData.opcode,\n      inputs: {},\n      \n      fields: fields,\n      topLevel: true,\n      next: null,\n      parent: null,\n      shadow: false,\n      x: 0,\n      y: 0,\n      isMonitored: monitorData.visible,\n      targetId: monitorData.targetId\n    }; \n    \n    \n    if (monitorData.opcode === 'data_variable') {\n      var _field = monitorBlock.fields.VARIABLE;\n      _field.id = monitorData.id;\n      _field.variableType = Variable.SCALAR_TYPE;\n    } else if (monitorData.opcode === 'data_listcontents') {\n      var _field2 = monitorBlock.fields.LIST;\n      _field2.id = monitorData.id;\n      _field2.variableType = Variable.LIST_TYPE;\n    }\n    runtime.monitorBlocks.createBlock(monitorBlock); \n    var extensionID = getExtensionIdForOpcode(monitorBlock.opcode);\n    if (extensionID) {\n      extensions.extensionIDs.add(extensionID);\n    }\n  }\n  runtime.requestAddMonitor(MonitorRecord(monitorData));\n}; \n\n\n\nvar replaceUnsafeCharsInVariableIds = function replaceUnsafeCharsInVariableIds(targets) {\n  var allVarRefs = VariableUtil.getAllVarRefsForTargets(targets, true); \n  targets.forEach(function (t) {\n    Object.keys(t.variables).forEach(function (id) {\n      var newId = StringUtil.replaceUnsafeChars(id);\n      if (newId === id) return;\n      t.variables[id].id = newId;\n      t.variables[newId] = t.variables[id];\n      delete t.variables[id];\n    });\n  }); \n  for (var id in allVarRefs) {\n    var newId = StringUtil.replaceUnsafeChars(id);\n    if (id === newId) continue; \n    \n    \n    \n    VariableUtil.updateVariableIdentifiers(allVarRefs[id], newId);\n  }\n  return targets;\n};\n/**\n * Deserialize the specified representation of a VM runtime and loads it into the provided runtime instance.\n * @param  {object} json - JSON representation of a VM runtime.\n * @param  {Runtime} runtime - Runtime instance\n * @param {JSZip} zip - Sb3 file describing this project (to load assets from)\n * @param {boolean} isSingleSprite - If true treat as single sprite, else treat as whole project\n * @returns {Promise.<ImportedProject>} Promise that resolves to the list of targets after the project is deserialized\n */\nvar deserialize = function deserialize(json, runtime, zip, isSingleSprite) {\n  var extensions = {\n    extensionIDs: new Set(),\n    extensionURLs: new Map()\n  }; \n  \n  \n  \n  var targetObjects = ((isSingleSprite ? [json] : json.targets) || []).map(function (t, i) {\n    return Object.assign(t, {\n      targetPaneOrder: i\n    });\n  }).sort(function (a, b) {\n    return a.layerOrder - b.layerOrder;\n  });\n  var monitorObjects = json.monitors || [];\n  return Promise.resolve(targetObjects.map(function (target) {\n    return parseScratchAssets(target, runtime, zip);\n  })) \n  \n  .then(function (assets) {\n    return Promise.resolve(assets);\n  }).then(function (assets) {\n    return Promise.all(targetObjects.map(function (target, index) {\n      return parseScratchObject(target, runtime, extensions, zip, assets[index]);\n    }));\n  }).then(function (targets) {\n    return targets \n    .map(function (t, i) {\n      \n      \n      \n      t.layerOrder = i;\n      return t;\n    }).sort(function (a, b) {\n      return a.targetPaneOrder - b.targetPaneOrder;\n    }).map(function (t) {\n      \n      \n      delete t.targetPaneOrder;\n      return t;\n    });\n  }).then(function (targets) {\n    return replaceUnsafeCharsInVariableIds(targets);\n  }).then(function (targets) {\n    monitorObjects.map(function (monitorDesc) {\n      return deserializeMonitor(monitorDesc, runtime, targets, extensions);\n    });\n    return targets;\n  }).then(function (targets) {\n    return {\n      targets: targets,\n      extensions: extensions\n    };\n  });\n};\nmodule.exports = {\n  serialize: serialize,\n  deserialize: deserialize,\n  deserializeBlocks: deserializeBlocks,\n  serializeBlocks: serializeBlocks,\n  getExtensionIdForOpcode: getExtensionIdForOpcode\n};\n })