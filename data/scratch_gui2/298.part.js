/* 298 */\n (function(module, exports, __webpack_require__) {\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nvar Timer = __webpack_require__(136);\nvar RateLimiter = function () {\n \n  function RateLimiter(maxRate) {\n    _classCallCheck(this, RateLimiter);\n   \n    this._maxTokens = maxRate;\n   \n    this._refillInterval = 1000 / maxRate;\n   \n    this._count = this._maxTokens;\n    this._timer = new Timer();\n    this._timer.start();\n   \n    this._lastUpdateTime = this._timer.timeElapsed();\n  }\n \n  _createClass(RateLimiter, [{\n    key: \"okayToSend\",\n    value: function okayToSend() {\n      \n      \n      var now = this._timer.timeElapsed();\n      var timeSinceRefill = now - this._lastUpdateTime;\n      var refillCount = Math.floor(timeSinceRefill / this._refillInterval); \n      \n      \n      if (refillCount > 0) {\n        this._lastUpdateTime = now;\n      } \n      this._count = Math.min(this._maxTokens, this._count + refillCount); \n      if (this._count > 0) {\n        this._count--;\n        return true;\n      }\n      return false;\n    }\n  }]);\n  return RateLimiter;\n}();\nmodule.exports = RateLimiter;\n })