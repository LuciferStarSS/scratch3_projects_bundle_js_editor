/* 1099 */\n (function(module, exports, __webpack_require__) {\nvar _BoostColorIndex;\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nvar ArgumentType = __webpack_require__(63);\nvar BlockType = __webpack_require__(45);\nvar Cast = __webpack_require__(48);\nvar formatMessage = __webpack_require__(71);\nvar color = __webpack_require__(180);\nvar BLE = __webpack_require__(221);\nvar Base64Util = __webpack_require__(182);\nvar MathUtil = __webpack_require__(62);\nvar RateLimiter = __webpack_require__(298);\nvar log = __webpack_require__(39);\n/**\n * The LEGO Wireless Protocol documentation used to create this extension can be found at:\n * https://lego.github.io/lego-ble-wireless-protocol-docs/index.html\n */\n/**\n * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.\n * @type {string}\n */\n\nvar iconURI = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAMAAAC5zwKfAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACpQTFRF////fIel5ufolZ62/2YavsPS+YZOkJmy9/j53+Hk6+zs6N/b6dfO////tDhMHAAAAA50Uk5T/////////////////wBFwNzIAAAA6ElEQVR42uzX2w6DIBAEUGDVtlr//3dLaLwgiwUd2z7MJPJg5EQWiGhGcAxBggQJEiT436CIfqXJPTn3MKNYYMSDFpoAmp24OaYgvwKnFgL2zvVTCwHrMoMi+nUQLFthaNCCa0iwclLkDgYVsQp0mzxuqXgK1MRzoCLWgkPXNN2wI/q6Kvt7u/cX0HtejN8x2sXpnpb8J8D3b0Keuhh3X975M+i0xNVbg3s1TIasgK21bQyGO+s2PykaGMYbge8KrNrssvkOWDXkErB8UuBHETjoYLkKBA8ZfuDkbwVBggQJEiR4MC8BBgDTtMZLx2nFCQAAAABJRU5ErkJggg==';\n/**\n * Boost BLE UUIDs.\n * @enum {string}\n */\nvar BoostBLE = {\n  service: '00001623-1212-efde-1623-785feabcd123',\n  characteristic: '00001624-1212-efde-1623-785feabcd123',\n  sendInterval: 100,\n  sendRateMax: 20\n};\n/**\n * Boost Motor Max Power Add. Defines how much more power than the target speed\n * the motors may supply to reach the target speed faster.\n * Lower number == softer, slower reached target speed.\n * Higher number == harder, faster reached target speed.\n * @constant {number}\n */\nvar BoostMotorMaxPowerAdd = 10;\n/**\n * A time interval to wait (in milliseconds) in between battery check calls.\n * @type {number}\n */\nvar BoostPingInterval = 5000;\n/**\n * The number of continuous samples the color-sensor will evaluate color from.\n * @type {number}\n */\nvar BoostColorSampleSize = 5;\n/**\n * Enum for Boost sensor and actuator types.\n * @readonly\n * @enum {number}\n */\nvar BoostIO = {\n  MOTOR_WEDO: 0x01,\n  MOTOR_SYSTEM: 0x02,\n  BUTTON: 0x05,\n  LIGHT: 0x08,\n  VOLTAGE: 0x14,\n  CURRENT: 0x15,\n  PIEZO: 0x16,\n  LED: 0x17,\n  TILT_EXTERNAL: 0x22,\n  MOTION_SENSOR: 0x23,\n  COLOR: 0x25,\n  MOTOREXT: 0x26,\n  MOTORINT: 0x27,\n  TILT: 0x28\n};\n/**\n * Enum for ids for various output command feedback types on the Boost.\n * @readonly\n * @enum {number}\n */\nvar BoostPortFeedback = {\n  IN_PROGRESS: 0x01,\n  COMPLETED: 0x02,\n  DISCARDED: 0x04,\n  IDLE: 0x08,\n  BUSY_OR_FULL: 0x10\n};\n/**\n * Enum for physical Boost Ports\n * @readonly\n * @enum {number}\n */\nvar BoostPort10000223OrOlder = {\n  A: 55,\n  B: 56,\n  C: 1,\n  D: 2\n};\nvar BoostPort10000224OrNewer = {\n  A: 0,\n  B: 1,\n  C: 2,\n  D: 3\n}; \nvar BoostPort = BoostPort10000224OrNewer;\n/**\n * Ids for each color sensor value used by the extension.\n * @readonly\n * @enum {string}\n */\nvar BoostColor = {\n  ANY: 'any',\n  NONE: 'none',\n  RED: 'red',\n  BLUE: 'blue',\n  GREEN: 'green',\n  YELLOW: 'yellow',\n  WHITE: 'white',\n  BLACK: 'black'\n};\n/**\n * Enum for indices for each color sensed by the Boost vision sensor.\n * @readonly\n * @enum {number}\n */\nvar BoostColorIndex = (_BoostColorIndex = {}, _defineProperty(_BoostColorIndex, BoostColor.NONE, 255), _defineProperty(_BoostColorIndex, BoostColor.RED, 9), _defineProperty(_BoostColorIndex, BoostColor.BLUE, 3), _defineProperty(_BoostColorIndex, BoostColor.GREEN, 5), _defineProperty(_BoostColorIndex, BoostColor.YELLOW, 7), _defineProperty(_BoostColorIndex, BoostColor.WHITE, 10), _defineProperty(_BoostColorIndex, BoostColor.BLACK, 0), _BoostColorIndex);\n/**\n * Enum for Message Types\n * @readonly\n * @enum {number}\n */\nvar BoostMessage = {\n  HUB_PROPERTIES: 0x01,\n  HUB_ACTIONS: 0x02,\n  HUB_ALERTS: 0x03,\n  HUB_ATTACHED_IO: 0x04,\n  ERROR: 0x05,\n  PORT_INPUT_FORMAT_SETUP_SINGLE: 0x41,\n  PORT_INPUT_FORMAT_SETUP_COMBINED: 0x42,\n  PORT_INFORMATION: 0x43,\n  PORT_MODEINFORMATION: 0x44,\n  PORT_VALUE: 0x45,\n  PORT_VALUE_COMBINED: 0x46,\n  PORT_INPUT_FORMAT: 0x47,\n  PORT_INPUT_FORMAT_COMBINED: 0x48,\n  OUTPUT: 0x81,\n  PORT_FEEDBACK: 0x82\n};\n/**\n * Enum for Hub Property Types\n * @readonly\n * @enum {number}\n */\nvar BoostHubProperty = {\n  ADVERTISEMENT_NAME: 0x01,\n  BUTTON: 0x02,\n  FW_VERSION: 0x03,\n  HW_VERSION: 0x04,\n  RSSI: 0x05,\n  BATTERY_VOLTAGE: 0x06,\n  BATTERY_TYPE: 0x07,\n  MANUFACTURER_NAME: 0x08,\n  RADIO_FW_VERSION: 0x09,\n  LEGO_WP_VERSION: 0x0A,\n  SYSTEM_TYPE_ID: 0x0B,\n  HW_NETWORK_ID: 0x0C,\n  PRIMARY_MAC: 0x0D,\n  SECONDARY_MAC: 0x0E,\n  HW_NETWORK_FAMILY: 0x0F\n};\n/**\n * Enum for Hub Property Operations\n * @readonly\n * @enum {number}\n */\nvar BoostHubPropertyOperation = {\n  SET: 0x01,\n  ENABLE_UPDATES: 0x02,\n  DISABLE_UPDATES: 0x03,\n  RESET: 0x04,\n  REQUEST_UPDATE: 0x05,\n  UPDATE: 0x06\n};\n/**\n * Enum for Motor Subcommands (for 0x81)\n * @readonly\n * @enum {number}\n */\nvar BoostOutputSubCommand = {\n  START_POWER: 0x01,\n  START_POWER_PAIR: 0x02,\n  SET_ACC_TIME: 0x05,\n  SET_DEC_TIME: 0x06,\n  START_SPEED: 0x07,\n  START_SPEED_PAIR: 0x08,\n  START_SPEED_FOR_TIME: 0x09,\n  START_SPEED_FOR_TIME_PAIR: 0x0A,\n  START_SPEED_FOR_DEGREES: 0x0B,\n  START_SPEED_FOR_DEGREES_PAIR: 0x0C,\n  GO_TO_ABS_POSITION: 0x0D,\n  GO_TO_ABS_POSITION_PAIR: 0x0E,\n  PRESET_ENCODER: 0x14,\n  WRITE_DIRECT_MODE_DATA: 0x51\n};\n/**\n * Enum for Startup/Completion information for an output command.\n * Startup and completion bytes must be OR'ed to be combined to a single byte.\n * @readonly\n * @enum {number}\n */\nvar BoostOutputExecution = {\n  \n  BUFFER_IF_NECESSARY: 0x00,\n  EXECUTE_IMMEDIATELY: 0x10,\n  \n  NO_ACTION: 0x00,\n  COMMAND_FEEDBACK: 0x01\n};\n/**\n * Enum for Boost Motor end states\n * @readonly\n * @enum {number}\n */\nvar BoostMotorEndState = {\n  FLOAT: 0,\n  HOLD: 126,\n  BRAKE: 127\n};\n/**\n * Enum for Boost Motor acceleration/deceleration profiles\n * @readyonly\n * @enum {number}\n */\nvar BoostMotorProfile = {\n  DO_NOT_USE: 0x00,\n  ACCELERATION: 0x01,\n  DECELERATION: 0x02\n};\n/**\n * Enum for when Boost IO's are attached/detached\n * @readonly\n * @enum {number}\n */\nvar BoostIOEvent = {\n  ATTACHED: 0x01,\n  DETACHED: 0x00,\n  ATTACHED_VIRTUAL: 0x02\n};\n/**\n * Enum for selected sensor modes.\n * @enum {number}\n */\nvar BoostMode = {\n  TILT: 0,\n  \n  LED: 1,\n  \n  COLOR: 0,\n  \n  MOTOR_SENSOR: 2,\n  \n  UNKNOWN: 0 \n};\n/**\n * Enum for Boost motor states.\n * @param {number}\n */\nvar BoostMotorState = {\n  OFF: 0,\n  ON_FOREVER: 1,\n  ON_FOR_TIME: 2,\n  ON_FOR_ROTATION: 3\n};\n/**\n * Helper function for converting a JavaScript number to an INT32-number\n * @param {number} number - a number\n * @return {array} - a 4-byte array of Int8-values representing an INT32-number\n */\nvar numberToInt32Array = function numberToInt32Array(number) {\n  var buffer = new ArrayBuffer(4);\n  var dataview = new DataView(buffer);\n  dataview.setInt32(0, number);\n  return [dataview.getInt8(3), dataview.getInt8(2), dataview.getInt8(1), dataview.getInt8(0)];\n};\n/**\n * Helper function for converting a regular array to a Little Endian INT32-value\n * @param {Array} array - an array containing UInt8-values\n * @return {number} - a number\n */\nvar int32ArrayToNumber = function int32ArrayToNumber(array) {\n  var i = Uint8Array.from(array);\n  var d = new DataView(i.buffer);\n  return d.getInt32(0, true);\n};\n/**\n * Manage power, direction, position, and timers for one Boost motor.\n */\nvar BoostMotor = function () {\n \n  function BoostMotor(parent, index) {\n    _classCallCheck(this, BoostMotor);\n   \n    this._parent = parent;\n   \n    this._index = index;\n   \n    this._direction = 1;\n   \n    this._power = 50;\n   \n    this._position = 0;\n   \n    this._status = BoostMotorState.OFF;\n   \n    this._pendingDurationTimeoutId = null;\n   \n    this._pendingDurationTimeoutStartTime = null;\n   \n    this._pendingDurationTimeoutDelay = null;\n   \n    this._pendingRotationDestination = null;\n   \n    this._pendingRotationPromise = null;\n    this.turnOff = this.turnOff.bind(this);\n  }\n \n  _createClass(BoostMotor, [{\n    key: \"_turnOn\",\n   \n    value: function _turnOn() {\n      var cmd = this._parent.generateOutputCommand(this._index, BoostOutputExecution.EXECUTE_IMMEDIATELY, BoostOutputSubCommand.START_SPEED, [this.power * this.direction, MathUtil.clamp(this.power + BoostMotorMaxPowerAdd, 0, 100), BoostMotorProfile.DO_NOT_USE]);\n      this._parent.send(BoostBLE.characteristic, cmd);\n    }\n   \n  }, {\n    key: \"turnOnForever\",\n    value: function turnOnForever() {\n      this.status = BoostMotorState.ON_FOREVER;\n      this._turnOn();\n    }\n   \n  }, {\n    key: \"turnOnFor\",\n    value: function turnOnFor(milliseconds) {\n      milliseconds = Math.max(0, milliseconds);\n      this.status = BoostMotorState.ON_FOR_TIME;\n      this._turnOn();\n      this._setNewDurationTimeout(this.turnOff, milliseconds);\n    }\n   \n  }, {\n    key: \"turnOnForDegrees\",\n    value: function turnOnForDegrees(degrees, direction) {\n      degrees = Math.max(0, degrees);\n      var cmd = this._parent.generateOutputCommand(this._index, BoostOutputExecution.EXECUTE_IMMEDIATELY ^ BoostOutputExecution.COMMAND_FEEDBACK, BoostOutputSubCommand.START_SPEED_FOR_DEGREES, [].concat(_toConsumableArray(numberToInt32Array(degrees)), [this.power * this.direction * direction, MathUtil.clamp(this.power + BoostMotorMaxPowerAdd, 0, 100), BoostMotorEndState.BRAKE, BoostMotorProfile.DO_NOT_USE]));\n      this.status = BoostMotorState.ON_FOR_ROTATION;\n      this._pendingRotationDestination = this.position + degrees * this.direction * direction;\n      this._parent.send(BoostBLE.characteristic, cmd);\n    }\n   \n  }, {\n    key: \"turnOff\",\n    value: function turnOff() {\n      var useLimiter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var cmd = this._parent.generateOutputCommand(this._index, BoostOutputExecution.EXECUTE_IMMEDIATELY, BoostOutputSubCommand.START_POWER, [BoostMotorEndState.FLOAT]);\n      this.status = BoostMotorState.OFF;\n      this._parent.send(BoostBLE.characteristic, cmd, useLimiter);\n    }\n   \n  }, {\n    key: \"_clearDurationTimeout\",\n    value: function _clearDurationTimeout() {\n      if (this._pendingDurationTimeoutId !== null) {\n        clearTimeout(this._pendingDurationTimeoutId);\n        this._pendingDurationTimeoutId = null;\n        this._pendingDurationTimeoutStartTime = null;\n        this._pendingDurationTimeoutDelay = null;\n      }\n    }\n   \n  }, {\n    key: \"_setNewDurationTimeout\",\n    value: function _setNewDurationTimeout(callback, delay) {\n      var _this = this;\n      this._clearDurationTimeout();\n      var timeoutID = setTimeout(function () {\n        if (_this._pendingDurationTimeoutId === timeoutID) {\n          _this._pendingDurationTimeoutId = null;\n          _this._pendingDurationTimeoutStartTime = null;\n          _this._pendingDurationTimeoutDelay = null;\n        }\n        callback();\n      }, delay);\n      this._pendingDurationTimeoutId = timeoutID;\n      this._pendingDurationTimeoutStartTime = Date.now();\n      this._pendingDurationTimeoutDelay = delay;\n    }\n   \n  }, {\n    key: \"_clearRotationState\",\n    value: function _clearRotationState() {\n      if (this._pendingRotationPromise !== null) {\n        this._pendingRotationPromise();\n        this._pendingRotationPromise = null;\n      }\n      this._pendingRotationDestination = null;\n    }\n  }, {\n    key: \"direction\",\n    get: function get() {\n      return this._direction;\n    }\n   \n    ,\n    set: function set(value) {\n      if (value < 0) {\n        this._direction = -1;\n      } else {\n        this._direction = 1;\n      }\n    }\n   \n  }, {\n    key: \"power\",\n    get: function get() {\n      return this._power;\n    }\n   \n    ,\n    set: function set(value) {\n     \n      if (value === 0) {\n        this._power = 0;\n      } else {\n        this._power = MathUtil.scale(value, 1, 100, 10, 100);\n      }\n    }\n   \n  }, {\n    key: \"position\",\n    get: function get() {\n      return this._position;\n    }\n   \n    ,\n    set: function set(value) {\n      this._position = value;\n    }\n   \n  }, {\n    key: \"status\",\n    get: function get() {\n      return this._status;\n    }\n   \n    ,\n    set: function set(value) {\n      this._clearRotationState();\n      this._clearDurationTimeout();\n      this._status = value;\n    }\n   \n  }, {\n    key: \"pendingDurationTimeoutStartTime\",\n    get: function get() {\n      return this._pendingDurationTimeoutStartTime;\n    }\n   \n  }, {\n    key: \"pendingDurationTimeoutDelay\",\n    get: function get() {\n      return this._pendingDurationTimeoutDelay;\n    }\n   \n  }, {\n    key: \"pendingRotationDestination\",\n    get: function get() {\n      return this._pendingRotationDestination;\n    }\n   \n  }, {\n    key: \"pendingRotationPromise\",\n    get: function get() {\n      return this._pendingRotationPromise;\n    }\n   \n    ,\n    set: function set(func) {\n      this._pendingRotationPromise = func;\n    }\n  }]);\n  return BoostMotor;\n}();\n/**\n * Manage communication with a Boost peripheral over a Bluetooth Low Energy client socket.\n */\nvar Boost = function () {\n  function Boost(runtime, extensionId) {\n    _classCallCheck(this, Boost);\n   \n    this._runtime = runtime;\n    this._runtime.on('PROJECT_STOP_ALL', this.stopAll.bind(this));\n   \n    this._extensionId = extensionId;\n   \n    this._ports = [];\n   \n    this._motors = [];\n   \n    this._sensors = {\n      tiltX: 0,\n      tiltY: 0,\n      color: BoostColor.NONE,\n      previousColor: BoostColor.NONE\n    };\n   \n    this._colorSamples = [];\n   \n    this._ble = null;\n    this._runtime.registerPeripheralExtension(extensionId, this);\n   \n    this._rateLimiter = new RateLimiter(BoostBLE.sendRateMax);\n   \n    this._pingDeviceId = null;\n    this.reset = this.reset.bind(this);\n    this._onConnect = this._onConnect.bind(this);\n    this._onMessage = this._onMessage.bind(this);\n    this._pingDevice = this._pingDevice.bind(this);\n  }\n \n  _createClass(Boost, [{\n    key: \"boostColorForIndex\",\n   \n    value: function boostColorForIndex(index) {\n      var colorForIndex = Object.keys(BoostColorIndex).find(function (key) {\n        return BoostColorIndex[key] === index;\n      });\n      return colorForIndex || BoostColor.NONE;\n    }\n   \n  }, {\n    key: \"motor\",\n    value: function motor(index) {\n      return this._motors[index];\n    }\n   \n  }, {\n    key: \"stopAllMotors\",\n    value: function stopAllMotors() {\n      this._motors.forEach(function (motor) {\n        if (motor) {\n          \n          \n          \n          motor.turnOff(false);\n        }\n      });\n    }\n   \n  }, {\n    key: \"setLED\",\n    value: function setLED(inputRGB) {\n      var rgb = [inputRGB >> 16 & 0x000000FF, inputRGB >> 8 & 0x000000FF, inputRGB & 0x000000FF];\n      var cmd = this.generateOutputCommand(this._ports.indexOf(BoostIO.LED), BoostOutputExecution.EXECUTE_IMMEDIATELY ^ BoostOutputExecution.COMMAND_FEEDBACK, BoostOutputSubCommand.WRITE_DIRECT_MODE_DATA, [BoostMode.LED].concat(rgb));\n      return this.send(BoostBLE.characteristic, cmd);\n    }\n   \n  }, {\n    key: \"setLEDMode\",\n    value: function setLEDMode() {\n      var cmd = this.generateInputCommand(this._ports.indexOf(BoostIO.LED), BoostMode.LED, 0, false);\n      return this.send(BoostBLE.characteristic, cmd);\n    }\n   \n  }, {\n    key: \"stopAll\",\n    value: function stopAll() {\n      if (!this.isConnected()) return;\n      this.stopAllMotors();\n    }\n   \n  }, {\n    key: \"scan\",\n    value: function scan() {\n      if (this._ble) {\n        this._ble.disconnect();\n      }\n      this._ble = new BLE(this._runtime, this._extensionId, {\n        filters: [{\n          services: [BoostBLE.service],\n          manufacturerData: {\n            0x0397: {\n              dataPrefix: [0x00, 0x40],\n              mask: [0x00, 0xFF]\n            }\n          }\n        }],\n        optionalServices: []\n      }, this._onConnect, this.reset);\n    }\n   \n  }, {\n    key: \"connect\",\n    value: function connect(id) {\n      if (this._ble) {\n        this._ble.connectPeripheral(id);\n      }\n    }\n   \n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      if (this._ble) {\n        this._ble.disconnect();\n      }\n      this.reset();\n    }\n   \n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this._ports = [];\n      this._motors = [];\n      this._sensors = {\n        tiltX: 0,\n        tiltY: 0,\n        color: BoostColor.NONE,\n        previousColor: BoostColor.NONE\n      };\n      if (this._pingDeviceId) {\n        window.clearInterval(this._pingDeviceId);\n        this._pingDeviceId = null;\n      }\n    }\n   \n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      var connected = false;\n      if (this._ble) {\n        connected = this._ble.isConnected();\n      }\n      return connected;\n    }\n   \n  }, {\n    key: \"send\",\n    value: function send(uuid, message) {\n      var useLimiter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      if (!this.isConnected()) return Promise.resolve();\n      if (useLimiter) {\n        if (!this._rateLimiter.okayToSend()) return Promise.resolve();\n      }\n      return this._ble.write(BoostBLE.service, uuid, Base64Util.uint8ArrayToBase64(message), 'base64');\n    }\n   \n  }, {\n    key: \"generateOutputCommand\",\n    value: function generateOutputCommand(portID, execution, subCommand, payload) {\n      var hubID = 0x00;\n      var command = [hubID, BoostMessage.OUTPUT, portID, execution, subCommand].concat(_toConsumableArray(payload));\n      command.unshift(command.length + 1); \n      return command;\n    }\n   \n  }, {\n    key: \"generateInputCommand\",\n    value: function generateInputCommand(portID, mode, delta, enableNotifications) {\n      var command = [0x00, \n      BoostMessage.PORT_INPUT_FORMAT_SETUP_SINGLE, portID, mode].concat(numberToInt32Array(delta)).concat([enableNotifications]);\n      command.unshift(command.length + 1); \n      return command;\n    }\n   \n  }, {\n    key: \"_onConnect\",\n    value: function _onConnect() {\n      var _this2 = this;\n      this._ble.startNotifications(BoostBLE.service, BoostBLE.characteristic, this._onMessage);\n      this._pingDeviceId = window.setInterval(this._pingDevice, BoostPingInterval); \n      setTimeout(function () {\n        var command = [0x00, \n        BoostMessage.HUB_PROPERTIES, BoostHubProperty.FW_VERSION, BoostHubPropertyOperation.REQUEST_UPDATE];\n        command.unshift(command.length + 1);\n        _this2.send(BoostBLE.characteristic, command, false);\n      }, 500);\n    }\n   \n  }, {\n    key: \"_onMessage\",\n    value: function _onMessage(base64) {\n      var data = Base64Util.base64ToUint8Array(base64);\n     \n      var messageType = data[2];\n      var portID = data[3];\n      switch (messageType) {\n        case BoostMessage.HUB_PROPERTIES:\n          {\n            var property = data[3];\n            switch (property) {\n              case BoostHubProperty.FW_VERSION:\n                {\n                  \n                  var fwVersion10000224 = int32ArrayToNumber([0x24, 0x02, 0x00, 0x10]);\n                  var fwHub = int32ArrayToNumber(data.slice(5, data.length));\n                  if (fwHub < fwVersion10000224) {\n                    BoostPort = BoostPort10000223OrOlder;\n                    log.info('Move Hub firmware older than version 1.0.00.0224 detected. Using old port mapping.');\n                  } else {\n                    BoostPort = BoostPort10000224OrNewer;\n                  }\n                  break;\n                }\n            }\n            break;\n          }\n        case BoostMessage.HUB_ATTACHED_IO:\n          {\n            \n            var event = data[4];\n            var typeId = data[5];\n            switch (event) {\n              case BoostIOEvent.ATTACHED:\n                this._registerSensorOrMotor(portID, typeId);\n                break;\n              case BoostIOEvent.DETACHED:\n                this._clearPort(portID);\n                break;\n              case BoostIOEvent.ATTACHED_VIRTUAL:\n              default:\n            }\n            break;\n          }\n        case BoostMessage.PORT_VALUE:\n          {\n            var type = this._ports[portID];\n            switch (type) {\n              case BoostIO.TILT:\n                this._sensors.tiltX = data[4];\n                this._sensors.tiltY = data[5];\n                break;\n              case BoostIO.COLOR:\n                this._colorSamples.unshift(data[4]);\n                if (this._colorSamples.length > BoostColorSampleSize) {\n                  this._colorSamples.pop();\n                  if (this._colorSamples.every(function (v, i, arr) {\n                    return v === arr[0];\n                  })) {\n                    this._sensors.previousColor = this._sensors.color;\n                    this._sensors.color = this.boostColorForIndex(this._colorSamples[0]);\n                  } else {\n                    this._sensors.color = BoostColor.NONE;\n                  }\n                } else {\n                  this._sensors.color = BoostColor.NONE;\n                }\n                break;\n              case BoostIO.MOTOREXT:\n              case BoostIO.MOTORINT:\n                this.motor(portID).position = int32ArrayToNumber(data.slice(4, 8));\n                break;\n              case BoostIO.CURRENT:\n              case BoostIO.VOLTAGE:\n              case BoostIO.LED:\n                break;\n              default:\n                log.warn(\"Unknown sensor value! Type: \".concat(type));\n            }\n            break;\n          }\n        case BoostMessage.PORT_FEEDBACK:\n          {\n            var feedback = data[4];\n            var motor = this.motor(portID);\n            if (motor) {\n              \n              var isBusy = feedback & BoostPortFeedback.IN_PROGRESS;\n              var commandCompleted = feedback & (BoostPortFeedback.COMPLETED ^ BoostPortFeedback.DISCARDED);\n              if (!isBusy && commandCompleted) {\n                if (motor.status === BoostMotorState.ON_FOR_ROTATION) {\n                  motor.status = BoostMotorState.OFF;\n                }\n              }\n            }\n            break;\n          }\n        case BoostMessage.ERROR:\n          log.warn(\"Error reported by hub: \".concat(data));\n          break;\n      }\n    }\n   \n  }, {\n    key: \"_pingDevice\",\n    value: function _pingDevice() {\n      this._ble.read(BoostBLE.service, BoostBLE.characteristic, false);\n    }\n   \n  }, {\n    key: \"_registerSensorOrMotor\",\n    value: function _registerSensorOrMotor(portID, type) {\n      \n      this._ports[portID] = type; \n      if (type === BoostIO.MOTORINT || type === BoostIO.MOTOREXT) {\n        this._motors[portID] = new BoostMotor(this, portID);\n      } \n      var mode = null;\n      var delta = 1;\n      switch (type) {\n        case BoostIO.MOTORINT:\n        case BoostIO.MOTOREXT:\n          mode = BoostMode.MOTOR_SENSOR;\n          break;\n        case BoostIO.COLOR:\n          mode = BoostMode.COLOR;\n          delta = 0;\n          break;\n        case BoostIO.LED:\n          mode = BoostMode.LED;\n         \n          this.setLEDMode();\n          this.setLED(0x0000FF);\n          break;\n        case BoostIO.TILT:\n          mode = BoostMode.TILT;\n          break;\n        default:\n          mode = BoostMode.UNKNOWN;\n      }\n      var cmd = this.generateInputCommand(portID, mode, delta, true \n      );\n      this.send(BoostBLE.characteristic, cmd);\n    }\n   \n  }, {\n    key: \"_clearPort\",\n    value: function _clearPort(portID) {\n      var type = this._ports[portID];\n      if (type === BoostIO.TILT) {\n        this._sensors.tiltX = this._sensors.tiltY = 0;\n      }\n      if (type === BoostIO.COLOR) {\n        this._sensors.color = BoostColor.NONE;\n      }\n      this._ports[portID] = 'none';\n      this._motors[portID] = null;\n    }\n  }, {\n    key: \"tiltX\",\n    get: function get() {\n      return this._sensors.tiltX;\n    }\n   \n  }, {\n    key: \"tiltY\",\n    get: function get() {\n      return this._sensors.tiltY;\n    }\n   \n  }, {\n    key: \"color\",\n    get: function get() {\n      return this._sensors.color;\n    }\n   \n  }, {\n    key: \"previousColor\",\n    get: function get() {\n      return this._sensors.previousColor;\n    }\n  }]);\n  return Boost;\n}();\n/**\n * Enum for motor specification.\n * @readonly\n * @enum {string}\n */\nvar BoostMotorLabel = {\n  A: 'A',\n  B: 'B',\n  C: 'C',\n  D: 'D',\n  AB: 'AB',\n  ALL: 'ABCD'\n};\n/**\n * Enum for motor direction specification.\n * @readonly\n * @enum {string}\n */\nvar BoostMotorDirection = {\n  FORWARD: 'this way',\n  BACKWARD: 'that way',\n  REVERSE: 'reverse'\n};\n/**\n * Enum for tilt sensor direction.\n * @readonly\n * @enum {string}\n */\nvar BoostTiltDirection = {\n  UP: 'up',\n  DOWN: 'down',\n  LEFT: 'left',\n  RIGHT: 'right',\n  ANY: 'any'\n};\n/**\n * Scratch 3.0 blocks to interact with a LEGO Boost peripheral.\n */\nvar Scratch3BoostBlocks = function () {\n  _createClass(Scratch3BoostBlocks, null, [{\n    key: \"EXTENSION_ID\",\n   \n    get: function get() {\n      return 'boost';\n    }\n   \n  }, {\n    key: \"TILT_THRESHOLD\",\n    get: function get() {\n      return 15;\n    }\n   \n  }]);\n  function Scratch3BoostBlocks(runtime) {\n    _classCallCheck(this, Scratch3BoostBlocks);\n   \n    this.runtime = runtime; \n    this._peripheral = new Boost(this.runtime, Scratch3BoostBlocks.EXTENSION_ID);\n  }\n \n  _createClass(Scratch3BoostBlocks, [{\n    key: \"getInfo\",\n    value: function getInfo() {\n      return {\n        id: Scratch3BoostBlocks.EXTENSION_ID,\n        name: 'BOOST',\n        blockIconURI: iconURI,\n        showStatusButton: true,\n        blocks: [{\n          opcode: 'motorOnFor',\n          text: formatMessage({\n            id: 'boost.motorOnFor',\n            default: 'turn motor [MOTOR_ID] for [DURATION] seconds',\n            description: 'turn a motor on for some time'\n          }),\n          blockType: BlockType.COMMAND,\n          arguments: {\n            MOTOR_ID: {\n              type: ArgumentType.STRING,\n              menu: 'MOTOR_ID',\n              defaultValue: BoostMotorLabel.A\n            },\n            DURATION: {\n              type: ArgumentType.NUMBER,\n              defaultValue: 1\n            }\n          }\n        }, {\n          opcode: 'motorOnForRotation',\n          text: formatMessage({\n            id: 'boost.motorOnForRotation',\n            default: 'turn motor [MOTOR_ID] for [ROTATION] rotations',\n            description: 'turn a motor on for rotation'\n          }),\n          blockType: BlockType.COMMAND,\n          arguments: {\n            MOTOR_ID: {\n              type: ArgumentType.STRING,\n              menu: 'MOTOR_ID',\n              defaultValue: BoostMotorLabel.A\n            },\n            ROTATION: {\n              type: ArgumentType.NUMBER,\n              defaultValue: 1\n            }\n          }\n        }, {\n          opcode: 'motorOn',\n          text: formatMessage({\n            id: 'boost.motorOn',\n            default: 'turn motor [MOTOR_ID] on',\n            description: 'turn a motor on indefinitely'\n          }),\n          blockType: BlockType.COMMAND,\n          arguments: {\n            MOTOR_ID: {\n              type: ArgumentType.STRING,\n              menu: 'MOTOR_ID',\n              defaultValue: BoostMotorLabel.A\n            }\n          }\n        }, {\n          opcode: 'motorOff',\n          text: formatMessage({\n            id: 'boost.motorOff',\n            default: 'turn motor [MOTOR_ID] off',\n            description: 'turn a motor off'\n          }),\n          blockType: BlockType.COMMAND,\n          arguments: {\n            MOTOR_ID: {\n              type: ArgumentType.STRING,\n              menu: 'MOTOR_ID',\n              defaultValue: BoostMotorLabel.A\n            }\n          }\n        }, {\n          opcode: 'setMotorPower',\n          text: formatMessage({\n            id: 'boost.setMotorPower',\n            default: 'set motor [MOTOR_ID] speed to [POWER] %',\n            description: 'set the motor\\'s speed without turning it on'\n          }),\n          blockType: BlockType.COMMAND,\n          arguments: {\n            MOTOR_ID: {\n              type: ArgumentType.STRING,\n              menu: 'MOTOR_ID',\n              defaultValue: BoostMotorLabel.ALL\n            },\n            POWER: {\n              type: ArgumentType.NUMBER,\n              defaultValue: 100\n            }\n          }\n        }, {\n          opcode: 'setMotorDirection',\n          text: formatMessage({\n            id: 'boost.setMotorDirection',\n            default: 'set motor [MOTOR_ID] direction [MOTOR_DIRECTION]',\n            description: 'set the motor\\'s turn direction without turning it on'\n          }),\n          blockType: BlockType.COMMAND,\n          arguments: {\n            MOTOR_ID: {\n              type: ArgumentType.STRING,\n              menu: 'MOTOR_ID',\n              defaultValue: BoostMotorLabel.A\n            },\n            MOTOR_DIRECTION: {\n              type: ArgumentType.STRING,\n              menu: 'MOTOR_DIRECTION',\n              defaultValue: BoostMotorDirection.FORWARD\n            }\n          }\n        }, {\n          opcode: 'getMotorPosition',\n          text: formatMessage({\n            id: 'boost.getMotorPosition',\n            default: 'motor [MOTOR_REPORTER_ID] position',\n            description: 'the position returned by the motor'\n          }),\n          blockType: BlockType.REPORTER,\n          arguments: {\n            MOTOR_REPORTER_ID: {\n              type: ArgumentType.STRING,\n              menu: 'MOTOR_REPORTER_ID',\n              defaultValue: BoostMotorLabel.A\n            }\n          }\n        }, {\n          opcode: 'whenColor',\n          text: formatMessage({\n            id: 'boost.whenColor',\n            default: 'when [COLOR] brick seen',\n            description: 'check for when color'\n          }),\n          blockType: BlockType.HAT,\n          arguments: {\n            COLOR: {\n              type: ArgumentType.STRING,\n              menu: 'COLOR',\n              defaultValue: BoostColor.ANY\n            }\n          }\n        }, {\n          opcode: 'seeingColor',\n          text: formatMessage({\n            id: 'boost.seeingColor',\n            default: 'seeing [COLOR] brick?',\n            description: 'is the color sensor seeing a certain color?'\n          }),\n          blockType: BlockType.BOOLEAN,\n          arguments: {\n            COLOR: {\n              type: ArgumentType.STRING,\n              menu: 'COLOR',\n              defaultValue: BoostColor.ANY\n            }\n          }\n        }, {\n          opcode: 'whenTilted',\n          text: formatMessage({\n            id: 'boost.whenTilted',\n            default: 'when tilted [TILT_DIRECTION_ANY]',\n            description: 'check when tilted in a certain direction'\n          }),\n          func: 'isTilted',\n          blockType: BlockType.HAT,\n          arguments: {\n            TILT_DIRECTION_ANY: {\n              type: ArgumentType.STRING,\n              menu: 'TILT_DIRECTION_ANY',\n              defaultValue: BoostTiltDirection.ANY\n            }\n          }\n        }, {\n          opcode: 'getTiltAngle',\n          text: formatMessage({\n            id: 'boost.getTiltAngle',\n            default: 'tilt angle [TILT_DIRECTION]',\n            description: 'the angle returned by the tilt sensor'\n          }),\n          blockType: BlockType.REPORTER,\n          arguments: {\n            TILT_DIRECTION: {\n              type: ArgumentType.STRING,\n              menu: 'TILT_DIRECTION',\n              defaultValue: BoostTiltDirection.UP\n            }\n          }\n        }, {\n          opcode: 'setLightHue',\n          text: formatMessage({\n            id: 'boost.setLightHue',\n            default: 'set light color to [HUE]',\n            description: 'set the LED color'\n          }),\n          blockType: BlockType.COMMAND,\n          arguments: {\n            HUE: {\n              type: ArgumentType.NUMBER,\n              defaultValue: 50\n            }\n          }\n        }],\n        menus: {\n          MOTOR_ID: {\n            acceptReporters: true,\n            items: [{\n              text: 'A',\n              value: BoostMotorLabel.A\n            }, {\n              text: 'B',\n              value: BoostMotorLabel.B\n            }, {\n              text: 'C',\n              value: BoostMotorLabel.C\n            }, {\n              text: 'D',\n              value: BoostMotorLabel.D\n            }, {\n              text: 'AB',\n              value: BoostMotorLabel.AB\n            }, {\n              text: 'ABCD',\n              value: BoostMotorLabel.ALL\n            }]\n          },\n          MOTOR_REPORTER_ID: {\n            acceptReporters: true,\n            items: [{\n              text: 'A',\n              value: BoostMotorLabel.A\n            }, {\n              text: 'B',\n              value: BoostMotorLabel.B\n            }, {\n              text: 'C',\n              value: BoostMotorLabel.C\n            }, {\n              text: 'D',\n              value: BoostMotorLabel.D\n            }]\n          },\n          MOTOR_DIRECTION: {\n            acceptReporters: true,\n            items: [{\n              text: formatMessage({\n                id: 'boost.motorDirection.forward',\n                default: 'this way',\n                description: 'label for forward element in motor direction menu for LEGO Boost extension'\n              }),\n              value: BoostMotorDirection.FORWARD\n            }, {\n              text: formatMessage({\n                id: 'boost.motorDirection.backward',\n                default: 'that way',\n                description: 'label for backward element in motor direction menu for LEGO Boost extension'\n              }),\n              value: BoostMotorDirection.BACKWARD\n            }, {\n              text: formatMessage({\n                id: 'boost.motorDirection.reverse',\n                default: 'reverse',\n                description: 'label for reverse element in motor direction menu for LEGO Boost extension'\n              }),\n              value: BoostMotorDirection.REVERSE\n            }]\n          },\n          TILT_DIRECTION: {\n            acceptReporters: true,\n            items: [{\n              text: formatMessage({\n                id: 'boost.tiltDirection.up',\n                default: 'up',\n                description: 'label for up element in tilt direction menu for LEGO Boost extension'\n              }),\n              value: BoostTiltDirection.UP\n            }, {\n              text: formatMessage({\n                id: 'boost.tiltDirection.down',\n                default: 'down',\n                description: 'label for down element in tilt direction menu for LEGO Boost extension'\n              }),\n              value: BoostTiltDirection.DOWN\n            }, {\n              text: formatMessage({\n                id: 'boost.tiltDirection.left',\n                default: 'left',\n                description: 'label for left element in tilt direction menu for LEGO Boost extension'\n              }),\n              value: BoostTiltDirection.LEFT\n            }, {\n              text: formatMessage({\n                id: 'boost.tiltDirection.right',\n                default: 'right',\n                description: 'label for right element in tilt direction menu for LEGO Boost extension'\n              }),\n              value: BoostTiltDirection.RIGHT\n            }]\n          },\n          TILT_DIRECTION_ANY: {\n            acceptReporters: true,\n            items: [{\n              text: formatMessage({\n                id: 'boost.tiltDirection.up',\n                default: 'up'\n              }),\n              value: BoostTiltDirection.UP\n            }, {\n              text: formatMessage({\n                id: 'boost.tiltDirection.down',\n                default: 'down'\n              }),\n              value: BoostTiltDirection.DOWN\n            }, {\n              text: formatMessage({\n                id: 'boost.tiltDirection.left',\n                default: 'left'\n              }),\n              value: BoostTiltDirection.LEFT\n            }, {\n              text: formatMessage({\n                id: 'boost.tiltDirection.right',\n                default: 'right'\n              }),\n              value: BoostTiltDirection.RIGHT\n            }, {\n              text: formatMessage({\n                id: 'boost.tiltDirection.any',\n                default: 'any',\n                description: 'label for any element in tilt direction menu for LEGO Boost extension'\n              }),\n              value: BoostTiltDirection.ANY\n            }]\n          },\n          COLOR: {\n            acceptReporters: true,\n            items: [{\n              text: formatMessage({\n                id: 'boost.color.red',\n                default: 'red',\n                description: 'the color red'\n              }),\n              value: BoostColor.RED\n            }, {\n              text: formatMessage({\n                id: 'boost.color.blue',\n                default: 'blue',\n                description: 'the color blue'\n              }),\n              value: BoostColor.BLUE\n            }, {\n              text: formatMessage({\n                id: 'boost.color.green',\n                default: 'green',\n                description: 'the color green'\n              }),\n              value: BoostColor.GREEN\n            }, {\n              text: formatMessage({\n                id: 'boost.color.yellow',\n                default: 'yellow',\n                description: 'the color yellow'\n              }),\n              value: BoostColor.YELLOW\n            }, {\n              text: formatMessage({\n                id: 'boost.color.white',\n                default: 'white',\n                desription: 'the color white'\n              }),\n              value: BoostColor.WHITE\n            }, {\n              text: formatMessage({\n                id: 'boost.color.black',\n                default: 'black',\n                description: 'the color black'\n              }),\n              value: BoostColor.BLACK\n            }, {\n              text: formatMessage({\n                id: 'boost.color.any',\n                default: 'any color',\n                description: 'any color'\n              }),\n              value: BoostColor.ANY\n            }]\n          }\n        }\n      };\n    }\n   \n  }, {\n    key: \"motorOnFor\",\n    value: function motorOnFor(args) {\n      var _this3 = this;\n      \n      var durationMS = Cast.toNumber(args.DURATION) * 1000;\n      durationMS = MathUtil.clamp(durationMS, 0, 15000);\n      return new Promise(function (resolve) {\n        _this3._forEachMotor(args.MOTOR_ID, function (motorIndex) {\n          var motor = _this3._peripheral.motor(motorIndex);\n          if (motor) motor.turnOnFor(durationMS);\n        }); \n        setTimeout(resolve, durationMS);\n      });\n    }\n   \n  }, {\n    key: \"motorOnForRotation\",\n    value: function motorOnForRotation(args) {\n      var _this4 = this;\n      \n      var degrees = Cast.toNumber(args.ROTATION) * 360; \n      var sign = Math.sign(degrees);\n      degrees = Math.abs(MathUtil.clamp(degrees, -360000, 360000));\n      var motors = [];\n      this._forEachMotor(args.MOTOR_ID, function (motorIndex) {\n        motors.push(motorIndex);\n      });\n     \n      var promises = motors.map(function (portID) {\n        var motor = _this4._peripheral.motor(portID);\n        if (motor) {\n          \n          if (motor.power === 0) return Promise.resolve();\n          return new Promise(function (resolve) {\n            motor.turnOnForDegrees(degrees, sign);\n            motor.pendingRotationPromise = resolve;\n          });\n        }\n        return null;\n      });\n     \n      return Promise.all(promises).then(function () {});\n    }\n   \n  }, {\n    key: \"motorOn\",\n    value: function motorOn(args) {\n      var _this5 = this;\n      \n      this._forEachMotor(args.MOTOR_ID, function (motorIndex) {\n        var motor = _this5._peripheral.motor(motorIndex);\n        if (motor) motor.turnOnForever();\n      });\n      return new Promise(function (resolve) {\n        window.setTimeout(function () {\n          resolve();\n        }, BoostBLE.sendInterval);\n      });\n    }\n   \n  }, {\n    key: \"motorOff\",\n    value: function motorOff(args) {\n      var _this6 = this;\n      \n      this._forEachMotor(args.MOTOR_ID, function (motorIndex) {\n        var motor = _this6._peripheral.motor(motorIndex);\n        if (motor) motor.turnOff();\n      });\n      return new Promise(function (resolve) {\n        window.setTimeout(function () {\n          resolve();\n        }, BoostBLE.sendInterval);\n      });\n    }\n   \n  }, {\n    key: \"setMotorPower\",\n    value: function setMotorPower(args) {\n      var _this7 = this;\n      \n      this._forEachMotor(args.MOTOR_ID, function (motorIndex) {\n        var motor = _this7._peripheral.motor(motorIndex);\n        if (motor) {\n          motor.power = MathUtil.clamp(Cast.toNumber(args.POWER), 0, 100);\n          switch (motor.status) {\n            case BoostMotorState.ON_FOREVER:\n              motor.turnOnForever();\n              break;\n            case BoostMotorState.ON_FOR_TIME:\n              motor.turnOnFor(motor.pendingDurationTimeoutStartTime + motor.pendingDurationTimeoutDelay - Date.now());\n              break;\n          }\n        }\n      });\n      return new Promise(function (resolve) {\n        window.setTimeout(function () {\n          resolve();\n        }, BoostBLE.sendInterval);\n      });\n    }\n   \n  }, {\n    key: \"setMotorDirection\",\n    value: function setMotorDirection(args) {\n      var _this8 = this;\n      \n      this._forEachMotor(args.MOTOR_ID, function (motorIndex) {\n        var motor = _this8._peripheral.motor(motorIndex);\n        if (motor) {\n          switch (args.MOTOR_DIRECTION) {\n            case BoostMotorDirection.FORWARD:\n              motor.direction = 1;\n              break;\n            case BoostMotorDirection.BACKWARD:\n              motor.direction = -1;\n              break;\n            case BoostMotorDirection.REVERSE:\n              motor.direction = -motor.direction;\n              break;\n            default:\n              log.warn(\"Unknown motor direction in setMotorDirection: \".concat(args.DIRECTION));\n              break;\n          } \n          if (motor) {\n            switch (motor.status) {\n              case BoostMotorState.ON_FOREVER:\n                motor.turnOnForever();\n                break;\n              case BoostMotorState.ON_FOR_TIME:\n                motor.turnOnFor(motor.pendingDurationTimeoutStartTime + motor.pendingDurationTimeoutDelay - Date.now());\n                break;\n            }\n          }\n        }\n      });\n      return new Promise(function (resolve) {\n        window.setTimeout(function () {\n          resolve();\n        }, BoostBLE.sendInterval);\n      });\n    }\n   \n  }, {\n    key: \"getMotorPosition\",\n    value: function getMotorPosition(args) {\n      var portID = null;\n      switch (args.MOTOR_REPORTER_ID) {\n        case BoostMotorLabel.A:\n          portID = BoostPort.A;\n          break;\n        case BoostMotorLabel.B:\n          portID = BoostPort.B;\n          break;\n        case BoostMotorLabel.C:\n          portID = BoostPort.C;\n          break;\n        case BoostMotorLabel.D:\n          portID = BoostPort.D;\n          break;\n        default:\n          log.warn('Asked for a motor position that doesnt exist!');\n          return false;\n      }\n      if (portID !== null && this._peripheral.motor(portID)) {\n        var val = this._peripheral.motor(portID).position; \n        \n        if (portID === BoostPort.A) {\n          val *= -1;\n        }\n        return MathUtil.wrapClamp(val, 0, 360);\n      }\n      return 0;\n    }\n   \n  }, {\n    key: \"_forEachMotor\",\n    value: function _forEachMotor(motorID, callback) {\n      var motors;\n      switch (motorID) {\n        case BoostMotorLabel.A:\n          motors = [BoostPort.A];\n          break;\n        case BoostMotorLabel.B:\n          motors = [BoostPort.B];\n          break;\n        case BoostMotorLabel.C:\n          motors = [BoostPort.C];\n          break;\n        case BoostMotorLabel.D:\n          motors = [BoostPort.D];\n          break;\n        case BoostMotorLabel.AB:\n          motors = [BoostPort.A, BoostPort.B];\n          break;\n        case BoostMotorLabel.ALL:\n          motors = [BoostPort.A, BoostPort.B, BoostPort.C, BoostPort.D];\n          break;\n        default:\n          log.warn(\"Invalid motor ID: \".concat(motorID));\n          motors = [];\n          break;\n      }\n      var _iterator = _createForOfIteratorHelper(motors),\n          _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var index = _step.value;\n          callback(index);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n   \n  }, {\n    key: \"whenTilted\",\n    value: function whenTilted(args) {\n      return this._isTilted(args.TILT_DIRECTION_ANY);\n    }\n   \n  }, {\n    key: \"isTilted\",\n    value: function isTilted(args) {\n      return this._isTilted(args.TILT_DIRECTION_ANY);\n    }\n   \n  }, {\n    key: \"getTiltAngle\",\n    value: function getTiltAngle(args) {\n      return this._getTiltAngle(args.TILT_DIRECTION);\n    }\n   \n  }, {\n    key: \"_isTilted\",\n    value: function _isTilted(direction) {\n      switch (direction) {\n        case BoostTiltDirection.ANY:\n          return Math.abs(this._peripheral.tiltX) >= Scratch3BoostBlocks.TILT_THRESHOLD || Math.abs(this._peripheral.tiltY) >= Scratch3BoostBlocks.TILT_THRESHOLD;\n        default:\n          return this._getTiltAngle(direction) >= Scratch3BoostBlocks.TILT_THRESHOLD;\n      }\n    }\n   \n  }, {\n    key: \"_getTiltAngle\",\n    value: function _getTiltAngle(direction) {\n      switch (direction) {\n        case BoostTiltDirection.UP:\n          return this._peripheral.tiltY > 90 ? 256 - this._peripheral.tiltY : -this._peripheral.tiltY;\n        case BoostTiltDirection.DOWN:\n          return this._peripheral.tiltY > 90 ? this._peripheral.tiltY - 256 : this._peripheral.tiltY;\n        case BoostTiltDirection.LEFT:\n          return this._peripheral.tiltX > 90 ? this._peripheral.tiltX - 256 : this._peripheral.tiltX;\n        case BoostTiltDirection.RIGHT:\n          return this._peripheral.tiltX > 90 ? 256 - this._peripheral.tiltX : -this._peripheral.tiltX;\n        default:\n          log.warn(\"Unknown tilt direction in _getTiltAngle: \".concat(direction));\n      }\n    }\n   \n  }, {\n    key: \"whenColor\",\n    value: function whenColor(args) {\n      if (args.COLOR === BoostColor.ANY) {\n        \n        \n        \n        \n        return this._peripheral.color !== BoostColor.NONE && this._peripheral.color !== this._peripheral.previousColor;\n      }\n      return args.COLOR === this._peripheral.color;\n    }\n   \n  }, {\n    key: \"seeingColor\",\n    value: function seeingColor(args) {\n      if (args.COLOR === BoostColor.ANY) {\n        return this._peripheral.color !== BoostColor.NONE;\n      }\n      return args.COLOR === this._peripheral.color;\n    }\n   \n  }, {\n    key: \"setLightHue\",\n    value: function setLightHue(args) {\n      \n      var inputHue = Cast.toNumber(args.HUE);\n      inputHue = MathUtil.wrapClamp(inputHue, 0, 100);\n      var hue = inputHue * 360 / 100;\n      var rgbObject = color.hsvToRgb({\n        h: hue,\n        s: 1,\n        v: 1\n      });\n      var rgbDecimal = color.rgbToDecimal(rgbObject);\n      this._peripheral._led = inputHue;\n      this._peripheral.setLED(rgbDecimal);\n      return new Promise(function (resolve) {\n        window.setTimeout(function () {\n          resolve();\n        }, BoostBLE.sendInterval);\n      });\n    }\n  }]);\n  return Scratch3BoostBlocks;\n}();\nmodule.exports = Scratch3BoostBlocks;\n })