/* 1302 */\n (function(module, exports, __webpack_require__) {\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nvar base64js = __webpack_require__(1303);\n/**\n * Adapts Scratch 2.0 bitmaps for use in scratch 3.0\n */\nvar BitmapAdapter = function () {\n \n  function BitmapAdapter(makeImage, makeCanvas) {\n    _classCallCheck(this, BitmapAdapter);\n    this._makeImage = makeImage ? makeImage : function () {\n      return new Image();\n    };\n    this._makeCanvas = makeCanvas ? makeCanvas : function () {\n      return document.createElement('canvas');\n    };\n  } \n  _createClass(BitmapAdapter, [{\n    key: \"resize\",\n    value: function resize(image, newWidth, newHeight) {\n      \n      \n      var stretchWidthCanvas = this._makeCanvas();\n      stretchWidthCanvas.width = newWidth;\n      stretchWidthCanvas.height = image.height;\n      var context = stretchWidthCanvas.getContext('2d',{willReadFrequently:true});\n      context.imageSmoothingEnabled = false;\n      context.drawImage(image, 0, 0, stretchWidthCanvas.width, stretchWidthCanvas.height);\n      var stretchHeightCanvas = this._makeCanvas();\n      stretchHeightCanvas.width = newWidth;\n      stretchHeightCanvas.height = newHeight;\n      context = stretchHeightCanvas.getContext('2d',{willReadFrequently:true});\n      context.imageSmoothingEnabled = false;\n      context.drawImage(stretchWidthCanvas, 0, 0, stretchHeightCanvas.width, stretchHeightCanvas.height);\n      return stretchHeightCanvas;\n    }\n   \n  }, {\n    key: \"convertResolution1Bitmap\",\n    value: function convertResolution1Bitmap(dataURI, callback) {\n      var _this = this;\n      var image = this._makeImage();\n      image.src = dataURI;\n      image.onload = function () {\n        callback(null, _this.resize(image, image.width * 2, image.height * 2).toDataURL());\n      };\n      image.onerror = function () {\n        callback('Image load failed');\n      };\n    }\n   \n  }, {\n    key: \"getResizedWidthHeight\",\n    value: function getResizedWidthHeight(oldWidth, oldHeight) {\n      var STAGE_WIDTH = 480;\n      var STAGE_HEIGHT = 360;\n      var STAGE_RATIO = STAGE_WIDTH / STAGE_HEIGHT; \n      \n      if (oldWidth <= STAGE_WIDTH && oldHeight <= STAGE_HEIGHT) {\n        return {\n          width: oldWidth * 2,\n          height: oldHeight * 2\n        };\n      } \n      \n      if (oldWidth <= STAGE_WIDTH * 2 && oldHeight <= STAGE_HEIGHT * 2) {\n        return {\n          width: oldWidth,\n          height: oldHeight\n        };\n      }\n      var imageRatio = oldWidth / oldHeight; \n      if (imageRatio >= STAGE_RATIO) {\n        \n        return {\n          width: STAGE_WIDTH * 2,\n          height: STAGE_WIDTH * 2 / imageRatio\n        };\n      } \n      \n      \n      \n      \n      \n      \n      \n      return {\n        width: STAGE_HEIGHT * 2 * imageRatio,\n        height: STAGE_HEIGHT * 2\n      };\n    }\n   \n  }, {\n    key: \"importBitmap\",\n    value: function importBitmap(fileData, fileType) {\n      var _this2 = this;\n      var dataURI = fileData;\n      if (fileData instanceof ArrayBuffer) {\n        dataURI = this.convertBinaryToDataURI(fileData, fileType);\n      }\n      return new Promise(function (resolve, reject) {\n        var image = _this2._makeImage();\n        image.src = dataURI;\n        image.onload = function () {\n          var newSize = _this2.getResizedWidthHeight(image.width, image.height);\n          if (newSize.width === image.width && newSize.height === image.height) {\n            \n            resolve(_this2.convertDataURIToBinary(dataURI));\n          } else {\n            var resizedDataURI = _this2.resize(image, newSize.width, newSize.height).toDataURL();\n            resolve(_this2.convertDataURIToBinary(resizedDataURI));\n          }\n        };\n        image.onerror = function () {\n          reject('Image load failed');\n        };\n      });\n    } \n    \n  }, {\n    key: \"convertDataURIToBinary\",\n    value: function convertDataURIToBinary(dataURI) {\n      var BASE64_MARKER = ';base64,';\n      var base64Index = dataURI.indexOf(BASE64_MARKER) + BASE64_MARKER.length;\n      var base64 = dataURI.substring(base64Index);\n      var raw = window.atob(base64);\n      var rawLength = raw.length;\n      var array = new Uint8Array(new ArrayBuffer(rawLength));\n      for (var i = 0; i < rawLength; i++) {\n        array[i] = raw.charCodeAt(i);\n      }\n      return array;\n    }\n  }, {\n    key: \"convertBinaryToDataURI\",\n    value: function convertBinaryToDataURI(arrayBuffer, contentType) {\n      return \"data:\".concat(contentType, \";base64,\").concat(base64js.fromByteArray(new Uint8Array(arrayBuffer)));\n    }\n  }]);\n  return BitmapAdapter;\n}();\nmodule.exports = BitmapAdapter;\n })