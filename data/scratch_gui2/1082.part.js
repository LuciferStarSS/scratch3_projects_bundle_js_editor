/* 1082 */\n (function(module, exports, __webpack_require__) {\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nvar MathUtil = __webpack_require__(62);\nvar Mouse = function () {\n  function Mouse(runtime) {\n    _classCallCheck(this, Mouse);\n    this._x = 0;\n    this._y = 0;\n    this._isDown = false;\n   \n    this.runtime = runtime;\n  }\n \n  _createClass(Mouse, [{\n    key: \"_activateClickHats\",\n    value: function _activateClickHats(target) {\n      \n      \n      \n      \n      \n      this.runtime.startHats('event_whenthisspriteclicked', null, target);\n      this.runtime.startHats('event_whenstageclicked', null, target);\n    }\n   \n  }, {\n    key: \"_pickTarget\",\n    value: function _pickTarget(x, y) {\n      if (this.runtime.renderer) {\n        var drawableID = this.runtime.renderer.pick(x, y);\n        for (var i = 0; i < this.runtime.targets.length; i++) {\n          var target = this.runtime.targets[i];\n          if (target.hasOwnProperty('drawableID') && target.drawableID === drawableID) {\n            return target;\n          }\n        }\n      } \n      return this.runtime.getTargetForStage();\n    }\n   \n  }, {\n    key: \"postData\",\n    value: function postData(data) {\n      if (data.x) {\n        this._clientX = data.x;\n        this._scratchX = Math.round(MathUtil.clamp(480 * (data.x / data.canvasWidth - 0.5), -240, 240));\n      }\n      if (data.y) {\n        this._clientY = data.y;\n        this._scratchY = Math.round(MathUtil.clamp(-360 * (data.y / data.canvasHeight - 0.5), -180, 180));\n      }\n      if (typeof data.isDown !== 'undefined') {\n        var previousDownState = this._isDown;\n        this._isDown = data.isDown; \n        if (previousDownState === this._isDown) return; \n        if (data.wasDragged) return; \n        if (!(data.x > 0 && data.x < data.canvasWidth && data.y > 0 && data.y < data.canvasHeight)) return;\n        var target = this._pickTarget(data.x, data.y);\n        var isNewMouseDown = !previousDownState && this._isDown;\n        var isNewMouseUp = previousDownState && !this._isDown; \n        \n        if (target.draggable && isNewMouseUp) {\n          this._activateClickHats(target);\n        } else if (!target.draggable && isNewMouseDown) {\n          this._activateClickHats(target);\n        }\n      }\n    }\n   \n  }, {\n    key: \"getClientX\",\n    value: function getClientX() {\n      return this._clientX;\n    }\n   \n  }, {\n    key: \"getClientY\",\n    value: function getClientY() {\n      return this._clientY;\n    }\n   \n  }, {\n    key: \"getScratchX\",\n    value: function getScratchX() {\n      return this._scratchX;\n    }\n   \n  }, {\n    key: \"getScratchY\",\n    value: function getScratchY() {\n      return this._scratchY;\n    }\n   \n  }, {\n    key: \"getIsDown\",\n    value: function getIsDown() {\n      return this._isDown;\n    }\n  }]);\n  return Mouse;\n}();\nmodule.exports = Mouse;\n })