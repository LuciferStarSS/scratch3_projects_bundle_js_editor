\n (function(module, exports, __webpack_require__) {\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nvar adapter = __webpack_require__(960);\nvar mutationAdapter = __webpack_require__(433);\nvar xmlEscape = __webpack_require__(220);\nvar MonitorRecord = __webpack_require__(295);\nvar Clone = __webpack_require__(113);\nvar _require = __webpack_require__(181),\n    Map = _require.Map;\nvar BlocksExecuteCache = __webpack_require__(440);\nvar BlocksRuntimeCache = __webpack_require__(441);\nvar log = __webpack_require__(39);\nvar Variable = __webpack_require__(114);\nvar getMonitorIdForBlockWithArgs = __webpack_require__(296);\n\n\nvar Blocks = function () {\n  function Blocks(runtime, optNoGlow) {\n    _classCallCheck(this, Blocks);\n    oBC=this;\n    this.runtime = runtime;\n    \n    this._blocks = {};\n    \n    this._scripts = [];\n    \n    Object.defineProperty(this, '_cache', {\n      writable: true,\n      enumerable: false\n    });\n    this._cache = {\n      \n      inputs: {},\n      \n      procedureParamNames: {},\n      \n      procedureDefinitions: {},\n      \n      _executeCached: {},\n      \n      _monitored: null,\n      \n      scripts: {}\n    };\n    \n    this.forceNoGlow = optNoGlow || false;\n  }\n  \n  _createClass(Blocks, [{\n    key: \"getBlock\",\n    \n    value: function getBlock(blockId) {\n      return this._blocks[blockId];\n    }\n    \n  }, {\n    key: \"getScripts\",\n    value: function getScripts() {\n      return this._scripts;\n    }\n    \n  }, {\n    key: \"getNextBlock\",\n    value: function getNextBlock(id) {\n      var block = this._blocks[id];\n      return typeof block === 'undefined' ? null : block.next;\n    }\n    \n  }, {\n    key: \"getBranch\",\n    value: function getBranch(id, branchNum) {\n      var block = this._blocks[id];\n      if (typeof block === 'undefined') return null;\n      if (!branchNum) branchNum = 1;\n      var inputName = Blocks.BRANCH_INPUT_PREFIX;\n      if (branchNum > 1) {\n        inputName += branchNum;\n      } \n      var input = block.inputs[inputName];\n      return typeof input === 'undefined' ? null : input.block;\n    }\n    \n  }, {\n    key: \"getOpcode\",\n    value: function getOpcode(block) {\n      return typeof block === 'undefined' ? null : block.opcode;\n    }\n    \n  }, {\n    key: \"getFields\",\n    value: function getFields(block) {\n      return typeof block === 'undefined' ? null : block.fields;\n    }\n    \n  }, {\n    key: \"getInputs\",\n    value: function getInputs(block) {\n      if (typeof block === 'undefined') return null;\n      var inputs = this._cache.inputs[block.id];\n      if (typeof inputs !== 'undefined') {\n        return inputs;\n      }\n      inputs = {};\n      for (var input in block.inputs) {\n        \n        if (input.substring(0, Blocks.BRANCH_INPUT_PREFIX.length) !== Blocks.BRANCH_INPUT_PREFIX) {\n          inputs[input] = block.inputs[input];\n        }\n      }\n      this._cache.inputs[block.id] = inputs;\n      return inputs;\n    }\n    \n  }, {\n    key: \"getMutation\",\n    value: function getMutation(block) {\n      return typeof block === 'undefined' ? null : block.mutation;\n    }\n    \n  }, {\n    key: \"getTopLevelScript\",\n    value: function getTopLevelScript(id) {\n      var block = this._blocks[id];\n      if (typeof block === 'undefined') return null;\n      while (block.parent !== null) {\n        block = this._blocks[block.parent];\n      }\n      return block.id;\n    }\n    \n  }, {\n    key: \"getProcedureDefinition\",\n    value: function getProcedureDefinition(name) {\n      var blockID = this._cache.procedureDefinitions[name];\n      if (typeof blockID !== 'undefined') {\n        return blockID;\n      }\n      for (var id in this._blocks) {\n        if (!this._blocks.hasOwnProperty(id)) continue;\n        var block = this._blocks[id];\n        if (block.opcode === 'procedures_definition') {\n          var internal = this._getCustomBlockInternal(block);\n          if (internal && internal.mutation.proccode === name) {\n            this._cache.procedureDefinitions[name] = id; \n            return id;\n          }\n        }\n      }\n      this._cache.procedureDefinitions[name] = null;\n      return null;\n    }\n    \n  }, {\n    key: \"getProcedureParamNamesAndIds\",\n    value: function getProcedureParamNamesAndIds(name) {\n      return this.getProcedureParamNamesIdsAndDefaults(name).slice(0, 2);\n    }\n    \n  }, {\n    key: \"getProcedureParamNamesIdsAndDefaults\",\n    value: function getProcedureParamNamesIdsAndDefaults(name) {\n      var cachedNames = this._cache.procedureParamNames[name];\n      if (typeof cachedNames !== 'undefined') {\n        return cachedNames;\n      }\n      for (var id in this._blocks) {\n        if (!this._blocks.hasOwnProperty(id)) continue;\n        var block = this._blocks[id];\n        if (block.opcode === 'procedures_prototype' && block.mutation.proccode === name) {\n          var names = JSON.parse(block.mutation.argumentnames);\n          var ids = JSON.parse(block.mutation.argumentids);\n          var defaults = JSON.parse(block.mutation.argumentdefaults);\n          this._cache.procedureParamNames[name] = [names, ids, defaults];\n          return this._cache.procedureParamNames[name];\n        }\n      }\n      this._cache.procedureParamNames[name] = null;\n      return null;\n    }\n  }, {\n    key: \"duplicate\",\n    value: function duplicate() {\n      var newBlocks = new Blocks(this.runtime, this.forceNoGlow);\n      newBlocks._blocks = Clone.simple(this._blocks);\n      newBlocks._scripts = Clone.simple(this._scripts);\n      return newBlocks;\n    } \n    \n  }, {\n    key: \"blocklyListen\",\n    value: function blocklyListen(e) {\n      \n      if (_typeof(e) !== 'object') return;\n      if (typeof e.blockId !== 'string' && typeof e.varId !== 'string' && typeof e.commentId !== 'string') {\n        return;\n      }\n      var stage = this.runtime.getTargetForStage();\n      var editingTarget = this.runtime.getEditingTarget(); \n      if (e.element === 'stackclick') {\n        this.runtime.toggleScript(e.blockId, {\n          stackClick: true\n        });\n        return;\n      } \n      switch (e.type) {\n        case 'create':\n          {\n            var newBlocks = adapter(e); \n            for (var i = 0; i < newBlocks.length; i++) {\n              this.createBlock(newBlocks[i]);\n            }\n            break;\n          }\n        case 'change':\n          this.changeBlock({\n            id: e.blockId,\n            element: e.element,\n            name: e.name,\n            value: e.newValue\n          });\n          break;\n        case 'move':\n          this.moveBlock({\n            id: e.blockId,\n            oldParent: e.oldParentId,\n            oldInput: e.oldInputName,\n            newParent: e.newParentId,\n            newInput: e.newInputName,\n            newCoordinate: e.newCoordinate\n          });\n          break;\n        case 'dragOutside':\n          this.runtime.emitBlockDragUpdate(e.isOutside);\n          break;\n        case 'endDrag':\n          this.runtime.emitBlockDragUpdate(false\n          \n          ); \n          if (e.isOutside) {\n            var _newBlocks = adapter(e);\n            this.runtime.emitBlockEndDrag(_newBlocks, e.blockId);\n          }\n          break;\n        case 'delete':\n          \n          \n          if (!this._blocks.hasOwnProperty(e.blockId) || this._blocks[e.blockId].shadow) {\n            return;\n          } \n          if (this._blocks[e.blockId].topLevel) {\n            this.runtime.quietGlow(e.blockId);\n          }\n          this.deleteBlock(e.blockId);\n          break;\n        case 'var_create':\n          \n          \n          \n          \n          \n          \n          \n          if (e.isLocal && editingTarget && !editingTarget.isStage && !e.isCloud) {\n            if (!editingTarget.lookupVariableById(e.varId)) {\n              editingTarget.createVariable(e.varId, e.varName, e.varType);\n              this.emitProjectChanged();\n            }\n          } else {\n            if (stage.lookupVariableById(e.varId)) {\n              \n              return;\n            } \n            var allTargets = this.runtime.targets.filter(function (t) {\n              return t.isOriginal;\n            });\n            var _iterator = _createForOfIteratorHelper(allTargets),\n                _step;\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                var target = _step.value;\n                if (target.lookupVariableByNameAndType(e.varName, e.varType, true)) {\n                  return;\n                }\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n            stage.createVariable(e.varId, e.varName, e.varType, e.isCloud);\n            this.emitProjectChanged();\n          }\n          break;\n        case 'var_rename':\n          if (editingTarget && editingTarget.variables.hasOwnProperty(e.varId)) {\n            \n            editingTarget.renameVariable(e.varId, e.newName); \n            \n            editingTarget.blocks.updateBlocksAfterVarRename(e.varId, e.newName);\n          } else {\n            \n            stage.renameVariable(e.varId, e.newName); \n            var targets = this.runtime.targets;\n            for (var _i = 0; _i < targets.length; _i++) {\n              var currTarget = targets[_i];\n              currTarget.blocks.updateBlocksAfterVarRename(e.varId, e.newName);\n            }\n          }\n          this.emitProjectChanged();\n          break;\n        case 'var_delete':\n          {\n            var _target = editingTarget && editingTarget.variables.hasOwnProperty(e.varId) ? editingTarget : stage;\n            _target.deleteVariable(e.varId);\n            this.emitProjectChanged();\n            break;\n          }\n        case 'comment_create':\n          if (this.runtime.getEditingTarget()) {\n            var _currTarget = this.runtime.getEditingTarget();\n            _currTarget.createComment(e.commentId, e.blockId, e.text, e.xy.x, e.xy.y, e.width, e.height, e.minimized);\n            if (_currTarget.comments[e.commentId].x === null && _currTarget.comments[e.commentId].y === null) {\n              \n              \n              \n              \n              \n              \n              _currTarget.comments[e.commentId].x = e.xy.x;\n              _currTarget.comments[e.commentId].y = e.xy.y;\n            }\n          }\n          this.emitProjectChanged();\n          break;\n        case 'comment_change':\n          if (this.runtime.getEditingTarget()) {\n            var _currTarget2 = this.runtime.getEditingTarget();\n            if (!_currTarget2.comments.hasOwnProperty(e.commentId)) {\n              log.warn(\"Cannot change comment with id \".concat(e.commentId, \" because it does not exist.\"));\n              return;\n            }\n            var comment = _currTarget2.comments[e.commentId];\n            var change = e.newContents_;\n            if (change.hasOwnProperty('minimized')) {\n              comment.minimized = change.minimized;\n            }\n            if (change.hasOwnProperty('width') && change.hasOwnProperty('height')) {\n              comment.width = change.width;\n              comment.height = change.height;\n            }\n            if (change.hasOwnProperty('text')) {\n              comment.text = change.text;\n            }\n            this.emitProjectChanged();\n          }\n          break;\n        case 'comment_move':\n          if (this.runtime.getEditingTarget()) {\n            var _currTarget3 = this.runtime.getEditingTarget();\n            if (_currTarget3 && !_currTarget3.comments.hasOwnProperty(e.commentId)) {\n              log.warn(\"Cannot change comment with id \".concat(e.commentId, \" because it does not exist.\"));\n              return;\n            }\n            var _comment = _currTarget3.comments[e.commentId];\n            var newCoord = e.newCoordinate_;\n            _comment.x = newCoord.x;\n            _comment.y = newCoord.y;\n            this.emitProjectChanged();\n          }\n          break;\n        case 'comment_delete':\n          if (this.runtime.getEditingTarget()) {\n            var _currTarget4 = this.runtime.getEditingTarget();\n            if (!_currTarget4.comments.hasOwnProperty(e.commentId)) {\n              \n              \n              \n              \n              return;\n            }\n            delete _currTarget4.comments[e.commentId];\n            if (e.blockId) {\n              var block = _currTarget4.blocks.getBlock(e.blockId);\n              if (!block) {\n                log.warn(\"Could not find block referenced by comment with id: \".concat(e.commentId));\n                return;\n              }\n              delete block.comment;\n            }\n            this.emitProjectChanged();\n          }\n          break;\n      }\n    } \n    \n  }, {\n    key: \"resetCache\",\n    value: function resetCache() {\n      this._cache.inputs = {};\n      this._cache.procedureParamNames = {};\n      this._cache.procedureDefinitions = {};\n      this._cache._executeCached = {};\n      this._cache._monitored = null;\n      this._cache.scripts = {};\n    }\n    \n  }, {\n    key: \"emitProjectChanged\",\n    value: function emitProjectChanged() {\n      if (!this.forceNoGlow) {\n        this.runtime.emitProjectChanged();\n        //scratchStatus(\"PROJECT_CHANGED\");\n      }\n    }\n    \n  }, {\n    key: \"createBlock\",\n    value: function createBlock(block) {\n      \n      \n      if (this._blocks.hasOwnProperty(block.id)) {\n        return;\n      } \n      this._blocks[block.id] = block; \n      \n      \n      if (block.topLevel) {\n        this._addScript(block.id);\n      }\n      this.resetCache(); \n      \n      bCREATEBLOCK=true;\n      this.emitProjectChanged();\n    }\n    \n  }, {\n    key: \"changeBlock\",\n    value: function changeBlock(args) {\n      \n      if (['field', 'mutation', 'checkbox'].indexOf(args.element) === -1) return;\n      var block = this._blocks[args.id];\n      if (typeof block === 'undefined') return;\n      switch (args.element) {\n        case 'field':\n          \n          \n          \n          \n          \n          \n          \n          \n          \n          if (!block.fields[args.name]) return;\n          if (args.name === 'VARIABLE' || args.name === 'LIST' || args.name === 'BROADCAST_OPTION') {\n            \n            var variable = this.runtime.getEditingTarget().lookupVariableById(args.value);\n            if (variable) {\n              block.fields[args.name].value = variable.name;\n              block.fields[args.name].id = args.value;\n            }\n          } else {\n            \n            block.fields[args.name].value = args.value; \n            \n            \n            if (block.opcode === 'sensing_of_object_menu') {\n              if (block.fields.OBJECT.value === '_stage_') {\n                this._blocks[block.parent].fields.PROPERTY.value = 'backdrop #';\n              } else {\n                this._blocks[block.parent].fields.PROPERTY.value = 'x position';\n              }\n              this.runtime.requestBlocksUpdate();\n            }\n            var flyoutBlock = block.shadow && block.parent ? this._blocks[block.parent] : block;\n            if (flyoutBlock.isMonitored) {\n              this.runtime.requestUpdateMonitor(Map({\n                id: flyoutBlock.id,\n                params: this._getBlockParams(flyoutBlock)\n              }));\n            }\n          }\n          break;\n        case 'mutation':\n          block.mutation = mutationAdapter(args.value);\n          break;\n        case 'checkbox':\n          {\n            \n            \n            \n            if (block.fields && Object.keys(block.fields).length > 0 && block.opcode !== 'data_variable' && block.opcode !== 'data_listcontents') {\n              \n              \n              var newId = getMonitorIdForBlockWithArgs(block.id, block.fields); \n              \n              \n              var newBlock = this.runtime.monitorBlocks.getBlock(newId);\n              if (!newBlock) {\n                newBlock = JSON.parse(JSON.stringify(block));\n                newBlock.id = newId;\n                this.runtime.monitorBlocks.createBlock(newBlock);\n              }\n              block = newBlock; \n            }\n            var wasMonitored = block.isMonitored;\n            block.isMonitored = args.value; \n            var isSpriteLocalVariable = false;\n            if (block.opcode === 'data_variable') {\n              isSpriteLocalVariable = !this.runtime.getTargetForStage().variables[block.fields.VARIABLE.id];\n            } else if (block.opcode === 'data_listcontents') {\n              isSpriteLocalVariable = !this.runtime.getTargetForStage().variables[block.fields.LIST.id];\n            }\n            var isSpriteSpecific = isSpriteLocalVariable || this.runtime.monitorBlockInfo.hasOwnProperty(block.opcode) && this.runtime.monitorBlockInfo[block.opcode].isSpriteSpecific;\n            if (isSpriteSpecific) {\n              \n              \n              \n              block.targetId = block.targetId || this.runtime.getEditingTarget().id;\n            } else {\n              block.targetId = null;\n            }\n            if (wasMonitored && !block.isMonitored) {\n              this.runtime.requestHideMonitor(block.id);\n            } else if (!wasMonitored && block.isMonitored) {\n              \n              if (!this.runtime.requestShowMonitor(block.id)) {\n                this.runtime.requestAddMonitor(MonitorRecord({\n                  id: block.id,\n                  targetId: block.targetId,\n                  spriteName: block.targetId ? this.runtime.getTargetById(block.targetId).getName() : null,\n                  opcode: block.opcode,\n                  params: this._getBlockParams(block),\n                  \n                  value: '',\n                  mode: block.opcode === 'data_listcontents' ? 'list' : 'default'\n                }));\n              }\n            }\n            break;\n          }\n      }\n      this.emitProjectChanged();\n      this.resetCache();\n    }\n    \n  }, {\n    key: \"moveBlock\",\n    value: function moveBlock(e) {\n      if (!this._blocks.hasOwnProperty(e.id)) {\n        return;\n      }\n      var block = this._blocks[e.id]; \n      \n      \n      var didChange = false; \n      if (e.newCoordinate) {\n        didChange = block.x !== e.newCoordinate.x || block.y !== e.newCoordinate.y;\n        block.x = e.newCoordinate.x;\n        block.y = e.newCoordinate.y;\n      } \n      if (typeof e.oldParent !== 'undefined') {\n        var oldParent = this._blocks[e.oldParent];\n        if (typeof e.oldInput !== 'undefined' && oldParent.inputs[e.oldInput].block === e.id) {\n          \n          oldParent.inputs[e.oldInput].block = null;\n        } else if (oldParent.next === e.id) {\n          \n          oldParent.next = null;\n        }\n        this._blocks[e.id].parent = null;\n        didChange = true;\n      } \n      if (typeof e.newParent === 'undefined') {\n        this._addScript(e.id);\n      } else {\n        \n        this._deleteScript(e.id); \n        if (typeof e.newInput === 'undefined') {\n          \n          this._blocks[e.newParent].next = e.id;\n        } else {\n          \n          \n          var oldShadow = null;\n          if (this._blocks[e.newParent].inputs.hasOwnProperty(e.newInput)) {\n            oldShadow = this._blocks[e.newParent].inputs[e.newInput].shadow;\n          } \n          \n          \n          if (this._blocks[e.id].shadow) oldShadow = e.id;\n          this._blocks[e.newParent].inputs[e.newInput] = {\n            name: e.newInput,\n            block: e.id,\n            shadow: oldShadow\n          };\n        }\n        this._blocks[e.id].parent = e.newParent;\n        didChange = true;\n      }\n      this.resetCache();\n      if (didChange) this.emitProjectChanged();\n    }\n    \n  }, {\n    key: \"runAllMonitored\",\n    value: function runAllMonitored(runtime) {\n      var _this = this;\n      if (this._cache._monitored === null) {\n        this._cache._monitored = Object.keys(this._blocks).filter(function (blockId) {\n          return _this.getBlock(blockId).isMonitored;\n        }).map(function (blockId) {\n          var targetId = _this.getBlock(blockId).targetId;\n          return {\n            blockId: blockId,\n            target: targetId ? runtime.getTargetById(targetId) : null\n          };\n        });\n      }\n      var monitored = this._cache._monitored;\n      for (var i = 0; i < monitored.length; i++) {\n        var _monitored$i = monitored[i],\n            blockId = _monitored$i.blockId,\n            target = _monitored$i.target;\n        runtime.addMonitorScript(blockId, target);\n      }\n    }\n    \n  }, {\n    key: \"deleteBlock\",\n    value: function deleteBlock(blockId) {\n      \n      \n      var block = this._blocks[blockId];\n      if (!block) {\n        \n        return;\n      } \n      if (block.next !== null) {\n        this.deleteBlock(block.next);\n      } \n      for (var input in block.inputs) {\n        \n        if (block.inputs[input].block !== null) {\n          this.deleteBlock(block.inputs[input].block);\n        } \n        if (block.inputs[input].shadow !== null && block.inputs[input].shadow !== block.inputs[input].block) {\n          this.deleteBlock(block.inputs[input].shadow);\n        }\n      } \n      this._deleteScript(blockId); \n      delete this._blocks[blockId];\n      this.resetCache();\n      this.emitProjectChanged();\n    }\n    \n  }, {\n    key: \"getAllVariableAndListReferences\",\n    value: function getAllVariableAndListReferences(optBlocks, optIncludeBroadcast) {\n      var blocks = optBlocks ? optBlocks : this._blocks;\n      var allReferences = Object.create(null);\n      for (var blockId in blocks) {\n        var varOrListField = null;\n        var varType = null;\n        if (blocks[blockId].fields.VARIABLE) {\n          varOrListField = blocks[blockId].fields.VARIABLE;\n          varType = Variable.SCALAR_TYPE;\n        } else if (blocks[blockId].fields.LIST) {\n          varOrListField = blocks[blockId].fields.LIST;\n          varType = Variable.LIST_TYPE;\n        } else if (optIncludeBroadcast && blocks[blockId].fields.BROADCAST_OPTION) {\n          varOrListField = blocks[blockId].fields.BROADCAST_OPTION;\n          varType = Variable.BROADCAST_MESSAGE_TYPE;\n        }\n        if (varOrListField) {\n          var currVarId = varOrListField.id;\n          if (allReferences[currVarId]) {\n            allReferences[currVarId].push({\n              referencingField: varOrListField,\n              type: varType\n            });\n          } else {\n            allReferences[currVarId] = [{\n              referencingField: varOrListField,\n              type: varType\n            }];\n          }\n        }\n      }\n      return allReferences;\n    }\n    \n  }, {\n    key: \"updateBlocksAfterVarRename\",\n    value: function updateBlocksAfterVarRename(varId, newName) {\n      var blocks = this._blocks;\n      for (var blockId in blocks) {\n        var varOrListField = null;\n        if (blocks[blockId].fields.VARIABLE) {\n          varOrListField = blocks[blockId].fields.VARIABLE;\n        } else if (blocks[blockId].fields.LIST) {\n          varOrListField = blocks[blockId].fields.LIST;\n        }\n        if (varOrListField) {\n          var currFieldId = varOrListField.id;\n          if (varId === currFieldId) {\n            varOrListField.value = newName;\n          }\n        }\n      }\n    }\n    \n  }, {\n    key: \"updateTargetSpecificBlocks\",\n    value: function updateTargetSpecificBlocks(isStage) {\n      var blocks = this._blocks;\n      for (var blockId in blocks) {\n        if (isStage && blocks[blockId].opcode === 'event_whenthisspriteclicked') {\n          blocks[blockId].opcode = 'event_whenstageclicked';\n        } else if (!isStage && blocks[blockId].opcode === 'event_whenstageclicked') {\n          blocks[blockId].opcode = 'event_whenthisspriteclicked';\n        }\n      }\n    }\n    \n  }, {\n    key: \"updateAssetName\",\n    value: function updateAssetName(oldName, newName, assetType) {\n      var getAssetField;\n      if (assetType === 'costume') {\n        getAssetField = this._getCostumeField.bind(this);\n      } else if (assetType === 'sound') {\n        getAssetField = this._getSoundField.bind(this);\n      } else if (assetType === 'backdrop') {\n        getAssetField = this._getBackdropField.bind(this);\n      } else if (assetType === 'sprite') {\n        getAssetField = this._getSpriteField.bind(this);\n      } else {\n        return;\n      }\n      var blocks = this._blocks;\n      for (var blockId in blocks) {\n        var assetField = getAssetField(blockId);\n        if (assetField && assetField.value === oldName) {\n          assetField.value = newName;\n        }\n      }\n    }\n    \n  }, {\n    key: \"updateSensingOfReference\",\n    value: function updateSensingOfReference(oldName, newName, targetName) {\n      var blocks = this._blocks;\n      var blockUpdated = false;\n      for (var blockId in blocks) {\n        var block = blocks[blockId];\n        if (block.opcode === 'sensing_of' && block.fields.PROPERTY.value === oldName && \n        block.inputs.OBJECT.block === block.inputs.OBJECT.shadow) {\n          var inputBlock = this.getBlock(block.inputs.OBJECT.block);\n          if (inputBlock.fields.OBJECT.value === targetName) {\n            block.fields.PROPERTY.value = newName;\n            blockUpdated = true;\n          }\n        }\n      }\n      if (blockUpdated) this.resetCache();\n      return blockUpdated;\n    }\n    \n  }, {\n    key: \"_getCostumeField\",\n    value: function _getCostumeField(blockId) {\n      var block = this.getBlock(blockId);\n      if (block && block.fields.hasOwnProperty('COSTUME')) {\n        return block.fields.COSTUME;\n      }\n      return null;\n    }\n    \n  }, {\n    key: \"_getSoundField\",\n    value: function _getSoundField(blockId) {\n      var block = this.getBlock(blockId);\n      if (block && block.fields.hasOwnProperty('SOUND_MENU')) {\n        return block.fields.SOUND_MENU;\n      }\n      return null;\n    }\n    \n  }, {\n    key: \"_getBackdropField\",\n    value: function _getBackdropField(blockId) {\n      var block = this.getBlock(blockId);\n      if (block && block.fields.hasOwnProperty('BACKDROP')) {\n        return block.fields.BACKDROP;\n      }\n      return null;\n    }\n    \n  }, {\n    key: \"_getSpriteField\",\n    value: function _getSpriteField(blockId) {\n      var block = this.getBlock(blockId);\n      if (!block) {\n        return null;\n      }\n      var spriteMenuNames = ['TOWARDS', 'TO', 'OBJECT', 'VIDEOONMENU2', 'DISTANCETOMENU', 'TOUCHINGOBJECTMENU', 'CLONE_OPTION'];\n      for (var i = 0; i < spriteMenuNames.length; i++) {\n        var menuName = spriteMenuNames[i];\n        if (block.fields.hasOwnProperty(menuName)) {\n          return block.fields[menuName];\n        }\n      }\n      return null;\n    } \n    \n  }, {\n    key: \"toXML\",\n    value: function toXML(comments) {\n      var _this2 = this;\n      return this._scripts.map(function (script) {\n        return _this2.blockToXML(script, comments);\n      }).join();\n    }\n    \n  }, {\n    key: \"blockToXML\",\n    value: function blockToXML(blockId, comments) {\n      var block = this._blocks[blockId]; \n      \n      \n      if (!block) return; \n      var tagName = block.shadow ? 'shadow' : 'block';\n      var xmlString = \"<\".concat(tagName, \"\\n                id=\\\"\").concat(block.id, \"\\\"\\n                type=\\\"\").concat(block.opcode, \"\\\"\\n                \").concat(block.topLevel ? \"x=\\\"\".concat(block.x, \"\\\" y=\\\"\").concat(block.y, \"\\\"\") : '', \"\\n            >\");\n      var commentId = block.comment;\n      if (commentId) {\n        if (comments) {\n          if (comments.hasOwnProperty(commentId)) {\n            xmlString += comments[commentId].toXML();\n          } else {\n            log.warn(\"Could not find comment with id: \".concat(commentId, \" in provided comment descriptions.\"));\n          }\n        } else {\n          log.warn(\"Cannot serialize comment with id: \".concat(commentId, \"; no comment descriptions provided.\"));\n        }\n      } \n      if (block.mutation) {\n        xmlString += this.mutationToXML(block.mutation);\n      } \n      for (var input in block.inputs) {\n        if (!block.inputs.hasOwnProperty(input)) continue;\n        var blockInput = block.inputs[input]; \n        if (blockInput.block || blockInput.shadow) {\n          xmlString += \"<value name=\\\"\".concat(blockInput.name, \"\\\">\");\n          if (blockInput.block) {\n            xmlString += this.blockToXML(blockInput.block, comments);\n          }\n          if (blockInput.shadow && blockInput.shadow !== blockInput.block) {\n            \n            xmlString += this.blockToXML(blockInput.shadow, comments);\n          }\n          xmlString += '</value>';\n        }\n      } \n      for (var field in block.fields) {\n        if (!block.fields.hasOwnProperty(field)) continue;\n        var blockField = block.fields[field];\n        xmlString += \"<field name=\\\"\".concat(blockField.name, \"\\\"\");\n        var fieldId = blockField.id;\n        if (fieldId) {\n          xmlString += \" id=\\\"\".concat(fieldId, \"\\\"\");\n        }\n        var varType = blockField.variableType;\n        if (typeof varType === 'string') {\n          xmlString += \" variabletype=\\\"\".concat(varType, \"\\\"\");\n        }\n        var value = blockField.value;\n        if (typeof value === 'string') {\n          value = xmlEscape(blockField.value);\n        }\n        xmlString += \">\".concat(value, \"</field>\");\n      } \n      if (block.next) {\n        xmlString += \"<next>\".concat(this.blockToXML(block.next, comments), \"</next>\");\n      }\n      xmlString += \"</\".concat(tagName, \">\");\n      return xmlString;\n    }\n    \n  }, {\n    key: \"mutationToXML\",\n    value: function mutationToXML(mutation) {\n      var mutationString = \"<\".concat(mutation.tagName);\n      for (var prop in mutation) {\n        if (prop === 'children' || prop === 'tagName') continue;\n        var mutationValue = typeof mutation[prop] === 'string' ? xmlEscape(mutation[prop]) : mutation[prop]; \n        if (prop === 'blockInfo') {\n          mutationValue = xmlEscape(JSON.stringify(mutation[prop]));\n        }\n        mutationString += \" \".concat(prop, \"=\\\"\").concat(mutationValue, \"\\\"\");\n      }\n      mutationString += '>';\n      for (var i = 0; i < mutation.children.length; i++) {\n        mutationString += this.mutationToXML(mutation.children[i]);\n      }\n      mutationString += \"</\".concat(mutation.tagName, \">\");\n      return mutationString;\n    } \n    \n  }, {\n    key: \"_getBlockParams\",\n    value: function _getBlockParams(block) {\n      var params = {};\n      for (var key in block.fields) {\n        params[key] = block.fields[key].value;\n      }\n      for (var inputKey in block.inputs) {\n        var inputBlock = this._blocks[block.inputs[inputKey].block];\n        for (var _key in inputBlock.fields) {\n          params[_key] = inputBlock.fields[_key].value;\n        }\n      }\n      return params;\n    }\n    \n  }, {\n    key: \"_getCustomBlockInternal\",\n    value: function _getCustomBlockInternal(defineBlock) {\n      if (defineBlock.inputs && defineBlock.inputs.custom_block) {\n        return this._blocks[defineBlock.inputs.custom_block.block];\n      }\n    }\n    \n  }, {\n    key: \"_addScript\",\n    value: function _addScript(topBlockId) {\n      var i = this._scripts.indexOf(topBlockId);\n      if (i > -1) return; \n      this._scripts.push(topBlockId); \n      this._blocks[topBlockId].topLevel = true;\n    }\n    \n  }, {\n    key: \"_deleteScript\",\n    value: function _deleteScript(topBlockId) {\n      var i = this._scripts.indexOf(topBlockId);\n      if (i > -1) this._scripts.splice(i, 1); \n      if (this._blocks[topBlockId]) this._blocks[topBlockId].topLevel = false;\n    }\n  }], [{\n    key: \"BRANCH_INPUT_PREFIX\",\n    get: function get() {\n      return 'SUBSTACK';\n    }\n  }]);\n  return Blocks;\n}();\n\nBlocksExecuteCache.getCached = function (blocks, blockId, CacheType) {\n  var cached = blocks._cache._executeCached[blockId];\n  if (typeof cached !== 'undefined') {\n    return cached;\n  }\n  var block = blocks.getBlock(blockId);\n  if (typeof block === 'undefined') return null;\n  if (typeof CacheType === 'undefined') {\n    cached = {\n      id: blockId,\n      opcode: blocks.getOpcode(block),\n      fields: blocks.getFields(block),\n      inputs: blocks.getInputs(block),\n      mutation: blocks.getMutation(block)\n    };\n  } else {\n    cached = new CacheType(blocks, {\n      id: blockId,\n      opcode: blocks.getOpcode(block),\n      fields: blocks.getFields(block),\n      inputs: blocks.getInputs(block),\n      mutation: blocks.getMutation(block)\n    });\n  }\n  blocks._cache._executeCached[blockId] = cached;\n  return cached;\n};\n\nvar RuntimeScriptCache = BlocksRuntimeCache._RuntimeScriptCache;\n\nBlocksRuntimeCache.getScripts = function (blocks, opcode) {\n  var scripts = blocks._cache.scripts[opcode];\n  if (!scripts) {\n    scripts = blocks._cache.scripts[opcode] = [];\n    var allScripts = blocks._scripts;\n    for (var i = 0; i < allScripts.length; i++) {\n      var topBlockId = allScripts[i];\n      var block = blocks.getBlock(topBlockId);\n      if (block.opcode === opcode) {\n        scripts.push(new RuntimeScriptCache(blocks, topBlockId));\n      }\n    }\n  }\n  return scripts;\n};\nmodule.exports = Blocks;\n })