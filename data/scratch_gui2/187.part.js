/* 187 */\n (function(module, exports, __webpack_require__) {\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nvar EventEmitter = __webpack_require__(91);\nvar twgl = __webpack_require__(103);\nvar RenderConstants = __webpack_require__(230);\nvar Silhouette = __webpack_require__(1246);\nvar Skin = function (_EventEmitter) {\n  _inherits(Skin, _EventEmitter);\n  var _super = _createSuper(Skin);\n \n  function Skin(id) {\n    var _this;\n    _classCallCheck(this, Skin);\n    _this = _super.call(this);\n   \n    _this._id = id;\n   \n    _this._rotationCenter = twgl.v3.create(0, 0);\n   \n    _this._texture = null;\n   \n    _this._uniforms = {\n     \n      u_skinSize: [0, 0],\n     \n      u_skin: null\n    };\n   \n    _this._silhouette = new Silhouette();\n    _this.setMaxListeners(RenderConstants.SKIN_SHARE_SOFT_LIMIT);\n    return _this;\n  }\n \n  _createClass(Skin, [{\n    key: \"dispose\",\n    value: function dispose() {\n      this._id = RenderConstants.ID_NONE;\n    }\n   \n  }, {\n    key: \"useNearest\",\n   \n    \n    value: function useNearest(scale, drawable) {\n      return true;\n    }\n   \n  }, {\n    key: \"calculateRotationCenter\",\n    value: function calculateRotationCenter() {\n      return [this.size[0] / 2, this.size[1] / 2];\n    }\n   \n    \n  }, {\n    key: \"getTexture\",\n    value: function getTexture(scale) {\n      return this._emptyImageTexture;\n    }\n   \n  }, {\n    key: \"getFenceBounds\",\n    value: function getFenceBounds(drawable, result) {\n      return drawable.getAABB(result);\n    }\n   \n  }, {\n    key: \"getUniforms\",\n    value: function getUniforms(scale) {\n      this._uniforms.u_skin = this.getTexture(scale);\n      this._uniforms.u_skinSize = this.size;\n      return this._uniforms;\n    }\n   \n  }, {\n    key: \"updateSilhouette\",\n    value: function updateSilhouette() {}\n   \n  }, {\n    key: \"_setTexture\",\n    value: function _setTexture(textureData) {\n      var gl = this._renderer.gl;\n      gl.bindTexture(gl.TEXTURE_2D, this._texture); \n      \n      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureData);\n      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n      this._silhouette.update(textureData);\n    }\n   \n  }, {\n    key: \"setEmptyImageData\",\n    value: function setEmptyImageData() {\n      \n      this._texture = null;\n      if (!this._emptyImageData) {\n        \n        this._emptyImageData = new ImageData(1, 1); \n        var gl = this._renderer.gl;\n        var textureOptions = {\n          auto: true,\n          wrap: gl.CLAMP_TO_EDGE,\n          src: this._emptyImageData\n        }; \n        \n        \n        \n        this._emptyImageTexture = twgl.createTexture(gl, textureOptions);\n      }\n      this._rotationCenter[0] = 0;\n      this._rotationCenter[1] = 0;\n      this._silhouette.update(this._emptyImageData);\n      this.emit(Skin.Events.WasAltered);\n    }\n   \n  }, {\n    key: \"isTouchingNearest\",\n    value: function isTouchingNearest(vec) {\n      return this._silhouette.isTouchingNearest(vec);\n    }\n   \n  }, {\n    key: \"isTouchingLinear\",\n    value: function isTouchingLinear(vec) {\n      return this._silhouette.isTouchingLinear(vec);\n    }\n  }, {\n    key: \"id\",\n    get: function get() {\n      return this._id;\n    }\n   \n  }, {\n    key: \"rotationCenter\",\n    get: function get() {\n      return this._rotationCenter;\n    }\n   \n  }, {\n    key: \"size\",\n    get: function get() {\n      return [0, 0];\n    }\n  }]);\n  return Skin;\n}(EventEmitter);\n/**\n * These are the events which can be emitted by instances of this class.\n * @enum {string}\n */\nSkin.Events = {\n \n  WasAltered: 'WasAltered'\n};\nmodule.exports = Skin;\n })