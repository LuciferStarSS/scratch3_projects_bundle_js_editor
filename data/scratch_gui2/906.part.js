/* 906 */\n (function(module, exports, __webpack_require__) {\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nvar _TextEncoder;\nif (typeof TextEncoder === 'undefined') {\n  _TextEncoder = __webpack_require__(160).TextEncoder;\n} else {\n \n  _TextEncoder = TextEncoder;\n}\nvar EventEmitter = __webpack_require__(91);\nvar JSZip = __webpack_require__(398);\nvar Buffer = __webpack_require__(56).Buffer;\nvar centralDispatch = __webpack_require__(426);\nvar ExtensionManager = __webpack_require__(954);\nvar log = __webpack_require__(39);\nvar MathUtil = __webpack_require__(62);\nvar Runtime = __webpack_require__(450);\nvar StringUtil = __webpack_require__(102);\nvar formatMessage = __webpack_require__(71);\nvar Variable = __webpack_require__(114);\nvar newBlockIds = __webpack_require__(453);\nvar _require = __webpack_require__(225),\n    loadCostume = _require.loadCostume;\nvar _require2 = __webpack_require__(226),\n    loadSound = _require2.loadSound;\nvar _require3 = __webpack_require__(1104),\n    serializeSounds = _require3.serializeSounds,\n    serializeCostumes = _require3.serializeCostumes;\n__webpack_require__(1105);\nvar RESERVED_NAMES = ['_mouse_', '_stage_', '_edge_', '_myself_', '_random_'];\nvar CORE_EXTENSIONS = [\n  \n  \n  \n  \n  \n  \n  \n  \n];\n/**\n * Handles connections between blocks, stage, and extensions.\n * @constructor\n */\nvar VirtualMachine = function (_EventEmitter) {\n  _inherits(VirtualMachine, _EventEmitter);\n  var _super = _createSuper(VirtualMachine);\n  function VirtualMachine() {\n    var _this;\n    _classCallCheck(this, VirtualMachine);\n    _this = _super.call(this);\n   \n    _this.runtime = new Runtime();\n    centralDispatch.setService('runtime', _this.runtime).catch(function (e) {\n      log.error(\"Failed to register runtime service: \".concat(JSON.stringify(e)));\n    });\n   \n    _this.editingTarget = null;\n   \n    _this._dragTarget = null; \n    _this.runtime.on(Runtime.SCRIPT_GLOW_ON, function (glowData) {\n      _this.emit(Runtime.SCRIPT_GLOW_ON, glowData);\n    });\n    _this.runtime.on(Runtime.SCRIPT_GLOW_OFF, function (glowData) {\n      _this.emit(Runtime.SCRIPT_GLOW_OFF, glowData);\n    });\n    _this.runtime.on(Runtime.BLOCK_GLOW_ON, function (glowData) {\n      _this.emit(Runtime.BLOCK_GLOW_ON, glowData);\n    });\n    _this.runtime.on(Runtime.BLOCK_GLOW_OFF, function (glowData) {\n      _this.emit(Runtime.BLOCK_GLOW_OFF, glowData);\n    });\n    _this.runtime.on(Runtime.PROJECT_START, function () {\n      _this.emit(Runtime.PROJECT_START);\n    });\n    _this.runtime.on(Runtime.PROJECT_RUN_START, function () {\n      _this.emit(Runtime.PROJECT_RUN_START);\n    });\n    _this.runtime.on(Runtime.PROJECT_RUN_STOP, function () {\n      _this.emit(Runtime.PROJECT_RUN_STOP);\n    });\n    _this.runtime.on(Runtime.PROJECT_CHANGED, function () {\n      //scratchStatus(\"BACKUPNEEDED\");\n      _this.emit(Runtime.PROJECT_CHANGED);\n    });\n    _this.runtime.on(Runtime.VISUAL_REPORT, function (visualReport) {\n      _this.emit(Runtime.VISUAL_REPORT, visualReport);\n    });\n    _this.runtime.on(Runtime.TARGETS_UPDATE, function (emitProjectChanged) {\n      _this.emitTargetsUpdate(emitProjectChanged);\n    });\n    _this.runtime.on(Runtime.MONITORS_UPDATE, function (monitorList) {\n      _this.emit(Runtime.MONITORS_UPDATE, monitorList);\n    });\n    _this.runtime.on(Runtime.BLOCK_DRAG_UPDATE, function (areBlocksOverGui) {\n      _this.emit(Runtime.BLOCK_DRAG_UPDATE, areBlocksOverGui);\n    });\n    _this.runtime.on(Runtime.BLOCK_DRAG_END, function (blocks, topBlockId) {\n      _this.emit(Runtime.BLOCK_DRAG_END, blocks, topBlockId);\n    });\n    _this.runtime.on(Runtime.EXTENSION_ADDED, function (categoryInfo) {\n      _this.emit(Runtime.EXTENSION_ADDED, categoryInfo);\n    });\n    _this.runtime.on(Runtime.EXTENSION_FIELD_ADDED, function (fieldName, fieldImplementation) {\n      _this.emit(Runtime.EXTENSION_FIELD_ADDED, fieldName, fieldImplementation);\n    });\n    _this.runtime.on(Runtime.BLOCKSINFO_UPDATE, function (categoryInfo) {\n      _this.emit(Runtime.BLOCKSINFO_UPDATE, categoryInfo);\n    });\n    _this.runtime.on(Runtime.BLOCKS_NEED_UPDATE, function () {\n      _this.emitWorkspaceUpdate();\n    });\n    _this.runtime.on(Runtime.TOOLBOX_EXTENSIONS_NEED_UPDATE, function () {\n      _this.extensionManager.refreshBlocks();\n    });\n    _this.runtime.on(Runtime.PERIPHERAL_LIST_UPDATE, function (info) {\n      _this.emit(Runtime.PERIPHERAL_LIST_UPDATE, info);\n    });\n    _this.runtime.on(Runtime.USER_PICKED_PERIPHERAL, function (info) {\n      _this.emit(Runtime.USER_PICKED_PERIPHERAL, info);\n    });\n    _this.runtime.on(Runtime.PERIPHERAL_CONNECTED, function () {\n      return _this.emit(Runtime.PERIPHERAL_CONNECTED);\n    });\n    _this.runtime.on(Runtime.PERIPHERAL_REQUEST_ERROR, function () {\n      return _this.emit(Runtime.PERIPHERAL_REQUEST_ERROR);\n    });\n    _this.runtime.on(Runtime.PERIPHERAL_DISCONNECTED, function () {\n      return _this.emit(Runtime.PERIPHERAL_DISCONNECTED);\n    });\n    _this.runtime.on(Runtime.PERIPHERAL_CONNECTION_LOST_ERROR, function (data) {\n      return _this.emit(Runtime.PERIPHERAL_CONNECTION_LOST_ERROR, data);\n    });\n    _this.runtime.on(Runtime.PERIPHERAL_SCAN_TIMEOUT, function () {\n      return _this.emit(Runtime.PERIPHERAL_SCAN_TIMEOUT);\n    });\n    _this.runtime.on(Runtime.MIC_LISTENING, function (listening) {\n      _this.emit(Runtime.MIC_LISTENING, listening);\n    });\n    _this.runtime.on(Runtime.RUNTIME_STARTED, function () {\n      _this.emit(Runtime.RUNTIME_STARTED);\n    });\n    _this.runtime.on(Runtime.HAS_CLOUD_DATA_UPDATE, function (hasCloudData) {\n      _this.emit(Runtime.HAS_CLOUD_DATA_UPDATE, hasCloudData);\n    });\n    _this.extensionManager = new ExtensionManager(_this.runtime); \n    var _iterator = _createForOfIteratorHelper(CORE_EXTENSIONS),\n        _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var id = _step.value;\n        _this.extensionManager.loadExtensionIdSync(id);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    _this.blockListener = _this.blockListener.bind(_assertThisInitialized(_this));\n    _this.flyoutBlockListener = _this.flyoutBlockListener.bind(_assertThisInitialized(_this));\n    _this.monitorBlockListener = _this.monitorBlockListener.bind(_assertThisInitialized(_this));\n    _this.variableListener = _this.variableListener.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n \n  _createClass(VirtualMachine, [{\n    key: \"start\",\n    value: function start() {\n      this.runtime.start();\n    }\n   \n  }, {\n    key: \"greenFlag\",\n    value: function greenFlag() {\n      this.runtime.greenFlag();\n    }\n   \n  }, {\n    key: \"setTurboMode\",\n    value: function setTurboMode(turboModeOn) {\n      this.runtime.turboMode = !!turboModeOn;\n      if (this.runtime.turboMode) {\n        this.emit(Runtime.TURBO_MODE_ON);\n      } else {\n        this.emit(Runtime.TURBO_MODE_OFF);\n      }\n    }\n   \n  }, {\n    key: \"setCompatibilityMode\",\n    value: function setCompatibilityMode(compatibilityModeOn) {\n      this.runtime.setCompatibilityMode(!!compatibilityModeOn);\n    }\n   \n  }, {\n    key: \"stopAll\",\n    value: function stopAll() {\n      this.runtime.stopAll();\n    }\n   \n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.runtime.dispose();\n      this.editingTarget = null;\n      this.emitTargetsUpdate(false\n     \n      );\n    }\n   \n  }, {\n    key: \"getPlaygroundData\",\n    value: function getPlaygroundData() {\n      var instance = this; \n      var threadData = this.runtime.threads.filter(function (thread) {\n        return thread.target === instance.editingTarget;\n      }); \n      var filteredThreadData = JSON.stringify(threadData, function (key, value) {\n        if (key === 'target' || key === 'blockContainer') return;\n        return value;\n      }, 2);\n      this.emit('playgroundData', {\n        blocks: this.editingTarget.blocks,\n        threads: filteredThreadData\n      });\n    }\n   \n  }, {\n    key: \"postIOData\",\n    value: function postIOData(device, data) {\n      if (this.runtime.ioDevices[device]) {\n        this.runtime.ioDevices[device].postData(data);\n      }\n    }\n  }, {\n    key: \"setVideoProvider\",\n    value: function setVideoProvider(videoProvider) {\n      this.runtime.ioDevices.video.setProvider(videoProvider);\n    }\n  }, {\n    key: \"setCloudProvider\",\n    value: function setCloudProvider(cloudProvider) {\n      this.runtime.ioDevices.cloud.setProvider(cloudProvider);\n    }\n   \n  }, {\n    key: \"scanForPeripheral\",\n    value: function scanForPeripheral(extensionId) {\n      this.runtime.scanForPeripheral(extensionId);\n    }\n   \n  }, {\n    key: \"connectPeripheral\",\n    value: function connectPeripheral(extensionId, peripheralId) {\n      this.runtime.connectPeripheral(extensionId, peripheralId);\n    }\n   \n  }, {\n    key: \"disconnectPeripheral\",\n    value: function disconnectPeripheral(extensionId) {\n      this.runtime.disconnectPeripheral(extensionId);\n    }\n   \n  }, {\n    key: \"getPeripheralIsConnected\",\n    value: function getPeripheralIsConnected(extensionId) {\n      return this.runtime.getPeripheralIsConnected(extensionId);\n    }\n   \n  }, {\n    key: \"loadProject\",\n    value: function loadProject(input) {\n      var _this2 = this;\n      if (_typeof(input) === 'object' && !(input instanceof ArrayBuffer) && !ArrayBuffer.isView(input)) {\n        \n        \n        \n        \n        \n        \n        input = JSON.stringify(input);\n      }\n      var validationPromise = new Promise(function (resolve, reject) {\n        var validate = __webpack_require__(454); \n        \n        validate(input, false, function (error, res) {\n          if (error) return reject(error);\n          resolve(res);\n        });\n      }).catch(function (error) {\n        var _require4 = __webpack_require__(1481),\n            SB1File = _require4.SB1File,\n            ValidationError = _require4.ValidationError;\n        try {\n          var sb1 = new SB1File(input);\n          var json = sb1.json;\n          json.projectVersion = 2;\n          return Promise.resolve([json, sb1.zip]);\n        } catch (sb1Error) {\n          if (sb1Error instanceof ValidationError) {\n          } else {\n            \n            \n            \n            return Promise.reject(sb1Error);\n          }\n        } \n        \n        return Promise.reject(error);\n      });\n      return validationPromise.then(function (validatedInput) {\n        return _this2.deserializeProject(validatedInput[0], validatedInput[1]);\n      }).then(function () {\n        return _this2.runtime.emitProjectLoaded();\n      }).catch(function (error) {\n        \n        if (error.hasOwnProperty('validationError')) {\n       sError(JSON.stringify(error));\n          return Promise.reject(JSON.stringify(error));\n        }\n        return Promise.reject(error);\n      });\n    }\n   \n  }, {\n    key: \"downloadProjectId\",\n    value: function downloadProjectId(id) {\n      var storage = this.runtime.storage;\n      if (!storage) {\n        log.error('No storage module present; cannot load project: ', id);\n        return;\n      }\n      var vm = this;\n      var promise = storage.load(storage.AssetType.Project, id);\n      promise.then(function (projectAsset) {\n        vm.loadProject(projectAsset.data);\n      });\n    }\n   \n  }, {\n    key: \"saveProjectSb3\",\n    value: function saveProjectSb3() {\n      var soundDescs = serializeSounds(this.runtime);\n      var costumeDescs = serializeCostumes(this.runtime);\n      var projectJson = this.toJSON(); \n      \n      var zip = new JSZip(); \n      zip.file('project.json', projectJson);\n      this._addFileDescsToZip(soundDescs.concat(costumeDescs), zip);\n      return zip.generateAsync({\n        type: 'blob',\n        mimeType: 'application/x.scratch.sb3',\n        compression: 'DEFLATE',\n        compressionOptions: {\n          level: 6 \n        }\n      });\n    }\n   \n  }, {\n    key: \"saveProjectOnline\",\n    value: function saveProjectOnline(bAutoSave) {\n      var soundDescs = serializeSounds(this.runtime);\n      var costumeDescs = serializeCostumes(this.runtime);\n      var projectJson = this.toJSON(); \n      \n      var zip = new JSZip(); \n      zip.file('project.json', projectJson);\n      this._addFileDescsToZip(soundDescs.concat(costumeDescs), zip);\n\t \n \t  zip.generateAsync({type:\"Blob\",compression: \"DEFLATE\"}).then(function(content) {\n\t\tvar file = new File([content],'SCRATCH.zip',{type: \"zip\"});\n\t\tvar formData = new FormData();\n\t\tformData.append(\"SBFILE\",file);\n\t\t\n\t\t $.ajax({\n\t\t\turl:bAutoSave==true?'autosaveProject.php':'saveProject.php',\n\t\t\ttype:'POST',\n\t\t\tdata:formData,\n\t\t\tprocessData:false,\n\t\t\tcontentType:false,\n\t\t\tsuccess:function (data) {\n              saveStatus(data);\n\t\t\t}\n\t\t });\n      });\n    }\n   \n  }, {\n    key: \"_addFileDescsToZip\",\n    value: function _addFileDescsToZip(fileDescs, zip) {\n      for (var i = 0; i < fileDescs.length; i++) {\n        var currFileDesc = fileDescs[i];\n        zip.file(currFileDesc.fileName, currFileDesc.fileContent);\n      }\n    }\n   \n  }, {\n    key: \"exportSprite\",\n    value: function exportSprite(targetId, optZipType) {\n      var sb3 = __webpack_require__(186);\n      var soundDescs = serializeSounds(this.runtime, targetId);\n      var costumeDescs = serializeCostumes(this.runtime, targetId);\n      var spriteJson = StringUtil.stringify(sb3.serialize(this.runtime, targetId));\n      var zip = new JSZip();\n      zip.file('sprite.json', spriteJson);\n      this._addFileDescsToZip(soundDescs.concat(costumeDescs), zip);\n      return zip.generateAsync({\n        type: typeof optZipType === 'string' ? optZipType : 'blob',\n        mimeType: 'application/x.scratch.sprite3',\n        compression: 'DEFLATE',\n        compressionOptions: {\n          level: 6\n        }\n      });\n    }\n   \n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var sb3 = __webpack_require__(186);\n      return StringUtil.stringify(sb3.serialize(this.runtime));\n    } \n    \n   \n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      log.warning('fromJSON is now just a wrapper around loadProject, please use that function instead.');\n      return this.loadProject(json);\n    }\n   \n  }, {\n    key: \"deserializeProject\",\n    value: function deserializeProject(projectJSON, zip) {\n      var _this3 = this;\n      \n      this.clear();\n      var runtime = this.runtime;\n      var deserializePromise = function deserializePromise() {\n        var projectVersion = projectJSON.projectVersion;\n        if (projectVersion === 2) {\n          var sb2 = __webpack_require__(481);\n          return sb2.deserialize(projectJSON, runtime, false, zip);\n        }\n        if (projectVersion === 3) {\n          var sb3 = __webpack_require__(186);\n          return sb3.deserialize(projectJSON, runtime, zip);\n        }\n        return Promise.reject('Unable to verify Scratch Project version.');\n      };\n      return deserializePromise().then(function (_ref) {\n        var targets = _ref.targets,\n            extensions = _ref.extensions;\n        return _this3.installTargets(targets, extensions, true);\n      });\n    }\n   \n  }, {\n    key: \"installTargets\",\n    value: function installTargets(targets, extensions, wholeProject) {\n      var _this4 = this;\n      var extensionPromises = [];\n      extensions.extensionIDs.forEach(function (extensionID) {\n        if (!_this4.extensionManager.isExtensionLoaded(extensionID)) {\n          var extensionURL = extensions.extensionURLs.get(extensionID) || extensionID;\n          extensionPromises.push(_this4.extensionManager.loadExtensionURL(extensionURL));\n        }\n      });\n      targets = targets.filter(function (target) {\n        return !!target;\n      });\n      return Promise.all(extensionPromises).then(function () {\n        targets.forEach(function (target) {\n          _this4.runtime.addTarget(target);\n         \n          target.updateAllDrawableProperties(); \n          if (target.isSprite()) _this4.renameSprite(target.id, target.getName());\n        }); \n        \n        _this4.runtime.executableTargets.sort(function (a, b) {\n          return a.layerOrder - b.layerOrder;\n        });\n        targets.forEach(function (target) {\n          delete target.layerOrder;\n        }); \n        if (wholeProject && targets.length > 1) {\n          _this4.editingTarget = targets[1];\n        } else {\n          _this4.editingTarget = targets[0];\n        }\n        if (!wholeProject) {\n          _this4.editingTarget.fixUpVariableReferences();\n        } \n        _this4.emitTargetsUpdate(false\n       \n        );\n        _this4.emitWorkspaceUpdate();\n        _this4.runtime.setEditingTarget(_this4.editingTarget);\n        _this4.runtime.ioDevices.cloud.setStage(_this4.runtime.getTargetForStage());\n      });\n    }\n   \n  }, {\n    key: \"addSprite\",\n    value: function addSprite(input) {\n      var _this5 = this;\n      var errorPrefix = 'Sprite Upload Error:';\n      if (_typeof(input) === 'object' && !(input instanceof ArrayBuffer) && !ArrayBuffer.isView(input)) {\n        \n        \n        \n        \n        \n        \n        input = JSON.stringify(input);\n      }\n      var validationPromise = new Promise(function (resolve, reject) {\n        var validate = __webpack_require__(454); \n        \n        \n        validate(input, true, function (error, res) {\n          if (error) return reject(error);\n          resolve(res);\n        });\n      });\n      scratchStatus(\"BACKUPNEEDED\");\n      return validationPromise.then(function (validatedInput) {\n        var projectVersion = validatedInput[0].projectVersion;\n        if (projectVersion === 2) {\n          return _this5._addSprite2(validatedInput[0], validatedInput[1]);\n        }\n        if (projectVersion === 3) {\n          return _this5._addSprite3(validatedInput[0], validatedInput[1]);\n        }\n        return Promise.reject(\"\".concat(errorPrefix, \" Unable to verify sprite version.\"));\n      }).then(function () {\n        return _this5.runtime.emitProjectChanged();\n      }).catch(function (error) {\n        \n        if (error.hasOwnProperty('validationError')) {\n       sError(JSON.stringify(error));\n          return Promise.reject(JSON.stringify(error));\n        }\n        return Promise.reject(\"\".concat(errorPrefix, \" \").concat(error));\n      });\n    }\n   \n  }, {\n    key: \"_addSprite2\",\n    value: function _addSprite2(sprite, zip) {\n      var _this6 = this;\n      \n      var sb2 = __webpack_require__(481);\n      return sb2.deserialize(sprite, this.runtime, true, zip).then(function (_ref2) {\n        var targets = _ref2.targets,\n            extensions = _ref2.extensions;\n        return _this6.installTargets(targets, extensions, false);\n      });\n    }\n   \n  }, {\n    key: \"_addSprite3\",\n    value: function _addSprite3(sprite, zip) {\n      var _this7 = this;\n      \n      var sb3 = __webpack_require__(186);\n      return sb3.deserialize(sprite, this.runtime, zip, true).then(function (_ref3) {\n        var targets = _ref3.targets,\n            extensions = _ref3.extensions;\n        return _this7.installTargets(targets, extensions, false);\n      });\n    }\n   \n  }, {\n    key: \"addCostume\",\n    value: function addCostume(md5ext, costumeObject, optTargetId, optVersion) {\n      var _this8 = this;\n      var target = optTargetId ? this.runtime.getTargetById(optTargetId) : this.editingTarget;\n      if (target) {\n        scratchStatus(\"BACKUPNEEDED\");\n        return loadCostume(md5ext, costumeObject, this.runtime, optVersion).then(function () {\n          target.addCostume(costumeObject);\n          target.setCostume(target.getCostumes().length - 1);\n          _this8.runtime.emitProjectChanged();\n        });\n      } \n      return Promise.reject();\n    }\n   \n  }, {\n    key: \"addCostumeFromLibrary\",\n    value: function addCostumeFromLibrary(md5ext, costumeObject) {\n      if (!this.editingTarget) return Promise.reject();\n      return this.addCostume(md5ext, costumeObject, this.editingTarget.id, 2\n     \n      );\n    }\n   \n  }, {\n    key: \"duplicateCostume\",\n    value: function duplicateCostume(costumeIndex) {\n      var _this9 = this;\n      var originalCostume = this.editingTarget.getCostumes()[costumeIndex];\n      var clone = Object.assign({}, originalCostume);\n      var md5ext = \"\".concat(clone.assetId, \".\").concat(clone.dataFormat);\n      return loadCostume(md5ext, clone, this.runtime).then(function () {\n        _this9.editingTarget.addCostume(clone, costumeIndex + 1);\n        _this9.editingTarget.setCostume(costumeIndex + 1);\n        _this9.emitTargetsUpdate();\n      });\n    }\n   \n  }, {\n    key: \"duplicateSound\",\n    value: function duplicateSound(soundIndex) {\n      var _this10 = this;\n      var originalSound = this.editingTarget.getSounds()[soundIndex];\n      var clone = Object.assign({}, originalSound);\n      return loadSound(clone, this.runtime, this.editingTarget.sprite.soundBank).then(function () {\n        _this10.editingTarget.addSound(clone, soundIndex + 1);\n        _this10.emitTargetsUpdate();\n      });\n    }\n   \n  }, {\n    key: \"renameCostume\",\n    value: function renameCostume(costumeIndex, newName) {\n      this.editingTarget.renameCostume(costumeIndex, newName);\n      this.emitTargetsUpdate();\n    }\n   \n  }, {\n    key: \"deleteCostume\",\n    value: function deleteCostume(costumeIndex) {\n      var _this11 = this;\n      var deletedCostume = this.editingTarget.deleteCostume(costumeIndex);\n      if (deletedCostume) {\n        var target = this.editingTarget;\n        this.runtime.emitProjectChanged();\n        return function () {\n          target.addCostume(deletedCostume);\n          _this11.emitTargetsUpdate();\n        };\n      }\n      return null;\n    }\n   \n  }, {\n    key: \"addSound\",\n    value: function addSound(soundObject, optTargetId) {\n      var _this12 = this;\n      var target = optTargetId ? this.runtime.getTargetById(optTargetId) : this.editingTarget;\n      if (target) {\n        return loadSound(soundObject, this.runtime, target.sprite.soundBank).then(function () {\n          target.addSound(soundObject);\n          _this12.emitTargetsUpdate();\n        });\n      } \n      return new Promise.reject();\n    }\n   \n  }, {\n    key: \"renameSound\",\n    value: function renameSound(soundIndex, newName) {\n      this.editingTarget.renameSound(soundIndex, newName);\n      this.emitTargetsUpdate();\n    }\n   \n  }, {\n    key: \"getSoundBuffer\",\n    value: function getSoundBuffer(soundIndex) {\n      var id = this.editingTarget.sprite.sounds[soundIndex].soundId;\n      if (id && this.runtime && this.runtime.audioEngine) {\n        return this.editingTarget.sprite.soundBank.getSoundPlayer(id).buffer;\n      }\n      return null;\n    }\n   \n  }, {\n    key: \"updateSoundBuffer\",\n    value: function updateSoundBuffer(soundIndex, newBuffer, soundEncoding) {\n      var sound = this.editingTarget.sprite.sounds[soundIndex];\n      var id = sound ? sound.soundId : null;\n      if (id && this.runtime && this.runtime.audioEngine) {\n        this.editingTarget.sprite.soundBank.getSoundPlayer(id).buffer = newBuffer;\n      } \n      if (soundEncoding) {\n        \n        \n        \n        \n        \n        sound.format = '';\n        var storage = this.runtime.storage;\n        sound.asset = storage.createAsset(storage.AssetType.Sound, storage.DataFormat.WAV, soundEncoding, null, true \n        );\n        sound.assetId = sound.asset.assetId;\n        sound.dataFormat = storage.DataFormat.WAV;\n        sound.md5 = \"\".concat(sound.assetId, \".\").concat(sound.dataFormat);\n        sound.sampleCount = newBuffer.length;\n        sound.rate = newBuffer.sampleRate;\n      } \n      \n      \n      this.emitTargetsUpdate();\n    }\n   \n  }, {\n    key: \"deleteSound\",\n    value: function deleteSound(soundIndex) {\n      var _this13 = this;\n      var target = this.editingTarget;\n      var deletedSound = this.editingTarget.deleteSound(soundIndex);\n      if (deletedSound) {\n        this.runtime.emitProjectChanged();\n        var restoreFun = function restoreFun() {\n          target.addSound(deletedSound);\n          _this13.emitTargetsUpdate();\n        };\n        return restoreFun;\n      }\n      return null;\n    }\n   \n  }, {\n    key: \"getCostume\",\n    value: function getCostume(costumeIndex) {\n      var asset = this.editingTarget.getCostumes()[costumeIndex].asset;\n      if (!asset || !this.runtime || !this.runtime.storage) return null;\n      var format = asset.dataFormat;\n      if (format === this.runtime.storage.DataFormat.SVG) {\n        return asset.decodeText();\n      } else if (format === this.runtime.storage.DataFormat.PNG || format === this.runtime.storage.DataFormat.JPG) {\n        return asset.encodeDataURI();\n      }\n      log.error(\"Unhandled format: \".concat(asset.dataFormat));\n      return null;\n    }\n   \n  }, {\n    key: \"updateBitmap\",\n    value: function updateBitmap(costumeIndex, bitmap, rotationCenterX, rotationCenterY, bitmapResolution) {\n      var _this14 = this;\n      var costume = this.editingTarget.getCostumes()[costumeIndex];\n      if (!(costume && this.runtime && this.runtime.renderer)) return;\n      costume.rotationCenterX = rotationCenterX;\n      costume.rotationCenterY = rotationCenterY; \n      var bitmapWidth = bitmap.sourceWidth === 0 ? 0 : bitmap.width;\n      var bitmapHeight = bitmap.sourceHeight === 0 ? 0 : bitmap.height; \n      var canvas = document.createElement('canvas');\n      canvas.width = bitmapWidth;\n      canvas.height = bitmapHeight;\n      var context = canvas.getContext('2d',{willReadFrequently:true});\n      context.putImageData(bitmap, 0, 0); \n      \n      this.runtime.renderer.updateBitmapSkin(costume.skinId, canvas, bitmapResolution, [rotationCenterX / bitmapResolution, rotationCenterY / bitmapResolution]); \n      canvas.toBlob(function (blob) {\n        var reader = new FileReader();\n        reader.addEventListener('loadend', function () {\n          var storage = _this14.runtime.storage;\n          costume.dataFormat = storage.DataFormat.PNG;\n          costume.bitmapResolution = bitmapResolution;\n          costume.size = [bitmapWidth, bitmapHeight];\n          costume.asset = storage.createAsset(storage.AssetType.ImageBitmap, costume.dataFormat, Buffer.from(reader.result), null, \n          true \n          );\n          costume.assetId = costume.asset.assetId;\n          costume.md5 = \"\".concat(costume.assetId, \".\").concat(costume.dataFormat);\n          _this14.emitTargetsUpdate();\n        }); \n        if (blob) {\n          reader.readAsArrayBuffer(blob);\n        }\n      });\n    }\n   \n  }, {\n    key: \"updateSvg\",\n    value: function updateSvg(costumeIndex, svg, rotationCenterX, rotationCenterY) {\n      var costume = this.editingTarget.getCostumes()[costumeIndex];\n      if (costume && this.runtime && this.runtime.renderer) {\n        costume.rotationCenterX = rotationCenterX;\n        costume.rotationCenterY = rotationCenterY;\n        this.runtime.renderer.updateSVGSkin(costume.skinId, svg, [rotationCenterX, rotationCenterY]);\n        costume.size = this.runtime.renderer.getSkinSize(costume.skinId);\n      }\n      var storage = this.runtime.storage; \n      \n      costume.dataFormat = storage.DataFormat.SVG;\n      costume.bitmapResolution = 1;\n      costume.asset = storage.createAsset(storage.AssetType.ImageVector, costume.dataFormat, new _TextEncoder().encode(svg), null, true \n      );\n      costume.assetId = costume.asset.assetId;\n      costume.md5 = \"\".concat(costume.assetId, \".\").concat(costume.dataFormat);\n      this.emitTargetsUpdate();\n    }\n   \n  }, {\n    key: \"addBackdrop\",\n    value: function addBackdrop(md5ext, backdropObject) {\n      var _this15 = this;\n      return loadCostume(md5ext, backdropObject, this.runtime).then(function () {\n        var stage = _this15.runtime.getTargetForStage();\n        stage.addCostume(backdropObject);\n        stage.setCostume(stage.getCostumes().length - 1);\n        _this15.runtime.emitProjectChanged();\n      });\n    }\n   \n  }, {\n    key: \"renameSprite\",\n    value: function renameSprite(targetId, newName) {\n      var target = this.runtime.getTargetById(targetId);\n      if (target) {\n        if (!target.isSprite()) {\n          throw new Error('Cannot rename non-sprite targets.');\n        }\n        var sprite = target.sprite;\n        if (!sprite) {\n          throw new Error('No sprite associated with this target.');\n        }\n        if (newName && RESERVED_NAMES.indexOf(newName) === -1) {\n          var names = this.runtime.targets.filter(function (runtimeTarget) {\n            return runtimeTarget.isSprite() && runtimeTarget.id !== target.id;\n          }).map(function (runtimeTarget) {\n            return runtimeTarget.sprite.name;\n          });\n          var oldName = sprite.name;\n          var newUnusedName = StringUtil.unusedName(newName, names);\n          sprite.name = newUnusedName;\n          var allTargets = this.runtime.targets;\n          for (var i = 0; i < allTargets.length; i++) {\n            var currTarget = allTargets[i];\n            currTarget.blocks.updateAssetName(oldName, newName, 'sprite');\n          }\n          if (newUnusedName !== oldName) this.emitTargetsUpdate();\n        }\n      } else {\n        throw new Error('No target with the provided id.');\n      }\n    }\n   \n  }, {\n    key: \"deleteSprite\",\n    value: function deleteSprite(targetId) {\n      var _this16 = this;\n      var target = this.runtime.getTargetById(targetId);\n      if (target) {\n        var targetIndexBeforeDelete = this.runtime.targets.map(function (t) {\n          return t.id;\n        }).indexOf(target.id);\n        if (!target.isSprite()) {\n          throw new Error('Cannot delete non-sprite targets.');\n        }\n        var sprite = target.sprite;\n        if (!sprite) {\n          throw new Error('No sprite associated with this target.');\n        }\n        var spritePromise = this.exportSprite(targetId, 'uint8array');\n        var restoreSprite = function restoreSprite() {\n          return spritePromise.then(function (spriteBuffer) {\n            return _this16.addSprite(spriteBuffer);\n          });\n        }; \n        \n        target.deleteMonitors();\n        var currentEditingTarget = this.editingTarget;\n        for (var i = 0; i < sprite.clones.length; i++) {\n          var clone = sprite.clones[i];\n          this.runtime.stopForTarget(sprite.clones[i]);\n          this.runtime.disposeTarget(sprite.clones[i]); \n          if (clone === currentEditingTarget) {\n            var nextTargetIndex = Math.min(this.runtime.targets.length - 1, targetIndexBeforeDelete);\n            if (this.runtime.targets.length > 0) {\n              this.setEditingTarget(this.runtime.targets[nextTargetIndex].id);\n            } else {\n              this.editingTarget = null;\n            }\n          }\n        } \n        scratchStatus(\"BACKUPNEEDED\");\n        this.emitTargetsUpdate();\n        return restoreSprite;\n      }\n      throw new Error('No target with the provided id.');\n    }\n   \n  }, {\n    key: \"duplicateSprite\",\n    value: function duplicateSprite(targetId) {\n      var _this17 = this;\n      var target = this.runtime.getTargetById(targetId);\n      if (!target) {\n        throw new Error('No target with the provided id.');\n      } else if (!target.isSprite()) {\n        throw new Error('Cannot duplicate non-sprite targets.');\n      } else if (!target.sprite) {\n        throw new Error('No sprite associated with this target.');\n      }\n      return target.duplicate().then(function (newTarget) {\n        _this17.runtime.addTarget(newTarget);\n        newTarget.goBehindOther(target);\n        _this17.setEditingTarget(newTarget.id);\n      });\n    }\n   \n  }, {\n    key: \"attachAudioEngine\",\n    value: function attachAudioEngine(audioEngine) {\n      this.runtime.attachAudioEngine(audioEngine);\n    }\n   \n  }, {\n    key: \"attachRenderer\",\n    value: function attachRenderer(renderer) {\n      this.runtime.attachRenderer(renderer);\n    }\n   \n  }, {\n    key: \"attachV2SVGAdapter\",\n   \n    value: function attachV2SVGAdapter(svgAdapter) {\n      this.runtime.attachV2SVGAdapter(svgAdapter);\n    }\n   \n  }, {\n    key: \"attachV2BitmapAdapter\",\n    value: function attachV2BitmapAdapter(bitmapAdapter) {\n      this.runtime.attachV2BitmapAdapter(bitmapAdapter);\n    }\n   \n  }, {\n    key: \"attachStorage\",\n    value: function attachStorage(storage) {\n      this.runtime.attachStorage(storage);\n    }\n   \n  }, {\n    key: \"setLocale\",\n    value: function setLocale(locale, messages) {\n      if (locale !== formatMessage.setup().locale) {\n        formatMessage.setup({\n          locale: locale,\n          translations: _defineProperty({}, locale, messages)\n        });\n      }\n      scratchStatus(\"SETLOCALE\");\n      return this.extensionManager.refreshBlocks();\n    }\n   \n  }, {\n    key: \"getLocale\",\n    value: function getLocale() {\n      return formatMessage.setup().locale;\n    }\n   \n  }, {\n    key: \"blockListener\",\n    value: function blockListener(e) {\n      if (this.editingTarget) {\n        this.editingTarget.blocks.blocklyListen(e);\n      }\n    }\n   \n  }, {\n    key: \"flyoutBlockListener\",\n    value: function flyoutBlockListener(e) {\n      this.runtime.flyoutBlocks.blocklyListen(e);\n    }\n   \n  }, {\n    key: \"monitorBlockListener\",\n    value: function monitorBlockListener(e) {\n      \n      \n      if (['create', 'change'].indexOf(e.type) !== -1) {\n        this.runtime.monitorBlocks.blocklyListen(e);\n      }\n    }\n   \n  }, {\n    key: \"variableListener\",\n    value: function variableListener(e) {\n      \n      \n      if (['var_create', 'var_rename', 'var_delete'].indexOf(e.type) !== -1) {\n        this.runtime.getTargetForStage().blocks.blocklyListen(e);\n      }\n    }\n   \n  }, {\n    key: \"setEditingTarget\",\n    value: function setEditingTarget(targetId) {\n      \n      if (this.editingTarget && targetId === this.editingTarget.id) {\n        return;\n      }\n      var target = this.runtime.getTargetById(targetId);\n      if (target) {\n        this.editingTarget = target; \n        this.emitTargetsUpdate(false\n       \n        );\n        this.emitWorkspaceUpdate();\n        this.runtime.setEditingTarget(target);\n      }\n    }\n   \n  }, {\n    key: \"shareBlocksToTarget\",\n    value: function shareBlocksToTarget(blocks, targetId, optFromTargetId) {\n      var _this18 = this;\n      var sb3 = __webpack_require__(186);\n      var copiedBlocks = JSON.parse(JSON.stringify(blocks));\n      newBlockIds(copiedBlocks);\n      var target = this.runtime.getTargetById(targetId);\n      if (optFromTargetId) {\n        \n        \n        var fromTarget = this.runtime.getTargetById(optFromTargetId);\n        fromTarget.resolveVariableSharingConflictsWithTarget(copiedBlocks, target);\n      } \n      var extensionIDs = new Set(copiedBlocks.map(function (b) {\n        return sb3.getExtensionIdForOpcode(b.opcode);\n      }).filter(function (id) {\n        return !!id;\n      }) \n      .filter(function (id) {\n        return !_this18.extensionManager.isExtensionLoaded(id);\n      }) \n      ); \n      var extensionPromises = Array.from(extensionIDs, function (id) {\n        return _this18.extensionManager.loadExtensionURL(id);\n      });\n      return Promise.all(extensionPromises).then(function () {\n        copiedBlocks.forEach(function (block) {\n          target.blocks.createBlock(block);\n        });\n        target.blocks.updateTargetSpecificBlocks(target.isStage);\n      });\n    }\n   \n  }, {\n    key: \"shareCostumeToTarget\",\n    value: function shareCostumeToTarget(costumeIndex, targetId) {\n      var _this19 = this;\n      var originalCostume = this.editingTarget.getCostumes()[costumeIndex];\n      var clone = Object.assign({}, originalCostume);\n      var md5ext = \"\".concat(clone.assetId, \".\").concat(clone.dataFormat);\n      return loadCostume(md5ext, clone, this.runtime).then(function () {\n        var target = _this19.runtime.getTargetById(targetId);\n        if (target) {\n          target.addCostume(clone);\n          target.setCostume(target.getCostumes().length - 1);\n        }\n      });\n    }\n   \n  }, {\n    key: \"shareSoundToTarget\",\n    value: function shareSoundToTarget(soundIndex, targetId) {\n      var _this20 = this;\n      var originalSound = this.editingTarget.getSounds()[soundIndex];\n      var clone = Object.assign({}, originalSound);\n      var target = this.runtime.getTargetById(targetId);\n      return loadSound(clone, this.runtime, target.sprite.soundBank).then(function () {\n        if (target) {\n          target.addSound(clone);\n          _this20.emitTargetsUpdate();\n        }\n      });\n    }\n   \n  }, {\n    key: \"refreshWorkspace\",\n    value: function refreshWorkspace() {\n      if (this.editingTarget) {\n        this.emitWorkspaceUpdate();\n        this.runtime.setEditingTarget(this.editingTarget);\n        this.emitTargetsUpdate(false\n       \n        );\n      }\n    }\n   \n  }, {\n    key: \"emitTargetsUpdate\",\n    value: function emitTargetsUpdate(triggerProjectChange) {\n      if (typeof triggerProjectChange === 'undefined') triggerProjectChange = true;\n      this.emit('targetsUpdate', {\n        \n        targetList: this.runtime.targets.filter( \n        function (target) {\n          return !target.hasOwnProperty('isOriginal') || target.isOriginal;\n        }).map(function (target) {\n          return target.toJSON();\n        }),\n        \n        editingTarget: this.editingTarget ? this.editingTarget.id : null\n      });\n      if (triggerProjectChange) {\n        this.runtime.emitProjectChanged();\n      }\n    }\n   \n  }, {\n    key: \"emitWorkspaceUpdate\",\n    value: function emitWorkspaceUpdate() {\n      var _this21 = this;\n      \n      var stageVariables = this.runtime.getTargetForStage().variables;\n      var messageIds = [];\n      for (var varId in stageVariables) {\n        if (stageVariables[varId].type === Variable.BROADCAST_MESSAGE_TYPE) {\n          messageIds.push(varId);\n        }\n      } \n      \n      for (var i = 0; i < this.runtime.targets.length; i++) {\n        var currTarget = this.runtime.targets[i];\n        var currBlocks = currTarget.blocks._blocks;\n        for (var blockId in currBlocks) {\n          if (currBlocks[blockId].fields.BROADCAST_OPTION) {\n            var id = currBlocks[blockId].fields.BROADCAST_OPTION.id;\n            var index = messageIds.indexOf(id);\n            if (index !== -1) {\n              messageIds = messageIds.slice(0, index).concat(messageIds.slice(index + 1));\n            }\n          }\n        }\n      } \n      for (var _i = 0; _i < messageIds.length; _i++) {\n        var _id = messageIds[_i];\n        delete this.runtime.getTargetForStage().variables[_id];\n      }\n      var globalVarMap = Object.assign({}, this.runtime.getTargetForStage().variables);\n      var localVarMap = this.editingTarget.isStage ? Object.create(null) : Object.assign({}, this.editingTarget.variables);\n      var globalVariables = Object.keys(globalVarMap).map(function (k) {\n        return globalVarMap[k];\n      });\n      var localVariables = Object.keys(localVarMap).map(function (k) {\n        return localVarMap[k];\n      });\n      var workspaceComments = Object.keys(this.editingTarget.comments).map(function (k) {\n        return _this21.editingTarget.comments[k];\n      }).filter(function (c) {\n        return c.blockId === null;\n      });\n      var xmlString = \"<xml xmlns=\\\"http://www.w3.org/1999/xhtml\\\">\\n                            <variables>\\n                                \".concat(globalVariables.map(function (v) {\n        return v.toXML();\n      }).join(), \"\\n                                \").concat(localVariables.map(function (v) {\n        return v.toXML(true);\n      }).join(), \"\\n                            </variables>\\n                            \").concat(workspaceComments.map(function (c) {\n        return c.toXML();\n      }).join(), \"\\n                            \").concat(this.editingTarget.blocks.toXML(this.editingTarget.comments), \"\\n                        </xml>\");\n      this.emit('workspaceUpdate', {\n        xml: xmlString\n      });\n    }\n   \n  }, {\n    key: \"getTargetIdForDrawableId\",\n    value: function getTargetIdForDrawableId(drawableId) {\n      var target = this.runtime.getTargetByDrawableId(drawableId);\n      if (target && target.hasOwnProperty('id') && target.hasOwnProperty('isStage') && !target.isStage) {\n        return target.id;\n      }\n      return null;\n    }\n   \n  }, {\n    key: \"reorderTarget\",\n    value: function reorderTarget(targetIndex, newIndex) {\n      var targets = this.runtime.targets;\n      targetIndex = MathUtil.clamp(targetIndex, 0, targets.length - 1);\n      newIndex = MathUtil.clamp(newIndex, 0, targets.length - 1);\n      if (targetIndex === newIndex) return false;\n      var target = targets[targetIndex];\n      targets = targets.slice(0, targetIndex).concat(targets.slice(targetIndex + 1));\n      targets.splice(newIndex, 0, target);\n      this.runtime.targets = targets;\n      this.emitTargetsUpdate();\n      return true;\n    }\n   \n  }, {\n    key: \"reorderCostume\",\n    value: function reorderCostume(targetId, costumeIndex, newIndex) {\n      var target = this.runtime.getTargetById(targetId);\n      if (target) {\n        var reorderSuccessful = target.reorderCostume(costumeIndex, newIndex);\n        if (reorderSuccessful) {\n          this.runtime.emitProjectChanged();\n        }\n        return reorderSuccessful;\n      }\n      return false;\n    }\n   \n  }, {\n    key: \"reorderSound\",\n    value: function reorderSound(targetId, soundIndex, newIndex) {\n      var target = this.runtime.getTargetById(targetId);\n      if (target) {\n        var reorderSuccessful = target.reorderSound(soundIndex, newIndex);\n        if (reorderSuccessful) {\n          this.runtime.emitProjectChanged();\n        }\n        return reorderSuccessful;\n      }\n      return false;\n    }\n   \n  }, {\n    key: \"startDrag\",\n    value: function startDrag(targetId) {\n      var target = this.runtime.getTargetById(targetId);\n      if (target) {\n        this._dragTarget = target;\n        target.startDrag();\n      }\n    }\n   \n  }, {\n    key: \"stopDrag\",\n    value: function stopDrag(targetId) {\n      var target = this.runtime.getTargetById(targetId);\n      if (target) {\n        this._dragTarget = null;\n        target.stopDrag();\n        this.setEditingTarget(target.sprite && target.sprite.clones[0] ? target.sprite.clones[0].id : target.id);\n      }\n    }\n   \n  }, {\n    key: \"postSpriteInfo\",\n    value: function postSpriteInfo(data) {\n      if (this._dragTarget) {\n        this._dragTarget.postSpriteInfo(data);\n      } else {\n        this.editingTarget.postSpriteInfo(data);\n      } \n      \n      \n      \n      this.runtime.emitProjectChanged();\n    }\n   \n  }, {\n    key: \"setVariableValue\",\n    value: function setVariableValue(targetId, variableId, value) {\n      var target = this.runtime.getTargetById(targetId);\n      if (target) {\n        var variable = target.lookupVariableById(variableId);\n        if (variable) {\n          variable.value = value;\n          if (variable.isCloud) {\n            this.runtime.ioDevices.cloud.requestUpdateVariable(variable.name, variable.value);\n          }\n          return true;\n        }\n      }\n      return false;\n    }\n   \n  }, {\n    key: \"getVariableValue\",\n    value: function getVariableValue(targetId, variableId) {\n      var target = this.runtime.getTargetById(targetId);\n      if (target) {\n        var variable = target.lookupVariableById(variableId);\n        if (variable) {\n          return variable.value;\n        }\n      }\n      return null;\n    }\n   \n  }, {\n    key: \"configureScratchLinkSocketFactory\",\n    value: function configureScratchLinkSocketFactory(factory) {\n      this.runtime.configureScratchLinkSocketFactory(factory);\n    }\n  }, {\n    key: \"assets\",\n    get: function get() {\n      return this.runtime.targets.reduce(function (acc, target) {\n        return acc.concat(target.sprite.sounds.map(function (sound) {\n          return sound.asset;\n        })).concat(target.sprite.costumes.map(function (costume) {\n          return costume.asset;\n        }));\n      }, []);\n    }\n  }, {\n    key: \"renderer\",\n    get: function get() {\n      return this.runtime && this.runtime.renderer;\n    }\n  }]);\n  return VirtualMachine;\n}(EventEmitter);\nmodule.exports = VirtualMachine;\n })