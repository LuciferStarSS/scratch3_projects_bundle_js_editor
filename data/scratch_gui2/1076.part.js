/* 1076 */\n (function(module, exports, __webpack_require__) {\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nvar Thread = __webpack_require__(224);\nvar Timer = __webpack_require__(136);\n/**\n * @fileoverview\n * Interface provided to block primitive functions for interacting with the\n * runtime, thread, target, and convenient methods.\n */\nvar BlockUtility = function () {\n  function BlockUtility() {\n    var _this = this;\n    var sequencer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var thread = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    _classCallCheck(this, BlockUtility);\n   \n    this.sequencer = sequencer;\n   \n    this.thread = thread;\n    this._nowObj = {\n      now: function now() {\n        return _this.sequencer.runtime.currentMSecs;\n      }\n    };\n  }\n \n  _createClass(BlockUtility, [{\n    key: \"stackTimerFinished\",\n   \n    value: function stackTimerFinished() {\n      var timeElapsed = this.stackFrame.timer.timeElapsed();\n      if (timeElapsed < this.stackFrame.duration) {\n        return false;\n      }\n      return true;\n    }\n   \n  }, {\n    key: \"stackTimerNeedsInit\",\n    value: function stackTimerNeedsInit() {\n      return !this.stackFrame.timer;\n    }\n   \n  }, {\n    key: \"startStackTimer\",\n    value: function startStackTimer(duration) {\n      if (this.nowObj) {\n        this.stackFrame.timer = new Timer(this.nowObj);\n      } else {\n        this.stackFrame.timer = new Timer();\n      }\n      this.stackFrame.timer.start();\n      this.stackFrame.duration = duration;\n    }\n   \n  }, {\n    key: \"yield\",\n    value: function _yield() {\n      this.thread.status = Thread.STATUS_YIELD;\n    }\n   \n  }, {\n    key: \"yieldTick\",\n    value: function yieldTick() {\n      this.thread.status = Thread.STATUS_YIELD_TICK;\n    }\n   \n  }, {\n    key: \"startBranch\",\n    value: function startBranch(branchNum, isLoop) {\n      this.sequencer.stepToBranch(this.thread, branchNum, isLoop);\n    }\n   \n  }, {\n    key: \"stopAll\",\n    value: function stopAll() {\n      this.sequencer.runtime.stopAll();\n    }\n   \n  }, {\n    key: \"stopOtherTargetThreads\",\n    value: function stopOtherTargetThreads() {\n      this.sequencer.runtime.stopForTarget(this.thread.target, this.thread);\n    }\n   \n  }, {\n    key: \"stopThisScript\",\n    value: function stopThisScript() {\n      this.thread.stopThisScript();\n    }\n   \n  }, {\n    key: \"startProcedure\",\n    value: function startProcedure(procedureCode) {\n      this.sequencer.stepToProcedure(this.thread, procedureCode);\n    }\n   \n  }, {\n    key: \"getProcedureParamNamesAndIds\",\n    value: function getProcedureParamNamesAndIds(procedureCode) {\n      return this.thread.target.blocks.getProcedureParamNamesAndIds(procedureCode);\n    }\n   \n  }, {\n    key: \"getProcedureParamNamesIdsAndDefaults\",\n    value: function getProcedureParamNamesIdsAndDefaults(procedureCode) {\n      return this.thread.target.blocks.getProcedureParamNamesIdsAndDefaults(procedureCode);\n    }\n   \n  }, {\n    key: \"initParams\",\n    value: function initParams() {\n      this.thread.initParams();\n    }\n   \n  }, {\n    key: \"pushParam\",\n    value: function pushParam(paramName, paramValue) {\n      this.thread.pushParam(paramName, paramValue);\n    }\n   \n  }, {\n    key: \"getParam\",\n    value: function getParam(paramName) {\n      return this.thread.getParam(paramName);\n    }\n   \n  }, {\n    key: \"startHats\",\n    value: function startHats(requestedHat, optMatchFields, optTarget) {\n      \n      \n      \n      var callerThread = this.thread;\n      var callerSequencer = this.sequencer;\n      var result = this.sequencer.runtime.startHats(requestedHat, optMatchFields, optTarget); \n      this.thread = callerThread;\n      this.sequencer = callerSequencer;\n      return result;\n    }\n   \n  }, {\n    key: \"ioQuery\",\n    value: function ioQuery(device, func, args) {\n      \n      if (this.sequencer.runtime.ioDevices[device] && this.sequencer.runtime.ioDevices[device][func]) {\n        var devObject = this.sequencer.runtime.ioDevices[device];\n        return devObject[func].apply(devObject, args);\n      }\n    }\n  }, {\n    key: \"target\",\n    get: function get() {\n      return this.thread.target;\n    }\n   \n  }, {\n    key: \"runtime\",\n    get: function get() {\n      return this.sequencer.runtime;\n    }\n   \n  }, {\n    key: \"nowObj\",\n    get: function get() {\n      if (this.runtime) {\n        return this._nowObj;\n      }\n      return null;\n    }\n   \n  }, {\n    key: \"stackFrame\",\n    get: function get() {\n      var frame = this.thread.peekStackFrame();\n      if (frame.executionContext === null) {\n        frame.executionContext = {};\n      }\n      return frame.executionContext;\n    }\n  }]);\n  return BlockUtility;\n}();\nmodule.exports = BlockUtility;\n })