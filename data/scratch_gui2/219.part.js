\n (function(module, exports, __webpack_require__) {\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nvar MathUtil = __webpack_require__(62);\nvar StringUtil = __webpack_require__(102);\nvar Cast = __webpack_require__(48);\nvar Clone = __webpack_require__(113);\nvar Target = __webpack_require__(959);\nvar StageLayering = __webpack_require__(115);\n\nvar RenderedTarget = function (_Target) {\n  _inherits(RenderedTarget, _Target);\n  var _super = _createSuper(RenderedTarget);\n  \n  function RenderedTarget(sprite, runtime) {\n    var _this;\n    _classCallCheck(this, RenderedTarget);\n    _this = _super.call(this, runtime, sprite.blocks);\n    \n    _this.sprite = sprite;\n    \n    _this.renderer = null;\n    if (_this.runtime) {\n      _this.renderer = _this.runtime.renderer;\n    }\n    \n    _this.drawableID = null;\n    \n    _this.dragging = false;\n    \n    _this.effects = {\n      color: 0,\n      fisheye: 0,\n      whirl: 0,\n      pixelate: 0,\n      mosaic: 0,\n      brightness: 0,\n      ghost: 0\n    };\n    \n    _this.isOriginal = true;\n    \n    _this.isStage = false;\n    \n    _this.x = 0;\n    \n    _this.y = 0;\n    \n    _this.direction = 90;\n    \n    _this.draggable = false;\n    \n    _this.visible = true;\n    \n    _this.size = 100;\n    \n    _this.currentCostume = 0;\n    \n    _this.rotationStyle = RenderedTarget.ROTATION_STYLE_ALL_AROUND;\n    \n    _this.volume = 100;\n    \n    _this.tempo = 60;\n    \n    _this.videoTransparency = 50;\n    \n    _this.videoState = RenderedTarget.VIDEO_STATE.ON;\n    \n    _this.textToSpeechLanguage = null;\n    return _this;\n  }\n  \n  _createClass(RenderedTarget, [{\n    key: \"initDrawable\",\n    value: function initDrawable(layerGroup) {\n      if (this.renderer) {\n        this.drawableID = this.renderer.createDrawable(layerGroup);\n      } \n      if (!this.isOriginal) {\n        this.runtime.startHats('control_start_as_clone', null, this);\n      }\n    }\n  }, {\n    key: \"initAudio\",\n    \n    value: function initAudio() {}\n    \n  }, {\n    key: \"setXY\",\n    \n    value: function setXY(x, y, force) {\n      if (this.isStage) return;\n      if (this.dragging && !force) return;\n      var oldX = this.x;\n      var oldY = this.y;\n      if (this.renderer) {\n        var position = this.renderer.getFencedPositionOfDrawable(this.drawableID, [x, y]);\n        this.x = position[0];\n        this.y = position[1];\n        this.renderer.updateDrawablePosition(this.drawableID, position);\n        if (this.visible) {\n          this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);\n          this.runtime.requestRedraw();\n        }\n      } else {\n        this.x = x;\n        this.y = y;\n      }\n      if(strInvited == this.sprite.name) updateNP(1,this.x+\",\"+this.y);\n      this.emit(RenderedTarget.EVENT_TARGET_MOVED, this, oldX, oldY, force);\n      this.runtime.requestTargetsUpdate(this);\n    }\n    \n  }, {\n    key: \"_getRenderedDirectionAndScale\",\n    value: function _getRenderedDirectionAndScale() {\n      \n      var finalDirection = this.direction;\n      var finalScale = [this.size, this.size];\n      if (this.rotationStyle === RenderedTarget.ROTATION_STYLE_NONE) {\n        \n        finalDirection = 90;\n      } else if (this.rotationStyle === RenderedTarget.ROTATION_STYLE_LEFT_RIGHT) {\n        \n        finalDirection = 90;\n        var scaleFlip = this.direction < 0 ? -1 : 1;\n        finalScale = [scaleFlip * this.size, this.size];\n      }\n      return {\n        direction: finalDirection,\n        scale: finalScale\n      };\n    }\n    \n  }, {\n    key: \"setDirection\",\n    value: function setDirection(direction) {\n      if (this.isStage) {\n        return;\n      }\n      if (!isFinite(direction)) {\n        return;\n      } \n      this.direction = MathUtil.wrapClamp(direction, -179, 180);\n      if (this.renderer) {\n        var _this$_getRenderedDir = this._getRenderedDirectionAndScale(),\n            renderedDirection = _this$_getRenderedDir.direction,\n            scale = _this$_getRenderedDir.scale;\n        this.renderer.updateDrawableDirectionScale(this.drawableID, renderedDirection, scale);\n        if (this.visible) {\n          this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);\n          if(strInvited == this.sprite.name) updateNP(2,this.direction);\n          this.runtime.requestRedraw();\n        }\n      }\n      this.runtime.requestTargetsUpdate(this);\n    }\n    \n  }, {\n    key: \"setDraggable\",\n    value: function setDraggable(draggable) {\n      if (this.isStage) return;\n      this.draggable = !!draggable;\n      this.runtime.requestTargetsUpdate(this);\n    }\n    \n  }, {\n    key: \"setVisible\",\n    value: function setVisible(visible) {\n      if (this.isStage) {\n        return;\n      }\n      this.visible = !!visible;\n      if (this.renderer) {\n        this.renderer.updateDrawableVisible(this.drawableID, this.visible);\n        if (this.visible) {\n          this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);\n          this.runtime.requestRedraw();\n        }\n      }\n      this.runtime.requestTargetsUpdate(this);\n    }\n    \n  }, {\n    key: \"setSize\",\n    value: function setSize(size) {\n      if (this.isStage) {\n        return;\n      }\n      if (this.renderer) {\n        \n        \n        var costumeSize = this.renderer.getCurrentSkinSize(this.drawableID);\n        var origW = costumeSize[0];\n        var origH = costumeSize[1];\n        var minScale = Math.min(1, Math.max(5 / origW, 5 / origH));\n        var maxScale = Math.min(4.0 * this.runtime.constructor.STAGE_WIDTH / origW, 4.0 * this.runtime.constructor.STAGE_HEIGHT / origH);\n        this.size = MathUtil.clamp(size / 100, minScale, maxScale) * 100;\n        var _this$_getRenderedDir2 = this._getRenderedDirectionAndScale(),\n            direction = _this$_getRenderedDir2.direction,\n            scale = _this$_getRenderedDir2.scale;\n        this.renderer.updateDrawableDirectionScale(this.drawableID, direction, scale);\n        if (this.visible) {\n          this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);\n          if(strInvited == this.sprite.name) updateNP(3,this.size);\n          this.runtime.requestRedraw();\n        }\n      }\n      this.runtime.requestTargetsUpdate(this);\n    }\n    \n  }, {\n    key: \"setEffect\",\n    value: function setEffect(effectName, value) {\n      if (!this.effects.hasOwnProperty(effectName)) return;\n      this.effects[effectName] = value;\n      if (this.renderer) {\n        this.renderer.updateDrawableEffect(this.drawableID, effectName, value);\n        if (this.visible) {\n          this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);\n          if(strInvited == this.sprite.name) updateNP(5,\"\\\"\"+effectName+\"\\\",\"+value);\n          this.runtime.requestRedraw();\n        }\n      }\n    }\n    \n  }, {\n    key: \"clearEffects\",\n    value: function clearEffects() {\n      for (var effectName in this.effects) {\n        if (!this.effects.hasOwnProperty(effectName)) continue;\n        this.effects[effectName] = 0;\n      }\n      if (this.renderer) {\n        for (var _effectName in this.effects) {\n          if (!this.effects.hasOwnProperty(_effectName)) continue;\n          this.renderer.updateDrawableEffect(this.drawableID, _effectName, 0);\n        }\n        if (this.visible) {\n          this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);\n          this.runtime.requestRedraw();\n        }\n      }\n    }\n    \n  }, {\n    key: \"setCostume\",\n    value: function setCostume(index) {\n      \n      index = Math.round(index);\n      if ([Infinity, -Infinity, NaN].includes(index)) index = 0;\n      this.currentCostume = MathUtil.wrapClamp(index, 0, this.sprite.costumes.length - 1);\n      if (this.renderer) {\n        var costume = this.getCostumes()[this.currentCostume];\n        this.renderer.updateDrawableSkinId(this.drawableID, costume.skinId);\n        if (this.visible) {\n          this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);\n          if(strInvited == this.sprite.name) updateNP(4,\"\\\"\"+this.sprite.costumes[this.currentCostume].md5+\"\\\",\\\"\"+this.currentCostume+\"\\\"\");\n          this.runtime.requestRedraw();\n        }\n      }\n      this.runtime.requestTargetsUpdate(this);\n    }\n    \n  }, {\n    key: \"addCostume\",\n    value: function addCostume(costumeObject, index) {\n      if (typeof index === 'number' && !isNaN(index)) {\n        this.sprite.addCostumeAt(costumeObject, index);\n      } else {\n        this.sprite.addCostumeAt(costumeObject, this.sprite.costumes.length);\n      }\n      scratchStatus(\"BACKUPNEEDED\");\n    }\n    \n  }, {\n    key: \"renameCostume\",\n    value: function renameCostume(costumeIndex, newName) {\n      var usedNames = this.sprite.costumes.filter(function (costume, index) {\n        return costumeIndex !== index;\n      }).map(function (costume) {\n        return costume.name;\n      });\n      var oldName = this.getCostumes()[costumeIndex].name;\n      var newUnusedName = StringUtil.unusedName(newName, usedNames);\n      this.getCostumes()[costumeIndex].name = newUnusedName;\n      if (this.isStage) {\n        \n        \n        var targets = this.runtime.targets;\n        for (var i = 0; i < targets.length; i++) {\n          var currTarget = targets[i];\n          currTarget.blocks.updateAssetName(oldName, newUnusedName, 'backdrop');\n        }\n      } else {\n        this.blocks.updateAssetName(oldName, newUnusedName, 'costume');\n      }\n    }\n    \n  }, {\n    key: \"deleteCostume\",\n    value: function deleteCostume(index) {\n      var originalCostumeCount = this.sprite.costumes.length;\n      if (originalCostumeCount === 1) return null;\n      if (index < 0 || index >= originalCostumeCount) {\n        return null;\n      }\n      var deletedCostume = this.sprite.deleteCostumeAt(index);\n      if (index === this.currentCostume && index === originalCostumeCount - 1) {\n        this.setCostume(index - 1);\n      } else if (index < this.currentCostume) {\n        this.setCostume(this.currentCostume - 1);\n      } else {\n        this.setCostume(this.currentCostume);\n      }\n      this.runtime.requestTargetsUpdate(this);\n      return deletedCostume;\n      scratchStatus(\"BACKUPNEEDED\");\n    }\n    \n  }, {\n    key: \"addSound\",\n    value: function addSound(soundObject, index) {\n      var usedNames = this.sprite.sounds.map(function (sound) {\n        return sound.name;\n      });\n      soundObject.name = StringUtil.unusedName(soundObject.name, usedNames);\n      if (typeof index === 'number' && !isNaN(index)) {\n        this.sprite.sounds.splice(index, 0, soundObject);\n      } else {\n        this.sprite.sounds.push(soundObject);\n      }\n    }\n    \n  }, {\n    key: \"renameSound\",\n    value: function renameSound(soundIndex, newName) {\n      var usedNames = this.sprite.sounds.filter(function (sound, index) {\n        return soundIndex !== index;\n      }).map(function (sound) {\n        return sound.name;\n      });\n      var oldName = this.sprite.sounds[soundIndex].name;\n      var newUnusedName = StringUtil.unusedName(newName, usedNames);\n      this.sprite.sounds[soundIndex].name = newUnusedName;\n      this.blocks.updateAssetName(oldName, newUnusedName, 'sound');\n    }\n    \n  }, {\n    key: \"deleteSound\",\n    value: function deleteSound(index) {\n      \n      if (index < 0 || index >= this.sprite.sounds.length) {\n        return null;\n      } \n      var deletedSound = this.sprite.sounds.splice(index, 1)[0];\n      this.runtime.requestTargetsUpdate(this);\n      return deletedSound;\n    }\n    \n  }, {\n    key: \"setRotationStyle\",\n    value: function setRotationStyle(rotationStyle) {\n      if (rotationStyle === RenderedTarget.ROTATION_STYLE_NONE) {\n        this.rotationStyle = RenderedTarget.ROTATION_STYLE_NONE;\n      } else if (rotationStyle === RenderedTarget.ROTATION_STYLE_ALL_AROUND) {\n        this.rotationStyle = RenderedTarget.ROTATION_STYLE_ALL_AROUND;\n      } else if (rotationStyle === RenderedTarget.ROTATION_STYLE_LEFT_RIGHT) {\n        this.rotationStyle = RenderedTarget.ROTATION_STYLE_LEFT_RIGHT;\n      }\n      if (this.renderer) {\n        var _this$_getRenderedDir3 = this._getRenderedDirectionAndScale(),\n            direction = _this$_getRenderedDir3.direction,\n            scale = _this$_getRenderedDir3.scale;\n        this.renderer.updateDrawableDirectionScale(this.drawableID, direction, scale);\n        if (this.visible) {\n          this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);\n          this.runtime.requestRedraw();\n        }\n      }\n      this.runtime.requestTargetsUpdate(this);\n    }\n    \n  }, {\n    key: \"getCostumeIndexByName\",\n    value: function getCostumeIndexByName(costumeName) {\n      for (var i = 0; i < this.sprite.costumes.length; i++) {\n        if (this.getCostumes()[i].name === costumeName) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    \n  }, {\n    key: \"getCurrentCostume\",\n    value: function getCurrentCostume() {\n      return this.getCostumes()[this.currentCostume];\n    }\n    \n  }, {\n    key: \"getCostumes\",\n    value: function getCostumes() {\n      return this.sprite.costumes;\n    }\n    \n  }, {\n    key: \"reorderCostume\",\n    value: function reorderCostume(costumeIndex, newIndex) {\n      newIndex = MathUtil.clamp(newIndex, 0, this.sprite.costumes.length - 1);\n      costumeIndex = MathUtil.clamp(costumeIndex, 0, this.sprite.costumes.length - 1);\n      if (newIndex === costumeIndex) return false;\n      var currentCostume = this.getCurrentCostume();\n      var costume = this.sprite.costumes[costumeIndex]; \n      this.sprite.deleteCostumeAt(costumeIndex);\n      this.addCostume(costume, newIndex);\n      this.currentCostume = this.getCostumeIndexByName(currentCostume.name);\n      return true;\n    }\n    \n  }, {\n    key: \"reorderSound\",\n    value: function reorderSound(soundIndex, newIndex) {\n      newIndex = MathUtil.clamp(newIndex, 0, this.sprite.sounds.length - 1);\n      soundIndex = MathUtil.clamp(soundIndex, 0, this.sprite.sounds.length - 1);\n      if (newIndex === soundIndex) return false;\n      var sound = this.sprite.sounds[soundIndex];\n      this.deleteSound(soundIndex);\n      this.addSound(sound, newIndex);\n      return true;\n    }\n    \n  }, {\n    key: \"getSounds\",\n    value: function getSounds() {\n      return this.sprite.sounds;\n    }\n    \n  }, {\n    key: \"updateAllDrawableProperties\",\n    value: function updateAllDrawableProperties() {\n      if (this.renderer) {\n        var _this$_getRenderedDir4 = this._getRenderedDirectionAndScale(),\n            direction = _this$_getRenderedDir4.direction,\n            scale = _this$_getRenderedDir4.scale;\n        this.renderer.updateDrawablePosition(this.drawableID, [this.x, this.y]);\n        this.renderer.updateDrawableDirectionScale(this.drawableID, direction, scale);\n        this.renderer.updateDrawableVisible(this.drawableID, this.visible);\n        var costume = this.getCostumes()[this.currentCostume];\n        this.renderer.updateDrawableSkinId(this.drawableID, costume.skinId);\n        for (var effectName in this.effects) {\n          if (!this.effects.hasOwnProperty(effectName)) continue;\n          this.renderer.updateDrawableEffect(this.drawableID, effectName, this.effects[effectName]);\n        }\n        if (this.visible) {\n          this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);\n          this.runtime.requestRedraw();\n        }\n      }\n      this.runtime.requestTargetsUpdate(this);\n    }\n    \n  }, {\n    key: \"getName\",\n    value: function getName() {\n      return this.sprite.name;\n    }\n    \n  }, {\n    key: \"isSprite\",\n    value: function isSprite() {\n      return !this.isStage && this.isOriginal;\n    }\n    \n  }, {\n    key: \"getBounds\",\n    value: function getBounds() {\n      if (this.renderer) {\n        return this.runtime.renderer.getBounds(this.drawableID);\n      }\n      return null;\n    }\n    \n  }, {\n    key: \"getBoundsForBubble\",\n    value: function getBoundsForBubble() {\n      if (this.renderer) {\n        return this.runtime.renderer.getBoundsForBubble(this.drawableID);\n      }\n      return null;\n    }\n    \n  }, {\n    key: \"isTouchingObject\",\n    value: function isTouchingObject(requestedObject) {\n      if (requestedObject === '_mouse_') {\n        if (!this.runtime.ioDevices.mouse) return false;\n        var mouseX = this.runtime.ioDevices.mouse.getClientX();\n        var mouseY = this.runtime.ioDevices.mouse.getClientY();\n        return this.isTouchingPoint(mouseX, mouseY);\n      } else if (requestedObject === '_edge_') {\n        return this.isTouchingEdge();\n      }\n      return this.isTouchingSprite(requestedObject);\n    }\n    \n  }, {\n    key: \"isTouchingPoint\",\n    value: function isTouchingPoint(x, y) {\n      if (this.renderer) {\n        return this.renderer.drawableTouching(this.drawableID, x, y);\n      }\n      return false;\n    }\n    \n  }, {\n    key: \"isTouchingEdge\",\n    value: function isTouchingEdge() {\n      if (this.renderer) {\n        var stageWidth = this.runtime.constructor.STAGE_WIDTH;\n        var stageHeight = this.runtime.constructor.STAGE_HEIGHT;\n        var bounds = this.getBounds();\n        if (bounds.left < -stageWidth / 2 || bounds.right > stageWidth / 2 || bounds.top > stageHeight / 2 || bounds.bottom < -stageHeight / 2) {\n          return true;\n        }\n      }\n      return false;\n    }\n    \n  }, {\n    key: \"isTouchingSprite\",\n    value: function isTouchingSprite(spriteName) {\n      spriteName = Cast.toString(spriteName);\n      var firstClone = this.runtime.getSpriteTargetByName(spriteName);\n      if (!firstClone || !this.renderer) {\n        return false;\n      } \n      \n      \n      var drawableCandidates = firstClone.sprite.clones.filter(function (clone) {\n        return !clone.dragging;\n      }).map(function (clone) {\n        return clone.drawableID;\n      });\n      return this.renderer.isTouchingDrawables(this.drawableID, drawableCandidates);\n    }\n    \n  }, {\n    key: \"isTouchingColor\",\n    value: function isTouchingColor(rgb) {\n      if (this.renderer) {\n        return this.renderer.isTouchingColor(this.drawableID, rgb);\n      }\n      return false;\n    }\n    \n  }, {\n    key: \"colorIsTouchingColor\",\n    value: function colorIsTouchingColor(targetRgb, maskRgb) {\n      if (this.renderer) {\n        return this.renderer.isTouchingColor(this.drawableID, targetRgb, maskRgb);\n      }\n      return false;\n    }\n  }, {\n    key: \"getLayerOrder\",\n    value: function getLayerOrder() {\n      if (this.renderer) {\n        return this.renderer.getDrawableOrder(this.drawableID);\n      }\n      return null;\n    }\n    \n  }, {\n    key: \"goToFront\",\n    value: function goToFront() {\n      \n      if (this.renderer) {\n        \n        \n        this.renderer.setDrawableOrder(this.drawableID, Infinity, StageLayering.SPRITE_LAYER);\n      }\n      this.runtime.setExecutablePosition(this, Infinity);\n    }\n    \n  }, {\n    key: \"goToBack\",\n    value: function goToBack() {\n      \n      if (this.renderer) {\n        \n        \n        this.renderer.setDrawableOrder(this.drawableID, -Infinity, StageLayering.SPRITE_LAYER, false);\n      }\n      this.runtime.setExecutablePosition(this, -Infinity);\n    }\n    \n  }, {\n    key: \"goForwardLayers\",\n    value: function goForwardLayers(nLayers) {\n      if (this.renderer) {\n        this.renderer.setDrawableOrder(this.drawableID, nLayers, StageLayering.SPRITE_LAYER, true);\n      }\n      this.runtime.moveExecutable(this, nLayers);\n    }\n    \n  }, {\n    key: \"goBackwardLayers\",\n    value: function goBackwardLayers(nLayers) {\n      if (this.renderer) {\n        this.renderer.setDrawableOrder(this.drawableID, -nLayers, StageLayering.SPRITE_LAYER, true);\n      }\n      this.runtime.moveExecutable(this, -nLayers);\n    }\n    \n  }, {\n    key: \"goBehindOther\",\n    value: function goBehindOther(other) {\n      if (this.renderer) {\n        var otherLayer = this.renderer.setDrawableOrder(other.drawableID, 0, StageLayering.SPRITE_LAYER, true);\n        this.renderer.setDrawableOrder(this.drawableID, otherLayer, StageLayering.SPRITE_LAYER);\n      }\n      var executionPosition = this.runtime.executableTargets.indexOf(other);\n      this.runtime.setExecutablePosition(this, executionPosition);\n    }\n    \n  }, {\n    key: \"keepInFence\",\n    value: function keepInFence(newX, newY, optFence) {\n      var fence = optFence;\n      if (!fence) {\n        fence = {\n          left: -this.runtime.constructor.STAGE_WIDTH / 2,\n          right: this.runtime.constructor.STAGE_WIDTH / 2,\n          top: this.runtime.constructor.STAGE_HEIGHT / 2,\n          bottom: -this.runtime.constructor.STAGE_HEIGHT / 2\n        };\n      }\n      var bounds = this.getBounds();\n      if (!bounds) return; \n      bounds.left += newX - this.x;\n      bounds.right += newX - this.x;\n      bounds.top += newY - this.y;\n      bounds.bottom += newY - this.y; \n      var dx = 0;\n      var dy = 0;\n      if (bounds.left < fence.left) {\n        dx += fence.left - bounds.left;\n      }\n      if (bounds.right > fence.right) {\n        dx += fence.right - bounds.right;\n      }\n      if (bounds.top > fence.top) {\n        dy += fence.top - bounds.top;\n      }\n      if (bounds.bottom < fence.bottom) {\n        dy += fence.bottom - bounds.bottom;\n      }\n      return [newX + dx, newY + dy];\n    }\n    \n  }, {\n    key: \"makeClone\",\n    value: function makeClone() {\n      if (!this.runtime.clonesAvailable() || this.isStage) {\n        return null; \n      }\n      this.runtime.changeCloneCounter(1);\n      var newClone = this.sprite.createClone(); \n      newClone.x = this.x;\n      newClone.y = this.y;\n      newClone.direction = this.direction;\n      newClone.draggable = this.draggable;\n      newClone.visible = this.visible;\n      newClone.size = this.size;\n      newClone.currentCostume = this.currentCostume;\n      newClone.rotationStyle = this.rotationStyle;\n      newClone.effects = Clone.simple(this.effects);\n      newClone.variables = this.duplicateVariables();\n      newClone._edgeActivatedHatValues = Clone.simple(this._edgeActivatedHatValues);\n      newClone.initDrawable(StageLayering.SPRITE_LAYER);\n      newClone.updateAllDrawableProperties();\n      return newClone;\n    }\n    \n  }, {\n    key: \"duplicate\",\n    value: function duplicate() {\n      var _this2 = this;\n      return this.sprite.duplicate().then(function (newSprite) {\n        var newTarget = newSprite.createClone(); \n        \n        newTarget.x = (Math.random() - 0.5) * 400 / 2;\n        newTarget.y = (Math.random() - 0.5) * 300 / 2;\n        newTarget.direction = _this2.direction;\n        newTarget.draggable = _this2.draggable;\n        newTarget.visible = _this2.visible;\n        newTarget.size = _this2.size;\n        newTarget.currentCostume = _this2.currentCostume;\n        newTarget.rotationStyle = _this2.rotationStyle;\n        newTarget.effects = JSON.parse(JSON.stringify(_this2.effects));\n        newTarget.variables = _this2.duplicateVariables(newTarget.blocks);\n        newTarget.updateAllDrawableProperties();\n        scratchStatus(\"BACKUPNEEDED\");\n        return newTarget;\n      });\n    }\n    \n  }, {\n    key: \"onGreenFlag\",\n    value: function onGreenFlag() {\n      this.clearEffects();\n    }\n    \n  }, {\n    key: \"onStopAll\",\n    value: function onStopAll() {\n      this.clearEffects();\n    }\n    \n  }, {\n    key: \"postSpriteInfo\",\n    value: function postSpriteInfo(data) {\n      var force = data.hasOwnProperty('force') ? data.force : null;\n      var isXChanged = data.hasOwnProperty('x');\n      var isYChanged = data.hasOwnProperty('y');\n      if (isXChanged || isYChanged) {\n        this.setXY(isXChanged ? data.x : this.x, isYChanged ? data.y : this.y, force);\n      }\n      if (data.hasOwnProperty('direction')) {\n        this.setDirection(data.direction);\n      }\n      if (data.hasOwnProperty('draggable')) {\n        this.setDraggable(data.draggable);\n      }\n      if (data.hasOwnProperty('rotationStyle')) {\n        this.setRotationStyle(data.rotationStyle);\n      }\n      if (data.hasOwnProperty('visible')) {\n        this.setVisible(data.visible);\n      }\n      if (data.hasOwnProperty('size')) {\n        this.setSize(data.size);\n      }\n    }\n    \n  }, {\n    key: \"startDrag\",\n    value: function startDrag() {\n      this.dragging = true;\n    }\n    \n  }, {\n    key: \"stopDrag\",\n    value: function stopDrag() {\n      this.dragging = false;\n    }\n    \n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var costumes = this.getCostumes();\n      return {\n        id: this.id,\n        name: this.getName(),\n        isStage: this.isStage,\n        x: this.x,\n        y: this.y,\n        size: this.size,\n        direction: this.direction,\n        draggable: this.draggable,\n        currentCostume: this.currentCostume,\n        costume: costumes[this.currentCostume],\n        costumeCount: costumes.length,\n        visible: this.visible,\n        rotationStyle: this.rotationStyle,\n        comments: this.comments,\n        blocks: this.blocks._blocks,\n        variables: this.variables,\n        costumes: costumes,\n        sounds: this.getSounds(),\n        textToSpeechLanguage: this.textToSpeechLanguage,\n        tempo: this.tempo,\n        volume: this.volume,\n        videoTransparency: this.videoTransparency,\n        videoState: this.videoState\n      };\n    }\n    \n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.runtime.changeCloneCounter(-1);\n      this.runtime.stopForTarget(this);\n      this.runtime.removeExecutable(this);\n      this.sprite.removeClone(this);\n      if (this.renderer && this.drawableID !== null) {\n        this.renderer.destroyDrawable(this.drawableID, this.isStage ? StageLayering.BACKGROUND_LAYER : StageLayering.SPRITE_LAYER);\n        if (this.visible) {\n          this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);\n          this.runtime.requestRedraw();\n        }\n      }\n    }\n  }, {\n    key: \"audioPlayer\",\n    get: function get() {\n      var _this3 = this;\n      \n    //console.warn('get audioPlayer deprecated, please update to use .sprite.soundBank methods');\n    //console.warn(new Error('stack for debug').stack);\n      \n      var bank = this.sprite.soundBank;\n      var audioPlayerProxy = {\n        playSound: function playSound(soundId) {\n          return bank.play(_this3, soundId);\n        }\n      };\n      Object.defineProperty(this, 'audioPlayer', {\n        configurable: false,\n        enumerable: true,\n        writable: false,\n        value: audioPlayerProxy\n      });\n      return audioPlayerProxy;\n    }\n  }], [{\n    key: \"EVENT_TARGET_MOVED\",\n    get: function get() {\n      return 'TARGET_MOVED';\n    }\n    \n  }, {\n    key: \"EVENT_TARGET_VISUAL_CHANGE\",\n    get: function get() {\n      return 'EVENT_TARGET_VISUAL_CHANGE';\n    }\n    \n  }, {\n    key: \"ROTATION_STYLE_ALL_AROUND\",\n    get: function get() {\n      return 'all around';\n    }\n    \n  }, {\n    key: \"ROTATION_STYLE_LEFT_RIGHT\",\n    get: function get() {\n      return 'left-right';\n    }\n    \n  }, {\n    key: \"ROTATION_STYLE_NONE\",\n    get: function get() {\n      return \"don't rotate\";\n    }\n    \n  }, {\n    key: \"VIDEO_STATE\",\n    get: function get() {\n      return {\n        OFF: 'off',\n        ON: 'on',\n        ON_FLIPPED: 'on-flipped'\n      };\n    }\n  }]);\n  return RenderedTarget;\n}(Target);\nmodule.exports = RenderedTarget;\n })