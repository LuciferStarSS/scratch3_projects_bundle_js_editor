/* 481 */\n (function(module, exports, __webpack_require__) {\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n/**\n * @fileoverview\n * Partial implementation of an SB2 JSON importer.\n * Parses provided JSON and then generates all needed\n * scratch-vm runtime structures.\n */\nvar Blocks = __webpack_require__(135);\nvar RenderedTarget = __webpack_require__(219);\nvar Sprite = __webpack_require__(479);\nvar Color = __webpack_require__(180);\nvar log = __webpack_require__(39);\nvar uid = __webpack_require__(94);\nvar StringUtil = __webpack_require__(102);\nvar MathUtil = __webpack_require__(62);\nvar specMap = __webpack_require__(1187);\nvar Comment = __webpack_require__(297);\nvar Variable = __webpack_require__(114);\nvar MonitorRecord = __webpack_require__(295);\nvar StageLayering = __webpack_require__(115);\nvar _require = __webpack_require__(225),\n    loadCostume = _require.loadCostume;\nvar _require2 = __webpack_require__(226),\n    loadSound = _require2.loadSound;\nvar _require3 = __webpack_require__(480),\n    deserializeCostume = _require3.deserializeCostume,\n    deserializeSound = _require3.deserializeSound; \nvar CORE_EXTENSIONS = ['argument', 'control', 'data', 'event', 'looks', 'math', 'motion', 'operator', 'procedures', 'sensing', 'sound']; \n\n\nvar WORKSPACE_X_SCALE = 1.5;\nvar WORKSPACE_Y_SCALE = 2.2;\n/**\n * Convert a Scratch 2.0 procedure string (e.g., \"my_procedure %s %b %n\")\n * into an argument map. This allows us to provide the expected inputs\n * to a mutated procedure call.\n * @param {string} procCode Scratch 2.0 procedure string.\n * @return {object} Argument map compatible with those in sb2specmap.\n */\nvar parseProcedureArgMap = function parseProcedureArgMap(procCode) {\n  var argMap = [{} \n  ];\n  var INPUT_PREFIX = 'input';\n  var inputCount = 0; \n  var parts = procCode.split(/(?=[^\\\\]%[nbs])/);\n  for (var i = 0; i < parts.length; i++) {\n    var part = parts[i].trim();\n    if (part.substring(0, 1) === '%') {\n      var argType = part.substring(1, 2);\n      var arg = {\n        type: 'input',\n        inputName: INPUT_PREFIX + inputCount++\n      };\n      if (argType === 'n') {\n        arg.inputOp = 'math_number';\n      } else if (argType === 's') {\n        arg.inputOp = 'text';\n      } else if (argType === 'b') {\n        arg.inputOp = 'boolean';\n      }\n      argMap.push(arg);\n    }\n  }\n  return argMap;\n};\n/**\n * Generate a list of \"argument IDs\" for procdefs and caller mutations.\n * IDs just end up being `input0`, `input1`, ... which is good enough.\n * @param {string} procCode Scratch 2.0 procedure string.\n * @return {Array.<string>} Array of argument id strings.\n */\nvar parseProcedureArgIds = function parseProcedureArgIds(procCode) {\n  return parseProcedureArgMap(procCode).map(function (arg) {\n    return arg.inputName;\n  }).filter(function (name) {\n    return name;\n  }); \n};\n/**\n * Flatten a block tree into a block list.\n * Children are temporarily stored on the `block.children` property.\n * @param {Array.<object>} blocks list generated by `parseBlockList`.\n * @return {Array.<object>} Flattened list to be passed to `blocks.createBlock`.\n */\nvar flatten = function flatten(blocks) {\n  var finalBlocks = [];\n  for (var i = 0; i < blocks.length; i++) {\n    var block = blocks[i];\n    finalBlocks.push(block);\n    if (block.children) {\n      finalBlocks = finalBlocks.concat(flatten(block.children));\n    }\n    delete block.children;\n  }\n  return finalBlocks;\n};\n/**\n * Parse any list of blocks from SB2 JSON into a list of VM-format blocks.\n * Could be used to parse a top-level script,\n * a list of blocks in a branch (e.g., in forever),\n * or a list of blocks in an argument (e.g., move [pick random...]).\n * @param {Array.<object>} blockList SB2 JSON-format block list.\n * @param {Function} addBroadcastMsg function to update broadcast message name map\n * @param {Function} getVariableId function to retreive a variable's ID based on name\n * @param {ImportedExtensionsInfo} extensions - (in/out) parsed extension information will be stored here.\n * @param {ParseState} parseState - info on the state of parsing beyond the current block.\n * @param {object<int, Comment>} comments - Comments from sb2 project that need to be attached to blocks.\n * They are indexed in this object by the sb2 flattened block list index indicating\n * which block they should attach to.\n * @param {int} commentIndex The current index of the top block in this list if it were in a flattened\n * list of all blocks for the target\n * @return {Array<Array.<object>|int>} Tuple where first item is the Scratch VM-format block list, and\n * second item is the updated comment index\n */\nvar parseBlockList = function parseBlockList(blockList, addBroadcastMsg, getVariableId, extensions, parseState, comments, commentIndex) {\n  var resultingList = [];\n  var previousBlock = null; \n  for (var i = 0; i < blockList.length; i++) {\n    var block = blockList[i]; \n    var parsedBlockAndComments = parseBlock(block, addBroadcastMsg, getVariableId, extensions, parseState, comments, commentIndex);\n    var parsedBlock = parsedBlockAndComments[0]; \n    commentIndex = parsedBlockAndComments[1];\n    if (!parsedBlock) continue;\n    if (previousBlock) {\n      parsedBlock.parent = previousBlock.id;\n      previousBlock.next = parsedBlock.id;\n    }\n    previousBlock = parsedBlock;\n    resultingList.push(parsedBlock);\n  }\n  return [resultingList, commentIndex];\n};\n/**\n * Parse a Scratch object's scripts into VM blocks.\n * This should only handle top-level scripts that include X, Y coordinates.\n * @param {!object} scripts Scripts object from SB2 JSON.\n * @param {!Blocks} blocks Blocks object to load parsed blocks into.\n * @param {Function} addBroadcastMsg function to update broadcast message name map\n * @param {Function} getVariableId function to retreive a variable's ID based on name\n * @param {ImportedExtensionsInfo} extensions - (in/out) parsed extension information will be stored here.\n * @param {object} comments Comments that need to be attached to the blocks that need to be parsed\n */\nvar parseScripts = function parseScripts(scripts, blocks, addBroadcastMsg, getVariableId, extensions, comments) {\n  \n  \n  var scriptIndexForComment = 0;\n  for (var i = 0; i < scripts.length; i++) {\n    var script = scripts[i];\n    var scriptX = script[0];\n    var scriptY = script[1];\n    var blockList = script[2];\n    var parseState = {};\n    var _parseBlockList = parseBlockList(blockList, addBroadcastMsg, getVariableId, extensions, parseState, comments, scriptIndexForComment),\n        _parseBlockList2 = _slicedToArray(_parseBlockList, 2),\n        parsedBlockList = _parseBlockList2[0],\n        newCommentIndex = _parseBlockList2[1];\n    scriptIndexForComment = newCommentIndex;\n    if (parsedBlockList[0]) {\n      parsedBlockList[0].x = scriptX * WORKSPACE_X_SCALE;\n      parsedBlockList[0].y = scriptY * WORKSPACE_Y_SCALE;\n      parsedBlockList[0].topLevel = true;\n      parsedBlockList[0].parent = null;\n    } \n    var convertedBlocks = flatten(parsedBlockList);\n    for (var j = 0; j < convertedBlocks.length; j++) {\n      blocks.createBlock(convertedBlocks[j]);\n    }\n  }\n};\n/**\n * Create a callback for assigning fixed IDs to imported variables\n * Generator stores the global variable mapping in a closure\n * @param {!string} targetId the id of the target to scope the variable to\n * @return {string} variable ID\n */\nvar generateVariableIdGetter = function () {\n  var globalVariableNameMap = {};\n  var namer = function namer(targetId, name, type) {\n    return \"\".concat(targetId, \"-\").concat(StringUtil.replaceUnsafeChars(name), \"-\").concat(type);\n  };\n  return function (targetId, topLevel) {\n    \n    if (topLevel) globalVariableNameMap = {};\n    return function (name, type) {\n      if (topLevel) {\n        \n        globalVariableNameMap[\"\".concat(name, \"-\").concat(type)] = namer(targetId, name, type);\n        return globalVariableNameMap[\"\".concat(name, \"-\").concat(type)];\n      } \n      if (globalVariableNameMap[\"\".concat(name, \"-\").concat(type)]) return globalVariableNameMap[\"\".concat(name, \"-\").concat(type)];\n      return namer(targetId, name, type);\n    };\n  };\n}();\nvar globalBroadcastMsgStateGenerator = function () {\n  var broadcastMsgNameMap = {};\n  var allBroadcastFields = [];\n  var emptyStringName = uid();\n  return function (topLevel) {\n    if (topLevel) broadcastMsgNameMap = {};\n    return {\n      broadcastMsgMapUpdater: function broadcastMsgMapUpdater(name, field) {\n        name = name.toLowerCase();\n        if (name === '') {\n          name = emptyStringName;\n        }\n        broadcastMsgNameMap[name] = \"broadcastMsgId-\".concat(StringUtil.replaceUnsafeChars(name));\n        allBroadcastFields.push(field);\n        return broadcastMsgNameMap[name];\n      },\n      globalBroadcastMsgs: broadcastMsgNameMap,\n      allBroadcastFields: allBroadcastFields,\n      emptyMsgName: emptyStringName\n    };\n  };\n}();\n/**\n * Parse a single monitor object and create all its in-memory VM objects.\n *\n * It is important that monitors are parsed last,\n * - after all sprite targets have finished parsing, and\n * - after the rest of the stage has finished parsing.\n *\n * It is specifically important that all the scripts in the project\n * have been parsed and all the relevant targets exist, have uids,\n * and have their variables initialized.\n * Calling this function before these things are true, will result in\n * undefined behavior.\n * @param {!object} object - From-JSON \"Monitor object\"\n * @param {!Runtime} runtime - (in/out) Runtime object to load monitor info into.\n * @param {!Array.<Target>} targets - Targets have already been parsed.\n * @param {ImportedExtensionsInfo} extensions - (in/out) parsed extension information will be stored here.\n */\nvar parseMonitorObject = function parseMonitorObject(object, runtime, targets, extensions) {\n  \n  \n  var mapped = specMap[object.cmd];\n  if (!mapped) {\n    log.warn(\"Could not find monitor block with opcode: \".concat(object.cmd));\n    return;\n  } \n  \n  \n  \n  \n  var opcode = specMap[object.cmd].opcode;\n  var extIndex = opcode.indexOf('_');\n  var extID = opcode.substring(0, extIndex);\n  if (extID === 'videoSensing') {\n    return;\n  } else if (CORE_EXTENSIONS.indexOf(extID) === -1 && extID !== '' && !extensions.extensionIDs.has(extID) && !object.visible) {\n    \n    \n    \n    \n    return;\n  }\n  var target = null; \n  \n  if (!object.hasOwnProperty('target')) {\n    var _loop = function _loop(i) {\n      var currTarget = targets[i];\n      var listVariables = Object.keys(currTarget.variables).filter(function (key) {\n        var variable = currTarget.variables[key];\n        return variable.type === Variable.LIST_TYPE && variable.name === object.listName;\n      });\n      if (listVariables.length > 0) {\n        target = currTarget; \n        object.target = currTarget.getName(); \n      }\n    };\n    for (var i = 0; i < targets.length; i++) {\n      _loop(i);\n    }\n  } \n  target = target || targets.filter(function (t) {\n    return t.getName() === object.target;\n  })[0];\n  if (!target) throw new Error('Cannot create monitor for target that cannot be found by name'); \n  var getVariableId = generateVariableIdGetter(target.id, false); \n  var _parseBlock = parseBlock([object.cmd, object.param], \n  null, \n  getVariableId, extensions, {}, null, \n  null \n  ),\n      _parseBlock2 = _slicedToArray(_parseBlock, 2),\n      block = _parseBlock2[0],\n      _ = _parseBlock2[1]; \n  \n  \n  if (object.cmd === 'getVar:') {\n    block.id = getVariableId(object.param, Variable.SCALAR_TYPE);\n  } else if (object.cmd === 'contentsOfList:') {\n    block.id = getVariableId(object.param, Variable.LIST_TYPE);\n  } else if (runtime.monitorBlockInfo.hasOwnProperty(block.opcode)) {\n    block.id = runtime.monitorBlockInfo[block.opcode].getId(target.id, block.fields);\n  } else {\n    \n    \n    \n    \n    block.id = block.opcode;\n  } \n  block.targetId = target.isStage ? null : target.id; \n  block.isMonitored = object.visible;\n  var existingMonitorBlock = runtime.monitorBlocks._blocks[block.id];\n  if (existingMonitorBlock) {\n    \n    \n    \n    existingMonitorBlock.isMonitored = object.visible;\n    existingMonitorBlock.targetId = block.targetId;\n  } else {\n    \n    var newBlocks = flatten([block]);\n    for (var _i2 = 0; _i2 < newBlocks.length; _i2++) {\n      runtime.monitorBlocks.createBlock(newBlocks[_i2]);\n    }\n  } \n  switch (object.mode) {\n    case 1:\n      object.mode = 'default';\n      break;\n    case 2:\n      object.mode = 'large';\n      break;\n    case 3:\n      object.mode = 'slider';\n      break;\n  } \n  runtime.requestAddMonitor(MonitorRecord({\n    id: block.id,\n    targetId: block.targetId,\n    spriteName: block.targetId ? object.target : null,\n    opcode: block.opcode,\n    params: runtime.monitorBlocks._getBlockParams(block),\n    value: '',\n    mode: object.mode,\n    sliderMin: object.sliderMin,\n    sliderMax: object.sliderMax,\n    isDiscrete: object.isDiscrete,\n    x: object.x,\n    y: object.y,\n    width: object.width,\n    height: object.height,\n    visible: object.visible\n  }));\n};\n/**\n * Parse the assets of a single \"Scratch object\" and load them. This\n * preprocesses objects to support loading the data for those assets over a\n * network while the objects are further processed into Blocks, Sprites, and a\n * list of needed Extensions.\n * @param {!object} object - From-JSON \"Scratch object:\" sprite, stage, watcher.\n * @param {!Runtime} runtime - Runtime object to load all structures into.\n * @param {boolean} topLevel - Whether this is the top-level object (stage).\n * @param {?object} zip - Optional zipped assets for local file import\n * @return {?{costumePromises:Array.<Promise>,soundPromises:Array.<Promise>,soundBank:SoundBank,children:object}}\n *   Object of arrays of promises and child objects for asset objects used in\n *   Sprites. As well as a SoundBank for the sound assets. null for unsupported\n *   objects.\n */\nvar parseScratchAssets = function parseScratchAssets(object, runtime, topLevel, zip) {\n  if (!object.hasOwnProperty('objName')) {\n    \n    return null;\n  }\n  var assets = {\n    costumePromises: [],\n    soundPromises: [],\n    soundBank: runtime.audioEngine && runtime.audioEngine.createBank(),\n    children: []\n  }; \n  var costumePromises = assets.costumePromises;\n  if (object.hasOwnProperty('costumes')) {\n    var _loop2 = function _loop2(i) {\n      var costumeSource = object.costumes[i];\n      var bitmapResolution = costumeSource.bitmapResolution || 1;\n      var costume = {\n        name: costumeSource.costumeName,\n        bitmapResolution: bitmapResolution,\n        rotationCenterX: topLevel ? 240 * bitmapResolution : costumeSource.rotationCenterX,\n        rotationCenterY: topLevel ? 180 * bitmapResolution : costumeSource.rotationCenterY,\n        \n        \n        \n        \n        md5: costumeSource.baseLayerMD5,\n        skinId: null\n      };\n      var md5ext = costumeSource.baseLayerMD5;\n      var idParts = StringUtil.splitFirst(md5ext, '.');\n      var md5 = idParts[0];\n      var ext = void 0;\n      if (idParts.length === 2 && idParts[1]) {\n        ext = idParts[1];\n      } else {\n        \n        ext = 'png'; \n        costume.md5 = \"\".concat(costume.md5, \".\").concat(ext);\n      }\n      costume.dataFormat = ext;\n      costume.assetId = md5;\n      if (costumeSource.textLayerMD5) {\n        costume.textLayerMD5 = StringUtil.splitFirst(costumeSource.textLayerMD5, '.')[0];\n      } \n      \n      \n      var assetFileName = \"\".concat(costumeSource.baseLayerID, \".\").concat(ext);\n      var textLayerFileName = costumeSource.textLayerID ? \"\".concat(costumeSource.textLayerID, \".png\") : null;\n      costumePromises.push(deserializeCostume(costume, runtime, zip, assetFileName, textLayerFileName).then(function () {\n        return loadCostume(costume.md5, costume, runtime, 2\n       \n        );\n      }));\n    };\n    for (var i = 0; i < object.costumes.length; i++) {\n      _loop2(i);\n    }\n  } \n  var soundBank = assets.soundBank,\n      soundPromises = assets.soundPromises;\n  if (object.hasOwnProperty('sounds')) {\n    var _loop3 = function _loop3(s) {\n      var soundSource = object.sounds[s];\n      var sound = {\n        name: soundSource.soundName,\n        format: soundSource.format,\n        rate: soundSource.rate,\n        sampleCount: soundSource.sampleCount,\n        \n        \n        \n        \n        \n        \n        md5: soundSource.md5,\n        data: null\n      };\n      var md5ext = soundSource.md5;\n      var idParts = StringUtil.splitFirst(md5ext, '.');\n      var md5 = idParts[0];\n      var ext = idParts[1].toLowerCase();\n      sound.dataFormat = ext;\n      sound.assetId = md5; \n      \n      \n      \n      var assetFileName = \"\".concat(soundSource.soundID, \".\").concat(ext);\n      soundPromises.push(deserializeSound(sound, runtime, zip, assetFileName).then(function () {\n        return loadSound(sound, runtime, soundBank);\n      }));\n    };\n    for (var s = 0; s < object.sounds.length; s++) {\n      _loop3(s);\n    }\n  } \n  var childrenAssets = assets.children;\n  if (object.children) {\n    for (var m = 0; m < object.children.length; m++) {\n      childrenAssets.push(parseScratchAssets(object.children[m], runtime, false, zip));\n    }\n  }\n  return assets;\n};\n/**\n * Parse a single \"Scratch object\" and create all its in-memory VM objects.\n * TODO: parse the \"info\" section, especially \"savedExtensions\"\n * @param {!object} object - From-JSON \"Scratch object:\" sprite, stage, watcher.\n * @param {!Runtime} runtime - Runtime object to load all structures into.\n * @param {ImportedExtensionsInfo} extensions - (in/out) parsed extension information will be stored here.\n * @param {boolean} topLevel - Whether this is the top-level object (stage).\n * @param {?object} zip - Optional zipped assets for local file import\n * @param {object} assets - Promises for assets of this scratch object grouped\n *   into costumes and sounds\n * @return {!Promise.<Array.<Target>>} Promise for the loaded targets when ready, or null for unsupported objects.\n */\nvar parseScratchObject = function parseScratchObject(object, runtime, extensions, topLevel, zip, assets) {\n  if (!object.hasOwnProperty('objName')) {\n    if (object.hasOwnProperty('listName')) {\n      \n      object.cmd = 'contentsOfList:';\n      object.param = object.listName;\n      object.mode = 'list';\n    } \n    object.deferredMonitor = true;\n    return Promise.resolve(object);\n  } \n  var blocks = new Blocks(runtime); \n  var sprite = new Sprite(blocks, runtime); \n  if (object.hasOwnProperty('objName')) {\n    if (topLevel && object.objName !== 'Stage') {\n      var _iterator = _createForOfIteratorHelper(object.children),\n          _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var child = _step.value;\n          if (!child.hasOwnProperty('objName') && child.target === object.objName) {\n            child.target = 'Stage';\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      object.objName = 'Stage';\n    }\n    sprite.name = object.objName;\n  } \n  var costumePromises = assets.costumePromises; \n  var soundBank = assets.soundBank,\n      soundPromises = assets.soundPromises; \n  var target = sprite.createClone(topLevel ? StageLayering.BACKGROUND_LAYER : StageLayering.SPRITE_LAYER);\n  var getVariableId = generateVariableIdGetter(target.id, topLevel);\n  var globalBroadcastMsgObj = globalBroadcastMsgStateGenerator(topLevel);\n  var addBroadcastMsg = globalBroadcastMsgObj.broadcastMsgMapUpdater; \n  if (object.hasOwnProperty('variables')) {\n    for (var j = 0; j < object.variables.length; j++) {\n      var variable = object.variables[j]; \n      \n      \n      \n      var isCloud = variable.isPersistent && topLevel && runtime.canAddCloudVariable();\n      var newVariable = new Variable(getVariableId(variable.name, Variable.SCALAR_TYPE), variable.name, Variable.SCALAR_TYPE, isCloud);\n      if (isCloud) runtime.addCloudVariable();\n      newVariable.value = variable.value;\n      target.variables[newVariable.id] = newVariable;\n    }\n  } \n  \n  var blockComments = {};\n  if (object.hasOwnProperty('scriptComments')) {\n    var comments = object.scriptComments.map(function (commentDesc) {\n      var _commentDesc = _slicedToArray(commentDesc, 7),\n          commentX = _commentDesc[0],\n          commentY = _commentDesc[1],\n          commentWidth = _commentDesc[2],\n          commentHeight = _commentDesc[3],\n          commentFullSize = _commentDesc[4],\n          flattenedBlockIndex = _commentDesc[5],\n          commentText = _commentDesc[6];\n      var isBlockComment = commentDesc[5] >= 0;\n      var newComment = new Comment(null, \n      commentText, \n      \n      \n      isBlockComment ? null : commentX * WORKSPACE_X_SCALE, isBlockComment ? null : commentY * WORKSPACE_Y_SCALE, commentWidth * WORKSPACE_X_SCALE, commentHeight * WORKSPACE_Y_SCALE, !commentFullSize);\n      if (isBlockComment) {\n        \n        \n        \n        \n        \n        \n        \n        \n        newComment.blockId = flattenedBlockIndex; \n        \n        if (blockComments.hasOwnProperty(flattenedBlockIndex)) {\n          blockComments[flattenedBlockIndex].push(newComment);\n        } else {\n          blockComments[flattenedBlockIndex] = [newComment];\n        }\n      }\n      return newComment;\n    }); \n    \n    comments.forEach(function (comment) {\n      target.comments[comment.id] = comment;\n    });\n  } \n  if (object.hasOwnProperty('scripts')) {\n    parseScripts(object.scripts, blocks, addBroadcastMsg, getVariableId, extensions, blockComments);\n  } \n  \n  \n  \n  \n  \n  \n  for (var commentIndex in blockComments) {\n    var currBlockComments = blockComments[commentIndex];\n    currBlockComments.forEach(function (c) {\n      if (typeof c.blockId === 'number') {\n        c.blockId = null;\n      }\n    });\n  } \n  blocks.updateTargetSpecificBlocks(topLevel); \n  if (object.hasOwnProperty('lists')) {\n    for (var k = 0; k < object.lists.length; k++) {\n      var list = object.lists[k];\n      var _newVariable = new Variable(getVariableId(list.listName, Variable.LIST_TYPE), list.listName, Variable.LIST_TYPE, false);\n      _newVariable.value = list.contents;\n      target.variables[_newVariable.id] = _newVariable;\n    }\n  }\n  if (object.hasOwnProperty('scratchX')) {\n    target.x = object.scratchX;\n  }\n  if (object.hasOwnProperty('scratchY')) {\n    target.y = object.scratchY;\n  }\n  if (object.hasOwnProperty('direction')) {\n    target.direction = object.direction;\n  }\n  if (object.hasOwnProperty('isDraggable')) {\n    target.draggable = object.isDraggable;\n  }\n  if (object.hasOwnProperty('scale')) {\n    \n    target.size = object.scale * 100;\n  }\n  if (object.hasOwnProperty('visible')) {\n    target.visible = object.visible;\n  }\n  if (object.hasOwnProperty('currentCostumeIndex')) {\n    \n    \n    \n    target.currentCostume = MathUtil.clamp(Math.floor(object.currentCostumeIndex), 0, object.costumes.length - 1);\n  }\n  if (object.hasOwnProperty('rotationStyle')) {\n    if (object.rotationStyle === 'none') {\n      target.rotationStyle = RenderedTarget.ROTATION_STYLE_NONE;\n    } else if (object.rotationStyle === 'leftRight') {\n      target.rotationStyle = RenderedTarget.ROTATION_STYLE_LEFT_RIGHT;\n    } else if (object.rotationStyle === 'normal') {\n      target.rotationStyle = RenderedTarget.ROTATION_STYLE_ALL_AROUND;\n    }\n  }\n  if (object.hasOwnProperty('tempoBPM')) {\n    target.tempo = object.tempoBPM;\n  }\n  if (object.hasOwnProperty('videoAlpha')) {\n    \n    \n    target.videoTransparency = 100 - 100 * object.videoAlpha;\n  }\n  if (object.hasOwnProperty('info')) {\n    if (object.info.hasOwnProperty('videoOn')) {\n      if (object.info.videoOn) {\n        target.videoState = RenderedTarget.VIDEO_STATE.ON;\n      } else {\n        target.videoState = RenderedTarget.VIDEO_STATE.OFF;\n      }\n    }\n  }\n  if (object.hasOwnProperty('indexInLibrary')) {\n    \n    \n    \n    target.targetPaneOrder = object.indexInLibrary;\n  }\n  target.isStage = topLevel;\n  Promise.all(costumePromises).then(function (costumes) {\n    sprite.costumes = costumes;\n  });\n  Promise.all(soundPromises).then(function (sounds) {\n    sprite.sounds = sounds; \n    sprite.soundBank = soundBank || null;\n  }); \n  var childrenPromises = [];\n  if (object.children) {\n    for (var m = 0; m < object.children.length; m++) {\n      childrenPromises.push(parseScratchObject(object.children[m], runtime, extensions, false, zip, assets.children[m]));\n    }\n  }\n  return Promise.all(costumePromises.concat(soundPromises)).then(function () {\n    return Promise.all(childrenPromises).then(function (children) {\n      \n      \n      if (target.isStage) {\n        var allBroadcastMsgs = globalBroadcastMsgObj.globalBroadcastMsgs;\n        var allBroadcastMsgFields = globalBroadcastMsgObj.allBroadcastFields;\n        var oldEmptyMsgName = globalBroadcastMsgObj.emptyMsgName;\n        if (allBroadcastMsgs[oldEmptyMsgName]) {\n          \n          var currIndex = 1;\n          while (allBroadcastMsgs[\"message\".concat(currIndex)]) {\n            currIndex += 1;\n          }\n          var newEmptyMsgName = \"message\".concat(currIndex); \n          \n          \n          allBroadcastMsgs[newEmptyMsgName] = allBroadcastMsgs[oldEmptyMsgName];\n          delete allBroadcastMsgs[oldEmptyMsgName]; \n          \n          for (var i = 0; i < allBroadcastMsgFields.length; i++) {\n            if (allBroadcastMsgFields[i].value === '') {\n              allBroadcastMsgFields[i].value = newEmptyMsgName;\n            }\n          }\n        } \n        \n        \n        for (var msgName in allBroadcastMsgs) {\n          var msgId = allBroadcastMsgs[msgName];\n          var newMsg = new Variable(msgId, msgName, Variable.BROADCAST_MESSAGE_TYPE, false);\n          target.variables[newMsg.id] = newMsg;\n        }\n      }\n      var targets = [target];\n      var deferredMonitors = [];\n      for (var n = 0; n < children.length; n++) {\n        if (children[n]) {\n          if (children[n].deferredMonitor) {\n            deferredMonitors.push(children[n]);\n          } else {\n            targets = targets.concat(children[n]);\n          }\n        }\n      } \n      \n      \n      \n      \n      \n      for (var _n2 = 0; _n2 < deferredMonitors.length; _n2++) {\n        parseMonitorObject(deferredMonitors[_n2], runtime, targets, extensions);\n      }\n      return targets;\n    });\n  });\n};\nvar reorderParsedTargets = function reorderParsedTargets(targets) {\n  \n  \n  var reordered = targets.map(function (t, index) {\n    t.layerOrder = index;\n    return t;\n  }).sort(function (a, b) {\n    return a.targetPaneOrder - b.targetPaneOrder;\n  }); \n  reordered.forEach(function (t) {\n    delete t.targetPaneOrder;\n  });\n  return reordered;\n};\n/**\n * Top-level handler. Parse provided JSON,\n * and process the top-level object (the stage object).\n * @param {!object} json SB2-format JSON to load.\n * @param {!Runtime} runtime Runtime object to load all structures into.\n * @param {boolean=} optForceSprite If set, treat as sprite (Sprite2).\n * @param {?object} zip Optional zipped assets for local file import\n * @return {Promise.<ImportedProject>} Promise that resolves to the loaded targets when ready.\n */\nvar sb2import = function sb2import(json, runtime, optForceSprite, zip) {\n  var extensions = {\n    extensionIDs: new Set(),\n    extensionURLs: new Map()\n  };\n  return Promise.resolve(parseScratchAssets(json, runtime, !optForceSprite, zip)) \n  \n  .then(function (assets) {\n    return Promise.resolve(assets);\n  }).then(function (assets) {\n    return parseScratchObject(json, runtime, extensions, !optForceSprite, zip, assets);\n  }).then(reorderParsedTargets).then(function (targets) {\n    return {\n      targets: targets,\n      extensions: extensions\n    };\n  });\n};\n/**\n * Given the sb2 block, inspect the specmap for a translation method or object.\n * @param {!object} block a sb2 formatted block\n * @return {object} specmap block to parse this opcode\n */\nvar specMapBlock = function specMapBlock(block) {\n  var opcode = block[0];\n  var mapped = opcode && specMap[opcode];\n  if (!mapped) {\n    log.warn(\"Couldn't find SB2 block: \".concat(opcode));\n    return null;\n  }\n  if (typeof mapped === 'function') {\n    return mapped(block);\n  }\n  return mapped;\n};\n/**\n * Parse a single SB2 JSON-formatted block and its children.\n * @param {!object} sb2block SB2 JSON-formatted block.\n * @param {Function} addBroadcastMsg function to update broadcast message name map\n * @param {Function} getVariableId function to retrieve a variable's ID based on name\n * @param {ImportedExtensionsInfo} extensions - (in/out) parsed extension information will be stored here.\n * @param {ParseState} parseState - info on the state of parsing beyond the current block.\n * @param {object<int, Comment>} comments - Comments from sb2 project that need to be attached to blocks.\n * They are indexed in this object by the sb2 flattened block list index indicating\n * which block they should attach to.\n * @param {int} commentIndex The comment index for the block to be parsed if it were in a flattened\n * list of all blocks for the target\n * @return {Array.<object|int>} Tuple where first item is the Scratch VM-format block (or null if unsupported object),\n * and second item is the updated comment index (after this block and its children are parsed)\n */\nvar parseBlock = function parseBlock(sb2block, addBroadcastMsg, getVariableId, extensions, parseState, comments, commentIndex) {\n  var commentsForParsedBlock = comments && typeof commentIndex === 'number' && !isNaN(commentIndex) ? comments[commentIndex] : null;\n  var blockMetadata = specMapBlock(sb2block);\n  if (!blockMetadata) {\n    \n    \n    \n    if (commentsForParsedBlock) {\n      commentsForParsedBlock.forEach(function (comment) {\n        comment.blockId = null;\n        comment.x = comment.y = 0;\n      });\n    }\n    return [null, commentIndex + 1];\n  }\n  var oldOpcode = sb2block[0]; \n  var index = blockMetadata.opcode.indexOf('_');\n  var prefix = blockMetadata.opcode.substring(0, index);\n  if (CORE_EXTENSIONS.indexOf(prefix) === -1) {\n    if (prefix !== '') extensions.extensionIDs.add(prefix);\n  } \n  var activeBlock = {\n    id: uid(),\n    \n    opcode: blockMetadata.opcode,\n    \n    inputs: {},\n    \n    fields: {},\n    \n    next: null,\n    \n    shadow: false,\n    \n    children: [] \n  }; \n  if (commentsForParsedBlock) {\n    \n    activeBlock.comment = commentsForParsedBlock[commentsForParsedBlock.length - 1].id;\n    commentsForParsedBlock.forEach(function (comment) {\n      if (comment.id === activeBlock.comment) {\n        comment.blockId = activeBlock.id;\n      } else {\n        \n        \n        comment.blockId = null;\n        comment.x = comment.y = 0;\n      }\n    });\n  }\n  commentIndex++;\n  var parentExpectedArg = parseState.expectedArg; \n  if (oldOpcode === 'call') {\n    blockMetadata.argMap = parseProcedureArgMap(sb2block[1]);\n  } \n  \n  \n  for (var i = 0; i < blockMetadata.argMap.length; i++) {\n    var expectedArg = blockMetadata.argMap[i];\n    var providedArg = sb2block[i + 1]; \n    \n    var shadowObscured = false; \n    if (expectedArg.type === 'input') {\n      \n      var inputUid = uid();\n      activeBlock.inputs[expectedArg.inputName] = {\n        name: expectedArg.inputName,\n        block: null,\n        shadow: null\n      };\n      if (_typeof(providedArg) === 'object' && providedArg) {\n        \n        var innerBlocks = void 0;\n        parseState.expectedArg = expectedArg;\n        if (_typeof(providedArg[0]) === 'object' && providedArg[0]) {\n          \n          var _parseBlockList3 = parseBlockList(providedArg, addBroadcastMsg, getVariableId, extensions, parseState, comments, commentIndex);\n          var _parseBlockList4 = _slicedToArray(_parseBlockList3, 2);\n          innerBlocks = _parseBlockList4[0];\n          commentIndex = _parseBlockList4[1];\n        } else {\n          \n          var parsedBlockDesc = parseBlock(providedArg, addBroadcastMsg, getVariableId, extensions, parseState, comments, commentIndex);\n          innerBlocks = parsedBlockDesc[0] ? [parsedBlockDesc[0]] : []; \n          commentIndex = parsedBlockDesc[1];\n        }\n        parseState.expectedArg = parentExpectedArg; \n        \n        \n        if (innerBlocks.length > 0) {\n          var previousBlock = null;\n          for (var j = 0; j < innerBlocks.length; j++) {\n            if (j === 0) {\n              innerBlocks[j].parent = activeBlock.id;\n            } else {\n              innerBlocks[j].parent = previousBlock;\n            }\n            previousBlock = innerBlocks[j].id;\n          }\n          activeBlock.inputs[expectedArg.inputName].block = innerBlocks[0].id;\n          activeBlock.children = activeBlock.children.concat(innerBlocks);\n        } \n        shadowObscured = true;\n      } \n      if (!expectedArg.inputOp) {\n        \n        log.warn(\"Unknown input operation for input \".concat(expectedArg.inputName, \" of opcode \").concat(activeBlock.opcode, \".\"));\n        continue;\n      }\n      if (expectedArg.inputOp === 'boolean' || expectedArg.inputOp === 'substack') {\n        \n        continue;\n      } \n      \n      var fieldValue = providedArg; \n      var fieldName = expectedArg.inputName;\n      if (expectedArg.inputOp === 'math_number' || expectedArg.inputOp === 'math_whole_number' || expectedArg.inputOp === 'math_positive_number' || expectedArg.inputOp === 'math_integer' || expectedArg.inputOp === 'math_angle') {\n        fieldName = 'NUM'; \n        if (shadowObscured) {\n          fieldValue = 10;\n        }\n      } else if (expectedArg.inputOp === 'text') {\n        fieldName = 'TEXT';\n        if (shadowObscured) {\n          fieldValue = '';\n        }\n      } else if (expectedArg.inputOp === 'colour_picker') {\n        \n        fieldValue = Color.decimalToHex(providedArg);\n        fieldName = 'COLOUR';\n        if (shadowObscured) {\n          fieldValue = '#990000';\n        }\n      } else if (expectedArg.inputOp === 'event_broadcast_menu') {\n        fieldName = 'BROADCAST_OPTION';\n        if (shadowObscured) {\n          fieldValue = '';\n        }\n      } else if (expectedArg.inputOp === 'sensing_of_object_menu') {\n        if (shadowObscured) {\n          fieldValue = '_stage_';\n        } else if (fieldValue === 'Stage') {\n          fieldValue = '_stage_';\n        }\n      } else if (expectedArg.inputOp === 'note') {\n        if (shadowObscured) {\n          fieldValue = 60;\n        }\n      } else if (expectedArg.inputOp === 'music.menu.DRUM') {\n        if (shadowObscured) {\n          fieldValue = 1;\n        }\n      } else if (expectedArg.inputOp === 'music.menu.INSTRUMENT') {\n        if (shadowObscured) {\n          fieldValue = 1;\n        }\n      } else if (expectedArg.inputOp === 'videoSensing.menu.ATTRIBUTE') {\n        if (shadowObscured) {\n          fieldValue = 'motion';\n        }\n      } else if (expectedArg.inputOp === 'videoSensing.menu.SUBJECT') {\n        if (shadowObscured) {\n          fieldValue = 'this sprite';\n        }\n      } else if (expectedArg.inputOp === 'videoSensing.menu.VIDEO_STATE') {\n        if (shadowObscured) {\n          fieldValue = 'on';\n        }\n      } else if (shadowObscured) {\n        \n        fieldValue = '';\n      }\n      var fields = {};\n      fields[fieldName] = {\n        name: fieldName,\n        value: fieldValue\n      }; \n      \n      if (expectedArg.inputOp === 'event_broadcast_menu') {\n        \n        \n        \n        \n        \n        \n        \n        \n        var broadcastId = addBroadcastMsg(fieldValue, fields[fieldName]);\n        fields[fieldName].id = broadcastId;\n        fields[fieldName].variableType = expectedArg.variableType;\n      }\n      activeBlock.children.push({\n        id: inputUid,\n        opcode: expectedArg.inputOp,\n        inputs: {},\n        fields: fields,\n        next: null,\n        topLevel: false,\n        parent: activeBlock.id,\n        shadow: true\n      });\n      activeBlock.inputs[expectedArg.inputName].shadow = inputUid; \n      if (!activeBlock.inputs[expectedArg.inputName].block) {\n        activeBlock.inputs[expectedArg.inputName].block = inputUid;\n      }\n    } else if (expectedArg.type === 'field') {\n      \n      activeBlock.fields[expectedArg.fieldName] = {\n        name: expectedArg.fieldName,\n        value: providedArg\n      };\n      if (expectedArg.fieldName === 'CURRENTMENU') {\n        \n        \n        activeBlock.fields[expectedArg.fieldName].value = providedArg.toUpperCase();\n        if (providedArg === 'day of week') {\n          activeBlock.fields[expectedArg.fieldName].value = 'DAYOFWEEK';\n        }\n      }\n      if (expectedArg.fieldName === 'VARIABLE') {\n        \n        activeBlock.fields[expectedArg.fieldName].id = getVariableId(providedArg, Variable.SCALAR_TYPE);\n      } else if (expectedArg.fieldName === 'LIST') {\n        \n        activeBlock.fields[expectedArg.fieldName].id = getVariableId(providedArg, Variable.LIST_TYPE);\n      } else if (expectedArg.fieldName === 'BROADCAST_OPTION') {\n        \n        \n        \n        \n        \n        \n        \n        var _broadcastId = addBroadcastMsg(providedArg, activeBlock.fields[expectedArg.fieldName]);\n        activeBlock.fields[expectedArg.fieldName].id = _broadcastId;\n      }\n      var varType = expectedArg.variableType;\n      if (typeof varType === 'string') {\n        activeBlock.fields[expectedArg.fieldName].variableType = varType;\n      }\n    }\n  } \n  switch (oldOpcode) {\n    case 'comeToFront':\n      activeBlock.fields.FRONT_BACK = {\n        name: 'FRONT_BACK',\n        value: 'front'\n      };\n      break;\n    case 'goBackByLayers:':\n      activeBlock.fields.FORWARD_BACKWARD = {\n        name: 'FORWARD_BACKWARD',\n        value: 'backward'\n      };\n      break;\n    case 'backgroundIndex':\n      activeBlock.fields.NUMBER_NAME = {\n        name: 'NUMBER_NAME',\n        value: 'number'\n      };\n      break;\n    case 'sceneName':\n      activeBlock.fields.NUMBER_NAME = {\n        name: 'NUMBER_NAME',\n        value: 'name'\n      };\n      break;\n    case 'costumeIndex':\n      activeBlock.fields.NUMBER_NAME = {\n        name: 'NUMBER_NAME',\n        value: 'number'\n      };\n      break;\n    case 'costumeName':\n      activeBlock.fields.NUMBER_NAME = {\n        name: 'NUMBER_NAME',\n        value: 'name'\n      };\n      break;\n  } \n  if (oldOpcode === 'stopScripts') {\n    \n    \n    if (sb2block[1] === 'other scripts in sprite' || sb2block[1] === 'other scripts in stage') {\n      activeBlock.mutation = {\n        tagName: 'mutation',\n        hasnext: 'true',\n        children: []\n      };\n    }\n  } else if (oldOpcode === 'procDef') {\n    \n    \n    var procData = sb2block.slice(1); \n    var _inputUid = uid();\n    var inputName = 'custom_block';\n    activeBlock.inputs[inputName] = {\n      name: inputName,\n      block: _inputUid,\n      shadow: _inputUid\n    };\n    activeBlock.children = [{\n      id: _inputUid,\n      opcode: 'procedures_prototype',\n      inputs: {},\n      fields: {},\n      next: null,\n      shadow: true,\n      children: [],\n      mutation: {\n        tagName: 'mutation',\n        proccode: procData[0],\n        \n        argumentnames: JSON.stringify(procData[1]),\n        \n        argumentids: JSON.stringify(parseProcedureArgIds(procData[0])),\n        argumentdefaults: JSON.stringify(procData[2]),\n        \n        warp: procData[3],\n        \n        children: []\n      }\n    }];\n  } else if (oldOpcode === 'call') {\n    \n    \n    activeBlock.mutation = {\n      tagName: 'mutation',\n      children: [],\n      proccode: sb2block[1],\n      argumentids: JSON.stringify(parseProcedureArgIds(sb2block[1]))\n    };\n  } else if (oldOpcode === 'getParam') {\n    var returnCode = sb2block[2]; \n    if (parentExpectedArg && parentExpectedArg.inputOp === 'boolean' && returnCode !== 'b') {\n      returnCode = 'b';\n    } \n    switch (returnCode) {\n      case 'r':\n        activeBlock.opcode = 'argument_reporter_string_number';\n        break;\n      case 'b':\n        activeBlock.opcode = 'argument_reporter_boolean';\n        break;\n    }\n  }\n  return [activeBlock, commentIndex];\n};\nmodule.exports = {\n  deserialize: sb2import\n};\n })