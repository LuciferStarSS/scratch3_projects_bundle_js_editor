/* 1246 */\n (function(module, exports) {\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n/**\n * @fileoverview\n * A representation of a Skin's silhouette that can test if a point on the skin\n * renders a pixel where it is drawn.\n */\n/**\n * <canvas> element used to update Silhouette data from skin bitmap data.\n * @type {CanvasElement}\n */\nvar __SilhouetteUpdateCanvas; \n\nvar intMin = function intMin(i, j) {\n  return j ^ (i ^ j) & i - j >> 31;\n};\nvar intMax = function intMax(i, j) {\n  return i ^ (i ^ j) & i - j >> 31;\n};\n/**\n * Internal helper function (in hopes that compiler can inline).  Get a pixel\n * from silhouette data, or 0 if outside it's bounds.\n * @private\n * @param {Silhouette} silhouette - has data width and height\n * @param {number} x - x\n * @param {number} y - y\n * @return {number} Alpha value for x/y position\n */\nvar getPoint = function getPoint(_ref, x, y) {\n  var width = _ref._width,\n      height = _ref._height,\n      data = _ref._colorData;\n  \n  if (x >= width || y >= height || x < 0 || y < 0) {\n    return 0;\n  }\n  return data[(y * width + x) * 4 + 3];\n};\n/**\n * Memory buffers for doing 4 corner sampling for linear interpolation\n */\nvar __cornerWork = [new Uint8ClampedArray(4), new Uint8ClampedArray(4), new Uint8ClampedArray(4), new Uint8ClampedArray(4)];\n/**\n * Get the color from a given silhouette at an x/y local texture position.\n * Multiply color values by alpha for proper blending.\n * @param {Silhouette} $0 The silhouette to sample.\n * @param {number} x X position of texture [0, width).\n * @param {number} y Y position of texture [0, height).\n * @param {Uint8ClampedArray} dst A color 4b space.\n * @return {Uint8ClampedArray} The dst vector.\n */\nvar getColor4b = function getColor4b(_ref2, x, y, dst) {\n  var width = _ref2._width,\n      height = _ref2._height,\n      data = _ref2._colorData;\n  \n  \n  x = intMax(0, intMin(x, width - 1));\n  y = intMax(0, intMin(y, height - 1)); \n  if (x >= width || y >= height || x < 0 || y < 0) {\n    return dst.fill(0);\n  }\n  var offset = (y * width + x) * 4; \n  var alpha = data[offset + 3] / 255;\n  dst[0] = data[offset] * alpha;\n  dst[1] = data[offset + 1] * alpha;\n  dst[2] = data[offset + 2] * alpha;\n  dst[3] = data[offset + 3];\n  return dst;\n};\n/**\n * Get the color from a given silhouette at an x/y local texture position.\n * Do not multiply color values by alpha, as it has already been done.\n * @param {Silhouette} $0 The silhouette to sample.\n * @param {number} x X position of texture [0, width).\n * @param {number} y Y position of texture [0, height).\n * @param {Uint8ClampedArray} dst A color 4b space.\n * @return {Uint8ClampedArray} The dst vector.\n */\nvar getPremultipliedColor4b = function getPremultipliedColor4b(_ref3, x, y, dst) {\n  var width = _ref3._width,\n      height = _ref3._height,\n      data = _ref3._colorData;\n  \n  x = intMax(0, intMin(x, width - 1));\n  y = intMax(0, intMin(y, height - 1));\n  var offset = (y * width + x) * 4;\n  dst[0] = data[offset];\n  dst[1] = data[offset + 1];\n  dst[2] = data[offset + 2];\n  dst[3] = data[offset + 3];\n  return dst;\n};\nvar Silhouette = function () {\n  function Silhouette() {\n    _classCallCheck(this, Silhouette);\n   \n    this._width = 0;\n   \n    this._height = 0;\n   \n    this._colorData = null; \n    \n    \n    this._getColor = getColor4b;\n    this.colorAtNearest = this.colorAtLinear = function (_, dst) {\n      return dst.fill(0);\n    };\n  }\n \n  _createClass(Silhouette, [{\n    key: \"update\",\n    value: function update(bitmapData) {\n      var isPremultiplied = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var imageData;\n      if (bitmapData instanceof ImageData) {\n        \n        imageData = bitmapData;\n        this._width = bitmapData.width;\n        this._height = bitmapData.height;\n      } else {\n        \n        \n        var canvas = Silhouette._updateCanvas();\n        var width = this._width = canvas.width = bitmapData.width;\n        var height = this._height = canvas.height = bitmapData.height;\n        var ctx = canvas.getContext('2d',{willReadFrequently:true});\n        if (!(width && height)) {\n          return;\n        }\n        ctx.clearRect(0, 0, width, height);\n        ctx.drawImage(bitmapData, 0, 0, width, height);\n        imageData = ctx.getImageData(0, 0, width, height);\n      }\n      if (isPremultiplied) {\n        this._getColor = getPremultipliedColor4b;\n      } else {\n        this._getColor = getColor4b;\n      }\n      this._colorData = imageData.data; \n      \n      delete this.colorAtNearest;\n      delete this.colorAtLinear;\n    }\n   \n  }, {\n    key: \"colorAtNearest\",\n    value: function colorAtNearest(vec, dst) {\n      return this._getColor(this, Math.floor(vec[0] * (this._width - 1)), Math.floor(vec[1] * (this._height - 1)), dst);\n    }\n   \n  }, {\n    key: \"colorAtLinear\",\n    value: function colorAtLinear(vec, dst) {\n      var x = vec[0] * (this._width - 1);\n      var y = vec[1] * (this._height - 1);\n      var x1D = x % 1;\n      var y1D = y % 1;\n      var x0D = 1 - x1D;\n      var y0D = 1 - y1D;\n      var xFloor = Math.floor(x);\n      var yFloor = Math.floor(y);\n      var x0y0 = this._getColor(this, xFloor, yFloor, __cornerWork[0]);\n      var x1y0 = this._getColor(this, xFloor + 1, yFloor, __cornerWork[1]);\n      var x0y1 = this._getColor(this, xFloor, yFloor + 1, __cornerWork[2]);\n      var x1y1 = this._getColor(this, xFloor + 1, yFloor + 1, __cornerWork[3]);\n      dst[0] = x0y0[0] * x0D * y0D + x0y1[0] * x0D * y1D + x1y0[0] * x1D * y0D + x1y1[0] * x1D * y1D;\n      dst[1] = x0y0[1] * x0D * y0D + x0y1[1] * x0D * y1D + x1y0[1] * x1D * y0D + x1y1[1] * x1D * y1D;\n      dst[2] = x0y0[2] * x0D * y0D + x0y1[2] * x0D * y1D + x1y0[2] * x1D * y0D + x1y1[2] * x1D * y1D;\n      dst[3] = x0y0[3] * x0D * y0D + x0y1[3] * x0D * y1D + x1y0[3] * x1D * y0D + x1y1[3] * x1D * y1D;\n      return dst;\n    }\n   \n  }, {\n    key: \"isTouchingNearest\",\n    value: function isTouchingNearest(vec) {\n      if (!this._colorData) return;\n      return getPoint(this, Math.floor(vec[0] * (this._width - 1)), Math.floor(vec[1] * (this._height - 1))) > 0;\n    }\n   \n  }, {\n    key: \"isTouchingLinear\",\n    value: function isTouchingLinear(vec) {\n      if (!this._colorData) return;\n      var x = Math.floor(vec[0] * (this._width - 1));\n      var y = Math.floor(vec[1] * (this._height - 1));\n      return getPoint(this, x, y) > 0 || getPoint(this, x + 1, y) > 0 || getPoint(this, x, y + 1) > 0 || getPoint(this, x + 1, y + 1) > 0;\n    }\n   \n  }], [{\n    key: \"_updateCanvas\",\n    value: function _updateCanvas() {\n      if (typeof __SilhouetteUpdateCanvas === 'undefined') {\n        __SilhouetteUpdateCanvas = document.createElement('canvas');\n      }\n      return __SilhouetteUpdateCanvas;\n    }\n  }]);\n  return Silhouette;\n}();\nmodule.exports = Silhouette;\n })