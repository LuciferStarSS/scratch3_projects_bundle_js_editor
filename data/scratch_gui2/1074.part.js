/* 1074 */\n (function(module, exports) {\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n/**\n * @fileoverview\n * A way to profile Scratch internal performance. Like what blocks run during a\n * step? How much time do they take? How much time is spent inbetween blocks?\n *\n * Profiler aims for to spend as little time inside its functions while\n * recording. For this it has a simple internal record structure that records a\n * series of values for each START and STOP event in a single array. This lets\n * all the values be pushed in one call for the array. This simplicity allows\n * the contents of the start() and stop() calls to be inlined in areas that are\n * called frequently enough to want even greater performance from Profiler so\n * what is recorded better reflects on the profiled code and not Profiler\n * itself.\n */\n/**\n * The next id returned for a new profile'd function.\n * @type {number}\n */\nvar nextId = 0;\n/**\n * The mapping of names to ids.\n * @const {Object.<string, number>}\n */\nvar profilerNames = {};\n/**\n * The START event identifier in Profiler records.\n * @const {number}\n */\nvar START = 0;\n/**\n * The STOP event identifier in Profiler records.\n * @const {number}\n */\nvar STOP = 1;\n/**\n * The number of cells used in the records array by a START event.\n * @const {number}\n */\nvar START_SIZE = 4;\n/**\n * The number of cells used in the records array by a STOP event.\n * @const {number}\n */\nvar STOP_SIZE = 2;\n/**\n * Stored reference to Performance instance provided by the Browser.\n * @const {Performance}\n */\nvar performance = (typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === 'object' && window.performance;\n/**\n * Callback handle called by Profiler for each frame it decodes from its\n * records.\n * @callback FrameCallback\n * @param {ProfilerFrame} frame\n */\n/**\n * A set of information about a frame of execution that was recorded.\n */\nvar ProfilerFrame =\n/**\n * @param {number} depth Depth of the frame in the recorded stack.\n */\nfunction ProfilerFrame(depth) {\n  _classCallCheck(this, ProfilerFrame);\n \n  this.id = -1;\n \n  this.totalTime = 0;\n \n  this.selfTime = 0;\n \n  this.arg = null;\n \n  this.depth = depth;\n \n  this.count = 0;\n};\nvar Profiler = function () {\n \n  function Profiler() {\n    var onFrame = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};\n    _classCallCheck(this, Profiler);\n   \n    this.records = [];\n   \n    this.increments = [];\n   \n    this.counters = [];\n   \n    this.nullFrame = new ProfilerFrame(-1);\n   \n    this._stack = [new ProfilerFrame(0)];\n   \n    this.onFrame = onFrame;\n   \n    this.START = START;\n   \n    this.STOP = STOP;\n  }\n \n  _createClass(Profiler, [{\n    key: \"start\",\n    value: function start(id, arg) {\n      this.records.push(START, id, arg, performance.now());\n    }\n   \n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.records.push(STOP, performance.now());\n    }\n   \n  }, {\n    key: \"increment\",\n    value: function increment(id) {\n      if (!this.increments[id]) {\n        this.increments[id] = new ProfilerFrame(-1);\n        this.increments[id].id = id;\n      }\n      this.increments[id].count += 1;\n    }\n   \n  }, {\n    key: \"frame\",\n    value: function frame(id, arg) {\n      for (var i = 0; i < this.counters.length; i++) {\n        if (this.counters[i].id === id && this.counters[i].arg === arg) {\n          return this.counters[i];\n        }\n      }\n      var newCounter = new ProfilerFrame(-1);\n      newCounter.id = id;\n      newCounter.arg = arg;\n      this.counters.push(newCounter);\n      return newCounter;\n    }\n   \n  }, {\n    key: \"reportFrames\",\n    value: function reportFrames() {\n      var stack = this._stack;\n      var depth = 1; \n      \n      \n      \n      \n      \n      \n      \n      for (var i = 0; i < this.records.length;) {\n        if (this.records[i] === START) {\n          if (depth >= stack.length) {\n            stack.push(new ProfilerFrame(depth));\n          } \n          var frame = stack[depth++];\n          frame.id = this.records[i + 1];\n          frame.arg = this.records[i + 2]; \n          \n          \n          \n          \n          //\n          \n          \n          \n          frame.totalTime = this.records[i + 3]; \n          \n          \n          frame.selfTime = 0;\n          i += START_SIZE;\n        } else if (this.records[i] === STOP) {\n          var now = this.records[i + 1];\n          var _frame = stack[--depth]; \n          \n          \n          _frame.totalTime = now - _frame.totalTime; \n          \n          _frame.selfTime += _frame.totalTime; \n          stack[depth - 1].selfTime -= _frame.totalTime; \n          _frame.count = 1;\n          this.onFrame(_frame);\n          i += STOP_SIZE;\n        } else {\n          this.records.length = 0;\n          throw new Error('Unable to decode Profiler records.');\n        }\n      }\n      for (var j = 0; j < this.increments.length; j++) {\n        if (this.increments[j] && this.increments[j].count > 0) {\n          this.onFrame(this.increments[j]);\n          this.increments[j].count = 0;\n        }\n      }\n      for (var k = 0; k < this.counters.length; k++) {\n        if (this.counters[k].count > 0) {\n          this.onFrame(this.counters[k]);\n          this.counters[k].count = 0;\n        }\n      }\n      this.records.length = 0;\n    }\n   \n  }, {\n    key: \"idByName\",\n    value: function idByName(name) {\n      return Profiler.idByName(name);\n    }\n   \n  }, {\n    key: \"nameById\",\n    value: function nameById(id) {\n      return Profiler.nameById(id);\n    }\n   \n  }], [{\n    key: \"idByName\",\n    value: function idByName(name) {\n      if (typeof profilerNames[name] !== 'number') {\n        profilerNames[name] = nextId++;\n      }\n      return profilerNames[name];\n    }\n   \n  }, {\n    key: \"nameById\",\n    value: function nameById(id) {\n      for (var name in profilerNames) {\n        if (profilerNames[name] === id) {\n          return name;\n        }\n      }\n      return null;\n    }\n   \n  }, {\n    key: \"available\",\n    value: function available() {\n      return (typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === 'object' && typeof window.performance !== 'undefined';\n    }\n  }]);\n  return Profiler;\n}();\n/**\n * A reference to the START record id constant.\n * @const {number}\n */\nProfiler.START = START;\n/**\n * A reference to the STOP record id constant.\n * @const {number}\n */\nProfiler.STOP = STOP;\nmodule.exports = Profiler;\n })