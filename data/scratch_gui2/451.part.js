/* 451 */\n (function(module, exports, __webpack_require__) {\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\nvar BlockUtility = __webpack_require__(1076);\nvar BlocksExecuteCache = __webpack_require__(440);\nvar log = __webpack_require__(39);\nvar Thread = __webpack_require__(224);\nvar _require = __webpack_require__(181),\n    Map = _require.Map;\nvar cast = __webpack_require__(48);\n/**\n * Single BlockUtility instance reused by execute for every pritimive ran.\n * @const\n */\nvar blockUtility = new BlockUtility();\n/**\n * Profiler frame name for block functions.\n * @const {string}\n */\nvar blockFunctionProfilerFrame = 'blockFunction';\n/**\n * Profiler frame ID for 'blockFunction'.\n * @type {number}\n */\nvar blockFunctionProfilerId = -1;\n/**\n * Utility function to determine if a value is a Promise.\n * @param {*} value Value to check for a Promise.\n * @return {boolean} True if the value appears to be a Promise.\n */\nvar isPromise = function isPromise(value) {\n  return value !== null && _typeof(value) === 'object' && typeof value.then === 'function';\n};\n/**\n * Handle any reported value from the primitive, either directly returned\n * or after a promise resolves.\n * @param {*} resolvedValue Value eventually returned from the primitive.\n * @param {!Sequencer} sequencer Sequencer stepping the thread for the ran\n * primitive.\n * @param {!Thread} thread Thread containing the primitive.\n * @param {!string} currentBlockId Id of the block in its thread for value from\n * the primitive.\n * @param {!string} opcode opcode used to identify a block function primitive.\n * @param {!boolean} isHat Is the current block a hat?\n */\n\n\nvar handleReport = function handleReport(resolvedValue, sequencer, thread, blockCached, lastOperation) {\n  var currentBlockId = blockCached.id;\n  var opcode = blockCached.opcode;\n  var isHat = blockCached._isHat;\n  thread.pushReportedValue(resolvedValue);\n  if (isHat) {\n    \n    if (sequencer.runtime.getIsEdgeActivatedHat(opcode)) {\n      \n      \n      \n      if (!thread.stackClick) {\n        var hasOldEdgeValue = thread.target.hasEdgeActivatedValue(currentBlockId);\n        var oldEdgeValue = thread.target.updateEdgeActivatedValue(currentBlockId, resolvedValue);\n        var edgeWasActivated = hasOldEdgeValue ? !oldEdgeValue && resolvedValue : resolvedValue;\n        if (!edgeWasActivated) {\n          sequencer.retireThread(thread);\n        }\n      }\n    } else if (!resolvedValue) {\n      \n      \n      sequencer.retireThread(thread);\n    }\n  } else {\n    \n    \n    if (lastOperation && typeof resolvedValue !== 'undefined' && thread.atStackTop()) {\n      if (thread.stackClick) {\n        sequencer.runtime.visualReport(currentBlockId, resolvedValue);\n      }\n      if (thread.updateMonitor) {\n        var targetId = sequencer.runtime.monitorBlocks.getBlock(currentBlockId).targetId;\n        if (targetId && !sequencer.runtime.getTargetById(targetId)) {\n          \n          return;\n        }\n        sequencer.runtime.requestUpdateMonitor(Map({\n          id: currentBlockId,\n          spriteName: targetId ? sequencer.runtime.getTargetById(targetId).getName() : null,\n          value: resolvedValue\n        }));\n      }\n    } \n    thread.status = Thread.STATUS_RUNNING;\n  }\n};\nvar handlePromise = function handlePromise(primitiveReportedValue, sequencer, thread, blockCached, lastOperation) {\n  if (thread.status === Thread.STATUS_RUNNING) {\n    \n    thread.status = Thread.STATUS_PROMISE_WAIT;\n  } \n  primitiveReportedValue.then(function (resolvedValue) {\n    handleReport(resolvedValue, sequencer, thread, blockCached, lastOperation); \n    if (lastOperation) {\n      var stackFrame;\n      var nextBlockId;\n      do {\n        \n        \n        var popped = thread.popStack();\n        if (popped === null) {\n          return;\n        }\n        nextBlockId = thread.target.blocks.getNextBlock(popped);\n        if (nextBlockId !== null) {\n          \n          break;\n        } \n        \n        stackFrame = thread.peekStackFrame();\n      } while (stackFrame !== null && !stackFrame.isLoop);\n      thread.pushStack(nextBlockId);\n    }\n  }, function (rejectionReason) {\n    \n    \n    log.warn('Primitive rejected promise: ', rejectionReason);\n    thread.status = Thread.STATUS_RUNNING;\n    thread.popStack();\n  });\n};\n/**\n * A execute.js internal representation of a block to reduce the time spent in\n * execute as the same blocks are called the most.\n *\n * With the help of the Blocks class create a mutable copy of block\n * information. The members of BlockCached derived values of block information\n * that does not need to be reevaluated until a change in Blocks. Since Blocks\n * handles where the cache instance is stored, it drops all cache versions of a\n * block when any change happens to it. This way we can quickly execute blocks\n * and keep perform the right action according to the current block information\n * in the editor.\n *\n * @param {Blocks} blockContainer the related Blocks instance\n * @param {object} cached default set of cached values\n */\nvar BlockCached = function BlockCached(blockContainer, cached) {\n  _classCallCheck(this, BlockCached);\n \n  this.id = cached.id;\n \n  this.opcode = cached.opcode;\n \n  this.fields = cached.fields;\n \n  this.inputs = cached.inputs;\n \n  this.mutation = cached.mutation;\n \n  this._profiler = null;\n \n  this._profilerFrame = null;\n \n  this._isHat = false;\n \n  this._blockFunction = null;\n \n  this._definedBlockFunction = false;\n \n  this._isShadowBlock = false;\n \n  this._shadowValue = null;\n \n  this._fields = Object.assign({}, this.fields);\n \n  this._inputs = Object.assign({}, this.inputs);\n \n  this._argValues = {\n    mutation: this.mutation\n  };\n \n  this._parentKey = null;\n \n  this._parentValues = null;\n \n  this._ops = [];\n  var runtime = blockUtility.sequencer.runtime;\n  var opcode = this.opcode,\n      fields = this.fields,\n      inputs = this.inputs; \n  this._isHat = runtime.getIsHat(opcode);\n  this._blockFunction = runtime.getOpcodeFunction(opcode);\n  this._definedBlockFunction = typeof this._blockFunction !== 'undefined'; \n  var fieldKeys = Object.keys(fields);\n  this._isShadowBlock = !this._definedBlockFunction && fieldKeys.length === 1 && Object.keys(inputs).length === 0;\n  this._shadowValue = this._isShadowBlock && fields[fieldKeys[0]].value; \n  for (var fieldName in fields) {\n    if (fieldName === 'VARIABLE' || fieldName === 'LIST' || fieldName === 'BROADCAST_OPTION') {\n      this._argValues[fieldName] = {\n        id: fields[fieldName].id,\n        name: fields[fieldName].value\n      };\n    } else {\n      this._argValues[fieldName] = fields[fieldName].value;\n    }\n  } \n  delete this._inputs.custom_block;\n  if ('BROADCAST_INPUT' in this._inputs) {\n    \n    \n    this._argValues.BROADCAST_OPTION = {\n      id: null,\n      name: null\n    }; \n    \n    var broadcastInput = this._inputs.BROADCAST_INPUT;\n    if (broadcastInput.block === broadcastInput.shadow) {\n      \n      \n      var shadow = blockContainer.getBlock(broadcastInput.shadow);\n      var broadcastField = shadow.fields.BROADCAST_OPTION;\n      this._argValues.BROADCAST_OPTION.id = broadcastField.id;\n      this._argValues.BROADCAST_OPTION.name = broadcastField.value; \n      \n      delete this._inputs.BROADCAST_INPUT;\n    }\n  } \n  \n  \n  \n  for (var inputName in this._inputs) {\n    var input = this._inputs[inputName];\n    if (input.block) {\n      var _this$_ops;\n      var inputCached = BlocksExecuteCache.getCached(blockContainer, input.block, BlockCached);\n      if (inputCached._isHat) {\n        continue;\n      }\n      (_this$_ops = this._ops).push.apply(_this$_ops, _toConsumableArray(inputCached._ops));\n      inputCached._parentKey = inputName;\n      inputCached._parentValues = this._argValues; \n      \n      if (inputCached._isShadowBlock) {\n        this._argValues[inputName] = inputCached._shadowValue;\n      }\n    }\n  } \n  \n  if (this._definedBlockFunction) {\n    this._ops.push(this);\n  }\n};\n/**\n * Initialize a BlockCached instance so its command/hat\n * block and reporters can be profiled during execution.\n * @param {Profiler} profiler - The profiler that is currently enabled.\n * @param {BlockCached} blockCached - The blockCached instance to profile.\n */\nvar _prepareBlockProfiling = function _prepareBlockProfiling(profiler, blockCached) {\n  blockCached._profiler = profiler;\n  if (blockFunctionProfilerId === -1) {\n    blockFunctionProfilerId = profiler.idByName(blockFunctionProfilerFrame);\n  }\n  var ops = blockCached._ops;\n  for (var i = 0; i < ops.length; i++) {\n    ops[i]._profilerFrame = profiler.frame(blockFunctionProfilerId, ops[i].opcode);\n  }\n};\n/**\n * Execute a block.\n * @param {!Sequencer} sequencer Which sequencer is executing.\n * @param {!Thread} thread Thread which to read and execute.\n */\nvar execute = function execute(sequencer, thread) {\n  var runtime = sequencer.runtime; \n  \n  blockUtility.sequencer = sequencer;\n  blockUtility.thread = thread; \n  var currentBlockId = thread.peekStack();\n  var currentStackFrame = thread.peekStackFrame();\n  var blockContainer = thread.blockContainer;\n  var blockCached = BlocksExecuteCache.getCached(blockContainer, currentBlockId, BlockCached);\n  if (blockCached === null) {\n    blockContainer = runtime.flyoutBlocks;\n    blockCached = BlocksExecuteCache.getCached(blockContainer, currentBlockId, BlockCached); \n    if (blockCached === null) {\n      \n      sequencer.retireThread(thread);\n      return;\n    }\n  }\n  var ops = blockCached._ops;\n  var length = ops.length;\n  var i = 0;\n  if (currentStackFrame.reported !== null) {\n    var reported = currentStackFrame.reported; \n    var _loop = function _loop() {\n      var _reported$i = reported[i],\n          oldOpCached = _reported$i.opCached,\n          inputValue = _reported$i.inputValue;\n      var opCached = ops.find(function (op) {\n        return op.id === oldOpCached;\n      });\n      if (opCached) {\n        var _inputName = opCached._parentKey;\n        var _argValues = opCached._parentValues;\n        if (_inputName === 'BROADCAST_INPUT') {\n          \n          \n          _argValues.BROADCAST_OPTION.id = null;\n          _argValues.BROADCAST_OPTION.name = cast.toString(inputValue);\n        } else {\n          _argValues[_inputName] = inputValue;\n        }\n      }\n    };\n    for (; i < reported.length; i++) {\n      _loop();\n    } \n    \n    \n    \n    if (reported.length > 0) {\n      var lastExisting = reported.reverse().find(function (report) {\n        return ops.find(function (op) {\n          return op.id === report.opCached;\n        });\n      });\n      if (lastExisting) {\n        i = ops.findIndex(function (opCached) {\n          return opCached.id === lastExisting.opCached;\n        }) + 1;\n      } else {\n        i = 0;\n      }\n    } \n    if (thread.justReported !== null && ops[i] && ops[i].id === currentStackFrame.reporting) {\n      var opCached = ops[i];\n      var inputValue = thread.justReported;\n      thread.justReported = null;\n      var inputName = opCached._parentKey;\n      var argValues = opCached._parentValues;\n      if (inputName === 'BROADCAST_INPUT') {\n        \n        \n        argValues.BROADCAST_OPTION.id = null;\n        argValues.BROADCAST_OPTION.name = cast.toString(inputValue);\n      } else {\n        argValues[inputName] = inputValue;\n      }\n      i += 1;\n    }\n    currentStackFrame.reporting = null;\n    currentStackFrame.reported = null;\n  }\n  var start = i;\n  for (; i < length; i++) {\n    var lastOperation = i === length - 1;\n    var _opCached = ops[i];\n    var blockFunction = _opCached._blockFunction; \n    var _argValues2 = _opCached._argValues; \n    \n    \n    \n    \n    if (!blockContainer.forceNoGlow) {\n      thread.requestScriptGlowInFrame = true;\n    } \n    var primitiveReportedValue = blockFunction(_argValues2, blockUtility); \n    if (isPromise(primitiveReportedValue)) {\n      handlePromise(primitiveReportedValue, sequencer, thread, _opCached, lastOperation); \n      \n      \n      \n      thread.justReported = null;\n      currentStackFrame.reporting = ops[i].id;\n      currentStackFrame.reported = ops.slice(0, i).map(function (reportedCached) {\n        var inputName = reportedCached._parentKey;\n        var reportedValues = reportedCached._parentValues;\n        if (inputName === 'BROADCAST_INPUT') {\n          return {\n            opCached: reportedCached.id,\n            inputValue: reportedValues[inputName].BROADCAST_OPTION.name\n          };\n        }\n        return {\n          opCached: reportedCached.id,\n          inputValue: reportedValues[inputName]\n        };\n      }); \n      \n      break;\n    } else if (thread.status === Thread.STATUS_RUNNING) {\n      if (lastOperation) {\n        handleReport(primitiveReportedValue, sequencer, thread, _opCached, lastOperation);\n      } else {\n        \n        \n        var _inputName2 = _opCached._parentKey;\n        var parentValues = _opCached._parentValues;\n        if (_inputName2 === 'BROADCAST_INPUT') {\n          \n          \n          parentValues.BROADCAST_OPTION.id = null;\n          parentValues.BROADCAST_OPTION.name = cast.toString(primitiveReportedValue);\n        } else {\n          parentValues[_inputName2] = primitiveReportedValue;\n        }\n      }\n    }\n  }\n  if (runtime.profiler !== null) {\n    if (blockCached._profiler !== runtime.profiler) {\n      _prepareBlockProfiling(runtime.profiler, blockCached);\n    } \n    \n    \n    \n    var end = Math.min(i + 1, length);\n    for (var p = start; p < end; p++) {\n      ops[p]._profilerFrame.count += 1;\n    }\n  }\n};\nmodule.exports = execute;\n })