/* 907 */\n (function(module, exports, __webpack_require__) {\n\n\n/**\n * @fileoverview Global |this| required for resolving indexes in node.\n * @suppress {globalThis}\n */\n(function(global) {\n  'use strict';\n  \n  if ( true && module.exports &&\n    !global[\"encoding-indexes\"]) {\n    global[\"encoding-indexes\"] =\n      __webpack_require__(908)[\"encoding-indexes\"];\n  }\n  //\n  \n  //\n \n  function inRange(a, min, max) {\n    return min <= a && a <= max;\n  }\n \n  function includes(array, item) {\n    return array.indexOf(item) !== -1;\n  }\n  var floor = Math.floor;\n \n  function ToDictionary(o) {\n    if (o === undefined) return {};\n    if (o === Object(o)) return o;\n    throw TypeError('Could not convert argument to dictionary');\n  }\n \n  function stringToCodePoints(string) {\n    \n    \n    var s = String(string);\n    \n    var n = s.length;\n    \n    var i = 0;\n    \n    var u = [];\n    \n    while (i < n) {\n      \n      var c = s.charCodeAt(i);\n      \n      \n      if (c < 0xD800 || c > 0xDFFF) {\n        \n        u.push(c);\n      }\n      \n      else if (0xDC00 <= c && c <= 0xDFFF) {\n        \n        u.push(0xFFFD);\n      }\n      \n      else if (0xD800 <= c && c <= 0xDBFF) {\n        \n        \n        if (i === n - 1) {\n          u.push(0xFFFD);\n        }\n        \n        else {\n          \n          var d = s.charCodeAt(i + 1);\n          \n          if (0xDC00 <= d && d <= 0xDFFF) {\n            \n            var a = c & 0x3FF;\n            \n            var b = d & 0x3FF;\n            \n            // 2^16+2^10*a+b.\n            u.push(0x10000 + (a << 10) + b);\n            \n            i += 1;\n          }\n          \n          \n          else  {\n            u.push(0xFFFD);\n          }\n        }\n      }\n      \n      i += 1;\n    }\n    \n    return u;\n  }\n \n  function codePointsToString(code_points) {\n    var s = '';\n    for (var i = 0; i < code_points.length; ++i) {\n      var cp = code_points[i];\n      if (cp <= 0xFFFF) {\n        s += String.fromCharCode(cp);\n      } else {\n        cp -= 0x10000;\n        s += String.fromCharCode((cp >> 10) + 0xD800,\n                                 (cp & 0x3FF) + 0xDC00);\n      }\n    }\n    return s;\n  }\n  //\n  \n  \n  //\n  //\n  \n  //\n \n  function isASCIIByte(a) {\n    return 0x00 <= a && a <= 0x7F;\n  }\n \n  var isASCIICodePoint = isASCIIByte;\n  var end_of_stream = -1;\n \n  function Stream(tokens) {\n   \n    this.tokens = [].slice.call(tokens);\n    \n    this.tokens.reverse();\n  }\n  Stream.prototype = {\n   \n    endOfStream: function() {\n      return !this.tokens.length;\n    },\n   \n     read: function() {\n      if (!this.tokens.length)\n        return end_of_stream;\n       return this.tokens.pop();\n     },\n   \n    prepend: function(token) {\n      if (Array.isArray(token)) {\n        var tokens =(token);\n        while (tokens.length)\n          this.tokens.push(tokens.pop());\n      } else {\n        this.tokens.push(token);\n      }\n    },\n   \n    push: function(token) {\n      if (Array.isArray(token)) {\n        var tokens =(token);\n        while (tokens.length)\n          this.tokens.unshift(tokens.shift());\n      } else {\n        this.tokens.unshift(token);\n      }\n    }\n  };\n  //\n  \n  //\n  \n \n  var finished = -1;\n \n  function decoderError(fatal, opt_code_point) {\n    if (fatal)\n      throw TypeError('Decoder error');\n    return opt_code_point || 0xFFFD;\n  }\n \n  function encoderError(code_point) {\n    throw TypeError('The code point ' + code_point + ' could not be encoded.');\n  }\n \n  function Decoder() {}\n  Decoder.prototype = {\n   \n    handler: function(stream, bite) {}\n  };\n \n  function Encoder() {}\n  Encoder.prototype = {\n   \n    handler: function(stream, code_point) {}\n  };\n  \n  \n  \n \n  function getEncoding(label) {\n    \n    label = String(label).trim().toLowerCase();\n    \n    \n    \n    if (Object.prototype.hasOwnProperty.call(label_to_encoding, label)) {\n      return label_to_encoding[label];\n    }\n    return null;\n  }\n \n  var encodings = [\n    {\n      \"encodings\": [\n        {\n          \"labels\": [\n            \"unicode-1-1-utf-8\",\n            \"utf-8\",\n            \"utf8\"\n          ],\n          \"name\": \"UTF-8\"\n        }\n      ],\n      \"heading\": \"The Encoding\"\n    },\n    {\n      \"encodings\": [\n        {\n          \"labels\": [\n            \"866\",\n            \"cp866\",\n            \"csibm866\",\n            \"ibm866\"\n          ],\n          \"name\": \"IBM866\"\n        },\n        {\n          \"labels\": [\n            \"csisolatin2\",\n            \"iso-8859-2\",\n            \"iso-ir-101\",\n            \"iso8859-2\",\n            \"iso88592\",\n            \"iso_8859-2\",\n            \"iso_8859-2:1987\",\n            \"l2\",\n            \"latin2\"\n          ],\n          \"name\": \"ISO-8859-2\"\n        },\n        {\n          \"labels\": [\n            \"csisolatin3\",\n            \"iso-8859-3\",\n            \"iso-ir-109\",\n            \"iso8859-3\",\n            \"iso88593\",\n            \"iso_8859-3\",\n            \"iso_8859-3:1988\",\n            \"l3\",\n            \"latin3\"\n          ],\n          \"name\": \"ISO-8859-3\"\n        },\n        {\n          \"labels\": [\n            \"csisolatin4\",\n            \"iso-8859-4\",\n            \"iso-ir-110\",\n            \"iso8859-4\",\n            \"iso88594\",\n            \"iso_8859-4\",\n            \"iso_8859-4:1988\",\n            \"l4\",\n            \"latin4\"\n          ],\n          \"name\": \"ISO-8859-4\"\n        },\n        {\n          \"labels\": [\n            \"csisolatincyrillic\",\n            \"cyrillic\",\n            \"iso-8859-5\",\n            \"iso-ir-144\",\n            \"iso8859-5\",\n            \"iso88595\",\n            \"iso_8859-5\",\n            \"iso_8859-5:1988\"\n          ],\n          \"name\": \"ISO-8859-5\"\n        },\n        {\n          \"labels\": [\n            \"arabic\",\n            \"asmo-708\",\n            \"csiso88596e\",\n            \"csiso88596i\",\n            \"csisolatinarabic\",\n            \"ecma-114\",\n            \"iso-8859-6\",\n            \"iso-8859-6-e\",\n            \"iso-8859-6-i\",\n            \"iso-ir-127\",\n            \"iso8859-6\",\n            \"iso88596\",\n            \"iso_8859-6\",\n            \"iso_8859-6:1987\"\n          ],\n          \"name\": \"ISO-8859-6\"\n        },\n        {\n          \"labels\": [\n            \"csisolatingreek\",\n            \"ecma-118\",\n            \"elot_928\",\n            \"greek\",\n            \"greek8\",\n            \"iso-8859-7\",\n            \"iso-ir-126\",\n            \"iso8859-7\",\n            \"iso88597\",\n            \"iso_8859-7\",\n            \"iso_8859-7:1987\",\n            \"sun_eu_greek\"\n          ],\n          \"name\": \"ISO-8859-7\"\n        },\n        {\n          \"labels\": [\n            \"csiso88598e\",\n            \"csisolatinhebrew\",\n            \"hebrew\",\n            \"iso-8859-8\",\n            \"iso-8859-8-e\",\n            \"iso-ir-138\",\n            \"iso8859-8\",\n            \"iso88598\",\n            \"iso_8859-8\",\n            \"iso_8859-8:1988\",\n            \"visual\"\n          ],\n          \"name\": \"ISO-8859-8\"\n        },\n        {\n          \"labels\": [\n            \"csiso88598i\",\n            \"iso-8859-8-i\",\n            \"logical\"\n          ],\n          \"name\": \"ISO-8859-8-I\"\n        },\n        {\n          \"labels\": [\n            \"csisolatin6\",\n            \"iso-8859-10\",\n            \"iso-ir-157\",\n            \"iso8859-10\",\n            \"iso885910\",\n            \"l6\",\n            \"latin6\"\n          ],\n          \"name\": \"ISO-8859-10\"\n        },\n        {\n          \"labels\": [\n            \"iso-8859-13\",\n            \"iso8859-13\",\n            \"iso885913\"\n          ],\n          \"name\": \"ISO-8859-13\"\n        },\n        {\n          \"labels\": [\n            \"iso-8859-14\",\n            \"iso8859-14\",\n            \"iso885914\"\n          ],\n          \"name\": \"ISO-8859-14\"\n        },\n        {\n          \"labels\": [\n            \"csisolatin9\",\n            \"iso-8859-15\",\n            \"iso8859-15\",\n            \"iso885915\",\n            \"iso_8859-15\",\n            \"l9\"\n          ],\n          \"name\": \"ISO-8859-15\"\n        },\n        {\n          \"labels\": [\n            \"iso-8859-16\"\n          ],\n          \"name\": \"ISO-8859-16\"\n        },\n        {\n          \"labels\": [\n            \"cskoi8r\",\n            \"koi\",\n            \"koi8\",\n            \"koi8-r\",\n            \"koi8_r\"\n          ],\n          \"name\": \"KOI8-R\"\n        },\n        {\n          \"labels\": [\n            \"koi8-ru\",\n            \"koi8-u\"\n          ],\n          \"name\": \"KOI8-U\"\n        },\n        {\n          \"labels\": [\n            \"csmacintosh\",\n            \"mac\",\n            \"macintosh\",\n            \"x-mac-roman\"\n          ],\n          \"name\": \"macintosh\"\n        },\n        {\n          \"labels\": [\n            \"dos-874\",\n            \"iso-8859-11\",\n            \"iso8859-11\",\n            \"iso885911\",\n            \"tis-620\",\n            \"windows-874\"\n          ],\n          \"name\": \"windows-874\"\n        },\n        {\n          \"labels\": [\n            \"cp1250\",\n            \"windows-1250\",\n            \"x-cp1250\"\n          ],\n          \"name\": \"windows-1250\"\n        },\n        {\n          \"labels\": [\n            \"cp1251\",\n            \"windows-1251\",\n            \"x-cp1251\"\n          ],\n          \"name\": \"windows-1251\"\n        },\n        {\n          \"labels\": [\n            \"ansi_x3.4-1968\",\n            \"ascii\",\n            \"cp1252\",\n            \"cp819\",\n            \"csisolatin1\",\n            \"ibm819\",\n            \"iso-8859-1\",\n            \"iso-ir-100\",\n            \"iso8859-1\",\n            \"iso88591\",\n            \"iso_8859-1\",\n            \"iso_8859-1:1987\",\n            \"l1\",\n            \"latin1\",\n            \"us-ascii\",\n            \"windows-1252\",\n            \"x-cp1252\"\n          ],\n          \"name\": \"windows-1252\"\n        },\n        {\n          \"labels\": [\n            \"cp1253\",\n            \"windows-1253\",\n            \"x-cp1253\"\n          ],\n          \"name\": \"windows-1253\"\n        },\n        {\n          \"labels\": [\n            \"cp1254\",\n            \"csisolatin5\",\n            \"iso-8859-9\",\n            \"iso-ir-148\",\n            \"iso8859-9\",\n            \"iso88599\",\n            \"iso_8859-9\",\n            \"iso_8859-9:1989\",\n            \"l5\",\n            \"latin5\",\n            \"windows-1254\",\n            \"x-cp1254\"\n          ],\n          \"name\": \"windows-1254\"\n        },\n        {\n          \"labels\": [\n            \"cp1255\",\n            \"windows-1255\",\n            \"x-cp1255\"\n          ],\n          \"name\": \"windows-1255\"\n        },\n        {\n          \"labels\": [\n            \"cp1256\",\n            \"windows-1256\",\n            \"x-cp1256\"\n          ],\n          \"name\": \"windows-1256\"\n        },\n        {\n          \"labels\": [\n            \"cp1257\",\n            \"windows-1257\",\n            \"x-cp1257\"\n          ],\n          \"name\": \"windows-1257\"\n        },\n        {\n          \"labels\": [\n            \"cp1258\",\n            \"windows-1258\",\n            \"x-cp1258\"\n          ],\n          \"name\": \"windows-1258\"\n        },\n        {\n          \"labels\": [\n            \"x-mac-cyrillic\",\n            \"x-mac-ukrainian\"\n          ],\n          \"name\": \"x-mac-cyrillic\"\n        }\n      ],\n      \"heading\": \"Legacy single-byte encodings\"\n    },\n    {\n      \"encodings\": [\n        {\n          \"labels\": [\n            \"chinese\",\n            \"csgb2312\",\n            \"csiso58gb231280\",\n            \"gb2312\",\n            \"gb_2312\",\n            \"gb_2312-80\",\n            \"gbk\",\n            \"iso-ir-58\",\n            \"x-gbk\"\n          ],\n          \"name\": \"GBK\"\n        },\n        {\n          \"labels\": [\n            \"gb18030\"\n          ],\n          \"name\": \"gb18030\"\n        }\n      ],\n      \"heading\": \"Legacy multi-byte Chinese (simplified) encodings\"\n    },\n    {\n      \"encodings\": [\n        {\n          \"labels\": [\n            \"big5\",\n            \"big5-hkscs\",\n            \"cn-big5\",\n            \"csbig5\",\n            \"x-x-big5\"\n          ],\n          \"name\": \"Big5\"\n        }\n      ],\n      \"heading\": \"Legacy multi-byte Chinese (traditional) encodings\"\n    },\n    {\n      \"encodings\": [\n        {\n          \"labels\": [\n            \"cseucpkdfmtjapanese\",\n            \"euc-jp\",\n            \"x-euc-jp\"\n          ],\n          \"name\": \"EUC-JP\"\n        },\n        {\n          \"labels\": [\n            \"csiso2022jp\",\n            \"iso-2022-jp\"\n          ],\n          \"name\": \"ISO-2022-JP\"\n        },\n        {\n          \"labels\": [\n            \"csshiftjis\",\n            \"ms932\",\n            \"ms_kanji\",\n            \"shift-jis\",\n            \"shift_jis\",\n            \"sjis\",\n            \"windows-31j\",\n            \"x-sjis\"\n          ],\n          \"name\": \"Shift_JIS\"\n        }\n      ],\n      \"heading\": \"Legacy multi-byte Japanese encodings\"\n    },\n    {\n      \"encodings\": [\n        {\n          \"labels\": [\n            \"cseuckr\",\n            \"csksc56011987\",\n            \"euc-kr\",\n            \"iso-ir-149\",\n            \"korean\",\n            \"ks_c_5601-1987\",\n            \"ks_c_5601-1989\",\n            \"ksc5601\",\n            \"ksc_5601\",\n            \"windows-949\"\n          ],\n          \"name\": \"EUC-KR\"\n        }\n      ],\n      \"heading\": \"Legacy multi-byte Korean encodings\"\n    },\n    {\n      \"encodings\": [\n        {\n          \"labels\": [\n            \"csiso2022kr\",\n            \"hz-gb-2312\",\n            \"iso-2022-cn\",\n            \"iso-2022-cn-ext\",\n            \"iso-2022-kr\"\n          ],\n          \"name\": \"replacement\"\n        },\n        {\n          \"labels\": [\n            \"utf-16be\"\n          ],\n          \"name\": \"UTF-16BE\"\n        },\n        {\n          \"labels\": [\n            \"utf-16\",\n            \"utf-16le\"\n          ],\n          \"name\": \"UTF-16LE\"\n        },\n        {\n          \"labels\": [\n            \"x-user-defined\"\n          ],\n          \"name\": \"x-user-defined\"\n        }\n      ],\n      \"heading\": \"Legacy miscellaneous encodings\"\n    }\n  ];\n  \n \n  var label_to_encoding = {};\n  encodings.forEach(function(category) {\n    category.encodings.forEach(function(encoding) {\n      encoding.labels.forEach(function(label) {\n        label_to_encoding[label] = encoding;\n      });\n    });\n  });\n  \n \n  var encoders = {};\n \n  var decoders = {};\n  //\n  \n  //\n \n  function indexCodePointFor(pointer, index) {\n    if (!index) return null;\n    return index[pointer] || null;\n  }\n \n  function indexPointerFor(code_point, index) {\n    var pointer = index.indexOf(code_point);\n    return pointer === -1 ? null : pointer;\n  }\n \n  function index(name) {\n    if (!('encoding-indexes' in global)) {\n      throw Error(\"Indexes missing.\" +\n                  \" Did you forget to include encoding-indexes.js first?\");\n    }\n    return global['encoding-indexes'][name];\n  }\n \n  function indexGB18030RangesCodePointFor(pointer) {\n    \n    \n    if ((pointer > 39419 && pointer < 189000) || (pointer > 1237575))\n      return null;\n    \n    if (pointer === 7457) return 0xE7C7;\n    \n    \n    \n    var offset = 0;\n    var code_point_offset = 0;\n    var idx = index('gb18030-ranges');\n    var i;\n    for (i = 0; i < idx.length; ++i) {\n     \n      var entry = idx[i];\n      if (entry[0] <= pointer) {\n        offset = entry[0];\n        code_point_offset = entry[1];\n      } else {\n        break;\n      }\n    }\n    \n    \n    return code_point_offset + pointer - offset;\n  }\n \n  function indexGB18030RangesPointerFor(code_point) {\n    \n    if (code_point === 0xE7C7) return 7457;\n    \n    \n    \n    var offset = 0;\n    var pointer_offset = 0;\n    var idx = index('gb18030-ranges');\n    var i;\n    for (i = 0; i < idx.length; ++i) {\n     \n      var entry = idx[i];\n      if (entry[1] <= code_point) {\n        offset = entry[1];\n        pointer_offset = entry[0];\n      } else {\n        break;\n      }\n    }\n    \n    \n    return pointer_offset + code_point - offset;\n  }\n \n  function indexShiftJISPointerFor(code_point) {\n    \n    \n    shift_jis_index = shift_jis_index ||\n      index('jis0208').map(function(code_point, pointer) {\n        return inRange(pointer, 8272, 8835) ? null : code_point;\n      });\n    var index_ = shift_jis_index;\n    \n    return index_.indexOf(code_point);\n  }\n  var shift_jis_index;\n \n  function indexBig5PointerFor(code_point) {\n    \n    big5_index_no_hkscs = big5_index_no_hkscs ||\n      index('big5').map(function(code_point, pointer) {\n        return (pointer < (0xA1 - 0x81) * 157) ? null : code_point;\n      });\n    var index_ = big5_index_no_hkscs;\n    \n    \n    \n    if (code_point === 0x2550 || code_point === 0x255E ||\n        code_point === 0x2561 || code_point === 0x256A ||\n        code_point === 0x5341 || code_point === 0x5345) {\n      return index_.lastIndexOf(code_point);\n    }\n    \n    return indexPointerFor(code_point, index_);\n  }\n  var big5_index_no_hkscs;\n  //\n  \n  //\n  var DEFAULT_ENCODING = 'utf-8';\n  \n \n  function TextDecoder(label, options) {\n    \n    if (!(this instanceof TextDecoder))\n      throw TypeError('Called as a function. Did you forget \\'new\\'?');\n    label = label !== undefined ? String(label) : DEFAULT_ENCODING;\n    options = ToDictionary(options);\n    \n    \n    \n    \n   \n    this._encoding = null;\n   \n    this._decoder = null;\n   \n    this._ignoreBOM = false;\n   \n    this._BOMseen = false;\n   \n    this._error_mode = 'replacement';\n   \n    this._do_not_flush = false;\n    \n    \n    var encoding = getEncoding(label);\n    \n    if (encoding === null || encoding.name === 'replacement')\n      throw RangeError('Unknown encoding: ' + label);\n    if (!decoders[encoding.name]) {\n      throw Error('Decoder not present.' +\n                  ' Did you forget to include encoding-indexes.js first?');\n    }\n    \n    var dec = this;\n    \n    dec._encoding = encoding;\n    \n    \n    if (Boolean(options['fatal']))\n      dec._error_mode = 'fatal';\n    \n    \n    if (Boolean(options['ignoreBOM']))\n      dec._ignoreBOM = true;\n    \n    if (!Object.defineProperty) {\n      this.encoding = dec._encoding.name.toLowerCase();\n      this.fatal = dec._error_mode === 'fatal';\n      this.ignoreBOM = dec._ignoreBOM;\n    }\n    \n    return dec;\n  }\n  if (Object.defineProperty) {\n    \n    Object.defineProperty(TextDecoder.prototype, 'encoding', {\n     \n      get: function() { return this._encoding.name.toLowerCase(); }\n    });\n    \n    \n    Object.defineProperty(TextDecoder.prototype, 'fatal', {\n     \n      get: function() { return this._error_mode === 'fatal'; }\n    });\n    \n    \n    Object.defineProperty(TextDecoder.prototype, 'ignoreBOM', {\n     \n      get: function() { return this._ignoreBOM; }\n    });\n  }\n \n  TextDecoder.prototype.decode = function decode(input, options) {\n    var bytes;\n    if (typeof input === 'object' && input instanceof ArrayBuffer) {\n      bytes = new Uint8Array(input);\n    } else if (typeof input === 'object' && 'buffer' in input &&\n               input.buffer instanceof ArrayBuffer) {\n      bytes = new Uint8Array(input.buffer,\n                             input.byteOffset,\n                             input.byteLength);\n    } else {\n      bytes = new Uint8Array(0);\n    }\n    options = ToDictionary(options);\n    \n    \n    \n    if (!this._do_not_flush) {\n      this._decoder = decoders[this._encoding.name]({\n        fatal: this._error_mode === 'fatal'});\n      this._BOMseen = false;\n    }\n    \n    \n    this._do_not_flush = Boolean(options['stream']);\n    \n    \n    var input_stream = new Stream(bytes);\n    \n    var output = [];\n   \n    var result;\n    \n    while (true) {\n      \n      var token = input_stream.read();\n      \n      \n      \n      if (token === end_of_stream)\n        break;\n      \n      \n      \n      result = this._decoder.handler(input_stream, token);\n      \n      if (result === finished)\n        break;\n      if (result !== null) {\n        if (Array.isArray(result))\n          output.push.apply(output,(result));\n        else\n          output.push(result);\n      }\n      \n      \n      \n    }\n    \n    if (!this._do_not_flush) {\n      do {\n        result = this._decoder.handler(input_stream, input_stream.read());\n        if (result === finished)\n          break;\n        if (result === null)\n          continue;\n        if (Array.isArray(result))\n          output.push.apply(output,(result));\n        else\n          output.push(result);\n      } while (!input_stream.endOfStream());\n      this._decoder = null;\n    }\n    \n    \n   \n    function serializeStream(stream) {\n      \n      \n      \n      \n      if (includes(['UTF-8', 'UTF-16LE', 'UTF-16BE'], this._encoding.name) &&\n          !this._ignoreBOM && !this._BOMseen) {\n        if (stream.length > 0 && stream[0] === 0xFEFF) {\n          \n          this._BOMseen = true;\n          stream.shift();\n        } else if (stream.length > 0) {\n          \n          \n          this._BOMseen = true;\n        } else {\n          \n          \n          \n        }\n      }\n      \n      return codePointsToString(stream);\n    }\n    return serializeStream.call(this, output);\n  };\n  \n \n  function TextEncoder(label, options) {\n    \n    if (!(this instanceof TextEncoder))\n      throw TypeError('Called as a function. Did you forget \\'new\\'?');\n    options = ToDictionary(options);\n    \n   \n    this._encoding = null;\n   \n    this._encoder = null;\n    \n   \n    this._do_not_flush = false;\n   \n    this._fatal = Boolean(options['fatal']) ? 'fatal' : 'replacement';\n    \n    var enc = this;\n    \n    if (Boolean(options['NONSTANDARD_allowLegacyEncoding'])) {\n      \n      label = label !== undefined ? String(label) : DEFAULT_ENCODING;\n      var encoding = getEncoding(label);\n      if (encoding === null || encoding.name === 'replacement')\n        throw RangeError('Unknown encoding: ' + label);\n      if (!encoders[encoding.name]) {\n        throw Error('Encoder not present.' +\n                    ' Did you forget to include encoding-indexes.js first?');\n      }\n      enc._encoding = encoding;\n    } else {\n      \n      enc._encoding = getEncoding('utf-8');\n      if (label !== undefined && 'console' in global) {\n      //console.warn('TextEncoder constructor called with encoding label, '\n                   //+ 'which is ignored.');\n      }\n    }\n    \n    if (!Object.defineProperty)\n      this.encoding = enc._encoding.name.toLowerCase();\n    \n    return enc;\n  }\n  if (Object.defineProperty) {\n    \n    Object.defineProperty(TextEncoder.prototype, 'encoding', {\n     \n      get: function() { return this._encoding.name.toLowerCase(); }\n    });\n  }\n \n  TextEncoder.prototype.encode = function encode(opt_string, options) {\n    opt_string = opt_string === undefined ? '' : String(opt_string);\n    options = ToDictionary(options);\n    \n    \n    \n    if (!this._do_not_flush)\n      this._encoder = encoders[this._encoding.name]({\n        fatal: this._fatal === 'fatal'});\n    this._do_not_flush = Boolean(options['stream']);\n    \n    var input = new Stream(stringToCodePoints(opt_string));\n    \n    var output = [];\n   \n    var result;\n    \n    while (true) {\n      \n      var token = input.read();\n      if (token === end_of_stream)\n        break;\n      \n      \n      result = this._encoder.handler(input, token);\n      if (result === finished)\n        break;\n      if (Array.isArray(result))\n        output.push.apply(output,(result));\n      else\n        output.push(result);\n    }\n    \n    if (!this._do_not_flush) {\n      while (true) {\n        result = this._encoder.handler(input, input.read());\n        if (result === finished)\n          break;\n        if (Array.isArray(result))\n          output.push.apply(output,(result));\n        else\n          output.push(result);\n      }\n      this._encoder = null;\n    }\n    \n    \n    \n    return new Uint8Array(output);\n  };\n  //\n  \n  //\n  \n  \n \n  function UTF8Decoder(options) {\n    var fatal = options.fatal;\n    \n    \n    \n    \n    var utf8_code_point = 0,\n        utf8_bytes_seen = 0,\n        utf8_bytes_needed = 0,\n        utf8_lower_boundary = 0x80,\n        utf8_upper_boundary = 0xBF;\n   \n    this.handler = function(stream, bite) {\n      \n      \n      if (bite === end_of_stream && utf8_bytes_needed !== 0) {\n        utf8_bytes_needed = 0;\n        return decoderError(fatal);\n      }\n      \n      if (bite === end_of_stream)\n        return finished;\n      \n      if (utf8_bytes_needed === 0) {\n        \n        if (inRange(bite, 0x00, 0x7F)) {\n          \n          return bite;\n        }\n        \n        else if (inRange(bite, 0xC2, 0xDF)) {\n          \n          utf8_bytes_needed = 1;\n          \n          utf8_code_point = bite & 0x1F;\n        }\n        \n        else if (inRange(bite, 0xE0, 0xEF)) {\n          \n          if (bite === 0xE0)\n            utf8_lower_boundary = 0xA0;\n          \n          if (bite === 0xED)\n            utf8_upper_boundary = 0x9F;\n          \n          utf8_bytes_needed = 2;\n          \n          utf8_code_point = bite & 0xF;\n        }\n        \n        else if (inRange(bite, 0xF0, 0xF4)) {\n          \n          if (bite === 0xF0)\n            utf8_lower_boundary = 0x90;\n          \n          if (bite === 0xF4)\n            utf8_upper_boundary = 0x8F;\n          \n          utf8_bytes_needed = 3;\n          \n          utf8_code_point = bite & 0x7;\n        }\n        \n        else {\n          \n          return decoderError(fatal);\n        }\n        \n        return null;\n      }\n      \n      \n      if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {\n        \n        \n        \n        utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\n        utf8_lower_boundary = 0x80;\n        utf8_upper_boundary = 0xBF;\n        \n        stream.prepend(bite);\n        \n        return decoderError(fatal);\n      }\n      \n      \n      utf8_lower_boundary = 0x80;\n      utf8_upper_boundary = 0xBF;\n      \n      \n      utf8_code_point = (utf8_code_point << 6) | (bite & 0x3F);\n      \n      utf8_bytes_seen += 1;\n      \n      \n      if (utf8_bytes_seen !== utf8_bytes_needed)\n        return null;\n      \n      var code_point = utf8_code_point;\n      \n      \n      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\n      \n      return code_point;\n    };\n  }\n  \n \n  function UTF8Encoder(options) {\n    var fatal = options.fatal;\n   \n    this.handler = function(stream, code_point) {\n      \n      if (code_point === end_of_stream)\n        return finished;\n      \n      \n      if (isASCIICodePoint(code_point))\n        return code_point;\n      \n      var count, offset;\n      \n      if (inRange(code_point, 0x0080, 0x07FF)) {\n        \n        count = 1;\n        offset = 0xC0;\n      }\n      \n      else if (inRange(code_point, 0x0800, 0xFFFF)) {\n        \n        count = 2;\n        offset = 0xE0;\n      }\n      \n      else if (inRange(code_point, 0x10000, 0x10FFFF)) {\n        \n        count = 3;\n        offset = 0xF0;\n      }\n      \n      \n      var bytes = [(code_point >> (6 * count)) + offset];\n      \n      while (count > 0) {\n        \n        var temp = code_point >> (6 * (count - 1));\n        \n        bytes.push(0x80 | (temp & 0x3F));\n        \n        count -= 1;\n      }\n      \n      return bytes;\n    };\n  }\n \n  encoders['UTF-8'] = function(options) {\n    return new UTF8Encoder(options);\n  };\n \n  decoders['UTF-8'] = function(options) {\n    return new UTF8Decoder(options);\n  };\n  //\n  \n  //\n  \n \n  function SingleByteDecoder(index, options) {\n    var fatal = options.fatal;\n   \n    this.handler = function(stream, bite) {\n      \n      if (bite === end_of_stream)\n        return finished;\n      \n      \n      if (isASCIIByte(bite))\n        return bite;\n      \n      \n      var code_point = index[bite - 0x80];\n      \n      if (code_point === null)\n        return decoderError(fatal);\n      \n      return code_point;\n    };\n  }\n  \n \n  function SingleByteEncoder(index, options) {\n    var fatal = options.fatal;\n   \n    this.handler = function(stream, code_point) {\n      \n      if (code_point === end_of_stream)\n        return finished;\n      \n      \n      if (isASCIICodePoint(code_point))\n        return code_point;\n      \n      \n      var pointer = indexPointerFor(code_point, index);\n      \n      if (pointer === null)\n        encoderError(code_point);\n      \n      return pointer + 0x80;\n    };\n  }\n  (function() {\n    if (!('encoding-indexes' in global))\n      return;\n    encodings.forEach(function(category) {\n      if (category.heading !== 'Legacy single-byte encodings')\n        return;\n      category.encodings.forEach(function(encoding) {\n        var name = encoding.name;\n        var idx = index(name.toLowerCase());\n       \n        decoders[name] = function(options) {\n          return new SingleByteDecoder(idx, options);\n        };\n       \n        encoders[name] = function(options) {\n          return new SingleByteEncoder(idx, options);\n        };\n      });\n    });\n  }());\n  //\n  \n  //\n  \n  \n  \n \n  decoders['GBK'] = function(options) {\n    return new GB18030Decoder(options);\n  };\n  \n  \n \n  encoders['GBK'] = function(options) {\n    return new GB18030Encoder(options, true);\n  };\n  \n  \n \n  function GB18030Decoder(options) {\n    var fatal = options.fatal;\n    \n    \n    var gb18030_first = 0x00,\n        gb18030_second = 0x00,\n        gb18030_third = 0x00;\n   \n    this.handler = function(stream, bite) {\n      \n      \n      if (bite === end_of_stream && gb18030_first === 0x00 &&\n          gb18030_second === 0x00 && gb18030_third === 0x00) {\n        return finished;\n      }\n      \n      \n      \n      if (bite === end_of_stream &&\n          (gb18030_first !== 0x00 || gb18030_second !== 0x00 ||\n           gb18030_third !== 0x00)) {\n        gb18030_first = 0x00;\n        gb18030_second = 0x00;\n        gb18030_third = 0x00;\n        decoderError(fatal);\n      }\n      var code_point;\n      \n      if (gb18030_third !== 0x00) {\n        \n        code_point = null;\n        \n        \n        \n        \n        if (inRange(bite, 0x30, 0x39)) {\n          code_point = indexGB18030RangesCodePointFor(\n              (((gb18030_first - 0x81) * 10 + gb18030_second - 0x30) * 126 +\n               gb18030_third - 0x81) * 10 + bite - 0x30);\n        }\n        \n        \n        var buffer = [gb18030_second, gb18030_third, bite];\n        \n        \n        gb18030_first = 0x00;\n        gb18030_second = 0x00;\n        gb18030_third = 0x00;\n        \n        \n        if (code_point === null) {\n          stream.prepend(buffer);\n          return decoderError(fatal);\n        }\n        \n        return code_point;\n      }\n      \n      if (gb18030_second !== 0x00) {\n        \n        \n        if (inRange(bite, 0x81, 0xFE)) {\n          gb18030_third = bite;\n          return null;\n        }\n        \n        \n        stream.prepend([gb18030_second, bite]);\n        gb18030_first = 0x00;\n        gb18030_second = 0x00;\n        return decoderError(fatal);\n      }\n      \n      if (gb18030_first !== 0x00) {\n        \n        \n        if (inRange(bite, 0x30, 0x39)) {\n          gb18030_second = bite;\n          return null;\n        }\n        \n        \n        var lead = gb18030_first;\n        var pointer = null;\n        gb18030_first = 0x00;\n        \n        \n        var offset = bite < 0x7F ? 0x40 : 0x41;\n        \n        \n        \n        if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0x80, 0xFE))\n          pointer = (lead - 0x81) * 190 + (bite - offset);\n        \n        \n        code_point = pointer === null ? null :\n            indexCodePointFor(pointer, index('gb18030'));\n        \n        \n        if (code_point === null && isASCIIByte(bite))\n          stream.prepend(bite);\n        \n        if (code_point === null)\n          return decoderError(fatal);\n        \n        return code_point;\n      }\n      \n      \n      if (isASCIIByte(bite))\n        return bite;\n      \n      if (bite === 0x80)\n        return 0x20AC;\n      \n      \n      if (inRange(bite, 0x81, 0xFE)) {\n        gb18030_first = bite;\n        return null;\n      }\n      \n      return decoderError(fatal);\n    };\n  }\n  \n \n  function GB18030Encoder(options, gbk_flag) {\n    var fatal = options.fatal;\n    \n   \n    this.handler = function(stream, code_point) {\n      \n      if (code_point === end_of_stream)\n        return finished;\n      \n      \n      if (isASCIICodePoint(code_point))\n        return code_point;\n      \n      if (code_point === 0xE5E5)\n        return encoderError(code_point);\n      \n      \n      if (gbk_flag && code_point === 0x20AC)\n        return 0x80;\n      \n      \n      var pointer = indexPointerFor(code_point, index('gb18030'));\n      \n      if (pointer !== null) {\n        \n        var lead = floor(pointer / 190) + 0x81;\n        \n        var trail = pointer % 190;\n        \n        var offset = trail < 0x3F ? 0x40 : 0x41;\n        \n        return [lead, trail + offset];\n      }\n      \n      if (gbk_flag)\n        return encoderError(code_point);\n      \n      \n      pointer = indexGB18030RangesPointerFor(code_point);\n      \n      var byte1 = floor(pointer / 10 / 126 / 10);\n      \n      pointer = pointer - byte1 * 10 * 126 * 10;\n      \n      var byte2 = floor(pointer / 10 / 126);\n      \n      pointer = pointer - byte2 * 10 * 126;\n      \n      var byte3 = floor(pointer / 10);\n      \n      var byte4 = pointer - byte3 * 10;\n      \n      \n      return [byte1 + 0x81,\n              byte2 + 0x30,\n              byte3 + 0x81,\n              byte4 + 0x30];\n    };\n  }\n \n  encoders['gb18030'] = function(options) {\n    return new GB18030Encoder(options);\n  };\n \n  decoders['gb18030'] = function(options) {\n    return new GB18030Decoder(options);\n  };\n  //\n  \n  //\n  \n  \n \n  function Big5Decoder(options) {\n    var fatal = options.fatal;\n    \n    var Big5_lead = 0x00;\n   \n    this.handler = function(stream, bite) {\n      \n      \n      if (bite === end_of_stream && Big5_lead !== 0x00) {\n        Big5_lead = 0x00;\n        return decoderError(fatal);\n      }\n      \n      \n      if (bite === end_of_stream && Big5_lead === 0x00)\n        return finished;\n      \n      \n      \n      if (Big5_lead !== 0x00) {\n        var lead = Big5_lead;\n        var pointer = null;\n        Big5_lead = 0x00;\n        \n        \n        var offset = bite < 0x7F ? 0x40 : 0x62;\n        \n        \n        \n        if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0xA1, 0xFE))\n          pointer = (lead - 0x81) * 157 + (bite - offset);\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        switch (pointer) {\n          case 1133: return [0x00CA, 0x0304];\n          case 1135: return [0x00CA, 0x030C];\n          case 1164: return [0x00EA, 0x0304];\n          case 1166: return [0x00EA, 0x030C];\n        }\n        \n        \n        var code_point = (pointer === null) ? null :\n            indexCodePointFor(pointer, index('big5'));\n        \n        \n        if (code_point === null && isASCIIByte(bite))\n          stream.prepend(bite);\n        \n        if (code_point === null)\n          return decoderError(fatal);\n        \n        return code_point;\n      }\n      \n      \n      if (isASCIIByte(bite))\n        return bite;\n      \n      \n      if (inRange(bite, 0x81, 0xFE)) {\n        Big5_lead = bite;\n        return null;\n      }\n      \n      return decoderError(fatal);\n    };\n  }\n  \n \n  function Big5Encoder(options) {\n    var fatal = options.fatal;\n   \n    this.handler = function(stream, code_point) {\n      \n      if (code_point === end_of_stream)\n        return finished;\n      \n      \n      if (isASCIICodePoint(code_point))\n        return code_point;\n      \n      var pointer = indexBig5PointerFor(code_point);\n      \n      if (pointer === null)\n        return encoderError(code_point);\n      \n      var lead = floor(pointer / 157) + 0x81;\n      \n      if (lead < 0xA1)\n        return encoderError(code_point);\n      \n      var trail = pointer % 157;\n      \n      \n      var offset = trail < 0x3F ? 0x40 : 0x62;\n      \n      return [lead, trail + offset];\n    };\n  }\n \n  encoders['Big5'] = function(options) {\n    return new Big5Encoder(options);\n  };\n \n  decoders['Big5'] = function(options) {\n    return new Big5Decoder(options);\n  };\n  //\n  \n  //\n  \n  \n \n  function EUCJPDecoder(options) {\n    var fatal = options.fatal;\n    \n    \n    var eucjp_jis0212_flag = false,\n        eucjp_lead = 0x00;\n   \n    this.handler = function(stream, bite) {\n      \n      \n      if (bite === end_of_stream && eucjp_lead !== 0x00) {\n        eucjp_lead = 0x00;\n        return decoderError(fatal);\n      }\n      \n      \n      if (bite === end_of_stream && eucjp_lead === 0x00)\n        return finished;\n      \n      \n      \n      if (eucjp_lead === 0x8E && inRange(bite, 0xA1, 0xDF)) {\n        eucjp_lead = 0x00;\n        return 0xFF61 - 0xA1 + bite;\n      }\n      \n      \n      \n      if (eucjp_lead === 0x8F && inRange(bite, 0xA1, 0xFE)) {\n        eucjp_jis0212_flag = true;\n        eucjp_lead = bite;\n        return null;\n      }\n      \n      \n      if (eucjp_lead !== 0x00) {\n        var lead = eucjp_lead;\n        eucjp_lead = 0x00;\n        \n        var code_point = null;\n        \n        \n        \n        \n        if (inRange(lead, 0xA1, 0xFE) && inRange(bite, 0xA1, 0xFE)) {\n          code_point = indexCodePointFor(\n            (lead - 0xA1) * 94 + (bite - 0xA1),\n            index(!eucjp_jis0212_flag ? 'jis0208' : 'jis0212'));\n        }\n        \n        eucjp_jis0212_flag = false;\n        \n        \n        if (!inRange(bite, 0xA1, 0xFE))\n          stream.prepend(bite);\n        \n        if (code_point === null)\n          return decoderError(fatal);\n        \n        return code_point;\n      }\n      \n      \n      if (isASCIIByte(bite))\n        return bite;\n      \n      \n      if (bite === 0x8E || bite === 0x8F || inRange(bite, 0xA1, 0xFE)) {\n        eucjp_lead = bite;\n        return null;\n      }\n      \n      return decoderError(fatal);\n    };\n  }\n  \n \n  function EUCJPEncoder(options) {\n    var fatal = options.fatal;\n   \n    this.handler = function(stream, code_point) {\n      \n      if (code_point === end_of_stream)\n        return finished;\n      \n      \n      if (isASCIICodePoint(code_point))\n        return code_point;\n      \n      if (code_point === 0x00A5)\n        return 0x5C;\n      \n      if (code_point === 0x203E)\n        return 0x7E;\n      \n      \n      \n      if (inRange(code_point, 0xFF61, 0xFF9F))\n        return [0x8E, code_point - 0xFF61 + 0xA1];\n      \n      if (code_point === 0x2212)\n        code_point = 0xFF0D;\n      \n      \n      var pointer = indexPointerFor(code_point, index('jis0208'));\n      \n      if (pointer === null)\n        return encoderError(code_point);\n      \n      var lead = floor(pointer / 94) + 0xA1;\n      \n      var trail = pointer % 94 + 0xA1;\n      \n      return [lead, trail];\n    };\n  }\n \n  encoders['EUC-JP'] = function(options) {\n    return new EUCJPEncoder(options);\n  };\n \n  decoders['EUC-JP'] = function(options) {\n    return new EUCJPDecoder(options);\n  };\n  \n  \n \n  function ISO2022JPDecoder(options) {\n    var fatal = options.fatal;\n   \n    var states = {\n      ASCII: 0,\n      Roman: 1,\n      Katakana: 2,\n      LeadByte: 3,\n      TrailByte: 4,\n      EscapeStart: 5,\n      Escape: 6\n    };\n    \n    \n    \n    \n    var iso2022jp_decoder_state = states.ASCII,\n        iso2022jp_decoder_output_state = states.ASCII,\n        iso2022jp_lead = 0x00,\n        iso2022jp_output_flag = false;\n   \n    this.handler = function(stream, bite) {\n      \n      switch (iso2022jp_decoder_state) {\n      default:\n      case states.ASCII:\n        \n        \n        \n        if (bite === 0x1B) {\n          \n          \n          iso2022jp_decoder_state = states.EscapeStart;\n          return null;\n        }\n        \n        if (inRange(bite, 0x00, 0x7F) && bite !== 0x0E\n            && bite !== 0x0F && bite !== 0x1B) {\n          \n          \n          iso2022jp_output_flag = false;\n          return bite;\n        }\n        \n        if (bite === end_of_stream) {\n          \n          return finished;\n        }\n        \n        \n        iso2022jp_output_flag = false;\n        return decoderError(fatal);\n      case states.Roman:\n        \n        \n        \n        if (bite === 0x1B) {\n          \n          \n          iso2022jp_decoder_state = states.EscapeStart;\n          return null;\n        }\n        \n        if (bite === 0x5C) {\n          \n          \n          iso2022jp_output_flag = false;\n          return 0x00A5;\n        }\n        \n        if (bite === 0x7E) {\n          \n          \n          iso2022jp_output_flag = false;\n          return 0x203E;\n        }\n        \n        if (inRange(bite, 0x00, 0x7F) && bite !== 0x0E && bite !== 0x0F\n            && bite !== 0x1B && bite !== 0x5C && bite !== 0x7E) {\n          \n          \n          iso2022jp_output_flag = false;\n          return bite;\n        }\n        \n        if (bite === end_of_stream) {\n          \n          return finished;\n        }\n        \n        \n        iso2022jp_output_flag = false;\n        return decoderError(fatal);\n      case states.Katakana:\n        \n        \n        \n        if (bite === 0x1B) {\n          \n          \n          iso2022jp_decoder_state = states.EscapeStart;\n          return null;\n        }\n        \n        if (inRange(bite, 0x21, 0x5F)) {\n          \n          \n          iso2022jp_output_flag = false;\n          return 0xFF61 - 0x21 + bite;\n        }\n        \n        if (bite === end_of_stream) {\n          \n          return finished;\n        }\n        \n        \n        iso2022jp_output_flag = false;\n        return decoderError(fatal);\n      case states.LeadByte:\n        \n        \n        \n        if (bite === 0x1B) {\n          \n          \n          iso2022jp_decoder_state = states.EscapeStart;\n          return null;\n        }\n        \n        if (inRange(bite, 0x21, 0x7E)) {\n          \n          \n          \n          iso2022jp_output_flag = false;\n          iso2022jp_lead = bite;\n          iso2022jp_decoder_state = states.TrailByte;\n          return null;\n        }\n        \n        if (bite === end_of_stream) {\n          \n          return finished;\n        }\n        \n        \n        iso2022jp_output_flag = false;\n        return decoderError(fatal);\n      case states.TrailByte:\n        \n        \n        \n        if (bite === 0x1B) {\n          \n          \n          iso2022jp_decoder_state = states.EscapeStart;\n          return decoderError(fatal);\n        }\n        \n        if (inRange(bite, 0x21, 0x7E)) {\n          \n          iso2022jp_decoder_state = states.LeadByte;\n          \n          var pointer = (iso2022jp_lead - 0x21) * 94 + bite - 0x21;\n          \n          \n          var code_point = indexCodePointFor(pointer, index('jis0208'));\n          \n          if (code_point === null)\n            return decoderError(fatal);\n          \n          return code_point;\n        }\n        \n        if (bite === end_of_stream) {\n          \n          \n          iso2022jp_decoder_state = states.LeadByte;\n          stream.prepend(bite);\n          return decoderError(fatal);\n        }\n        \n        \n        \n        iso2022jp_decoder_state = states.LeadByte;\n        return decoderError(fatal);\n      case states.EscapeStart:\n        \n        \n        \n        \n        if (bite === 0x24 || bite === 0x28) {\n          iso2022jp_lead = bite;\n          iso2022jp_decoder_state = states.Escape;\n          return null;\n        }\n        \n        stream.prepend(bite);\n        \n        \n        \n        iso2022jp_output_flag = false;\n        iso2022jp_decoder_state = iso2022jp_decoder_output_state;\n        return decoderError(fatal);\n      case states.Escape:\n        \n        \n        \n        var lead = iso2022jp_lead;\n        iso2022jp_lead = 0x00;\n        \n        var state = null;\n        \n        if (lead === 0x28 && bite === 0x42)\n          state = states.ASCII;\n        \n        if (lead === 0x28 && bite === 0x4A)\n          state = states.Roman;\n        \n        if (lead === 0x28 && bite === 0x49)\n          state = states.Katakana;\n        \n        \n        if (lead === 0x24 && (bite === 0x40 || bite === 0x42))\n          state = states.LeadByte;\n        \n        if (state !== null) {\n          \n          \n          iso2022jp_decoder_state = iso2022jp_decoder_state = state;\n          \n          var output_flag = iso2022jp_output_flag;\n          \n          iso2022jp_output_flag = true;\n          \n          \n          return !output_flag ? null : decoderError(fatal);\n        }\n        \n        stream.prepend([lead, bite]);\n        \n        \n        \n        iso2022jp_output_flag = false;\n        iso2022jp_decoder_state = iso2022jp_decoder_output_state;\n        return decoderError(fatal);\n      }\n    };\n  }\n  \n \n  function ISO2022JPEncoder(options) {\n    var fatal = options.fatal;\n    \n    \n    \n   \n    var states = {\n      ASCII: 0,\n      Roman: 1,\n      jis0208: 2\n    };\n    var iso2022jp_state = states.ASCII;\n   \n    this.handler = function(stream, code_point) {\n      \n      \n      \n      \n      if (code_point === end_of_stream &&\n          iso2022jp_state !== states.ASCII) {\n        stream.prepend(code_point);\n        iso2022jp_state = states.ASCII;\n        return [0x1B, 0x28, 0x42];\n      }\n      \n      \n      if (code_point === end_of_stream && iso2022jp_state === states.ASCII)\n        return finished;\n      \n      \n      if ((iso2022jp_state === states.ASCII ||\n           iso2022jp_state === states.Roman) &&\n          (code_point === 0x000E || code_point === 0x000F ||\n           code_point === 0x001B)) {\n        return encoderError(0xFFFD);\n      }\n      \n      \n      if (iso2022jp_state === states.ASCII &&\n          isASCIICodePoint(code_point))\n        return code_point;\n      \n      \n      \n      if (iso2022jp_state === states.Roman &&\n          ((isASCIICodePoint(code_point) &&\n           code_point !== 0x005C && code_point !== 0x007E) ||\n          (code_point == 0x00A5 || code_point == 0x203E))) {\n        \n        \n        if (isASCIICodePoint(code_point))\n          return code_point;\n        \n        if (code_point === 0x00A5)\n          return 0x5C;\n        \n        if (code_point === 0x203E)\n          return 0x7E;\n      }\n      \n      \n      \n      \n      if (isASCIICodePoint(code_point) &&\n          iso2022jp_state !== states.ASCII) {\n        stream.prepend(code_point);\n        iso2022jp_state = states.ASCII;\n        return [0x1B, 0x28, 0x42];\n      }\n      \n      \n      \n      \n      if ((code_point === 0x00A5 || code_point === 0x203E) &&\n          iso2022jp_state !== states.Roman) {\n        stream.prepend(code_point);\n        iso2022jp_state = states.Roman;\n        return [0x1B, 0x28, 0x4A];\n      }\n      \n      if (code_point === 0x2212)\n        code_point = 0xFF0D;\n      \n      \n      var pointer = indexPointerFor(code_point, index('jis0208'));\n      \n      if (pointer === null)\n        return encoderError(code_point);\n      \n      \n      \n      if (iso2022jp_state !== states.jis0208) {\n        stream.prepend(code_point);\n        iso2022jp_state = states.jis0208;\n        return [0x1B, 0x24, 0x42];\n      }\n      \n      var lead = floor(pointer / 94) + 0x21;\n      \n      var trail = pointer % 94 + 0x21;\n      \n      return [lead, trail];\n    };\n  }\n \n  encoders['ISO-2022-JP'] = function(options) {\n    return new ISO2022JPEncoder(options);\n  };\n \n  decoders['ISO-2022-JP'] = function(options) {\n    return new ISO2022JPDecoder(options);\n  };\n  \n  \n \n  function ShiftJISDecoder(options) {\n    var fatal = options.fatal;\n    \n    \n    var Shift_JIS_lead = 0x00;\n   \n    this.handler = function(stream, bite) {\n      \n      \n      if (bite === end_of_stream && Shift_JIS_lead !== 0x00) {\n        Shift_JIS_lead = 0x00;\n        return decoderError(fatal);\n      }\n      \n      \n      if (bite === end_of_stream && Shift_JIS_lead === 0x00)\n        return finished;\n      \n      \n      \n      if (Shift_JIS_lead !== 0x00) {\n        var lead = Shift_JIS_lead;\n        var pointer = null;\n        Shift_JIS_lead = 0x00;\n        \n        \n        var offset = (bite < 0x7F) ? 0x40 : 0x41;\n        \n        \n        var lead_offset = (lead < 0xA0) ? 0x81 : 0xC1;\n        \n        \n        \n        if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0x80, 0xFC))\n          pointer = (lead - lead_offset) * 188 + bite - offset;\n        \n        \n        if (inRange(pointer, 8836, 10715))\n          return 0xE000 - 8836 + pointer;\n        \n        \n        var code_point = (pointer === null) ? null :\n              indexCodePointFor(pointer, index('jis0208'));\n        \n        \n        if (code_point === null && isASCIIByte(bite))\n          stream.prepend(bite);\n        \n        if (code_point === null)\n          return decoderError(fatal);\n        \n        return code_point;\n      }\n      \n      \n      if (isASCIIByte(bite) || bite === 0x80)\n        return bite;\n      \n      \n      if (inRange(bite, 0xA1, 0xDF))\n        return 0xFF61 - 0xA1 + bite;\n      \n      \n      \n      if (inRange(bite, 0x81, 0x9F) || inRange(bite, 0xE0, 0xFC)) {\n        Shift_JIS_lead = bite;\n        return null;\n      }\n      \n      return decoderError(fatal);\n    };\n  }\n  \n \n  function ShiftJISEncoder(options) {\n    var fatal = options.fatal;\n   \n    this.handler = function(stream, code_point) {\n      \n      if (code_point === end_of_stream)\n        return finished;\n      \n      \n      if (isASCIICodePoint(code_point) || code_point === 0x0080)\n        return code_point;\n      \n      if (code_point === 0x00A5)\n        return 0x5C;\n      \n      if (code_point === 0x203E)\n        return 0x7E;\n      \n      \n      if (inRange(code_point, 0xFF61, 0xFF9F))\n        return code_point - 0xFF61 + 0xA1;\n      \n      if (code_point === 0x2212)\n        code_point = 0xFF0D;\n      \n      var pointer = indexShiftJISPointerFor(code_point);\n      \n      if (pointer === null)\n        return encoderError(code_point);\n      \n      var lead = floor(pointer / 188);\n      \n      \n      var lead_offset = (lead < 0x1F) ? 0x81 : 0xC1;\n      \n      var trail = pointer % 188;\n      \n      \n      var offset = (trail < 0x3F) ? 0x40 : 0x41;\n      \n      \n      return [lead + lead_offset, trail + offset];\n    };\n  }\n \n  encoders['Shift_JIS'] = function(options) {\n    return new ShiftJISEncoder(options);\n  };\n \n  decoders['Shift_JIS'] = function(options) {\n    return new ShiftJISDecoder(options);\n  };\n  //\n  \n  //\n  \n  \n \n  function EUCKRDecoder(options) {\n    var fatal = options.fatal;\n    \n    var euckr_lead = 0x00;\n   \n    this.handler = function(stream, bite) {\n      \n      \n      if (bite === end_of_stream && euckr_lead !== 0) {\n        euckr_lead = 0x00;\n        return decoderError(fatal);\n      }\n      \n      \n      if (bite === end_of_stream && euckr_lead === 0)\n        return finished;\n      \n      \n      \n      if (euckr_lead !== 0x00) {\n        var lead = euckr_lead;\n        var pointer = null;\n        euckr_lead = 0x00;\n        \n        \n        if (inRange(bite, 0x41, 0xFE))\n          pointer = (lead - 0x81) * 190 + (bite - 0x41);\n        \n        \n        var code_point = (pointer === null)\n              ? null : indexCodePointFor(pointer, index('euc-kr'));\n        \n        \n        if (pointer === null && isASCIIByte(bite))\n          stream.prepend(bite);\n        \n        if (code_point === null)\n          return decoderError(fatal);\n        \n        return code_point;\n      }\n      \n      \n      if (isASCIIByte(bite))\n        return bite;\n      \n      \n      if (inRange(bite, 0x81, 0xFE)) {\n        euckr_lead = bite;\n        return null;\n      }\n      \n      return decoderError(fatal);\n    };\n  }\n  \n \n  function EUCKREncoder(options) {\n    var fatal = options.fatal;\n   \n    this.handler = function(stream, code_point) {\n      \n      if (code_point === end_of_stream)\n        return finished;\n      \n      \n      if (isASCIICodePoint(code_point))\n        return code_point;\n      \n      \n      var pointer = indexPointerFor(code_point, index('euc-kr'));\n      \n      if (pointer === null)\n        return encoderError(code_point);\n      \n      var lead = floor(pointer / 190) + 0x81;\n      \n      var trail = (pointer % 190) + 0x41;\n      \n      return [lead, trail];\n    };\n  }\n \n  encoders['EUC-KR'] = function(options) {\n    return new EUCKREncoder(options);\n  };\n \n  decoders['EUC-KR'] = function(options) {\n    return new EUCKRDecoder(options);\n  };\n  //\n  \n  //\n  \n  \n  \n \n  function convertCodeUnitToBytes(code_unit, utf16be) {\n    \n    var byte1 = code_unit >> 8;\n    \n    var byte2 = code_unit & 0x00FF;\n    \n        \n    if (utf16be)\n      return [byte1, byte2];\n    \n    return [byte2, byte1];\n  }\n  \n \n  function UTF16Decoder(utf16_be, options) {\n    var fatal = options.fatal;\n    var utf16_lead_byte = null,\n        utf16_lead_surrogate = null;\n   \n    this.handler = function(stream, bite) {\n      \n      \n      \n      if (bite === end_of_stream && (utf16_lead_byte !== null ||\n                                utf16_lead_surrogate !== null)) {\n        return decoderError(fatal);\n      }\n      \n      \n      if (bite === end_of_stream && utf16_lead_byte === null &&\n          utf16_lead_surrogate === null) {\n        return finished;\n      }\n      \n      \n      if (utf16_lead_byte === null) {\n        utf16_lead_byte = bite;\n        return null;\n      }\n      \n      var code_unit;\n      if (utf16_be) {\n        \n        \n        code_unit = (utf16_lead_byte << 8) + bite;\n      } else {\n        \n        \n        code_unit = (bite << 8) + utf16_lead_byte;\n      }\n      \n      utf16_lead_byte = null;\n      \n      \n      \n      if (utf16_lead_surrogate !== null) {\n        var lead_surrogate = utf16_lead_surrogate;\n        utf16_lead_surrogate = null;\n        \n        \n        \n        if (inRange(code_unit, 0xDC00, 0xDFFF)) {\n          return 0x10000 + (lead_surrogate - 0xD800) * 0x400 +\n              (code_unit - 0xDC00);\n        }\n        \n        \n        \n        stream.prepend(convertCodeUnitToBytes(code_unit, utf16_be));\n        return decoderError(fatal);\n      }\n      \n      \n      if (inRange(code_unit, 0xD800, 0xDBFF)) {\n        utf16_lead_surrogate = code_unit;\n        return null;\n      }\n      \n      \n      if (inRange(code_unit, 0xDC00, 0xDFFF))\n        return decoderError(fatal);\n      \n      return code_unit;\n    };\n  }\n  \n \n  function UTF16Encoder(utf16_be, options) {\n    var fatal = options.fatal;\n   \n    this.handler = function(stream, code_point) {\n      \n      if (code_point === end_of_stream)\n        return finished;\n      \n      \n      \n      if (inRange(code_point, 0x0000, 0xFFFF))\n        return convertCodeUnitToBytes(code_point, utf16_be);\n      \n      \n      var lead = convertCodeUnitToBytes(\n        ((code_point - 0x10000) >> 10) + 0xD800, utf16_be);\n      \n      \n      var trail = convertCodeUnitToBytes(\n        ((code_point - 0x10000) & 0x3FF) + 0xDC00, utf16_be);\n      \n      return lead.concat(trail);\n    };\n  }\n  \n  \n \n  encoders['UTF-16BE'] = function(options) {\n    return new UTF16Encoder(true, options);\n  };\n  \n \n  decoders['UTF-16BE'] = function(options) {\n    return new UTF16Decoder(true, options);\n  };\n  \n  \n \n  encoders['UTF-16LE'] = function(options) {\n    return new UTF16Encoder(false, options);\n  };\n  \n \n  decoders['UTF-16LE'] = function(options) {\n    return new UTF16Decoder(false, options);\n  };\n  \n  \n \n  function XUserDefinedDecoder(options) {\n    var fatal = options.fatal;\n   \n    this.handler = function(stream, bite) {\n      \n      if (bite === end_of_stream)\n        return finished;\n      \n      \n      if (isASCIIByte(bite))\n        return bite;\n      \n      return 0xF780 + bite - 0x80;\n    };\n  }\n  \n \n  function XUserDefinedEncoder(options) {\n    var fatal = options.fatal;\n   \n    this.handler = function(stream, code_point) {\n      \n      if (code_point === end_of_stream)\n        return finished;\n      \n      \n      if (isASCIICodePoint(code_point))\n        return code_point;\n      \n      \n      if (inRange(code_point, 0xF780, 0xF7FF))\n        return code_point - 0xF780 + 0x80;\n      \n      return encoderError(code_point);\n    };\n  }\n \n  encoders['x-user-defined'] = function(options) {\n    return new XUserDefinedEncoder(options);\n  };\n \n  decoders['x-user-defined'] = function(options) {\n    return new XUserDefinedDecoder(options);\n  };\n  if (!global['TextEncoder'])\n    global['TextEncoder'] = TextEncoder;\n  if (!global['TextDecoder'])\n    global['TextDecoder'] = TextDecoder;\n  if ( true && module.exports) {\n    module.exports = {\n      TextEncoder: global['TextEncoder'],\n      TextDecoder: global['TextDecoder'],\n      EncodingIndexes: global[\"encoding-indexes\"]\n    };\n  }\n\n\n}(this || {}));\n })