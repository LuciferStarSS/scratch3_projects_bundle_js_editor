/* 1216 */\n (function(module, exports, __webpack_require__) {\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nvar log = __webpack_require__(308);\nvar Asset = __webpack_require__(309);\nvar Helper = __webpack_require__(484);\nvar ProxyTool = __webpack_require__(1217);\nvar ensureRequestConfig = function ensureRequestConfig(reqConfig) {\n  if (typeof reqConfig === 'string') {\n    return {\n      url: reqConfig\n    };\n  }\n  return reqConfig;\n};\n/**\n * @typedef {function} UrlFunction - A function which computes a URL from asset information.\n * @param {Asset} - The asset for which the URL should be computed.\n * @returns {(string|object)} - A string representing the URL for the asset request OR an object with configuration for\n *                              the underlying `nets` call (necessary for configuring e.g. authentication)\n */\nvar WebHelper = function (_Helper) {\n  _inherits(WebHelper, _Helper);\n  var _super = _createSuper(WebHelper);\n  function WebHelper(parent) {\n    var _this;\n    _classCallCheck(this, WebHelper);\n    _this = _super.call(this, parent);\n   \n    _this.stores = [];\n   \n    _this.assetTool = new ProxyTool();\n   \n    _this.projectTool = new ProxyTool(ProxyTool.TOOL_FILTER.READY);\n    return _this;\n  }\n \n  _createClass(WebHelper, [{\n    key: \"addSource\",\n    value: function addSource(types, urlFunction) {\n      log.warn('Deprecation: WebHelper.addSource has been replaced with WebHelper.addStore.');\n      this.addStore(types, urlFunction);\n    }\n   \n  }, {\n    key: \"addStore\",\n    value: function addStore(types, getFunction, createFunction, updateFunction) {\n      this.stores.push({\n        types: types.map(function (assetType) {\n          return assetType.name;\n        }),\n        get: getFunction,\n        create: createFunction,\n        update: updateFunction\n      });\n    }\n   \n  }, {\n    key: \"load\",\n    value: function load(assetType, assetId, dataFormat) {\n     \n      var errors = [];\n      var stores = this.stores.slice().filter(function (store) {\n        return store.types.indexOf(assetType.name) >= 0;\n      });\n      var asset = new Asset(assetType, assetId, dataFormat);\n      var tool = this.assetTool;\n      if (assetType.name === 'Project') {\n        tool = this.projectTool;\n      }\n      var storeIndex = 0;\n      var tryNextSource = function tryNextSource() {\n        var store = stores[storeIndex++];\n       \n        var reqConfigFunction = store.get;\n        if (reqConfigFunction) {\n          var reqConfig = ensureRequestConfig(reqConfigFunction(asset));\n          if (reqConfig === false) {\n            return tryNextSource();\n          }\n          return tool.get(reqConfig).then(function (body) {\n            return asset.setData(body, dataFormat);\n          }).catch(tryNextSource);\n        } else if (errors.length > 0) {\n          return Promise.reject(errors);\n        } \n        return Promise.resolve(null);\n      };\n      return tryNextSource().then(function () {\n        return asset;\n      });\n    }\n   \n  }, {\n    key: \"store\",\n    value: function store(assetType, dataFormat, data, assetId) {\n      var asset = new Asset(assetType, assetId, dataFormat); \n      var create = assetId === '' || assetId === null || typeof assetId === 'undefined'; \n      var store = this.stores.filter(function (s) {\n        return (\n          s.types.indexOf(assetType.name) !== -1 && ( \n          \n          create && s.create || s.update)\n        );\n      })[0];\n      var method = create ? 'post' : 'put';\n      if (!store) return Promise.reject('No appropriate stores');\n      var tool = this.assetTool;\n      if (assetType.name === 'Project') {\n        tool = this.projectTool;\n      }\n      var reqConfig = ensureRequestConfig(create ? store.create(asset) : store.update(asset));\n      var reqBodyConfig = Object.assign({\n        body: data,\n        method: method\n      }, reqConfig);\n      return tool.send(reqBodyConfig).then(function (body) {\n        \n        \n        \n        if (typeof body === 'string') {\n          try {\n            body = JSON.parse(body);\n          } catch (parseError) {\n            \n            \n            return body;\n          }\n        }\n        return Object.assign({\n          id: body['content-name'] || assetId\n        }, body);\n      });\n    }\n  }]);\n  return WebHelper;\n}(Helper);\nmodule.exports = WebHelper;\n })