/* 487 */\n (function(module, exports, __webpack_require__) {\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n/**\n * @fileoverview\n * A utility to transform a texture coordinate to another texture coordinate\n * representing how the shaders apply effects.\n */\nvar twgl = __webpack_require__(103);\nvar ShaderManager = __webpack_require__(188);\n/**\n * A texture coordinate is between 0 and 1. 0.5 is the center position.\n * @const {number}\n */\nvar CENTER_X = 0.5;\n/**\n * A texture coordinate is between 0 and 1. 0.5 is the center position.\n * @const {number}\n */\nvar CENTER_Y = 0.5;\n/**\n * Reused memory location for storing an HSV color value.\n * @type {Array<number>}\n */\nvar __hsv = [0, 0, 0];\n/**\n * Converts an RGB color value to HSV. Conversion formula\n * adapted from http://lolengine.net/blog/2013/01/13/fast-rgb-to-hsv.\n * Assumes r, g, and b are in the range [0, 255] and\n * returns h, s, and v in the range [0, 1].\n *\n * @param   {Array<number>} rgb   The RGB color value\n * @param   {number}        rgb.r The red color value\n * @param   {number}        rgb.g The green color value\n * @param   {number}        rgb.b The blue color value\n * @param   {Array<number>} dst   The array to store the RGB values in\n * @return  {Array<number>}       The `dst` array passed in\n */\nvar rgbToHsv = function rgbToHsv(_ref, dst) {\n  var _ref2 = _slicedToArray(_ref, 3),\n      r = _ref2[0],\n      g = _ref2[1],\n      b = _ref2[2];\n  var K = 0.0;\n  r /= 255;\n  g /= 255;\n  b /= 255;\n  var tmp = 0;\n  if (g < b) {\n    tmp = g;\n    g = b;\n    b = tmp;\n    K = -1;\n  }\n  if (r < g) {\n    tmp = r;\n    r = g;\n    g = tmp;\n    K = -2 / 6 - K;\n  }\n  var chroma = r - Math.min(g, b);\n  var h = Math.abs(K + (g - b) / (6 * chroma + Number.EPSILON));\n  var s = chroma / (r + Number.EPSILON);\n  var v = r;\n  dst[0] = h;\n  dst[1] = s;\n  dst[2] = v;\n  return dst;\n};\n/**\n * Converts an HSV color value to RGB. Conversion formula\n * adapted from https://gist.github.com/mjackson/5311256.\n * Assumes h, s, and v are contained in the set [0, 1] and\n * returns r, g, and b in the set [0, 255].\n *\n * @param   {Array<number>}                hsv The HSV color value\n * @param   {number}                       hsv.h     The hue\n * @param   {number}                       hsv.s     The saturation\n * @param   {number}                       hsv.v     The value\n * @param   {Uint8Array|Uint8ClampedArray} dst The array to store the RGB values in\n * @return  {Uint8Array|Uint8ClampedArray}     The `dst` array passed in\n */\nvar hsvToRgb = function hsvToRgb(_ref3, dst) {\n  var _ref4 = _slicedToArray(_ref3, 3),\n      h = _ref4[0],\n      s = _ref4[1],\n      v = _ref4[2];\n  if (s === 0) {\n    dst[0] = dst[1] = dst[2] = v * 255 + 0.5;\n    return dst;\n  } \n  h %= 1;\n  var i = h * 6 | 0;\n  var f = h * 6 - i;\n  var p = v * (1 - s);\n  var q = v * (1 - s * f);\n  var t = v * (1 - s * (1 - f));\n  var r = 0;\n  var g = 0;\n  var b = 0;\n  switch (i) {\n    case 0:\n      r = v;\n      g = t;\n      b = p;\n      break;\n    case 1:\n      r = q;\n      g = v;\n      b = p;\n      break;\n    case 2:\n      r = p;\n      g = v;\n      b = t;\n      break;\n    case 3:\n      r = p;\n      g = q;\n      b = v;\n      break;\n    case 4:\n      r = t;\n      g = p;\n      b = v;\n      break;\n    case 5:\n      r = v;\n      g = p;\n      b = q;\n      break;\n  } \n  dst[0] = r * 255 + 0.5;\n  dst[1] = g * 255 + 0.5;\n  dst[2] = b * 255 + 0.5;\n  return dst;\n};\nvar EffectTransform = function () {\n  function EffectTransform() {\n    _classCallCheck(this, EffectTransform);\n  }\n  _createClass(EffectTransform, null, [{\n    key: \"transformColor\",\n   \n    value: function transformColor(drawable, inOutColor, effectMask) {\n      \n      if (inOutColor[3] === 0) {\n        return inOutColor;\n      }\n      var effects = drawable.enabledEffects;\n      if (typeof effectMask === 'number') effects &= effectMask;\n      var uniforms = drawable.getUniforms();\n      var enableColor = (effects & ShaderManager.EFFECT_INFO.color.mask) !== 0;\n      var enableBrightness = (effects & ShaderManager.EFFECT_INFO.brightness.mask) !== 0;\n      if (enableColor || enableBrightness) {\n        \n        \n        \n        \n        \n        \n        var alpha = inOutColor[3] / 255;\n        inOutColor[0] /= alpha;\n        inOutColor[1] /= alpha;\n        inOutColor[2] /= alpha;\n        if (enableColor) {\n          \n          var hsv = rgbToHsv(inOutColor, __hsv); \n          \n          \n          var minV = 0.11 / 2.0; \n          var minS = 0.09; \n          if (hsv[2] < minV) {\n            hsv[0] = 0;\n            hsv[1] = 1;\n            hsv[2] = minV; \n          } else if (hsv[1] < minS) {\n            hsv[0] = 0;\n            hsv[1] = minS;\n          } \n          \n          hsv[0] = uniforms.u_color + hsv[0] + 1; \n          hsvToRgb(hsv, inOutColor);\n        }\n        if (enableBrightness) {\n          var brightness = uniforms.u_brightness * 255; \n          \n          inOutColor[0] += brightness;\n          inOutColor[1] += brightness;\n          inOutColor[2] += brightness;\n        } \n        \n        inOutColor[0] *= alpha;\n        inOutColor[1] *= alpha;\n        inOutColor[2] *= alpha;\n      }\n      if ((effects & ShaderManager.EFFECT_INFO.ghost.mask) !== 0) {\n        \n        inOutColor[0] *= uniforms.u_ghost;\n        inOutColor[1] *= uniforms.u_ghost;\n        inOutColor[2] *= uniforms.u_ghost;\n        inOutColor[3] *= uniforms.u_ghost;\n      }\n      return inOutColor;\n    }\n   \n  }, {\n    key: \"transformPoint\",\n    value: function transformPoint(drawable, vec, dst) {\n      twgl.v3.copy(vec, dst);\n      var effects = drawable.enabledEffects;\n      var uniforms = drawable.getUniforms();\n      if ((effects & ShaderManager.EFFECT_INFO.mosaic.mask) !== 0) {\n        \n        dst[0] = uniforms.u_mosaic * dst[0] % 1;\n        dst[1] = uniforms.u_mosaic * dst[1] % 1;\n      }\n      if ((effects & ShaderManager.EFFECT_INFO.pixelate.mask) !== 0) {\n        var skinUniforms = drawable.skin.getUniforms(); \n        var texelX = skinUniforms.u_skinSize[0] / uniforms.u_pixelate;\n        var texelY = skinUniforms.u_skinSize[1] / uniforms.u_pixelate; \n        \n        dst[0] = (Math.floor(dst[0] * texelX) + CENTER_X) / texelX;\n        dst[1] = (Math.floor(dst[1] * texelY) + CENTER_Y) / texelY;\n      }\n      if ((effects & ShaderManager.EFFECT_INFO.whirl.mask) !== 0) {\n        \n        var RADIUS = 0.5; \n        var offsetX = dst[0] - CENTER_X;\n        var offsetY = dst[1] - CENTER_Y; \n        var offsetMagnitude = Math.sqrt(Math.pow(offsetX, 2) + Math.pow(offsetY, 2)); \n        var whirlFactor = Math.max(1.0 - offsetMagnitude / RADIUS, 0.0); \n        var whirlActual = uniforms.u_whirl * whirlFactor * whirlFactor; \n        var sinWhirl = Math.sin(whirlActual); \n        var cosWhirl = Math.cos(whirlActual); \n        \n        \n        \n        var rot1 = cosWhirl;\n        var rot2 = -sinWhirl;\n        var rot3 = sinWhirl;\n        var rot4 = cosWhirl; \n        dst[0] = rot1 * offsetX + rot3 * offsetY + CENTER_X;\n        dst[1] = rot2 * offsetX + rot4 * offsetY + CENTER_Y;\n      }\n      if ((effects & ShaderManager.EFFECT_INFO.fisheye.mask) !== 0) {\n        \n        var vX = (dst[0] - CENTER_X) / CENTER_X;\n        var vY = (dst[1] - CENTER_Y) / CENTER_Y; \n        var vLength = Math.sqrt(vX * vX + vY * vY); \n        var r = Math.pow(Math.min(vLength, 1), uniforms.u_fisheye) * Math.max(1, vLength); \n        var unitX = vX / vLength;\n        var unitY = vY / vLength; \n        dst[0] = CENTER_X + r * unitX * CENTER_X;\n        dst[1] = CENTER_Y + r * unitY * CENTER_Y;\n      }\n      return dst;\n    }\n  }]);\n  return EffectTransform;\n}();\nmodule.exports = EffectTransform;\n })