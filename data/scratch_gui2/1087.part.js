/* 1087 */\n (function(module, exports, __webpack_require__) {\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nvar Cast = __webpack_require__(48);\nvar Clone = __webpack_require__(113);\nvar RenderedTarget = __webpack_require__(219);\nvar uid = __webpack_require__(94);\nvar StageLayering = __webpack_require__(115);\nvar getMonitorIdForBlockWithArgs = __webpack_require__(296);\nvar MathUtil = __webpack_require__(62);\n/**\n * @typedef {object} BubbleState - the bubble state associated with a particular target.\n * @property {Boolean} onSpriteRight - tracks whether the bubble is right or left of the sprite.\n * @property {?int} drawableId - the ID of the associated bubble Drawable, null if none.\n * @property {string} text - the text of the bubble.\n * @property {string} type - the type of the bubble, \"say\" or \"think\"\n * @property {?string} usageId - ID indicating the most recent usage of the say/think bubble.\n *      Used for comparison when determining whether to clear a say/think bubble.\n */\nvar Scratch3LooksBlocks = function () {\n  function Scratch3LooksBlocks(runtime) {\n    _classCallCheck(this, Scratch3LooksBlocks);\n   \n    this.runtime = runtime;\n    this._onTargetChanged = this._onTargetChanged.bind(this);\n    this._onResetBubbles = this._onResetBubbles.bind(this);\n    this._onTargetWillExit = this._onTargetWillExit.bind(this);\n    this._updateBubble = this._updateBubble.bind(this); \n    this.runtime.on('PROJECT_STOP_ALL', this._onResetBubbles);\n    this.runtime.on('targetWasRemoved', this._onTargetWillExit); \n    this.runtime.on(Scratch3LooksBlocks.SAY_OR_THINK, this._updateBubble);\n  }\n \n  _createClass(Scratch3LooksBlocks, [{\n    key: \"_getBubbleState\",\n   \n    value: function _getBubbleState(target) {\n      var bubbleState = target.getCustomState(Scratch3LooksBlocks.STATE_KEY);\n      if (!bubbleState) {\n        bubbleState = Clone.simple(Scratch3LooksBlocks.DEFAULT_BUBBLE_STATE);\n        target.setCustomState(Scratch3LooksBlocks.STATE_KEY, bubbleState);\n      }\n      return bubbleState;\n    }\n   \n  }, {\n    key: \"_onTargetChanged\",\n    value: function _onTargetChanged(target) {\n      var bubbleState = this._getBubbleState(target);\n      if (bubbleState.drawableId) {\n        this._positionBubble(target);\n      }\n    }\n   \n  }, {\n    key: \"_onTargetWillExit\",\n    value: function _onTargetWillExit(target) {\n      var bubbleState = this._getBubbleState(target);\n      if (bubbleState.drawableId && bubbleState.skinId) {\n        this.runtime.renderer.destroyDrawable(bubbleState.drawableId, StageLayering.SPRITE_LAYER);\n        this.runtime.renderer.destroySkin(bubbleState.skinId);\n        bubbleState.drawableId = null;\n        bubbleState.skinId = null;\n        this.runtime.requestRedraw();\n      }\n      target.removeListener(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this._onTargetChanged);\n    }\n   \n  }, {\n    key: \"_onResetBubbles\",\n    value: function _onResetBubbles() {\n      for (var n = 0; n < this.runtime.targets.length; n++) {\n        var bubbleState = this._getBubbleState(this.runtime.targets[n]);\n        bubbleState.text = '';\n        this._onTargetWillExit(this.runtime.targets[n]);\n      }\n      clearTimeout(this._bubbleTimeout);\n    }\n   \n  }, {\n    key: \"_positionBubble\",\n    value: function _positionBubble(target) {\n      if (!target.visible) return;\n      var bubbleState = this._getBubbleState(target);\n      var _this$runtime$rendere = this.runtime.renderer.getCurrentSkinSize(bubbleState.drawableId),\n          _this$runtime$rendere2 = _slicedToArray(_this$runtime$rendere, 2),\n          bubbleWidth = _this$runtime$rendere2[0],\n          bubbleHeight = _this$runtime$rendere2[1];\n      var targetBounds;\n      try {\n        targetBounds = target.getBoundsForBubble();\n      } catch (error_) {\n        \n        \n        targetBounds = {\n          left: target.x,\n          right: target.x,\n          top: target.y,\n          bottom: target.y\n        };\n      }\n      var stageSize = this.runtime.renderer.getNativeSize();\n      var stageBounds = {\n        left: -stageSize[0] / 2,\n        right: stageSize[0] / 2,\n        top: stageSize[1] / 2,\n        bottom: -stageSize[1] / 2\n      };\n      if (bubbleState.onSpriteRight && bubbleWidth + targetBounds.right > stageBounds.right && targetBounds.left - bubbleWidth > stageBounds.left) {\n        \n        bubbleState.onSpriteRight = false;\n        this._renderBubble(target);\n      } else if (!bubbleState.onSpriteRight && targetBounds.left - bubbleWidth < stageBounds.left && bubbleWidth + targetBounds.right < stageBounds.right) {\n        \n        bubbleState.onSpriteRight = true;\n        this._renderBubble(target);\n      } else {\n        this.runtime.renderer.updateDrawablePosition(bubbleState.drawableId, [bubbleState.onSpriteRight ? Math.max(stageBounds.left, \n        Math.min(stageBounds.right - bubbleWidth, targetBounds.right)) : Math.min(stageBounds.right - bubbleWidth, \n        Math.max(stageBounds.left, targetBounds.left - bubbleWidth)), \n        Math.min(stageBounds.top, targetBounds.bottom + bubbleHeight)]);\n        this.runtime.requestRedraw();\n      }\n    }\n   \n  }, {\n    key: \"_renderBubble\",\n    value: function _renderBubble(target) {\n      if (!this.runtime.renderer) return;\n      var bubbleState = this._getBubbleState(target);\n      var type = bubbleState.type,\n          text = bubbleState.text,\n          onSpriteRight = bubbleState.onSpriteRight; \n      if (!target.visible || text === '') {\n        this._onTargetWillExit(target);\n        return;\n      }\n      if (bubbleState.skinId) {\n        this.runtime.renderer.updateTextSkin(bubbleState.skinId, type, text, onSpriteRight, [0, 0]);\n      } else {\n        target.addListener(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this._onTargetChanged);\n        bubbleState.drawableId = this.runtime.renderer.createDrawable(StageLayering.SPRITE_LAYER);\n        bubbleState.skinId = this.runtime.renderer.createTextSkin(type, text, bubbleState.onSpriteRight, [0, 0]);\n        this.runtime.renderer.updateDrawableSkinId(bubbleState.drawableId, bubbleState.skinId);\n      }\n      this._positionBubble(target);\n    }\n   \n  }, {\n    key: \"_formatBubbleText\",\n    value: function _formatBubbleText(text) {\n      if (text === '') return text; \n      \n      \n      if (typeof text === 'number' && Math.abs(text) >= 0.01 && text % 1 !== 0) {\n        text = text.toFixed(2);\n      } \n      text = String(text).substr(0, Scratch3LooksBlocks.SAY_BUBBLE_LIMIT);\n      return text;\n    }\n   \n  }, {\n    key: \"_updateBubble\",\n    value: function _updateBubble(target, type, text) {\n      var bubbleState = this._getBubbleState(target);\n      bubbleState.type = type;\n      bubbleState.text = this._formatBubbleText(text);\n      bubbleState.usageId = uid();\n      this._renderBubble(target);\n    }\n   \n  }, {\n    key: \"getPrimitives\",\n    value: function getPrimitives() {\n      return {\n        looks_say: this.say,\n        looks_sayforsecs: this.sayforsecs,\n        looks_think: this.think,\n        looks_thinkforsecs: this.thinkforsecs,\n        looks_show: this.show,\n        looks_hide: this.hide,\n        looks_hideallsprites: function looks_hideallsprites() {},\n        \n        looks_switchcostumeto: this.switchCostume,\n        looks_switchbackdropto: this.switchBackdrop,\n        looks_switchbackdroptoandwait: this.switchBackdropAndWait,\n        looks_nextcostume: this.nextCostume,\n        looks_nextbackdrop: this.nextBackdrop,\n        looks_changeeffectby: this.changeEffect,\n        looks_seteffectto: this.setEffect,\n        looks_cleargraphiceffects: this.clearEffects,\n        looks_changesizeby: this.changeSize,\n        looks_setsizeto: this.setSize,\n        looks_changestretchby: function looks_changestretchby() {},\n        \n        looks_setstretchto: function looks_setstretchto() {},\n        looks_gotofrontback: this.goToFrontBack,\n        looks_goforwardbackwardlayers: this.goForwardBackwardLayers,\n        looks_size: this.getSize,\n        looks_costumenumbername: this.getCostumeNumberName,\n        looks_backdropnumbername: this.getBackdropNumberName\n      };\n    }\n  }, {\n    key: \"getMonitored\",\n    value: function getMonitored() {\n      return {\n        looks_size: {\n          isSpriteSpecific: true,\n          getId: function getId(targetId) {\n            return \"\".concat(targetId, \"_size\");\n          }\n        },\n        looks_costumenumbername: {\n          isSpriteSpecific: true,\n          getId: function getId(targetId, fields) {\n            return getMonitorIdForBlockWithArgs(\"\".concat(targetId, \"_costumenumbername\"), fields);\n          }\n        },\n        looks_backdropnumbername: {\n          getId: function getId(_, fields) {\n            return getMonitorIdForBlockWithArgs('backdropnumbername', fields);\n          }\n        }\n      };\n    }\n  }, {\n    key: \"say\",\n    value: function say(args, util) {\n      \n      this.runtime.emit(Scratch3LooksBlocks.SAY_OR_THINK, util.target, 'say', args.MESSAGE);\n    }\n  }, {\n    key: \"sayforsecs\",\n    value: function sayforsecs(args, util) {\n      var _this = this;\n      this.say(args, util);\n      var target = util.target;\n      var usageId = this._getBubbleState(target).usageId;\n      return new Promise(function (resolve) {\n        _this._bubbleTimeout = setTimeout(function () {\n          _this._bubbleTimeout = null; \n          if (_this._getBubbleState(target).usageId === usageId) {\n            _this._updateBubble(target, 'say', '');\n          }\n          resolve();\n        }, 1000 * args.SECS);\n      });\n    }\n  }, {\n    key: \"think\",\n    value: function think(args, util) {\n      this.runtime.emit(Scratch3LooksBlocks.SAY_OR_THINK, util.target, 'think', args.MESSAGE);\n    }\n  }, {\n    key: \"thinkforsecs\",\n    value: function thinkforsecs(args, util) {\n      var _this2 = this;\n      this.think(args, util);\n      var target = util.target;\n      var usageId = this._getBubbleState(target).usageId;\n      return new Promise(function (resolve) {\n        _this2._bubbleTimeout = setTimeout(function () {\n          _this2._bubbleTimeout = null; \n          if (_this2._getBubbleState(target).usageId === usageId) {\n            _this2._updateBubble(target, 'think', '');\n          }\n          resolve();\n        }, 1000 * args.SECS);\n      });\n    }\n  }, {\n    key: \"show\",\n    value: function show(args, util) {\n      util.target.setVisible(true);\n      this._renderBubble(util.target);\n    }\n  }, {\n    key: \"hide\",\n    value: function hide(args, util) {\n      util.target.setVisible(false);\n      this._renderBubble(util.target);\n    }\n   \n  }, {\n    key: \"_setCostume\",\n    value: function _setCostume(target, requestedCostume, optZeroIndex) {\n      if (typeof requestedCostume === 'number') {\n        \n        target.setCostume(optZeroIndex ? requestedCostume : requestedCostume - 1);\n      } else {\n        \n        var costumeIndex = target.getCostumeIndexByName(requestedCostume.toString());\n        if (costumeIndex !== -1) {\n          target.setCostume(costumeIndex);\n        } else if (requestedCostume === 'next costume') {\n          target.setCostume(target.currentCostume + 1);\n        } else if (requestedCostume === 'previous costume') {\n          target.setCostume(target.currentCostume - 1); \n          \n          \n        } else if (!(isNaN(requestedCostume) || Cast.isWhiteSpace(requestedCostume))) {\n          target.setCostume(optZeroIndex ? Number(requestedCostume) : Number(requestedCostume) - 1);\n        }\n      } \n      return [];\n    }\n   \n  }, {\n    key: \"_setBackdrop\",\n    value: function _setBackdrop(stage, requestedBackdrop, optZeroIndex) {\n      if (typeof requestedBackdrop === 'number') {\n        \n        stage.setCostume(optZeroIndex ? requestedBackdrop : requestedBackdrop - 1);\n      } else {\n        \n        var costumeIndex = stage.getCostumeIndexByName(requestedBackdrop.toString());\n        if (costumeIndex !== -1) {\n          stage.setCostume(costumeIndex);\n        } else if (requestedBackdrop === 'next backdrop') {\n          stage.setCostume(stage.currentCostume + 1);\n        } else if (requestedBackdrop === 'previous backdrop') {\n          stage.setCostume(stage.currentCostume - 1);\n        } else if (requestedBackdrop === 'random backdrop') {\n          var numCostumes = stage.getCostumes().length;\n          if (numCostumes > 1) {\n            \n            \n            var lowerBound = 0;\n            var upperBound = numCostumes - 1;\n            var costumeToExclude = stage.currentCostume;\n            var nextCostume = MathUtil.inclusiveRandIntWithout(lowerBound, upperBound, costumeToExclude);\n            stage.setCostume(nextCostume);\n          } \n          \n          \n        } else if (!(isNaN(requestedBackdrop) || Cast.isWhiteSpace(requestedBackdrop))) {\n          stage.setCostume(optZeroIndex ? Number(requestedBackdrop) : Number(requestedBackdrop) - 1);\n        }\n      }\n      var newName = stage.getCostumes()[stage.currentCostume].name;\n      return this.runtime.startHats('event_whenbackdropswitchesto', {\n        BACKDROP: newName\n      });\n    }\n  }, {\n    key: \"switchCostume\",\n    value: function switchCostume(args, util) {\n      this._setCostume(util.target, args.COSTUME);\n    }\n  }, {\n    key: \"nextCostume\",\n    value: function nextCostume(args, util) {\n      this._setCostume(util.target, util.target.currentCostume + 1, true);\n    }\n  }, {\n    key: \"switchBackdrop\",\n    value: function switchBackdrop(args) {\n      this._setBackdrop(this.runtime.getTargetForStage(), args.BACKDROP);\n    }\n  }, {\n    key: \"switchBackdropAndWait\",\n    value: function switchBackdropAndWait(args, util) {\n      \n      if (!util.stackFrame.startedThreads) {\n        \n        util.stackFrame.startedThreads = this._setBackdrop(this.runtime.getTargetForStage(), args.BACKDROP);\n        if (util.stackFrame.startedThreads.length === 0) {\n          \n          return;\n        }\n      } \n      var instance = this; \n      \n      \n      \n      var waiting = util.stackFrame.startedThreads.some(function (thread) {\n        return instance.runtime.threads.indexOf(thread) !== -1;\n      });\n      if (waiting) {\n        \n        \n        \n        if (util.stackFrame.startedThreads.every(function (thread) {\n          return instance.runtime.isWaitingThread(thread);\n        })) {\n          util.yieldTick();\n        } else {\n          util.yield();\n        }\n      }\n    }\n  }, {\n    key: \"nextBackdrop\",\n    value: function nextBackdrop() {\n      var stage = this.runtime.getTargetForStage();\n      this._setBackdrop(stage, stage.currentCostume + 1, true);\n    }\n  }, {\n    key: \"clampEffect\",\n    value: function clampEffect(effect, value) {\n      var clampedValue = value;\n      switch (effect) {\n        case 'ghost':\n          clampedValue = MathUtil.clamp(value, Scratch3LooksBlocks.EFFECT_GHOST_LIMIT.min, Scratch3LooksBlocks.EFFECT_GHOST_LIMIT.max);\n          break;\n        case 'brightness':\n          clampedValue = MathUtil.clamp(value, Scratch3LooksBlocks.EFFECT_BRIGHTNESS_LIMIT.min, Scratch3LooksBlocks.EFFECT_BRIGHTNESS_LIMIT.max);\n          break;\n      }\n      return clampedValue;\n    }\n  }, {\n    key: \"changeEffect\",\n    value: function changeEffect(args, util) {\n      var effect = Cast.toString(args.EFFECT).toLowerCase();\n      var change = Cast.toNumber(args.CHANGE);\n      if (!util.target.effects.hasOwnProperty(effect)) return;\n      var newValue = change + util.target.effects[effect];\n      newValue = this.clampEffect(effect, newValue);\n      util.target.setEffect(effect, newValue);\n    }\n  }, {\n    key: \"setEffect\",\n    value: function setEffect(args, util) {\n      var effect = Cast.toString(args.EFFECT).toLowerCase();\n      var value = Cast.toNumber(args.VALUE);\n      value = this.clampEffect(effect, value);\n      util.target.setEffect(effect, value);\n    }\n  }, {\n    key: \"clearEffects\",\n    value: function clearEffects(args, util) {\n      util.target.clearEffects();\n    }\n  }, {\n    key: \"changeSize\",\n    value: function changeSize(args, util) {\n      var change = Cast.toNumber(args.CHANGE);\n      util.target.setSize(util.target.size + change);\n    }\n  }, {\n    key: \"setSize\",\n    value: function setSize(args, util) {\n      var size = Cast.toNumber(args.SIZE);\n      util.target.setSize(size);\n    }\n  }, {\n    key: \"goToFrontBack\",\n    value: function goToFrontBack(args, util) {\n      if (!util.target.isStage) {\n        if (args.FRONT_BACK === 'front') {\n          util.target.goToFront();\n        } else {\n          util.target.goToBack();\n        }\n      }\n    }\n  }, {\n    key: \"goForwardBackwardLayers\",\n    value: function goForwardBackwardLayers(args, util) {\n      if (!util.target.isStage) {\n        if (args.FORWARD_BACKWARD === 'forward') {\n          util.target.goForwardLayers(Cast.toNumber(args.NUM));\n        } else {\n          util.target.goBackwardLayers(Cast.toNumber(args.NUM));\n        }\n      }\n    }\n  }, {\n    key: \"getSize\",\n    value: function getSize(args, util) {\n      return Math.round(util.target.size);\n    }\n  }, {\n    key: \"getBackdropNumberName\",\n    value: function getBackdropNumberName(args) {\n      var stage = this.runtime.getTargetForStage();\n      if (args.NUMBER_NAME === 'number') {\n        return stage.currentCostume + 1;\n      } \n      return stage.getCostumes()[stage.currentCostume].name;\n    }\n  }, {\n    key: \"getCostumeNumberName\",\n    value: function getCostumeNumberName(args, util) {\n      if (args.NUMBER_NAME === 'number') {\n        return util.target.currentCostume + 1;\n      } \n      return util.target.getCostumes()[util.target.currentCostume].name;\n    }\n  }], [{\n    key: \"DEFAULT_BUBBLE_STATE\",\n    get: function get() {\n      return {\n        drawableId: null,\n        onSpriteRight: true,\n        skinId: null,\n        text: '',\n        type: 'say',\n        usageId: null\n      };\n    }\n   \n  }, {\n    key: \"STATE_KEY\",\n    get: function get() {\n      return 'Scratch.looks';\n    }\n   \n  }, {\n    key: \"SAY_OR_THINK\",\n    get: function get() {\n      \n      \n      return 'SAY';\n    }\n   \n  }, {\n    key: \"SAY_BUBBLE_LIMIT\",\n    get: function get() {\n      return 330;\n    }\n   \n  }, {\n    key: \"EFFECT_GHOST_LIMIT\",\n    get: function get() {\n      return {\n        min: 0,\n        max: 100\n      };\n    }\n   \n  }, {\n    key: \"EFFECT_BRIGHTNESS_LIMIT\",\n    get: function get() {\n      return {\n        min: -100,\n        max: 100\n      };\n    }\n  }]);\n  return Scratch3LooksBlocks;\n}();\nmodule.exports = Scratch3LooksBlocks;\n })