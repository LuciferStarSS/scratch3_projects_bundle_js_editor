/* 450 */\n (function(module, exports, __webpack_require__) {\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nvar EventEmitter = __webpack_require__(91);\nvar _require = __webpack_require__(181),\n    OrderedMap = _require.OrderedMap;\nvar ArgumentType = __webpack_require__(63);\nvar Blocks = __webpack_require__(135);\nvar BlocksRuntimeCache = __webpack_require__(441);\nvar BlockType = __webpack_require__(45);\nvar Profiler = __webpack_require__(1074);\nvar Sequencer = __webpack_require__(1075);\nvar execute = __webpack_require__(451);\nvar ScratchBlocksConstants = __webpack_require__(1077);\nvar TargetType = __webpack_require__(432);\nvar Thread = __webpack_require__(224);\nvar log = __webpack_require__(39);\nvar maybeFormatMessage = __webpack_require__(428);\nvar StageLayering = __webpack_require__(115);\nvar Variable = __webpack_require__(114);\nvar xmlEscape = __webpack_require__(220);\nvar ScratchLinkWebSocket = __webpack_require__(1078); \nvar Clock = __webpack_require__(1079);\nvar Cloud = __webpack_require__(1080);\nvar Keyboard = __webpack_require__(1081);\nvar Mouse = __webpack_require__(1082);\nvar MouseWheel = __webpack_require__(1083);\nvar UserData = __webpack_require__(1084);\nvar Video = __webpack_require__(452);\nvar StringUtil = __webpack_require__(102);\nvar uid = __webpack_require__(94);\nvar defaultBlockPackages = {\n  scratch3_control: __webpack_require__(1085),\n  scratch3_event: __webpack_require__(1086),\n  scratch3_looks: __webpack_require__(1087),\n  scratch3_motion: __webpack_require__(1088),\n  scratch3_operators: __webpack_require__(1089),\n  scratch3_sound: __webpack_require__(1090),\n  scratch3_sensing: __webpack_require__(1091),\n  scratch3_data: __webpack_require__(1092),\n  scratch3_procedures: __webpack_require__(1093)\n};\nvar defaultExtensionColors = ['#0FBD8C', '#0DA57A', '#0B8E69'];\n/**\n * Information used for converting Scratch argument types into scratch-blocks data.\n * @type {object.<ArgumentType, {shadowType: string, fieldType: string}>}\n */\nvar ArgumentTypeMap = function () {\n  var map = {};\n  map[ArgumentType.ANGLE] = {\n    shadow: {\n      type: 'math_angle',\n      \n      \n      \n      \n      \n      \n      \n      fieldName: 'NUM'\n    }\n  };\n  map[ArgumentType.COLOR] = {\n    shadow: {\n      type: 'colour_picker',\n      fieldName: 'COLOUR'\n    }\n  };\n  map[ArgumentType.NUMBER] = {\n    shadow: {\n      type: 'math_number',\n      fieldName: 'NUM'\n    }\n  };\n  map[ArgumentType.STRING] = {\n    shadow: {\n      type: 'text',\n      fieldName: 'TEXT'\n    }\n  };\n  map[ArgumentType.BOOLEAN] = {\n    check: 'Boolean'\n  };\n  map[ArgumentType.MATRIX] = {\n    shadow: {\n      type: 'matrix',\n      fieldName: 'MATRIX'\n    }\n  };\n  map[ArgumentType.NOTE] = {\n    shadow: {\n      type: 'note',\n      fieldName: 'NOTE'\n    }\n  };\n  map[ArgumentType.IMAGE] = {\n    \n    \n    fieldType: 'field_image'\n  };\n  return map;\n}();\n/**\n * A pair of functions used to manage the cloud variable limit,\n * to be used when adding (or attempting to add) or removing a cloud variable.\n * @typedef {object} CloudDataManager\n * @property {function} canAddCloudVariable A function to call to check that\n * a cloud variable can be added.\n * @property {function} addCloudVariable A function to call to track a new\n * cloud variable on the runtime.\n * @property {function} removeCloudVariable A function to call when\n * removing an existing cloud variable.\n * @property {function} hasCloudVariables A function to call to check that\n * the runtime has any cloud variables.\n */\n/**\n * Creates and manages cloud variable limit in a project,\n * and returns two functions to be used to add a new\n * cloud variable (while checking that it can be added)\n * and remove an existing cloud variable.\n * These are to be called whenever attempting to create or delete\n * a cloud variable.\n * @return {CloudDataManager} The functions to be used when adding or removing a\n * cloud variable.\n */\nvar cloudDataManager = function cloudDataManager() {\n  var limit = 10;\n  var count = 0;\n  var canAddCloudVariable = function canAddCloudVariable() {\n    return count < limit;\n  };\n  var addCloudVariable = function addCloudVariable() {\n    count++;\n  };\n  var removeCloudVariable = function removeCloudVariable() {\n    count--;\n  };\n  var hasCloudVariables = function hasCloudVariables() {\n    return count > 0;\n  };\n  return {\n    canAddCloudVariable: canAddCloudVariable,\n    addCloudVariable: addCloudVariable,\n    removeCloudVariable: removeCloudVariable,\n    hasCloudVariables: hasCloudVariables\n  };\n};\n/**\n * Numeric ID for Runtime._step in Profiler instances.\n * @type {number}\n */\nvar stepProfilerId = -1;\n/**\n * Numeric ID for Sequencer.stepThreads in Profiler instances.\n * @type {number}\n */\nvar stepThreadsProfilerId = -1;\n/**\n * Numeric ID for RenderWebGL.draw in Profiler instances.\n * @type {number}\n */\nvar rendererDrawProfilerId = -1;\n/**\n * Manages targets, scripts, and the sequencer.\n * @constructor\n */\nvar Runtime = function (_EventEmitter) {\n  _inherits(Runtime, _EventEmitter);\n  var _super = _createSuper(Runtime);\n  function Runtime() {\n    var _this;\n    _classCallCheck(this, Runtime);\n    _this = _super.call(this);\n   \n    _this.targets = [];\n   \n    _this.executableTargets = [];\n   \n    _this.threads = [];\n   \n    _this.sequencer = new Sequencer(_assertThisInitialized(_this));\n   \n    _this.flyoutBlocks = new Blocks(_assertThisInitialized(_this), true\n   \n    );\n   \n    _this.monitorBlocks = new Blocks(_assertThisInitialized(_this), true\n   \n    );\n   \n    _this._editingTarget = null;\n   \n    _this._primitives = {};\n   \n    _this._blockInfo = [];\n   \n    _this._hats = {};\n   \n    _this._scriptGlowsPreviousFrame = [];\n   \n    _this._nonMonitorThreadCount = 0;\n   \n    _this._lastStepDoneThreads = null;\n   \n    _this._cloneCounter = 0;\n   \n    _this._refreshTargets = false;\n   \n    _this.monitorBlockInfo = {};\n   \n    _this._monitorState = OrderedMap({});\n   \n    _this._prevMonitorState = OrderedMap({});\n   \n    _this.turboMode = false;\n   \n    _this.compatibilityMode = false;\n   \n    _this._steppingInterval = null;\n   \n    _this.currentStepTime = null; \n    _this.updateCurrentMSecs();\n   \n    _this.redrawRequested = false; \n    _this._registerBlockPackages(); \n    \n   \n    _this.ioDevices = {\n      clock: new Clock(_assertThisInitialized(_this)),\n      cloud: new Cloud(_assertThisInitialized(_this)),\n      keyboard: new Keyboard(_assertThisInitialized(_this)),\n      mouse: new Mouse(_assertThisInitialized(_this)),\n      mouseWheel: new MouseWheel(_assertThisInitialized(_this)),\n      userData: new UserData(),\n      video: new Video(_assertThisInitialized(_this))\n    };\n   \n    _this.peripheralExtensions = {};\n   \n    _this.profiler = null;\n    var newCloudDataManager = cloudDataManager();\n   \n    _this.hasCloudData = newCloudDataManager.hasCloudVariables;\n   \n    _this.canAddCloudVariable = newCloudDataManager.canAddCloudVariable;\n   \n    _this.addCloudVariable = _this._initializeAddCloudVariable(newCloudDataManager);\n   \n    _this.removeCloudVariable = _this._initializeRemoveCloudVariable(newCloudDataManager);\n    return _this;\n  }\n \n  _createClass(Runtime, [{\n    key: \"_initializeAddCloudVariable\",\n    \n    \n    \n    value: function _initializeAddCloudVariable(newCloudDataManager) {\n      var _this2 = this;\n      \n      return function () {\n        var hadCloudVarsBefore = _this2.hasCloudData();\n        newCloudDataManager.addCloudVariable();\n        if (!hadCloudVarsBefore && _this2.hasCloudData()) {\n          _this2.emit(Runtime.HAS_CLOUD_DATA_UPDATE, true);\n        }\n      };\n    } \n  }, {\n    key: \"_initializeRemoveCloudVariable\",\n    value: function _initializeRemoveCloudVariable(newCloudDataManager) {\n      var _this3 = this;\n      return function () {\n        var hadCloudVarsBefore = _this3.hasCloudData();\n        newCloudDataManager.removeCloudVariable();\n        if (hadCloudVarsBefore && !_this3.hasCloudData()) {\n          _this3.emit(Runtime.HAS_CLOUD_DATA_UPDATE, false);\n        }\n      };\n    }\n   \n  }, {\n    key: \"_registerBlockPackages\",\n    value: function _registerBlockPackages() {\n      for (var packageName in defaultBlockPackages) {\n        if (defaultBlockPackages.hasOwnProperty(packageName)) {\n          \n          var packageObject = new defaultBlockPackages[packageName](this); \n          if (packageObject.getPrimitives) {\n            var packagePrimitives = packageObject.getPrimitives();\n            for (var op in packagePrimitives) {\n              if (packagePrimitives.hasOwnProperty(op)) {\n                this._primitives[op] = packagePrimitives[op].bind(packageObject);\n              }\n            }\n          } \n          if (packageObject.getHats) {\n            var packageHats = packageObject.getHats();\n            for (var hatName in packageHats) {\n              if (packageHats.hasOwnProperty(hatName)) {\n                this._hats[hatName] = packageHats[hatName];\n              }\n            }\n          } \n          if (packageObject.getMonitored) {\n            this.monitorBlockInfo = Object.assign({}, this.monitorBlockInfo, packageObject.getMonitored());\n          }\n        }\n      }\n    }\n  }, {\n    key: \"getMonitorState\",\n    value: function getMonitorState() {\n      return this._monitorState;\n    }\n   \n  }, {\n    key: \"_makeExtensionMenuId\",\n    value: function _makeExtensionMenuId(menuName, extensionId) {\n      return \"\".concat(extensionId, \"_menu_\").concat(xmlEscape(menuName));\n    }\n   \n  }, {\n    key: \"makeMessageContextForTarget\",\n    value: function makeMessageContextForTarget(target) {\n      var context = {};\n      target = target || this.getEditingTarget() || this.getTargetForStage();\n      if (target) {\n        context.targetType = target.isStage ? TargetType.STAGE : TargetType.SPRITE;\n      }\n    }\n   \n  }, {\n    key: \"_registerExtensionPrimitives\",\n    value: function _registerExtensionPrimitives(extensionInfo) {\n      var categoryInfo = {\n        id: extensionInfo.id,\n        name: maybeFormatMessage(extensionInfo.name),\n        showStatusButton: extensionInfo.showStatusButton,\n        blockIconURI: extensionInfo.blockIconURI,\n        menuIconURI: extensionInfo.menuIconURI\n      };\n      if (extensionInfo.color1) {\n        categoryInfo.color1 = extensionInfo.color1;\n        categoryInfo.color2 = extensionInfo.color2;\n        categoryInfo.color3 = extensionInfo.color3;\n      } else {\n        categoryInfo.color1 = defaultExtensionColors[0];\n        categoryInfo.color2 = defaultExtensionColors[1];\n        categoryInfo.color3 = defaultExtensionColors[2];\n      }\n      this._blockInfo.push(categoryInfo);\n      this._fillExtensionCategory(categoryInfo, extensionInfo);\n      for (var fieldTypeName in categoryInfo.customFieldTypes) {\n        if (extensionInfo.customFieldTypes.hasOwnProperty(fieldTypeName)) {\n          var fieldTypeInfo = categoryInfo.customFieldTypes[fieldTypeName]; \n          this.emit(Runtime.EXTENSION_FIELD_ADDED, {\n            name: \"field_\".concat(fieldTypeInfo.extendedName),\n            implementation: fieldTypeInfo.fieldImplementation\n          });\n        }\n      }\n      this.emit(Runtime.EXTENSION_ADDED, categoryInfo);\n    }\n   \n  }, {\n    key: \"_refreshExtensionPrimitives\",\n    value: function _refreshExtensionPrimitives(extensionInfo) {\n      var categoryInfo = this._blockInfo.find(function (info) {\n        return info.id === extensionInfo.id;\n      });\n      if (categoryInfo) {\n        categoryInfo.name = maybeFormatMessage(extensionInfo.name);\n        this._fillExtensionCategory(categoryInfo, extensionInfo);\n        this.emit(Runtime.BLOCKSINFO_UPDATE, categoryInfo);\n      }\n    }\n   \n  }, {\n    key: \"_fillExtensionCategory\",\n    value: function _fillExtensionCategory(categoryInfo, extensionInfo) {\n      categoryInfo.blocks = [];\n      categoryInfo.customFieldTypes = {};\n      categoryInfo.menus = [];\n      categoryInfo.menuInfo = {};\n      for (var menuName in extensionInfo.menus) {\n        if (extensionInfo.menus.hasOwnProperty(menuName)) {\n          var menuInfo = extensionInfo.menus[menuName];\n          var convertedMenu = this._buildMenuForScratchBlocks(menuName, menuInfo, categoryInfo);\n          categoryInfo.menus.push(convertedMenu);\n          categoryInfo.menuInfo[menuName] = menuInfo;\n        }\n      }\n      for (var fieldTypeName in extensionInfo.customFieldTypes) {\n        if (extensionInfo.customFieldTypes.hasOwnProperty(fieldTypeName)) {\n          var fieldType = extensionInfo.customFieldTypes[fieldTypeName];\n          var fieldTypeInfo = this._buildCustomFieldInfo(fieldTypeName, fieldType, extensionInfo.id, categoryInfo);\n          categoryInfo.customFieldTypes[fieldTypeName] = fieldTypeInfo;\n        }\n      }\n      var _iterator = _createForOfIteratorHelper(extensionInfo.blocks),\n          _step2;\n      try {\n        for (_iterator.s(); !(_step2 = _iterator.n()).done;) {\n          var blockInfo = _step2.value;\n          try {\n            var convertedBlock = this._convertForScratchBlocks(blockInfo, categoryInfo);\n            categoryInfo.blocks.push(convertedBlock);\n            if (convertedBlock.json) {\n              var opcode = convertedBlock.json.type;\n              if (blockInfo.blockType !== BlockType.EVENT) {\n                this._primitives[opcode] = convertedBlock.info.func;\n              }\n              if (blockInfo.blockType === BlockType.EVENT || blockInfo.blockType === BlockType.HAT) {\n                this._hats[opcode] = {\n                  edgeActivated: blockInfo.isEdgeActivated,\n                  restartExistingThreads: blockInfo.shouldRestartExistingThreads\n                };\n              }\n            }\n          } catch (e) {\n            log.error('Error parsing block: ', {\n              block: blockInfo,\n              error: e\n            });\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n   \n  }, {\n    key: \"_convertMenuItems\",\n    value: function _convertMenuItems(menuItems) {\n      if (typeof menuItems !== 'function') {\n        var extensionMessageContext = this.makeMessageContextForTarget();\n        return menuItems.map(function (item) {\n          var formattedItem = maybeFormatMessage(item, extensionMessageContext);\n          switch (_typeof(formattedItem)) {\n            case 'string':\n              return [formattedItem, formattedItem];\n            case 'object':\n              return [maybeFormatMessage(item.text, extensionMessageContext), item.value];\n            default:\n              throw new Error(\"Can't interpret menu item: \".concat(JSON.stringify(item)));\n          }\n        });\n      }\n      return menuItems;\n    }\n   \n  }, {\n    key: \"_buildMenuForScratchBlocks\",\n    value: function _buildMenuForScratchBlocks(menuName, menuInfo, categoryInfo) {\n      var menuId = this._makeExtensionMenuId(menuName, categoryInfo.id);\n      var menuItems = this._convertMenuItems(menuInfo.items);\n      return {\n        json: {\n          message0: '%1',\n          type: menuId,\n          inputsInline: true,\n          output: 'String',\n          colour: categoryInfo.color1,\n          colourSecondary: categoryInfo.color2,\n          colourTertiary: categoryInfo.color3,\n          outputShape: menuInfo.acceptReporters ? ScratchBlocksConstants.OUTPUT_SHAPE_ROUND : ScratchBlocksConstants.OUTPUT_SHAPE_SQUARE,\n          args0: [{\n            type: 'field_dropdown',\n            name: menuName,\n            options: menuItems\n          }]\n        }\n      };\n    }\n  }, {\n    key: \"_buildCustomFieldInfo\",\n    value: function _buildCustomFieldInfo(fieldName, fieldInfo, extensionId, categoryInfo) {\n      var extendedName = \"\".concat(extensionId, \"_\").concat(fieldName);\n      return {\n        fieldName: fieldName,\n        extendedName: extendedName,\n        argumentTypeInfo: {\n          shadow: {\n            type: extendedName,\n            fieldName: \"field_\".concat(extendedName)\n          }\n        },\n        scratchBlocksDefinition: this._buildCustomFieldTypeForScratchBlocks(extendedName, fieldInfo.output, fieldInfo.outputShape, categoryInfo),\n        fieldImplementation: fieldInfo.implementation\n      };\n    }\n   \n  }, {\n    key: \"_buildCustomFieldTypeForScratchBlocks\",\n    value: function _buildCustomFieldTypeForScratchBlocks(fieldName, output, outputShape, categoryInfo) {\n      return {\n        json: {\n          type: fieldName,\n          message0: '%1',\n          inputsInline: true,\n          output: output,\n          colour: categoryInfo.color1,\n          colourSecondary: categoryInfo.color2,\n          colourTertiary: categoryInfo.color3,\n          outputShape: outputShape,\n          args0: [{\n            name: \"field_\".concat(fieldName),\n            type: \"field_\".concat(fieldName)\n          }]\n        }\n      };\n    }\n   \n  }, {\n    key: \"_convertForScratchBlocks\",\n    value: function _convertForScratchBlocks(blockInfo, categoryInfo) {\n      if (blockInfo === '---') {\n        return this._convertSeparatorForScratchBlocks(blockInfo);\n      }\n      if (blockInfo.blockType === BlockType.BUTTON) {\n        return this._convertButtonForScratchBlocks(blockInfo);\n      }\n      return this._convertBlockForScratchBlocks(blockInfo, categoryInfo);\n    }\n   \n  }, {\n    key: \"_convertBlockForScratchBlocks\",\n    value: function _convertBlockForScratchBlocks(blockInfo, categoryInfo) {\n      var extendedOpcode = \"\".concat(categoryInfo.id, \"_\").concat(blockInfo.opcode);\n      var blockJSON = {\n        type: extendedOpcode,\n        inputsInline: true,\n        category: categoryInfo.name,\n        colour: categoryInfo.color1,\n        colourSecondary: categoryInfo.color2,\n        colourTertiary: categoryInfo.color3\n      };\n      var context = {\n        \n        \n        \n        \n        argsMap: {},\n        blockJSON: blockJSON,\n        categoryInfo: categoryInfo,\n        blockInfo: blockInfo,\n        inputList: []\n      }; \n      \n      \n      var iconURI = blockInfo.blockIconURI || categoryInfo.blockIconURI;\n      if (iconURI) {\n        blockJSON.extensions = ['scratch_extension'];\n        blockJSON.message0 = '%1 %2';\n        var iconJSON = {\n          type: 'field_image',\n          src: iconURI,\n          width: 40,\n          height: 40\n        };\n        var separatorJSON = {\n          type: 'field_vertical_separator'\n        };\n        blockJSON.args0 = [iconJSON, separatorJSON];\n      }\n      switch (blockInfo.blockType) {\n        case BlockType.COMMAND:\n          blockJSON.outputShape = ScratchBlocksConstants.OUTPUT_SHAPE_SQUARE;\n          blockJSON.previousStatement = null; \n          if (!blockInfo.isTerminal) {\n            blockJSON.nextStatement = null; \n          }\n          break;\n        case BlockType.REPORTER:\n          blockJSON.output = 'String'; \n          blockJSON.outputShape = ScratchBlocksConstants.OUTPUT_SHAPE_ROUND;\n          break;\n        case BlockType.BOOLEAN:\n          blockJSON.output = 'Boolean';\n          blockJSON.outputShape = ScratchBlocksConstants.OUTPUT_SHAPE_HEXAGONAL;\n          break;\n        case BlockType.HAT:\n        case BlockType.EVENT:\n          if (!blockInfo.hasOwnProperty('isEdgeActivated')) {\n            \n            blockInfo.isEdgeActivated = true;\n          }\n          blockJSON.outputShape = ScratchBlocksConstants.OUTPUT_SHAPE_SQUARE;\n          blockJSON.nextStatement = null; \n          break;\n        case BlockType.CONDITIONAL:\n        case BlockType.LOOP:\n          blockInfo.branchCount = blockInfo.branchCount || 1;\n          blockJSON.outputShape = ScratchBlocksConstants.OUTPUT_SHAPE_SQUARE;\n          blockJSON.previousStatement = null; \n          if (!blockInfo.isTerminal) {\n            blockJSON.nextStatement = null; \n          }\n          break;\n      }\n      var blockText = Array.isArray(blockInfo.text) ? blockInfo.text : [blockInfo.text];\n      var inTextNum = 0; \n      var inBranchNum = 0; \n      var outLineNum = 0; \n      var convertPlaceholders = this._convertPlaceholders.bind(this, context);\n      var extensionMessageContext = this.makeMessageContextForTarget(); \n      while (inTextNum < blockText.length || inBranchNum < blockInfo.branchCount) {\n        if (inTextNum < blockText.length) {\n          context.outLineNum = outLineNum;\n          var lineText = maybeFormatMessage(blockText[inTextNum], extensionMessageContext);\n          var convertedText = lineText.replace(/\\[(.+?)]/g, convertPlaceholders);\n          if (blockJSON[\"message\".concat(outLineNum)]) {\n            blockJSON[\"message\".concat(outLineNum)] += convertedText;\n          } else {\n            blockJSON[\"message\".concat(outLineNum)] = convertedText;\n          }\n          ++inTextNum;\n          ++outLineNum;\n        }\n        if (inBranchNum < blockInfo.branchCount) {\n          blockJSON[\"message\".concat(outLineNum)] = '%1';\n          blockJSON[\"args\".concat(outLineNum)] = [{\n            type: 'input_statement',\n            name: \"SUBSTACK\".concat(inBranchNum > 0 ? inBranchNum + 1 : '')\n          }];\n          ++inBranchNum;\n          ++outLineNum;\n        }\n      }\n      if (blockInfo.blockType === BlockType.REPORTER) {\n        if (!blockInfo.disableMonitor && context.inputList.length === 0) {\n          blockJSON.checkboxInFlyout = true;\n        }\n        if (blockInfo.forcedEnableMonitor) {                 //forcedEnableMonitor强制打开CheckBox\n          blockJSON.checkboxInFlyout = true;\n        }\n      } else if (blockInfo.blockType === BlockType.LOOP) {\n        \n        blockJSON[\"lastDummyAlign\".concat(outLineNum)] = 'RIGHT';\n        blockJSON[\"message\".concat(outLineNum)] = '%1';\n        blockJSON[\"args\".concat(outLineNum)] = [{\n          type: 'field_image',\n          src: './static/blocks-media/repeat.svg',\n          \n          width: 24,\n          height: 24,\n          alt: '*',\n          \n          flip_rtl: true\n        }];\n        ++outLineNum;\n      }\n      var mutation = blockInfo.isDynamic ? \"<mutation blockInfo=\\\"\".concat(xmlEscape(JSON.stringify(blockInfo)), \"\\\"/>\") : '';\n      var inputs = context.inputList.join('');\n      var blockXML = \"<block type=\\\"\".concat(extendedOpcode, \"\\\">\").concat(mutation).concat(inputs, \"</block>\");\n      return {\n        info: context.blockInfo,\n        json: context.blockJSON,\n        xml: blockXML\n      };\n    }\n   \n  }, {\n    key: \"_convertSeparatorForScratchBlocks\",\n    value: function _convertSeparatorForScratchBlocks(blockInfo) {\n      return {\n        info: blockInfo,\n        xml: '<sep gap=\"36\"/>'\n      };\n    }\n   \n  }, {\n    key: \"_convertButtonForScratchBlocks\",\n    value: function _convertButtonForScratchBlocks(buttonInfo) {\n      \n      var supportedCallbackKeys = ['MAKE_A_LIST', 'MAKE_A_PROCEDURE', 'MAKE_A_VARIABLE'];\n      if (supportedCallbackKeys.indexOf(buttonInfo.func) < 0) {\n        log.error(\"Custom button callbacks not supported yet: \".concat(buttonInfo.func));\n      }\n      var extensionMessageContext = this.makeMessageContextForTarget();\n      var buttonText = maybeFormatMessage(buttonInfo.text, extensionMessageContext);\n      return {\n        info: buttonInfo,\n        xml: \"<button text=\\\"\".concat(buttonText, \"\\\" callbackKey=\\\"\").concat(buttonInfo.func, \"\\\"></button>\")\n      };\n    }\n   \n  }, {\n    key: \"_constructInlineImageJson\",\n    value: function _constructInlineImageJson(argInfo) {\n      if (!argInfo.dataURI) {\n        log.warn('Missing data URI in extension block with argument type IMAGE');\n      }\n      return {\n        type: 'field_image',\n        src: argInfo.dataURI || '',\n        \n        width: 24,\n        height: 24,\n        \n        \n        \n        flip_rtl: argInfo.flipRTL || false\n      };\n    }\n   \n  }, {\n    key: \"_convertPlaceholders\",\n    value: function _convertPlaceholders(context, match, placeholder) {\n      \n      placeholder = placeholder.replace(/[<\"&]/, '_'); \n      var argInfo = context.blockInfo.arguments[placeholder] || {};\n      var argTypeInfo = ArgumentTypeMap[argInfo.type] || {}; \n      if (!ArgumentTypeMap[argInfo.type] && context.categoryInfo.customFieldTypes[argInfo.type]) {\n        argTypeInfo = context.categoryInfo.customFieldTypes[argInfo.type].argumentTypeInfo;\n      } \n      \n      var argJSON; \n      \n      if (argTypeInfo.fieldType === 'field_image') {\n        argJSON = this._constructInlineImageJson(argInfo);\n      } else {\n        \n        \n        argJSON = {\n          type: 'input_value',\n          name: placeholder\n        };\n        var defaultValue = typeof argInfo.defaultValue === 'undefined' ? '' : xmlEscape(maybeFormatMessage(argInfo.defaultValue, this.makeMessageContextForTarget()).toString());\n        if (argTypeInfo.check) {\n          \n          \n          \n          argJSON.check = argTypeInfo.check;\n        }\n        var valueName;\n        var shadowType;\n        var fieldName;\n        if (argInfo.menu) {\n          var menuInfo = context.categoryInfo.menuInfo[argInfo.menu];\n          if (menuInfo.acceptReporters) {\n            valueName = placeholder;\n            shadowType = this._makeExtensionMenuId(argInfo.menu, context.categoryInfo.id);\n            fieldName = argInfo.menu;\n          } else {\n            argJSON.type = 'field_dropdown';\n            argJSON.options = this._convertMenuItems(menuInfo.items);\n            valueName = null;\n            shadowType = null;\n            fieldName = placeholder;\n          }\n        } else {\n          valueName = placeholder;\n          shadowType = argTypeInfo.shadow && argTypeInfo.shadow.type || null;\n          fieldName = argTypeInfo.shadow && argTypeInfo.shadow.fieldName || null;\n        } \n        if (valueName) {\n          context.inputList.push(\"<value name=\\\"\".concat(placeholder, \"\\\">\"));\n        } \n        \n        if (shadowType) {\n          context.inputList.push(\"<shadow type=\\\"\".concat(shadowType, \"\\\">\"));\n        } \n        \n        if (defaultValue && fieldName) {\n          context.inputList.push(\"<field name=\\\"\".concat(fieldName, \"\\\">\").concat(defaultValue, \"</field>\"));\n        }\n        if (shadowType) {\n          context.inputList.push('</shadow>');\n        }\n        if (valueName) {\n          context.inputList.push('</value>');\n        }\n      }\n      var argsName = \"args\".concat(context.outLineNum);\n      var blockArgs = context.blockJSON[argsName] = context.blockJSON[argsName] || [];\n      if (argJSON) blockArgs.push(argJSON);\n      var argNum = blockArgs.length;\n      context.argsMap[placeholder] = argNum;\n      return \"%\".concat(argNum);\n    }\n   \n  }, {\n    key: \"getBlocksXML\",\n    value: function getBlocksXML(target) {\n      return this._blockInfo.map(function (categoryInfo) {\n        var name = categoryInfo.name,\n            color1 = categoryInfo.color1,\n            color2 = categoryInfo.color2; \n        \n        var paletteBlocks = categoryInfo.blocks.filter(function (block) {\n          var blockFilterIncludesTarget = true; \n          \n          if (target && block.info.filter) {\n            blockFilterIncludesTarget = block.info.filter.includes(target.isStage ? TargetType.STAGE : TargetType.SPRITE);\n          } \n          return blockFilterIncludesTarget && !block.info.hideFromPalette;\n        });\n        var colorXML = \"colour=\\\"\".concat(color1, \"\\\" secondaryColour=\\\"\").concat(color2, \"\\\"\"); \n        \n        var menuIconURI = '';\n        if (categoryInfo.menuIconURI) {\n          menuIconURI = categoryInfo.menuIconURI;\n        } else if (categoryInfo.blockIconURI) {\n          menuIconURI = categoryInfo.blockIconURI;\n        }\n        var menuIconXML = menuIconURI ? \"iconURI=\\\"\".concat(menuIconURI, \"\\\"\") : '';\n        var statusButtonXML = '';\n        if (categoryInfo.showStatusButton) {\n          statusButtonXML = 'showStatusButton=\"true\"';\n        }\n        return {\n          id: categoryInfo.id,\n          xml: \"<category name=\\\"\".concat(name, \"\\\" id=\\\"\").concat(categoryInfo.id, \"\\\" \").concat(statusButtonXML, \" \").concat(colorXML, \" \").concat(menuIconXML, \">\").concat(paletteBlocks.map(function (block) {\n            return block.xml;\n          }).join(''), \"</category>\")\n        };\n      });\n    }\n   \n  }, {\n    key: \"getBlocksJSON\",\n    value: function getBlocksJSON() {\n      return this._blockInfo.reduce(function (result, categoryInfo) {\n        return result.concat(categoryInfo.blocks.map(function (blockInfo) {\n          return blockInfo.json;\n        }));\n      }, []);\n    }\n   \n  }, {\n    key: \"getScratchLinkSocket\",\n    value: function getScratchLinkSocket(type) {\n      var factory = this._linkSocketFactory || this._defaultScratchLinkSocketFactory;\n      return factory(type);\n    }\n   \n  }, {\n    key: \"configureScratchLinkSocketFactory\",\n    value: function configureScratchLinkSocketFactory(factory) {\n      this._linkSocketFactory = factory;\n    }\n   \n  }, {\n    key: \"_defaultScratchLinkSocketFactory\",\n    value: function _defaultScratchLinkSocketFactory(type) {\n      return new ScratchLinkWebSocket(type);\n    }\n   \n  }, {\n    key: \"registerPeripheralExtension\",\n    value: function registerPeripheralExtension(extensionId, extension) {\n      this.peripheralExtensions[extensionId] = extension;\n    }\n   \n  }, {\n    key: \"scanForPeripheral\",\n    value: function scanForPeripheral(extensionId) {\n      if (this.peripheralExtensions[extensionId]) {\n        this.peripheralExtensions[extensionId].scan();\n      }\n    }\n   \n  }, {\n    key: \"connectPeripheral\",\n    value: function connectPeripheral(extensionId, peripheralId) {\n      if (this.peripheralExtensions[extensionId]) {\n        this.peripheralExtensions[extensionId].connect(peripheralId);\n      }\n    }\n   \n  }, {\n    key: \"disconnectPeripheral\",\n    value: function disconnectPeripheral(extensionId) {\n      if (this.peripheralExtensions[extensionId]) {\n        this.peripheralExtensions[extensionId].disconnect();\n      }\n    }\n   \n  }, {\n    key: \"getPeripheralIsConnected\",\n    value: function getPeripheralIsConnected(extensionId) {\n      var isConnected = false;\n      if (this.peripheralExtensions[extensionId]) {\n        isConnected = this.peripheralExtensions[extensionId].isConnected();\n      }\n      return isConnected;\n    }\n   \n  }, {\n    key: \"emitMicListening\",\n    value: function emitMicListening(listening) {\n      this.emit(Runtime.MIC_LISTENING, listening);\n    }\n   \n  }, {\n    key: \"getOpcodeFunction\",\n    value: function getOpcodeFunction(opcode) {\n      return this._primitives[opcode];\n    }\n   \n  }, {\n    key: \"getIsHat\",\n    value: function getIsHat(opcode) {\n      return this._hats.hasOwnProperty(opcode);\n    }\n   \n  }, {\n    key: \"getIsEdgeActivatedHat\",\n    value: function getIsEdgeActivatedHat(opcode) {\n      return this._hats.hasOwnProperty(opcode) && this._hats[opcode].edgeActivated;\n    }\n   \n  }, {\n    key: \"attachAudioEngine\",\n    value: function attachAudioEngine(audioEngine) {\n      this.audioEngine = audioEngine;\n    }\n   \n  }, {\n    key: \"attachRenderer\",\n    value: function attachRenderer(renderer) {\n      this.renderer = renderer;\n      this.renderer.setLayerGroupOrdering(StageLayering.LAYER_GROUPS);\n    }\n   \n  }, {\n    key: \"attachV2SVGAdapter\",\n    value: function attachV2SVGAdapter(svgAdapter) {\n      this.v2SvgAdapter = svgAdapter;\n    }\n   \n  }, {\n    key: \"attachV2BitmapAdapter\",\n    value: function attachV2BitmapAdapter(bitmapAdapter) {\n      this.v2BitmapAdapter = bitmapAdapter;\n    }\n   \n  }, {\n    key: \"attachStorage\",\n    value: function attachStorage(storage) {\n      this.storage = storage;\n    } \n    \n   \n  }, {\n    key: \"_pushThread\",\n    value: function _pushThread(id, target, opts) {\n      var thread = new Thread(id);\n      thread.target = target;\n      thread.stackClick = Boolean(opts && opts.stackClick);\n      thread.updateMonitor = Boolean(opts && opts.updateMonitor);\n      thread.blockContainer = thread.updateMonitor ? this.monitorBlocks : target.blocks;\n      thread.pushStack(id);\n      this.threads.push(thread);\n      return thread;\n    }\n   \n  }, {\n    key: \"_stopThread\",\n    value: function _stopThread(thread) {\n      \n      thread.isKilled = true; \n      this.sequencer.retireThread(thread);\n    }\n   \n  }, {\n    key: \"_restartThread\",\n    value: function _restartThread(thread) {\n      var newThread = new Thread(thread.topBlock);\n      newThread.target = thread.target;\n      newThread.stackClick = thread.stackClick;\n      newThread.updateMonitor = thread.updateMonitor;\n      newThread.blockContainer = thread.blockContainer;\n      newThread.pushStack(thread.topBlock);\n      var i = this.threads.indexOf(thread);\n      if (i > -1) {\n        this.threads[i] = newThread;\n        return newThread;\n      }\n      this.threads.push(thread);\n      return thread;\n    }\n   \n  }, {\n    key: \"isActiveThread\",\n    value: function isActiveThread(thread) {\n      return thread.stack.length > 0 && thread.status !== Thread.STATUS_DONE && this.threads.indexOf(thread) > -1;\n    }\n   \n  }, {\n    key: \"isWaitingThread\",\n    value: function isWaitingThread(thread) {\n      return thread.status === Thread.STATUS_PROMISE_WAIT || thread.status === Thread.STATUS_YIELD_TICK || !this.isActiveThread(thread);\n    }\n   \n  }, {\n    key: \"toggleScript\",\n    value: function toggleScript(topBlockId, opts) {\n      opts = Object.assign({\n        target: this._editingTarget,\n        stackClick: false\n      }, opts); \n      for (var i = 0; i < this.threads.length; i++) {\n        \n        if (this.threads[i].topBlock === topBlockId && this.threads[i].status !== Thread.STATUS_DONE) {\n          var blockContainer = opts.target.blocks;\n          var opcode = blockContainer.getOpcode(blockContainer.getBlock(topBlockId));\n          if (this.getIsEdgeActivatedHat(opcode) && this.threads[i].stackClick !== opts.stackClick) {\n            \n            \n            continue;\n          }\n          this._stopThread(this.threads[i]);\n          return;\n        }\n      } \n      this._pushThread(topBlockId, opts.target, opts);\n    }\n   \n  }, {\n    key: \"addMonitorScript\",\n    value: function addMonitorScript(topBlockId, optTarget) {\n      if (!optTarget) optTarget = this._editingTarget;\n      for (var i = 0; i < this.threads.length; i++) {\n        \n        if (this.threads[i].topBlock === topBlockId && this.threads[i].status !== Thread.STATUS_DONE && this.threads[i].updateMonitor) {\n          return;\n        }\n      } \n      this._pushThread(topBlockId, optTarget, {\n        updateMonitor: true\n      });\n    }\n   \n  }, {\n    key: \"allScriptsDo\",\n    value: function allScriptsDo(f, optTarget) {\n      var targets = this.executableTargets;\n      if (optTarget) {\n        targets = [optTarget];\n      }\n      for (var t = targets.length - 1; t >= 0; t--) {\n        var target = targets[t];\n        var scripts = target.blocks.getScripts();\n        for (var j = 0; j < scripts.length; j++) {\n          var topBlockId = scripts[j];\n          f(topBlockId, target);\n        }\n      }\n    }\n  }, {\n    key: \"allScriptsByOpcodeDo\",\n    value: function allScriptsByOpcodeDo(opcode, f, optTarget) {\n      var targets = this.executableTargets;\n      if (optTarget) {\n        targets = [optTarget];\n      }\n      for (var t = targets.length - 1; t >= 0; t--) {\n        var target = targets[t];\n        var scripts = BlocksRuntimeCache.getScripts(target.blocks, opcode);\n        for (var j = 0; j < scripts.length; j++) {\n          f(scripts[j], target);\n        }\n      }\n    }\n   \n  }, {\n    key: \"startHats\",\n    value: function startHats(requestedHatOpcode, optMatchFields, optTarget) {\n      var _this4 = this;\n      if (!this._hats.hasOwnProperty(requestedHatOpcode)) {\n        \n        return;\n      }\n      var instance = this;\n      var newThreads = []; \n      var hatMeta = instance._hats[requestedHatOpcode];\n      for (var opts in optMatchFields) {\n        if (!optMatchFields.hasOwnProperty(opts)) continue;\n        optMatchFields[opts] = optMatchFields[opts].toUpperCase();\n      } \n      this.allScriptsByOpcodeDo(requestedHatOpcode, function (script, target) {\n        var topBlockId = script.blockId,\n            hatFields = script.fieldsOfInputs; \n        \n        \n        \n        \n        for (var matchField in optMatchFields) {\n          if (hatFields[matchField].value !== optMatchFields[matchField]) {\n            \n            return;\n          }\n        }\n        if (hatMeta.restartExistingThreads) {\n          \n          \n          for (var i = 0; i < _this4.threads.length; i++) {\n            if (_this4.threads[i].target === target && _this4.threads[i].topBlock === topBlockId && \n            !_this4.threads[i].stackClick) {\n              newThreads.push(_this4._restartThread(_this4.threads[i]));\n              return;\n            }\n          }\n        } else {\n          \n          \n          for (var j = 0; j < _this4.threads.length; j++) {\n            if (_this4.threads[j].target === target && _this4.threads[j].topBlock === topBlockId && \n            !_this4.threads[j].stackClick && _this4.threads[j].status !== Thread.STATUS_DONE) {\n              \n              return;\n            }\n          }\n        } \n        newThreads.push(_this4._pushThread(topBlockId, target));\n      }, optTarget); \n      \n      newThreads.forEach(function (thread) {\n        execute(_this4.sequencer, thread);\n        thread.goToNextBlock();\n      });\n      return newThreads;\n    }\n   \n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.stopAll(); \n      this.targets.forEach(function (target) {\n        if (target.isOriginal) target.deleteMonitors();\n      });\n      this.targets.map(this.disposeTarget, this);\n      this._monitorState = OrderedMap({});\n      this.emit(Runtime.RUNTIME_DISPOSED);\n      this.ioDevices.clock.resetProjectTimer(); \n      \n      \n      \n      \n      if (this.hasCloudData()) {\n        this.emit(Runtime.HAS_CLOUD_DATA_UPDATE, false);\n      }\n      this.ioDevices.cloud.clear(); \n      var newCloudDataManager = cloudDataManager();\n      this.hasCloudData = newCloudDataManager.hasCloudVariables;\n      this.canAddCloudVariable = newCloudDataManager.canAddCloudVariable;\n      this.addCloudVariable = this._initializeAddCloudVariable(newCloudDataManager);\n      this.removeCloudVariable = this._initializeRemoveCloudVariable(newCloudDataManager);\n    }\n   \n  }, {\n    key: \"addTarget\",\n    value: function addTarget(target) {\n      this.targets.push(target);\n      this.executableTargets.push(target);\n    }\n   \n  }, {\n    key: \"moveExecutable\",\n    value: function moveExecutable(executableTarget, delta) {\n      var oldIndex = this.executableTargets.indexOf(executableTarget);\n      this.executableTargets.splice(oldIndex, 1);\n      var newIndex = oldIndex + delta;\n      if (newIndex > this.executableTargets.length) {\n        newIndex = this.executableTargets.length;\n      }\n      if (newIndex <= 0) {\n        if (this.executableTargets.length > 0 && this.executableTargets[0].isStage) {\n          newIndex = 1;\n        } else {\n          newIndex = 0;\n        }\n      }\n      this.executableTargets.splice(newIndex, 0, executableTarget);\n      return newIndex;\n    }\n   \n  }, {\n    key: \"setExecutablePosition\",\n    value: function setExecutablePosition(executableTarget, newIndex) {\n      var oldIndex = this.executableTargets.indexOf(executableTarget);\n      return this.moveExecutable(executableTarget, newIndex - oldIndex);\n    }\n   \n  }, {\n    key: \"removeExecutable\",\n    value: function removeExecutable(executableTarget) {\n      var oldIndex = this.executableTargets.indexOf(executableTarget);\n      if (oldIndex > -1) {\n        this.executableTargets.splice(oldIndex, 1);\n      }\n    }\n   \n  }, {\n    key: \"disposeTarget\",\n    value: function disposeTarget(disposingTarget) {\n      this.targets = this.targets.filter(function (target) {\n        if (disposingTarget !== target) return true; \n        target.dispose(); \n        return false;\n      });\n    }\n   \n  }, {\n    key: \"stopForTarget\",\n    value: function stopForTarget(target, optThreadException) {\n      \n      this.emit(Runtime.STOP_FOR_TARGET, target, optThreadException); \n      for (var i = 0; i < this.threads.length; i++) {\n        if (this.threads[i] === optThreadException) {\n          continue;\n        }\n        if (this.threads[i].target === target) {\n          this._stopThread(this.threads[i]);\n        }\n      }\n    }\n   \n  }, {\n    key: \"greenFlag\",\n    value: function greenFlag() {\n      bCleanClone=true;\n      this.stopAll();\n      this.emit(Runtime.PROJECT_START);\n      this.ioDevices.clock.resetProjectTimer();\n      this.targets.forEach(function (target) {\n        return target.clearEdgeActivatedValues();\n      }); \n      for (var i = 0; i < this.targets.length; i++) {\n        this.targets[i].onGreenFlag();\n      }\n      this.startHats('event_whenflagclicked');\n    }\n   \n  }, {\n    key: \"stopAll\",\n    value: function stopAll() {\n      scratchStatus(\"STOPALL\"); //Emit stop event to allow blocks to clean up any state.\n      this.emit(Runtime.PROJECT_STOP_ALL); \n      var newTargets = [];\n      for (var i = 0; i < this.targets.length; i++) {\n        this.targets[i].onStopAll();\n        if (this.targets[i].hasOwnProperty('isOriginal') && !this.targets[i].isOriginal && bCleanClone) {\n          this.targets[i].dispose();\n        } else {\n          newTargets.push(this.targets[i]);\n        }\n      }\n      bCleanClone=false;\n      this.targets = newTargets; \n      if (this.sequencer.activeThread !== null) {\n        this._stopThread(this.sequencer.activeThread);\n      } \n      this.threads = [];\n    }\n   \n  }, {\n    key: \"_step\",\n    value: function _step() {\n      if (this.profiler !== null) {\n        if (stepProfilerId === -1) {\n          stepProfilerId = this.profiler.idByName('Runtime._step');\n        }\n        this.profiler.start(stepProfilerId);\n      } \n      this.threads = this.threads.filter(function (thread) {\n        return !thread.isKilled;\n      }); \n      for (var hatType in this._hats) {\n        if (!this._hats.hasOwnProperty(hatType)) continue;\n        var hat = this._hats[hatType];\n        if (hat.edgeActivated) {\n          this.startHats(hatType);\n        }\n      }\n      this.redrawRequested = false;\n      this._pushMonitors();\n      if (this.profiler !== null) {\n        if (stepThreadsProfilerId === -1) {\n          stepThreadsProfilerId = this.profiler.idByName('Sequencer.stepThreads');\n        }\n        this.profiler.start(stepThreadsProfilerId);\n      }\n      var doneThreads = this.sequencer.stepThreads();\n      if (this.profiler !== null) {\n        this.profiler.stop();\n      }\n      this._updateGlows(doneThreads); \n      \n      this._emitProjectRunStatus(this.threads.length + doneThreads.length - this._getMonitorThreadCount([].concat(_toConsumableArray(this.threads), _toConsumableArray(doneThreads)))); \n      \n      this._lastStepDoneThreads = doneThreads;\n      if (this.renderer) {\n        \n        if (this.profiler !== null) {\n          if (rendererDrawProfilerId === -1) {\n            rendererDrawProfilerId = this.profiler.idByName('RenderWebGL.draw');\n          }\n          this.profiler.start(rendererDrawProfilerId);\n        }\n        this.renderer.draw();\n        if (this.profiler !== null) {\n          this.profiler.stop();\n        }\n      }\n      if (this._refreshTargets) {\n        this.emit(Runtime.TARGETS_UPDATE, false\n       \n        );\n        this._refreshTargets = false;\n      }\n      if (!this._prevMonitorState.equals(this._monitorState)) {\n        this.emit(Runtime.MONITORS_UPDATE, this._monitorState);\n        this._prevMonitorState = this._monitorState;\n      }\n      if (this.profiler !== null) {\n        this.profiler.stop();\n        this.profiler.reportFrames();\n      }\n    }\n   \n  }, {\n    key: \"_getMonitorThreadCount\",\n    value: function _getMonitorThreadCount(threads) {\n      var count = 0;\n      threads.forEach(function (thread) {\n        if (thread.updateMonitor) count++;\n      });\n      return count;\n    }\n   \n  }, {\n    key: \"_pushMonitors\",\n    value: function _pushMonitors() {\n      this.monitorBlocks.runAllMonitored(this);\n    }\n   \n  }, {\n    key: \"setEditingTarget\",\n    value: function setEditingTarget(editingTarget) {\n      var oldEditingTarget = this._editingTarget;\n      this._editingTarget = editingTarget; \n      this._scriptGlowsPreviousFrame = [];\n      this._updateGlows();\n      if (oldEditingTarget !== this._editingTarget) {\n        this.requestToolboxExtensionsUpdate();\n        scratchStatus(\"TARGETS_CHANGED\");\n      }\n    }\n   \n  }, {\n    key: \"setCompatibilityMode\",\n    value: function setCompatibilityMode(compatibilityModeOn) {\n      this.compatibilityMode = compatibilityModeOn;\n      if (this._steppingInterval) {\n        clearInterval(this._steppingInterval);\n        this._steppingInterval = null;\n        this.start();\n      }\n    }\n   \n  }, {\n    key: \"_updateGlows\",\n    value: function _updateGlows(optExtraThreads) {\n      var searchThreads = [];\n      searchThreads.push.apply(searchThreads, this.threads);\n      if (optExtraThreads) {\n        searchThreads.push.apply(searchThreads, optExtraThreads);\n      } \n      var requestedGlowsThisFrame = []; \n      var finalScriptGlows = []; \n      for (var i = 0; i < searchThreads.length; i++) {\n        var thread = searchThreads[i];\n        var target = thread.target;\n        if (target === this._editingTarget) {\n          var blockForThread = thread.blockGlowInFrame;\n          if (thread.requestScriptGlowInFrame || thread.stackClick) {\n            var script = target.blocks.getTopLevelScript(blockForThread);\n            if (!script) {\n              \n              script = this.flyoutBlocks.getTopLevelScript(blockForThread);\n            }\n            if (script) {\n              requestedGlowsThisFrame.push(script);\n            }\n          }\n        }\n      } \n      for (var j = 0; j < this._scriptGlowsPreviousFrame.length; j++) {\n        var previousFrameGlow = this._scriptGlowsPreviousFrame[j];\n        if (requestedGlowsThisFrame.indexOf(previousFrameGlow) < 0) {\n          \n          this.glowScript(previousFrameGlow, false);\n        } else {\n          \n          finalScriptGlows.push(previousFrameGlow);\n        }\n      }\n      for (var k = 0; k < requestedGlowsThisFrame.length; k++) {\n        var currentFrameGlow = requestedGlowsThisFrame[k];\n        if (this._scriptGlowsPreviousFrame.indexOf(currentFrameGlow) < 0) {\n          \n          this.glowScript(currentFrameGlow, true);\n          finalScriptGlows.push(currentFrameGlow);\n        }\n      }\n      this._scriptGlowsPreviousFrame = finalScriptGlows;\n    }\n   \n  }, {\n    key: \"_emitProjectRunStatus\",\n    value: function _emitProjectRunStatus(nonMonitorThreadCount) {\n      if (this._nonMonitorThreadCount === 0 && nonMonitorThreadCount > 0) {\n        this.emit(Runtime.PROJECT_RUN_START);\n      }\n      if (this._nonMonitorThreadCount > 0 && nonMonitorThreadCount === 0) {\n        this.emit(Runtime.PROJECT_RUN_STOP);\n      }\n      this._nonMonitorThreadCount = nonMonitorThreadCount;\n    }\n   \n  }, {\n    key: \"quietGlow\",\n    value: function quietGlow(scriptBlockId) {\n      var index = this._scriptGlowsPreviousFrame.indexOf(scriptBlockId);\n      if (index > -1) {\n        this._scriptGlowsPreviousFrame.splice(index, 1);\n      }\n    }\n   \n  }, {\n    key: \"glowBlock\",\n    value: function glowBlock(blockId, isGlowing) {\n      if (isGlowing) {\n        this.emit(Runtime.BLOCK_GLOW_ON, {\n          id: blockId\n        });\n      } else {\n        this.emit(Runtime.BLOCK_GLOW_OFF, {\n          id: blockId\n        });\n      }\n    }\n   \n  }, {\n    key: \"glowScript\",\n    value: function glowScript(topBlockId, isGlowing) {\n      if (isGlowing) {\n        this.emit(Runtime.SCRIPT_GLOW_ON, {\n          id: topBlockId\n        });\n      } else {\n        this.emit(Runtime.SCRIPT_GLOW_OFF, {\n          id: topBlockId\n        });\n      }\n    }\n   \n  }, {\n    key: \"emitBlockDragUpdate\",\n    value: function emitBlockDragUpdate(areBlocksOverGui) {\n      this.emit(Runtime.BLOCK_DRAG_UPDATE, areBlocksOverGui);\n      scratchStatus(\"BACKUPNEEDED\");\n    }\n   \n  }, {\n    key: \"emitBlockEndDrag\",\n    value: function emitBlockEndDrag(blocks, topBlockId) {\n      this.emit(Runtime.BLOCK_DRAG_END, blocks, topBlockId);\n    }\n   \n  }, {\n    key: \"visualReport\",\n    value: function visualReport(blockId, value) {\n      this.emit(Runtime.VISUAL_REPORT, {\n        id: blockId,\n        value: String(value)\n      });\n    }\n   \n  }, {\n    key: \"requestAddMonitor\",\n    value: function requestAddMonitor(monitor) {\n      var id = monitor.get('id');\n      if (!this.requestUpdateMonitor(monitor)) {\n        \n        \n        this._monitorState = this._monitorState.set(id, monitor);\n      }\n    }\n   \n  }, {\n    key: \"requestUpdateMonitor\",\n    value: function requestUpdateMonitor(monitor) {\n      var id = monitor.get('id');\n      if (this._monitorState.has(id)) {\n        this._monitorState = \n        this._monitorState.set(id, this._monitorState.get(id).mergeWith(function (prev, next) {\n          if (typeof next === 'undefined' || next === null) {\n            return prev;\n          }\n          return next;\n        }, monitor));\n        return true;\n      }\n      return false;\n    }\n   \n  }, {\n    key: \"requestRemoveMonitor\",\n    value: function requestRemoveMonitor(monitorId) {\n      this._monitorState = this._monitorState.delete(monitorId);\n    }\n   \n  }, {\n    key: \"requestHideMonitor\",\n    value: function requestHideMonitor(monitorId) {\n      return this.requestUpdateMonitor(new Map([['id', monitorId], ['visible', false]]));\n    }\n   \n  }, {\n    key: \"requestShowMonitor\",\n    value: function requestShowMonitor(monitorId) {\n      return this.requestUpdateMonitor(new Map([['id', monitorId], ['visible', true]]));\n    }\n   \n  }, {\n    key: \"requestRemoveMonitorByTargetId\",\n    value: function requestRemoveMonitorByTargetId(targetId) {\n      this._monitorState = this._monitorState.filterNot(function (value) {\n        return value.targetId === targetId;\n      });\n    }\n   \n  }, {\n    key: \"getTargetById\",\n    value: function getTargetById(targetId) {\n      for (var i = 0; i < this.targets.length; i++) {\n        var target = this.targets[i];\n        if (target.id === targetId) {\n          return target;\n        }\n      }\n    }\n   \n  }, {\n    key: \"getSpriteTargetByName\",\n    value: function getSpriteTargetByName(spriteName) {\n      for (var i = 0; i < this.targets.length; i++) {\n        var target = this.targets[i];\n        if (target.isStage) {\n          continue;\n        }\n        if (target.sprite && target.sprite.name === spriteName) {\n          return target;\n        }\n      }\n    }\n   \n  }, {\n    key: \"getTargetByDrawableId\",\n    value: function getTargetByDrawableId(drawableID) {\n      for (var i = 0; i < this.targets.length; i++) {\n        var target = this.targets[i];\n        if (target.drawableID === drawableID) return target;\n      }\n    }\n   \n  }, {\n    key: \"changeCloneCounter\",\n    value: function changeCloneCounter(changeAmount) {\n      //console.info(\"changeCloneCounter: %d\",this._cloneCounter);\n      this._cloneCounter += changeAmount;\n    }\n   \n  }, {\n    key: \"clonesAvailable\",\n    value: function clonesAvailable() {\n      //console.info(\"clonesAvailable: %d\",this._cloneCounter);\n      return this._cloneCounter < Runtime.MAX_CLONES;\n    }\n   \n  }, {\n    key: \"emitProjectLoaded\",\n    value: function emitProjectLoaded() {\n    this.emit(Runtime.PROJECT_LOADED);\n    scratchStatus(\"LOADED\");\n  }\n   \n  }, {\n    key: \"emitProjectChanged\",\n    value: function emitProjectChanged() {\n      this.emit(Runtime.PROJECT_CHANGED);\n    }\n   \n  }, {\n    key: \"fireTargetWasCreated\",\n    value: function fireTargetWasCreated(newTarget, sourceTarget) {\n      this.emit('targetWasCreated', newTarget, sourceTarget);\n    }\n   \n  }, {\n    key: \"fireTargetWasRemoved\",\n    value: function fireTargetWasRemoved(target) {\n      this.emit('targetWasRemoved', target);\n    }\n   \n  }, {\n    key: \"getTargetForStage\",\n    value: function getTargetForStage() {\n      for (var i = 0; i < this.targets.length; i++) {\n        var target = this.targets[i];\n        if (target.isStage) {\n          return target;\n        }\n      }\n    }\n   \n  }, {\n    key: \"getEditingTarget\",\n    value: function getEditingTarget() {\n      return this._editingTarget;\n    }\n  }, {\n    key: \"getAllVarNamesOfType\",\n    value: function getAllVarNamesOfType(varType) {\n      var varNames = [];\n      var _iterator2 = _createForOfIteratorHelper(this.targets),\n          _step3;\n      try {\n        for (_iterator2.s(); !(_step3 = _iterator2.n()).done;) {\n          var target = _step3.value;\n          var targetVarNames = target.getAllVariableNamesInScopeByType(varType, true);\n          varNames = varNames.concat(targetVarNames);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return varNames;\n    }\n   \n  }, {\n    key: \"getLabelForOpcode\",\n    value: function getLabelForOpcode(extendedOpcode) {\n      var _StringUtil$splitFirs = StringUtil.splitFirst(extendedOpcode, '_'),\n          _StringUtil$splitFirs2 = _slicedToArray(_StringUtil$splitFirs, 2),\n          category = _StringUtil$splitFirs2[0],\n          opcode = _StringUtil$splitFirs2[1];\n      if (!(category && opcode)) return;\n      var categoryInfo = this._blockInfo.find(function (ci) {\n        return ci.id === category;\n      });\n      if (!categoryInfo) return;\n      var block = categoryInfo.blocks.find(function (b) {\n        return b.info.opcode === opcode;\n      });\n      if (!block) return; \n      return {\n        category: 'extension',\n        \n        label: \"\".concat(categoryInfo.name, \": \").concat(block.info.text)\n      };\n    }\n   \n  }, {\n    key: \"createNewGlobalVariable\",\n    value: function createNewGlobalVariable(variableName, optVarId, optVarType) {\n      var varType = typeof optVarType === 'string' ? optVarType : Variable.SCALAR_TYPE;\n      var allVariableNames = this.getAllVarNamesOfType(varType);\n      var newName = StringUtil.unusedName(variableName, allVariableNames);\n      var variable = new Variable(optVarId || uid(), newName, varType);\n      var stage = this.getTargetForStage();\n      stage.variables[variable.id] = variable;\n      return variable;\n    }\n   \n  }, {\n    key: \"requestRedraw\",\n    value: function requestRedraw() {\n      this.redrawRequested = true;\n    }\n   \n  }, {\n    key: \"requestTargetsUpdate\",\n    value: function requestTargetsUpdate(target) {\n      if (!target.isOriginal) return;\n      this._refreshTargets = true;\n    }\n   \n  }, {\n    key: \"requestBlocksUpdate\",\n    value: function requestBlocksUpdate() {\n      this.emit(Runtime.BLOCKS_NEED_UPDATE);\n    }\n   \n  }, {\n    key: \"requestToolboxExtensionsUpdate\",\n    value: function requestToolboxExtensionsUpdate() {\n      this.emit(Runtime.TOOLBOX_EXTENSIONS_NEED_UPDATE);\n    }\n   \n  }, {\n    key: \"start\",\n    value: function start() {\n      var _this5 = this;\n      \n      if (this._steppingInterval) return;\n      var interval = Runtime.THREAD_STEP_INTERVAL;\n      if (this.compatibilityMode) {\n        interval = Runtime.THREAD_STEP_INTERVAL_COMPATIBILITY;\n      }\n      this.currentStepTime = interval;\n      this._steppingInterval = setInterval(function () {\n        _this5._step();\n      }, interval);\n      this.emit(Runtime.RUNTIME_STARTED);\n    }\n   \n  }, {\n    key: \"enableProfiling\",\n    value: function enableProfiling(onFrame) {\n      if (Profiler.available()) {\n        this.profiler = new Profiler(onFrame);\n      }\n    }\n   \n  }, {\n    key: \"disableProfiling\",\n    value: function disableProfiling() {\n      this.profiler = null;\n    }\n   \n  }, {\n    key: \"updateCurrentMSecs\",\n    value: function updateCurrentMSecs() {\n      this.currentMSecs = Date.now();\n    }\n  }], [{\n    key: \"STAGE_WIDTH\",\n    get: function get() {\n      return 480;\n    }\n   \n  }, {\n    key: \"STAGE_HEIGHT\",\n    get: function get() {\n      return 360;\n    }\n   \n  }, {\n    key: \"SCRIPT_GLOW_ON\",\n    get: function get() {\n      return 'SCRIPT_GLOW_ON';\n    }\n   \n  }, {\n    key: \"SCRIPT_GLOW_OFF\",\n    get: function get() {\n      return 'SCRIPT_GLOW_OFF';\n    }\n   \n  }, {\n    key: \"BLOCK_GLOW_ON\",\n    get: function get() {\n      return 'BLOCK_GLOW_ON';\n    }\n   \n  }, {\n    key: \"BLOCK_GLOW_OFF\",\n    get: function get() {\n      return 'BLOCK_GLOW_OFF';\n    }\n   \n  }, {\n    key: \"HAS_CLOUD_DATA_UPDATE\",\n    get: function get() {\n      return 'HAS_CLOUD_DATA_UPDATE';\n    }\n   \n  }, {\n    key: \"TURBO_MODE_ON\",\n    get: function get() {\n      return 'TURBO_MODE_ON';\n    }\n   \n  }, {\n    key: \"TURBO_MODE_OFF\",\n    get: function get() {\n      return 'TURBO_MODE_OFF';\n    }\n   \n  }, {\n    key: \"PROJECT_START\",\n    get: function get() {\n      return 'PROJECT_START';\n    }\n   \n  }, {\n    key: \"PROJECT_RUN_START\",\n    get: function get() {\n      return 'PROJECT_RUN_START';\n    }\n   \n  }, {\n    key: \"PROJECT_RUN_STOP\",\n    get: function get() {\n      return 'PROJECT_RUN_STOP';\n    }\n   \n  }, {\n    key: \"PROJECT_STOP_ALL\",\n    get: function get() {\n      return 'PROJECT_STOP_ALL';\n    }\n   \n  }, {\n    key: \"STOP_FOR_TARGET\",\n    get: function get() {\n      return 'STOP_FOR_TARGET';\n    }\n   \n  }, {\n    key: \"VISUAL_REPORT\",\n    get: function get() {\n      return 'VISUAL_REPORT';\n    }\n   \n  }, {\n    key: \"PROJECT_LOADED\",\n    get: function get() {\n      return 'PROJECT_LOADED';\n    }\n   \n  }, {\n    key: \"PROJECT_CHANGED\",\n    get: function get() {\n      return 'PROJECT_CHANGED';\n    }\n   \n  }, {\n    key: \"TOOLBOX_EXTENSIONS_NEED_UPDATE\",\n    get: function get() {\n      return 'TOOLBOX_EXTENSIONS_NEED_UPDATE';\n    }\n   \n  }, {\n    key: \"TARGETS_UPDATE\",\n    get: function get() {\n      return 'TARGETS_UPDATE';\n    }\n   \n  }, {\n    key: \"MONITORS_UPDATE\",\n    get: function get() {\n      return 'MONITORS_UPDATE';\n    }\n   \n  }, {\n    key: \"BLOCK_DRAG_UPDATE\",\n    get: function get() {\n      return 'BLOCK_DRAG_UPDATE';\n    }\n   \n  }, {\n    key: \"BLOCK_DRAG_END\",\n    get: function get() {\n      return 'BLOCK_DRAG_END';\n    }\n   \n  }, {\n    key: \"EXTENSION_ADDED\",\n    get: function get() {\n      return 'EXTENSION_ADDED';\n    }\n   \n  }, {\n    key: \"EXTENSION_FIELD_ADDED\",\n    get: function get() {\n      return 'EXTENSION_FIELD_ADDED';\n    }\n   \n  }, {\n    key: \"PERIPHERAL_LIST_UPDATE\",\n    get: function get() {\n      return 'PERIPHERAL_LIST_UPDATE';\n    }\n   \n  }, {\n    key: \"USER_PICKED_PERIPHERAL\",\n    get: function get() {\n      return 'USER_PICKED_PERIPHERAL';\n    }\n   \n  }, {\n    key: \"PERIPHERAL_CONNECTED\",\n    get: function get() {\n      return 'PERIPHERAL_CONNECTED';\n    }\n   \n  }, {\n    key: \"PERIPHERAL_DISCONNECTED\",\n    get: function get() {\n      return 'PERIPHERAL_DISCONNECTED';\n    }\n   \n  }, {\n    key: \"PERIPHERAL_REQUEST_ERROR\",\n    get: function get() {\n      return 'PERIPHERAL_REQUEST_ERROR';\n    }\n   \n  }, {\n    key: \"PERIPHERAL_CONNECTION_LOST_ERROR\",\n    get: function get() {\n      return 'PERIPHERAL_CONNECTION_LOST_ERROR';\n    }\n   \n  }, {\n    key: \"PERIPHERAL_SCAN_TIMEOUT\",\n    get: function get() {\n      return 'PERIPHERAL_SCAN_TIMEOUT';\n    }\n   \n  }, {\n    key: \"MIC_LISTENING\",\n    get: function get() {\n      return 'MIC_LISTENING';\n    }\n   \n  }, {\n    key: \"BLOCKSINFO_UPDATE\",\n    get: function get() {\n      return 'BLOCKSINFO_UPDATE';\n    }\n   \n  }, {\n    key: \"RUNTIME_STARTED\",\n    get: function get() {\n      return 'RUNTIME_STARTED';\n    }\n   \n  }, {\n    key: \"RUNTIME_DISPOSED\",\n    get: function get() {\n      return 'RUNTIME_DISPOSED';\n    }\n   \n  }, {\n    key: \"BLOCKS_NEED_UPDATE\",\n    get: function get() {\n      return 'BLOCKS_NEED_UPDATE';\n    }\n   \n  }, {\n    key: \"THREAD_STEP_INTERVAL\",\n    get: function get() {\n      return 1000 / 60;\n    }\n   \n  }, {\n    key: \"THREAD_STEP_INTERVAL_COMPATIBILITY\",\n    get: function get() {\n      return 1000 / 30;\n    }\n   \n  }, {\n    key: \"MAX_CLONES\",\n    get: function get() {\n      return 300;\n    }\n  }]);\n  return Runtime;\n}(EventEmitter);\n/**\n * Event fired after a new target has been created, possibly by cloning an existing target.\n *\n * @event Runtime#targetWasCreated\n * @param {Target} newTarget - the newly created target.\n * @param {Target} [sourceTarget] - the target used as a source for the new clone, if any.\n */\nmodule.exports = Runtime;\n })