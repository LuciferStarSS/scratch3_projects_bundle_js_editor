/* 959 */\n (function(module, exports, __webpack_require__) {\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nvar EventEmitter = __webpack_require__(91);\nvar Blocks = __webpack_require__(135);\nvar Variable = __webpack_require__(114);\nvar Comment = __webpack_require__(297);\nvar uid = __webpack_require__(94);\nvar _require = __webpack_require__(181),\n    Map = _require.Map;\nvar log = __webpack_require__(39);\nvar StringUtil = __webpack_require__(102);\nvar VariableUtil = __webpack_require__(442);\n/**\n * @fileoverview\n * A Target is an abstract \"code-running\" object for the Scratch VM.\n * Examples include sprites/clones or potentially physical-world devices.\n */\nvar Target = function (_EventEmitter) {\n  _inherits(Target, _EventEmitter);\n  var _super = _createSuper(Target);\n \n  function Target(runtime, blocks) {\n    var _this;\n    _classCallCheck(this, Target);\n    _this = _super.call(this);\n    if (!blocks) {\n      blocks = new Blocks(runtime);\n    }\n   \n    _this.runtime = runtime;\n   \n    _this.id = uid();\n   \n    _this.blocks = blocks;\n   \n    _this.variables = {};\n   \n    _this.comments = {};\n   \n    _this._customState = {};\n   \n    _this._edgeActivatedHatValues = {};\n    return _this;\n  }\n \n  _createClass(Target, [{\n    key: \"onGreenFlag\",\n    value: function onGreenFlag() {}\n   \n  }, {\n    key: \"getName\",\n    value: function getName() {\n      return this.id;\n    }\n   \n  }, {\n    key: \"updateEdgeActivatedValue\",\n    value: function updateEdgeActivatedValue(blockId, newValue) {\n      var oldValue = this._edgeActivatedHatValues[blockId];\n      this._edgeActivatedHatValues[blockId] = newValue;\n      return oldValue;\n    }\n  }, {\n    key: \"hasEdgeActivatedValue\",\n    value: function hasEdgeActivatedValue(blockId) {\n      return this._edgeActivatedHatValues.hasOwnProperty(blockId);\n    }\n   \n  }, {\n    key: \"clearEdgeActivatedValues\",\n    value: function clearEdgeActivatedValues() {\n      this._edgeActivatedHatValues = {};\n    }\n   \n  }, {\n    key: \"lookupOrCreateVariable\",\n    value: function lookupOrCreateVariable(id, name) {\n      var variable = this.lookupVariableById(id);\n      if (variable) return variable;\n      variable = this.lookupVariableByNameAndType(name, Variable.SCALAR_TYPE);\n      if (variable) return variable; \n      var newVariable = new Variable(id, name, Variable.SCALAR_TYPE, false);\n      this.variables[id] = newVariable;\n      return newVariable;\n    }\n   \n  }, {\n    key: \"lookupBroadcastMsg\",\n    value: function lookupBroadcastMsg(id, name) {\n      var broadcastMsg;\n      if (id) {\n        broadcastMsg = this.lookupVariableById(id);\n      } else if (name) {\n        broadcastMsg = this.lookupBroadcastByInputValue(name);\n      } else {\n        log.error('Cannot find broadcast message if neither id nor name are provided.');\n      }\n      if (broadcastMsg) {\n        if (name && broadcastMsg.name.toLowerCase() !== name.toLowerCase()) {\n          log.error(\"Found broadcast message with id: \".concat(id, \", but\") + \"its name, \".concat(broadcastMsg.name, \" did not match expected name \").concat(name, \".\"));\n        }\n        if (broadcastMsg.type !== Variable.BROADCAST_MESSAGE_TYPE) {\n          log.error(\"Found variable with id: \".concat(id, \", but its type \").concat(broadcastMsg.type) + \"did not match expected type \".concat(Variable.BROADCAST_MESSAGE_TYPE));\n        }\n        return broadcastMsg;\n      }\n    }\n   \n  }, {\n    key: \"lookupBroadcastByInputValue\",\n    value: function lookupBroadcastByInputValue(name) {\n      var vars = this.variables;\n      for (var propName in vars) {\n        if (vars[propName].type === Variable.BROADCAST_MESSAGE_TYPE && vars[propName].name.toLowerCase() === name.toLowerCase()) {\n          return vars[propName];\n        }\n      }\n    }\n   \n  }, {\n    key: \"lookupVariableById\",\n    value: function lookupVariableById(id) {\n      \n      if (this.variables.hasOwnProperty(id)) {\n        return this.variables[id];\n      } \n      if (this.runtime && !this.isStage) {\n        var stage = this.runtime.getTargetForStage();\n        if (stage && stage.variables.hasOwnProperty(id)) {\n          return stage.variables[id];\n        }\n      }\n    }\n   \n  }, {\n    key: \"lookupVariableByNameAndType\",\n    value: function lookupVariableByNameAndType(name, type, skipStage) {\n      if (typeof name !== 'string') return;\n      if (typeof type !== 'string') type = Variable.SCALAR_TYPE;\n      skipStage = skipStage || false;\n      for (var varId in this.variables) {\n        var currVar = this.variables[varId];\n        if (currVar.name === name && currVar.type === type) {\n          return currVar;\n        }\n      }\n      if (!skipStage && this.runtime && !this.isStage) {\n        var stage = this.runtime.getTargetForStage();\n        if (stage) {\n          for (var _varId in stage.variables) {\n            var _currVar = stage.variables[_varId];\n            if (_currVar.name === name && _currVar.type === type) {\n              return _currVar;\n            }\n          }\n        }\n      }\n      return null;\n    }\n   \n  }, {\n    key: \"lookupOrCreateList\",\n    value: function lookupOrCreateList(id, name) {\n      var list = this.lookupVariableById(id);\n      if (list) return list;\n      list = this.lookupVariableByNameAndType(name, Variable.LIST_TYPE);\n      if (list) return list; \n      var newList = new Variable(id, name, Variable.LIST_TYPE, false);\n      this.variables[id] = newList;\n      return newList;\n    }\n   \n  }, {\n    key: \"createVariable\",\n    value: function createVariable(id, name, type, isCloud) {\n      if (!this.variables.hasOwnProperty(id)) {\n        var newVariable = new Variable(id, name, type, false);\n        if (isCloud && this.isStage && this.runtime.canAddCloudVariable()) {\n          newVariable.isCloud = true;\n          this.runtime.addCloudVariable();\n          this.runtime.ioDevices.cloud.requestCreateVariable(newVariable);\n        }\n        this.variables[id] = newVariable;\n      }\n    }\n   \n  }, {\n    key: \"createComment\",\n    value: function createComment(id, blockId, text, x, y, width, height, minimized) {\n      if (!this.comments.hasOwnProperty(id)) {\n        var newComment = new Comment(id, text, x, y, width, height, minimized);\n        if (blockId) {\n          newComment.blockId = blockId;\n          var blockWithComment = this.blocks.getBlock(blockId);\n          if (blockWithComment) {\n            blockWithComment.comment = id;\n          } else {\n            log.warn(\"Could not find block with id \".concat(blockId, \" associated with commentId: \").concat(id));\n          }\n        }\n        this.comments[id] = newComment;\n      }\n    }\n   \n  }, {\n    key: \"renameVariable\",\n    value: function renameVariable(id, newName) {\n      var _this2 = this;\n      if (this.variables.hasOwnProperty(id)) {\n        var variable = this.variables[id];\n        if (variable.id === id) {\n          var oldName = variable.name;\n          variable.name = newName;\n          if (this.runtime) {\n            if (variable.isCloud && this.isStage) {\n              this.runtime.ioDevices.cloud.requestRenameVariable(oldName, newName);\n            }\n            if (variable.type === Variable.SCALAR_TYPE) {\n              \n              \n              var blockUpdated = false;\n              this.runtime.targets.forEach(function (t) {\n                blockUpdated = t.blocks.updateSensingOfReference(oldName, newName, _this2.isStage ? '_stage_' : _this2.getName()) || blockUpdated;\n              }); \n              if (blockUpdated) this.runtime.requestBlocksUpdate();\n            }\n            var blocks = this.runtime.monitorBlocks;\n            blocks.changeBlock({\n              id: id,\n              element: 'field',\n              name: variable.type === Variable.LIST_TYPE ? 'LIST' : 'VARIABLE',\n              value: id\n            }, this.runtime);\n            var monitorBlock = blocks.getBlock(variable.id);\n            if (monitorBlock) {\n              this.runtime.requestUpdateMonitor(Map({\n                id: id,\n                params: blocks._getBlockParams(monitorBlock)\n              }));\n            }\n          }\n        }\n      }\n    }\n   \n  }, {\n    key: \"deleteVariable\",\n    value: function deleteVariable(id) {\n      if (this.variables.hasOwnProperty(id)) {\n        \n        var deletedVariableName = this.variables[id].name;\n        var deletedVariableWasCloud = this.variables[id].isCloud;\n        delete this.variables[id];\n        if (this.runtime) {\n          if (deletedVariableWasCloud && this.isStage) {\n            this.runtime.ioDevices.cloud.requestDeleteVariable(deletedVariableName);\n            this.runtime.removeCloudVariable();\n          }\n          this.runtime.monitorBlocks.deleteBlock(id);\n          this.runtime.requestRemoveMonitor(id);\n        }\n      }\n    }\n   \n  }, {\n    key: \"deleteMonitors\",\n    value: function deleteMonitors() {\n      var _this3 = this;\n      this.runtime.requestRemoveMonitorByTargetId(this.id);\n      var targetSpecificMonitorBlockIds;\n      if (this.isStage) {\n        \n        targetSpecificMonitorBlockIds = Object.keys(this.variables);\n      } else {\n        targetSpecificMonitorBlockIds = Object.keys(this.runtime.monitorBlocks._blocks).filter(function (key) {\n          return _this3.runtime.monitorBlocks._blocks[key].targetId === _this3.id;\n        });\n      }\n      var _iterator = _createForOfIteratorHelper(targetSpecificMonitorBlockIds),\n          _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var blockId = _step.value;\n          this.runtime.monitorBlocks.deleteBlock(blockId);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n   \n  }, {\n    key: \"duplicateVariable\",\n    value: function duplicateVariable(id, optKeepOriginalId) {\n      if (this.variables.hasOwnProperty(id)) {\n        var originalVariable = this.variables[id];\n        var newVariable = new Variable(optKeepOriginalId ? id : null, \n        originalVariable.name, originalVariable.type, originalVariable.isCloud);\n        if (newVariable.type === Variable.LIST_TYPE) {\n          newVariable.value = originalVariable.value.slice(0);\n        } else {\n          newVariable.value = originalVariable.value;\n        }\n        return newVariable;\n      }\n      return null;\n    }\n   \n  }, {\n    key: \"duplicateVariables\",\n    value: function duplicateVariables(optBlocks) {\n      var _this4 = this;\n      var allVarRefs;\n      if (optBlocks) {\n        allVarRefs = optBlocks.getAllVariableAndListReferences();\n      }\n      return Object.keys(this.variables).reduce(function (accum, varId) {\n        var newVariable = _this4.duplicateVariable(varId, !optBlocks);\n        accum[newVariable.id] = newVariable;\n        if (optBlocks && allVarRefs) {\n          var currVarRefs = allVarRefs[varId];\n          if (currVarRefs) {\n            _this4.mergeVariables(varId, newVariable.id, currVarRefs);\n          }\n        }\n        return accum;\n      }, {});\n    }\n   \n  }, {\n    key: \"postSpriteInfo\",\n    value: function postSpriteInfo() {}\n   \n  }, {\n    key: \"getCustomState\",\n    value: function getCustomState(stateId) {\n      return this._customState[stateId];\n    }\n   \n  }, {\n    key: \"setCustomState\",\n    value: function setCustomState(stateId, newValue) {\n      this._customState[stateId] = newValue;\n    }\n   \n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this._customState = {};\n      if (this.runtime) {\n        this.runtime.removeExecutable(this);\n      }\n    } \n   \n  }, {\n    key: \"getAllVariableNamesInScopeByType\",\n    value: function getAllVariableNamesInScopeByType(type, skipStage) {\n      if (typeof type !== 'string') type = Variable.SCALAR_TYPE;\n      skipStage = skipStage || false;\n      var targetVariables = Object.values(this.variables).filter(function (v) {\n        return v.type === type;\n      }).map(function (variable) {\n        return variable.name;\n      });\n      if (skipStage || this.isStage || !this.runtime) {\n        return targetVariables;\n      }\n      var stage = this.runtime.getTargetForStage();\n      var stageVariables = stage.getAllVariableNamesInScopeByType(type);\n      return targetVariables.concat(stageVariables);\n    }\n   \n  }, {\n    key: \"mergeVariables\",\n    value: function mergeVariables(idToBeMerged, idToMergeWith, optReferencesToUpdate, optNewName) {\n      var referencesToChange = optReferencesToUpdate || \n      \n      this.blocks.getAllVariableAndListReferences()[idToBeMerged];\n      VariableUtil.updateVariableIdentifiers(referencesToChange, idToMergeWith, optNewName);\n    }\n   \n  }, {\n    key: \"shareLocalVariableToStage\",\n    value: function shareLocalVariableToStage(varId, varRefs) {\n      if (!this.runtime) return;\n      var variable = this.variables[varId];\n      if (!variable) {\n        log.warn(\"Cannot share a local variable to the stage if it's not local.\");\n        return;\n      }\n      var stage = this.runtime.getTargetForStage(); \n      \n      \n      \n      \n      \n      var varIdForStage = \"StageVarFromLocal_\".concat(varId);\n      var stageVar = stage.lookupVariableById(varIdForStage); \n      \n      \n      if (!stageVar) {\n        var varName = variable.name;\n        var varType = variable.type;\n        var newStageName = \"Stage: \".concat(varName);\n        stageVar = this.runtime.createNewGlobalVariable(newStageName, varIdForStage, varType);\n      } \n      this.mergeVariables(varId, stageVar.id, varRefs, stageVar.name);\n    }\n   \n  }, {\n    key: \"shareLocalVariableToSprite\",\n    value: function shareLocalVariableToSprite(varId, sprite, varRefs) {\n      if (!this.runtime) return;\n      if (this.isStage) return;\n      var variable = this.variables[varId];\n      if (!variable) {\n        log.warn(\"Tried to call 'shareLocalVariableToSprite' with a non-local variable.\");\n        return;\n      }\n      var varName = variable.name;\n      var varType = variable.type; \n      \n      var existingLocalVar = sprite.lookupVariableByNameAndType(varName, varType);\n      var newVarId;\n      if (existingLocalVar) {\n        newVarId = existingLocalVar.id;\n      } else {\n        var newVar = new Variable(null, varName, varType);\n        newVarId = newVar.id;\n        sprite.variables[newVarId] = newVar;\n      } \n      this.mergeVariables(varId, newVarId, varRefs);\n    }\n   \n  }, {\n    key: \"resolveVariableSharingConflictsWithTarget\",\n    value: function resolveVariableSharingConflictsWithTarget(blocks, receivingTarget) {\n      if (this.isStage) return; \n      var allVarListRefs = this.blocks.getAllVariableAndListReferences(blocks); \n      \n      \n      \n      for (var varId in allVarListRefs) {\n        var currVar = this.variables[varId];\n        if (!currVar) continue; \n        \n        var currVarListRefs = allVarListRefs[varId];\n        if (receivingTarget.isStage) {\n          this.shareLocalVariableToStage(varId, currVarListRefs);\n        } else {\n          this.shareLocalVariableToSprite(varId, receivingTarget, currVarListRefs);\n        }\n      }\n    }\n   \n    \n  }, {\n    key: \"fixUpVariableReferences\",\n    value: function fixUpVariableReferences() {\n      var _this5 = this;\n      if (!this.runtime) return; \n      if (this.isStage) return; \n      var stage = this.runtime.getTargetForStage();\n      if (!stage || !stage.variables) return;\n      var renameConflictingLocalVar = function renameConflictingLocalVar(id, name, type) {\n        var conflict = stage.lookupVariableByNameAndType(name, type);\n        if (conflict) {\n          var newName = StringUtil.unusedName(\"\".concat(_this5.getName(), \": \").concat(name), _this5.getAllVariableNamesInScopeByType(type));\n          _this5.renameVariable(id, newName);\n          return newName;\n        }\n        return null;\n      };\n      var allReferences = this.blocks.getAllVariableAndListReferences();\n      var unreferencedLocalVarIds = [];\n      if (Object.keys(this.variables).length > 0) {\n        for (var localVarId in this.variables) {\n          if (!this.variables.hasOwnProperty(localVarId)) continue;\n          if (!allReferences[localVarId]) unreferencedLocalVarIds.push(localVarId);\n        }\n      }\n      var conflictIdsToReplace = Object.create(null);\n      var conflictNamesToReplace = Object.create(null); \n      \n      var varNamesByType = {};\n      var allVarNames = function allVarNames(type) {\n        var namesOfType = varNamesByType[type];\n        if (namesOfType) return namesOfType;\n        varNamesByType[type] = _this5.runtime.getAllVarNamesOfType(type);\n        return varNamesByType[type];\n      };\n      for (var varId in allReferences) {\n        \n        var varRef = allReferences[varId][0];\n        var varName = varRef.referencingField.value;\n        var varType = varRef.type;\n        if (this.lookupVariableById(varId)) {\n          \n          \n          if (this.variables.hasOwnProperty(varId)) {\n            (function () {\n              \n              \n              \n              var newVarName = renameConflictingLocalVar(varId, varName, varType);\n              if (newVarName) {\n                \n                \n                \n                allReferences[varId].map(function (ref) {\n                  ref.referencingField.value = newVarName;\n                  return ref;\n                });\n              }\n            })();\n          }\n        } else {\n          \n          \n          \n          \n          \n          var existingVar = stage.lookupVariableByNameAndType(varName, varType);\n          if (existingVar) {\n            if (!conflictIdsToReplace[varId]) {\n              conflictIdsToReplace[varId] = existingVar.id;\n            }\n          } else {\n            \n            \n            \n            var allNames = allVarNames(varType);\n            var freshName = StringUtil.unusedName(varName, allNames);\n            stage.createVariable(varId, freshName, varType);\n            if (!conflictNamesToReplace[varId]) {\n              conflictNamesToReplace[varId] = freshName;\n            }\n          }\n        }\n      } \n      \n      for (var id in unreferencedLocalVarIds) {\n        var _varId2 = unreferencedLocalVarIds[id];\n        var name = this.variables[_varId2].name;\n        var type = this.variables[_varId2].type;\n        renameConflictingLocalVar(_varId2, name, type);\n      } \n      \n      \n      \n      \n      for (var conflictId in conflictIdsToReplace) {\n        var existingId = conflictIdsToReplace[conflictId];\n        var referencesToUpdate = allReferences[conflictId];\n        this.mergeVariables(conflictId, existingId, referencesToUpdate);\n      } \n      \n      \n      \n      \n      var _loop = function _loop(_conflictId) {\n        var newName = conflictNamesToReplace[_conflictId];\n        var referencesToUpdate = allReferences[_conflictId];\n        referencesToUpdate.map(function (ref) {\n          ref.referencingField.value = newName;\n          return ref;\n        });\n      };\n      for (var _conflictId in conflictNamesToReplace) {\n        _loop(_conflictId);\n      }\n    }\n  }]);\n  return Target;\n}(EventEmitter);\nmodule.exports = Target;\n })