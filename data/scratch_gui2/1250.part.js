/* 1250 */\n (function(module, exports, __webpack_require__) {\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nvar twgl = __webpack_require__(103);\nvar RenderConstants = __webpack_require__(230);\nvar Skin = __webpack_require__(187);\nvar ShaderManager = __webpack_require__(188);\n/**\n * Attributes to use when drawing with the pen\n * @typedef {object} PenSkin#PenAttributes\n * @property {number} [diameter] - The size (diameter) of the pen.\n * @property {Array<number>} [color4f] - The pen color as an array of [r,g,b,a], each component in the range [0,1].\n */\n/**\n * The pen attributes to use when unspecified.\n * @type {PenSkin#PenAttributes}\n * @memberof PenSkin\n * @private\n * @const\n */\nvar DefaultPenAttributes = {\n  color4f: [0, 0, 1, 1],\n  diameter: 1\n};\n/**\n * Reused memory location for storing a premultiplied pen color.\n * @type {FloatArray}\n */\nvar __premultipliedColor = [0, 0, 0, 0];\nvar PenSkin = function (_Skin) {\n  _inherits(PenSkin, _Skin);\n  var _super = _createSuper(PenSkin);\n \n  function PenSkin(id, renderer) {\n    var _this;\n    _classCallCheck(this, PenSkin);\n    _this = _super.call(this, id);\n   \n    _this._renderer = renderer;\n   \n    _this._size = null;\n   \n    _this._framebuffer = null;\n   \n    _this._silhouetteDirty = false;\n   \n    _this._silhouettePixels = null;\n   \n    _this._silhouetteImageData = null;\n   \n    _this._lineOnBufferDrawRegionId = {\n      enter: function enter() {\n        return _this._enterDrawLineOnBuffer();\n      },\n      exit: function exit() {\n        return _this._exitDrawLineOnBuffer();\n      }\n    };\n   \n    _this._usePenBufferDrawRegionId = {\n      enter: function enter() {\n        return _this._enterUsePenBuffer();\n      },\n      exit: function exit() {\n        return _this._exitUsePenBuffer();\n      }\n    };\n   \n    _this._lineBufferInfo = twgl.createBufferInfoFromArrays(_this._renderer.gl, {\n      a_position: {\n        numComponents: 2,\n        data: [1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1]\n      }\n    });\n    var NO_EFFECTS = 0;\n   \n    _this._lineShader = _this._renderer._shaderManager.getShader(ShaderManager.DRAW_MODE.line, NO_EFFECTS);\n    _this.onNativeSizeChanged = _this.onNativeSizeChanged.bind(_assertThisInitialized(_this));\n    _this._renderer.on(RenderConstants.Events.NativeSizeChanged, _this.onNativeSizeChanged);\n    _this._setCanvasSize(renderer.getNativeSize());\n    return _this;\n  }\n \n  _createClass(PenSkin, [{\n    key: \"dispose\",\n    value: function dispose() {\n      this._renderer.removeListener(RenderConstants.Events.NativeSizeChanged, this.onNativeSizeChanged);\n      this._renderer.gl.deleteTexture(this._texture);\n      this._texture = null;\n      _get(_getPrototypeOf(PenSkin.prototype), \"dispose\", this).call(this);\n    }\n   \n  }, {\n    key: \"useNearest\",\n    value: function useNearest(scale) {\n      \n      \n      return Math.max(scale[0], scale[1]) >= 100;\n    }\n   \n    \n  }, {\n    key: \"getTexture\",\n    value: function getTexture(scale) {\n      return this._texture;\n    }\n   \n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._renderer.enterDrawRegion(this._usePenBufferDrawRegionId);\n     \n      var gl = this._renderer.gl;\n      gl.clearColor(0, 0, 0, 0);\n      gl.clear(gl.COLOR_BUFFER_BIT);\n      this._silhouetteDirty = true;\n    }\n   \n  }, {\n    key: \"drawPoint\",\n    value: function drawPoint(penAttributes, x, y) {\n      this.drawLine(penAttributes, x, y, x, y);\n    }\n   \n  }, {\n    key: \"drawLine\",\n    value: function drawLine(penAttributes, x0, y0, x1, y1) {\n      \n      \n      var diameter = penAttributes.diameter || DefaultPenAttributes.diameter;\n      var offset = diameter === 1 || diameter === 3 ? 0.5 : 0;\n      this._drawLineOnBuffer(penAttributes, x0 + offset, y0 + offset, x1 + offset, y1 + offset);\n      this._silhouetteDirty = true;\n    }\n   \n  }, {\n    key: \"_enterDrawLineOnBuffer\",\n    value: function _enterDrawLineOnBuffer() {\n      var gl = this._renderer.gl;\n      twgl.bindFramebufferInfo(gl, this._framebuffer);\n      gl.viewport(0, 0, this._size[0], this._size[1]);\n      var currentShader = this._lineShader;\n      gl.useProgram(currentShader.program);\n      twgl.setBuffersAndAttributes(gl, currentShader, this._lineBufferInfo);\n      var uniforms = {\n        u_skin: this._texture,\n        u_stageSize: this._size\n      };\n      twgl.setUniforms(currentShader, uniforms);\n    }\n   \n  }, {\n    key: \"_exitDrawLineOnBuffer\",\n    value: function _exitDrawLineOnBuffer() {\n      var gl = this._renderer.gl;\n      twgl.bindFramebufferInfo(gl, null);\n    }\n   \n  }, {\n    key: \"_enterUsePenBuffer\",\n    value: function _enterUsePenBuffer() {\n      twgl.bindFramebufferInfo(this._renderer.gl, this._framebuffer);\n    }\n   \n  }, {\n    key: \"_exitUsePenBuffer\",\n    value: function _exitUsePenBuffer() {\n      twgl.bindFramebufferInfo(this._renderer.gl, null);\n    }\n   \n  }, {\n    key: \"_drawLineOnBuffer\",\n    value: function _drawLineOnBuffer(penAttributes, x0, y0, x1, y1) {\n      var gl = this._renderer.gl;\n      var currentShader = this._lineShader;\n      this._renderer.enterDrawRegion(this._lineOnBufferDrawRegionId); \n      var penColor = penAttributes.color4f || DefaultPenAttributes.color4f;\n      __premultipliedColor[0] = penColor[0] * penColor[3];\n      __premultipliedColor[1] = penColor[1] * penColor[3];\n      __premultipliedColor[2] = penColor[2] * penColor[3];\n      __premultipliedColor[3] = penColor[3]; \n      // 'mediump' precision is only required to have a range up to 2^14 (16384), so any lines longer than 2^7 (128)\n      \n      \n      \n      var lineDiffX = x1 - x0;\n      var lineDiffY = y1 - y0;\n      var lineLength = Math.sqrt(lineDiffX * lineDiffX + lineDiffY * lineDiffY);\n      var uniforms = {\n        u_lineColor: __premultipliedColor,\n        u_lineThickness: penAttributes.diameter || DefaultPenAttributes.diameter,\n        u_lineLength: lineLength,\n        u_penPoints: [x0, -y0, lineDiffX, -lineDiffY]\n      };\n      twgl.setUniforms(currentShader, uniforms);\n      twgl.drawBufferInfo(gl, this._lineBufferInfo, gl.TRIANGLES);\n      this._silhouetteDirty = true;\n    }\n   \n  }, {\n    key: \"onNativeSizeChanged\",\n    value: function onNativeSizeChanged(event) {\n      this._setCanvasSize(event.newSize);\n    }\n   \n  }, {\n    key: \"_setCanvasSize\",\n    value: function _setCanvasSize(canvasSize) {\n      var _canvasSize = _slicedToArray(canvasSize, 2),\n          width = _canvasSize[0],\n          height = _canvasSize[1];\n      this._size = canvasSize;\n      this._rotationCenter[0] = width / 2;\n      this._rotationCenter[1] = height / 2;\n      var gl = this._renderer.gl;\n      this._texture = twgl.createTexture(gl, {\n        mag: gl.NEAREST,\n        min: gl.NEAREST,\n        wrap: gl.CLAMP_TO_EDGE,\n        width: width,\n        height: height\n      });\n      var attachments = [{\n        format: gl.RGBA,\n        attachment: this._texture\n      }];\n      if (this._framebuffer) {\n        twgl.resizeFramebufferInfo(gl, this._framebuffer, attachments, width, height);\n      } else {\n        this._framebuffer = twgl.createFramebufferInfo(gl, attachments, width, height);\n      }\n      gl.clearColor(0, 0, 0, 0);\n      gl.clear(gl.COLOR_BUFFER_BIT);\n      this._silhouettePixels = new Uint8Array(Math.floor(width * height * 4));\n      this._silhouetteImageData = new ImageData(width, height);\n      this._silhouetteDirty = true;\n    }\n   \n  }, {\n    key: \"updateSilhouette\",\n    value: function updateSilhouette() {\n      if (this._silhouetteDirty) {\n        this._renderer.enterDrawRegion(this._usePenBufferDrawRegionId); \n        var gl = this._renderer.gl;\n        gl.readPixels(0, 0, this._size[0], this._size[1], gl.RGBA, gl.UNSIGNED_BYTE, this._silhouettePixels);\n        this._silhouetteImageData.data.set(this._silhouettePixels);\n        this._silhouette.update(this._silhouetteImageData, true\n       \n        );\n        this._silhouetteDirty = false;\n      }\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this._size;\n    }\n  }]);\n  return PenSkin;\n}(Skin);\nmodule.exports = PenSkin;\n })