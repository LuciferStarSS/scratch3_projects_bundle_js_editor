/* 935 */\n (function(module, exports, __webpack_require__) {\n\"use strict\";\n\n\n//\n\n\n\n//\n\n\n\n//\n\n\n\n\n\n\n\nvar utils = __webpack_require__(111);\nvar MAXBITS = 15;\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\nvar lbase = [\n  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0\n];\nvar lext = [\n  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78\n];\nvar dbase = [\n  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n  8193, 12289, 16385, 24577, 0, 0\n];\nvar dext = [\n  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n  28, 28, 29, 29, 64, 64\n];\nmodule.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)\n{\n  var bits = opts.bits;\n      //here = opts.here;\n  var len = 0;              \n  var sym = 0;              \n  var min = 0, max = 0;         \n  var root = 0;             \n  var curr = 0;             \n  var drop = 0;             \n  var left = 0;                  \n  var used = 0;             \n  var huff = 0;             \n  var incr;             \n  var fill;             \n  var low;              \n  var mask;             \n  var next;            \n  var base = null;    \n  var base_index = 0;\n\n  var end;                   \n  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];   \n  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    \n  var extra = null;\n  var extra_index = 0;\n  var here_bits, here_op, here_val;\n \n \n  for (len = 0; len <= MAXBITS; len++) {\n    count[len] = 0;\n  }\n  for (sym = 0; sym < codes; sym++) {\n    count[lens[lens_index + sym]]++;\n  }\n \n  root = bits;\n  for (max = MAXBITS; max >= 1; max--) {\n    if (count[max] !== 0) { break; }\n  }\n  if (root > max) {\n    root = max;\n  }\n  if (max === 0) {                    \n    //table.op[opts.table_index] = 64;  //here.op = (var char)64;   \n    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;\n    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n    //table.op[opts.table_index] = 64;\n    //table.bits[opts.table_index] = 1;\n    //table.val[opts.table_index++] = 0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n    opts.bits = 1;\n    return 0;    \n  }\n  for (min = 1; min < max; min++) {\n    if (count[min] !== 0) { break; }\n  }\n  if (root < min) {\n    root = min;\n  }\n \n  left = 1;\n  for (len = 1; len <= MAXBITS; len++) {\n    left <<= 1;\n    left -= count[len];\n    if (left < 0) {\n      return -1;\n    }       \n  }\n  if (left > 0 && (type === CODES || max !== 1)) {\n    return -1;                     \n  }\n \n  offs[1] = 0;\n  for (len = 1; len < MAXBITS; len++) {\n    offs[len + 1] = offs[len] + count[len];\n  }\n \n  for (sym = 0; sym < codes; sym++) {\n    if (lens[lens_index + sym] !== 0) {\n      work[offs[lens[lens_index + sym]]++] = sym;\n    }\n  }\n \n \n  \n  \n  if (type === CODES) {\n    base = extra = work;   \n    end = 19;\n  } else if (type === LENS) {\n    base = lbase;\n    base_index -= 257;\n    extra = lext;\n    extra_index -= 257;\n    end = 256;\n  } else {                   \n    base = dbase;\n    extra = dext;\n    end = -1;\n  }\n \n  huff = 0;                  \n  sym = 0;                   \n  len = min;                 \n  next = table_index;             \n  curr = root;               \n  drop = 0;                  \n  low = -1;                  \n  used = 1 << root;         \n  mask = used - 1;           \n \n  if ((type === LENS && used > ENOUGH_LENS) ||\n    (type === DISTS && used > ENOUGH_DISTS)) {\n    return 1;\n  }\n \n  for (;;) {\n   \n    here_bits = len - drop;\n    if (work[sym] < end) {\n      here_op = 0;\n      here_val = work[sym];\n    }\n    else if (work[sym] > end) {\n      here_op = extra[extra_index + work[sym]];\n      here_val = base[base_index + work[sym]];\n    }\n    else {\n      here_op = 32 + 64;        \n      here_val = 0;\n    }\n   \n    incr = 1 << (len - drop);\n    fill = 1 << curr;\n    min = fill;                \n    do {\n      fill -= incr;\n      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;\n    } while (fill !== 0);\n   \n    incr = 1 << (len - 1);\n    while (huff & incr) {\n      incr >>= 1;\n    }\n    if (incr !== 0) {\n      huff &= incr - 1;\n      huff += incr;\n    } else {\n      huff = 0;\n    }\n   \n    sym++;\n    if (--count[len] === 0) {\n      if (len === max) { break; }\n      len = lens[lens_index + work[sym]];\n    }\n   \n    if (len > root && (huff & mask) !== low) {\n     \n      if (drop === 0) {\n        drop = root;\n      }\n     \n      next += min;           \n     \n      curr = len - drop;\n      left = 1 << curr;\n      while (curr + drop < max) {\n        left -= count[curr + drop];\n        if (left <= 0) { break; }\n        curr++;\n        left <<= 1;\n      }\n     \n      used += 1 << curr;\n      if ((type === LENS && used > ENOUGH_LENS) ||\n        (type === DISTS && used > ENOUGH_DISTS)) {\n        return 1;\n      }\n     \n      low = huff & mask;\n     \n      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;\n    }\n  }\n \n  if (huff !== 0) {\n    //table.op[next + huff] = 64;           \n    //table.bits[next + huff] = len - drop;\n    //table.val[next + huff] = 0;\n    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;\n  }\n \n  //opts.table_index += used;\n  opts.bits = root;\n  return 0;\n};\n })