/* 442 */\n (function(module, exports) {\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nvar VariableUtil = function () {\n  function VariableUtil() {\n    _classCallCheck(this, VariableUtil);\n  }\n  _createClass(VariableUtil, null, [{\n    key: \"_mergeVarRefObjects\",\n    value: function _mergeVarRefObjects(accum, obj2) {\n      for (var id in obj2) {\n        if (accum[id]) {\n          accum[id] = accum[id].concat(obj2[id]);\n        } else {\n          accum[id] = obj2[id];\n        }\n      }\n      return accum;\n    }\n   \n  }, {\n    key: \"getAllVarRefsForTargets\",\n    value: function getAllVarRefsForTargets(targets, shouldIncludeBroadcast) {\n      return targets.map(function (t) {\n        return t.blocks.getAllVariableAndListReferences(null, shouldIncludeBroadcast);\n      }).reduce(VariableUtil._mergeVarRefObjects, {});\n    }\n   \n  }, {\n    key: \"updateVariableIdentifiers\",\n    value: function updateVariableIdentifiers(referencesToUpdate, newId, optNewName) {\n      referencesToUpdate.map(function (ref) {\n        ref.referencingField.id = newId;\n        if (optNewName) {\n          ref.referencingField.value = optNewName;\n        }\n        return ref;\n      });\n    }\n  }]);\n  return VariableUtil;\n}();\nmodule.exports = VariableUtil;\n })