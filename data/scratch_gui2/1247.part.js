/* 1247 */\n (function(module, exports, __webpack_require__) {\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\nvar twgl = __webpack_require__(103);\nvar Rectangle = __webpack_require__(486);\nvar RenderConstants = __webpack_require__(230);\nvar ShaderManager = __webpack_require__(188);\nvar Skin = __webpack_require__(187);\nvar EffectTransform = __webpack_require__(487);\nvar log = __webpack_require__(488);\n/**\n * An internal workspace for calculating texture locations from world vectors\n * this is REUSED for memory conservation reasons\n * @type {twgl.v3}\n */\nvar __isTouchingPosition = twgl.v3.create();\nvar FLOATING_POINT_ERROR_ALLOWANCE = 1e-6;\n/**\n * Convert a scratch space location into a texture space float.  Uses the\n * internal __isTouchingPosition as a return value, so this should be copied\n * if you ever need to get two local positions and store both.  Requires that\n * the drawable inverseMatrix is up to date.\n *\n * @param {Drawable} drawable The drawable to get the inverse matrix and uniforms from\n * @param {twgl.v3} vec [x,y] scratch space vector\n * @return {twgl.v3} [x,y] texture space float vector - transformed by effects and matrix\n */\nvar getLocalPosition = function getLocalPosition(drawable, vec) {\n  \n  var localPosition = __isTouchingPosition;\n  var v0 = vec[0];\n  var v1 = vec[1];\n  var m = drawable._inverseMatrix; \n  var d = v0 * m[3] + v1 * m[7] + m[15]; \n  \n  \n  localPosition[0] = 0.5 - (v0 * m[0] + v1 * m[4] + m[12]) / d;\n  localPosition[1] = (v0 * m[1] + v1 * m[5] + m[13]) / d + 0.5; \n  \n  \n  if (Math.abs(localPosition[0]) < FLOATING_POINT_ERROR_ALLOWANCE) localPosition[0] = 0;\n  if (Math.abs(localPosition[1]) < FLOATING_POINT_ERROR_ALLOWANCE) localPosition[1] = 0; \n  \n  if (drawable.enabledEffects !== 0 && localPosition[0] >= 0 && localPosition[0] < 1 && localPosition[1] >= 0 && localPosition[1] < 1) {\n    EffectTransform.transformPoint(drawable, localPosition, localPosition);\n  }\n  return localPosition;\n};\nvar Drawable = function () {\n \n  function Drawable(id) {\n    _classCallCheck(this, Drawable);\n   \n    this._id = id;\n   \n    this._uniforms = {\n     \n      u_modelMatrix: twgl.m4.identity(),\n     \n      u_silhouetteColor: Drawable.color4fFromID(this._id)\n    }; \n    var numEffects = ShaderManager.EFFECTS.length;\n    for (var index = 0; index < numEffects; ++index) {\n      var effectName = ShaderManager.EFFECTS[index];\n      var effectInfo = ShaderManager.EFFECT_INFO[effectName];\n      var converter = effectInfo.converter;\n      this._uniforms[effectInfo.uniformName] = converter(0);\n    }\n    this._position = twgl.v3.create(0, 0);\n    this._scale = twgl.v3.create(100, 100);\n    this._direction = 90;\n    this._transformDirty = true;\n    this._rotationMatrix = twgl.m4.identity();\n    this._rotationTransformDirty = true;\n    this._rotationAdjusted = twgl.v3.create();\n    this._rotationCenterDirty = true;\n    this._skinScale = twgl.v3.create(0, 0, 0);\n    this._skinScaleDirty = true;\n    this._inverseMatrix = twgl.m4.identity();\n    this._inverseTransformDirty = true;\n    this._visible = true;\n   \n    this.enabledEffects = 0;\n   \n    this._convexHullPoints = null;\n    this._convexHullDirty = true; \n    \n    \n    this._transformedHullPoints = null;\n    this._transformedHullDirty = true;\n    this._skinWasAltered = this._skinWasAltered.bind(this);\n    this.isTouching = this._isTouchingNever;\n  }\n \n  _createClass(Drawable, [{\n    key: \"dispose\",\n    value: function dispose() {\n      \n      this.skin = null;\n    }\n   \n  }, {\n    key: \"setTransformDirty\",\n    value: function setTransformDirty() {\n      this._transformDirty = true;\n      this._inverseTransformDirty = true;\n      this._transformedHullDirty = true;\n    }\n   \n  }, {\n    key: \"getUniforms\",\n   \n    value: function getUniforms() {\n      if (this._transformDirty) {\n        this._calculateTransform();\n      }\n      return this._uniforms;\n    }\n   \n  }, {\n    key: \"getVisible\",\n    value: function getVisible() {\n      return this._visible;\n    }\n   \n  }, {\n    key: \"updatePosition\",\n    value: function updatePosition(position) {\n      if (this._position[0] !== position[0] || this._position[1] !== position[1]) {\n        this._position[0] = Math.round(position[0]);\n        this._position[1] = Math.round(position[1]);\n        this.setTransformDirty();\n      }\n    }\n   \n  }, {\n    key: \"updateDirection\",\n    value: function updateDirection(direction) {\n      if (this._direction !== direction) {\n        this._direction = direction;\n        this._rotationTransformDirty = true;\n        this.setTransformDirty();\n      }\n    }\n   \n  }, {\n    key: \"updateScale\",\n    value: function updateScale(scale) {\n      if (this._scale[0] !== scale[0] || this._scale[1] !== scale[1]) {\n        this._scale[0] = scale[0];\n        this._scale[1] = scale[1];\n        this._rotationCenterDirty = true;\n        this._skinScaleDirty = true;\n        this.setTransformDirty();\n      }\n    }\n   \n  }, {\n    key: \"updateVisible\",\n    value: function updateVisible(visible) {\n      if (this._visible !== visible) {\n        this._visible = visible;\n        this.setConvexHullDirty();\n      }\n    }\n   \n  }, {\n    key: \"updateEffect\",\n    value: function updateEffect(effectName, rawValue) {\n      var effectInfo = ShaderManager.EFFECT_INFO[effectName];\n      if (rawValue) {\n        this.enabledEffects |= effectInfo.mask;\n      } else {\n        this.enabledEffects &= ~effectInfo.mask;\n      }\n      var converter = effectInfo.converter;\n      this._uniforms[effectInfo.uniformName] = converter(rawValue);\n      if (effectInfo.shapeChanges) {\n        this.setConvexHullDirty();\n      }\n    }\n   \n  }, {\n    key: \"updateProperties\",\n    value: function updateProperties(properties) {\n      if ('position' in properties) {\n        this.updatePosition(properties.position);\n      }\n      if ('direction' in properties) {\n        this.updateDirection(properties.direction);\n      }\n      if ('scale' in properties) {\n        this.updateScale(properties.scale);\n      }\n      if ('visible' in properties) {\n        this.updateVisible(properties.visible);\n      }\n      var numEffects = ShaderManager.EFFECTS.length;\n      for (var index = 0; index < numEffects; ++index) {\n        var effectName = ShaderManager.EFFECTS[index];\n        if (effectName in properties) {\n          this.updateEffect(effectName, properties[effectName]);\n        }\n      }\n    }\n   \n  }, {\n    key: \"_calculateTransform\",\n    value: function _calculateTransform() {\n      if (this._rotationTransformDirty) {\n        var rotation = (270 - this._direction) * Math.PI / 180; \n        \n        \n        \n        \n        \n        \n        var c = Math.cos(rotation);\n        var s = Math.sin(rotation);\n        this._rotationMatrix[0] = c;\n        this._rotationMatrix[1] = s; \n        \n        this._rotationMatrix[4] = -s;\n        this._rotationMatrix[5] = c; \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        this._rotationTransformDirty = false;\n      } \n      if (this._rotationCenterDirty && this.skin !== null) {\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        var rotationCenter = this.skin.rotationCenter;\n        var skinSize = this.skin.size;\n        var center0 = rotationCenter[0];\n        var center1 = rotationCenter[1];\n        var skinSize0 = skinSize[0];\n        var skinSize1 = skinSize[1];\n        var _scale = this._scale[0];\n        var _scale2 = this._scale[1];\n        var rotationAdjusted = this._rotationAdjusted;\n        rotationAdjusted[0] = (center0 - skinSize0 / 2) * _scale / 100;\n        rotationAdjusted[1] = (center1 - skinSize1 / 2) * _scale2 / 100 * -1; \n        this._rotationCenterDirty = false;\n      }\n      if (this._skinScaleDirty && this.skin !== null) {\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        var _skinSize = this.skin.size;\n        var scaledSize = this._skinScale;\n        scaledSize[0] = _skinSize[0] * this._scale[0] / 100;\n        scaledSize[1] = _skinSize[1] * this._scale[1] / 100; \n        this._skinScaleDirty = false;\n      }\n      var modelMatrix = this._uniforms.u_modelMatrix; \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      var scale0 = this._skinScale[0];\n      var scale1 = this._skinScale[1];\n      var rotation00 = this._rotationMatrix[0];\n      var rotation01 = this._rotationMatrix[1];\n      var rotation10 = this._rotationMatrix[4];\n      var rotation11 = this._rotationMatrix[5];\n      var adjusted0 = this._rotationAdjusted[0];\n      var adjusted1 = this._rotationAdjusted[1];\n      var position0 = this._position[0];\n      var position1 = this._position[1]; \n      \n      \n      modelMatrix[0] = scale0 * rotation00;\n      modelMatrix[1] = scale0 * rotation01; \n      \n      modelMatrix[4] = scale1 * rotation10;\n      modelMatrix[5] = scale1 * rotation11; \n      \n      \n      \n      \n      \n      modelMatrix[12] = rotation00 * adjusted0 + rotation10 * adjusted1 + position0;\n      modelMatrix[13] = rotation01 * adjusted0 + rotation11 * adjusted1 + position1; \n      \n      this._transformDirty = false;\n    }\n   \n  }, {\n    key: \"needsConvexHullPoints\",\n    value: function needsConvexHullPoints() {\n      return !this._convexHullPoints || this._convexHullDirty || this._convexHullPoints.length === 0;\n    }\n   \n  }, {\n    key: \"setConvexHullDirty\",\n    value: function setConvexHullDirty() {\n      this._convexHullDirty = true;\n    }\n   \n  }, {\n    key: \"setConvexHullPoints\",\n    value: function setConvexHullPoints(points) {\n      this._convexHullPoints = points;\n      this._convexHullDirty = false; \n      \n      this._transformedHullPoints = [];\n      for (var i = 0; i < points.length; i++) {\n        this._transformedHullPoints.push(twgl.v3.create());\n      }\n      this._transformedHullDirty = true;\n    }\n   \n    \n    \n    \n    \n    \n    \n    \n  }, {\n    key: \"_isTouchingNever\",\n    value: function _isTouchingNever(vec) {\n      return false;\n    }\n  }, {\n    key: \"_isTouchingNearest\",\n    value: function _isTouchingNearest(vec) {\n      return this.skin.isTouchingNearest(getLocalPosition(this, vec));\n    }\n  }, {\n    key: \"_isTouchingLinear\",\n    value: function _isTouchingLinear(vec) {\n      return this.skin.isTouchingLinear(getLocalPosition(this, vec));\n    }\n   \n  }, {\n    key: \"getBounds\",\n    value: function getBounds(result) {\n      if (this.needsConvexHullPoints()) {\n        throw new Error('Needs updated convex hull points before bounds calculation.');\n      }\n      if (this._transformDirty) {\n        this._calculateTransform();\n      }\n      var transformedHullPoints = this._getTransformedHullPoints(); \n      result = result || new Rectangle();\n      result.initFromPointsAABB(transformedHullPoints);\n      return result;\n    }\n   \n  }, {\n    key: \"getBoundsForBubble\",\n    value: function getBoundsForBubble(result) {\n      if (this.needsConvexHullPoints()) {\n        throw new Error('Needs updated convex hull points before bubble bounds calculation.');\n      }\n      if (this._transformDirty) {\n        this._calculateTransform();\n      }\n      var slice = 8; \n      var transformedHullPoints = this._getTransformedHullPoints();\n      var maxY = Math.max.apply(null, transformedHullPoints.map(function (p) {\n        return p[1];\n      }));\n      var filteredHullPoints = transformedHullPoints.filter(function (p) {\n        return p[1] > maxY - slice;\n      }); \n      result = result || new Rectangle();\n      result.initFromPointsAABB(filteredHullPoints);\n      return result;\n    }\n   \n  }, {\n    key: \"getAABB\",\n    value: function getAABB(result) {\n      if (this._transformDirty) {\n        this._calculateTransform();\n      }\n      var tm = this._uniforms.u_modelMatrix;\n      result = result || new Rectangle();\n      result.initFromModelMatrix(tm);\n      return result;\n    }\n   \n  }, {\n    key: \"getFastBounds\",\n    value: function getFastBounds(result) {\n      if (!this.needsConvexHullPoints()) {\n        return this.getBounds(result);\n      }\n      return this.getAABB(result);\n    }\n   \n  }, {\n    key: \"_getTransformedHullPoints\",\n    value: function _getTransformedHullPoints() {\n      if (!this._transformedHullDirty) {\n        return this._transformedHullPoints;\n      }\n      var projection = twgl.m4.ortho(-1, 1, -1, 1, -1, 1);\n      var skinSize = this.skin.size;\n      var halfXPixel = 1 / skinSize[0] / 2;\n      var halfYPixel = 1 / skinSize[1] / 2;\n      var tm = twgl.m4.multiply(this._uniforms.u_modelMatrix, projection);\n      for (var i = 0; i < this._convexHullPoints.length; i++) {\n        var point = this._convexHullPoints[i];\n        var dstPoint = this._transformedHullPoints[i];\n        dstPoint[0] = 0.5 + -point[0] / skinSize[0] - halfXPixel;\n        dstPoint[1] = point[1] / skinSize[1] - 0.5 + halfYPixel;\n        twgl.m4.transformPoint(tm, dstPoint, dstPoint);\n      }\n      this._transformedHullDirty = false;\n      return this._transformedHullPoints;\n    }\n   \n  }, {\n    key: \"updateMatrix\",\n    value: function updateMatrix() {\n      if (this._transformDirty) {\n        this._calculateTransform();\n      } \n      if (this._inverseTransformDirty) {\n        var inverse = this._inverseMatrix;\n        twgl.m4.copy(this._uniforms.u_modelMatrix, inverse); \n        \n        \n        inverse[10] = 1;\n        twgl.m4.inverse(inverse, inverse);\n        this._inverseTransformDirty = false;\n      }\n    }\n   \n  }, {\n    key: \"updateCPURenderAttributes\",\n    value: function updateCPURenderAttributes() {\n      this.updateMatrix(); \n      if (this.skin) {\n        this.skin.updateSilhouette(this._scale);\n        if (this.skin.useNearest(this._scale, this)) {\n          this.isTouching = this._isTouchingNearest;\n        } else {\n          this.isTouching = this._isTouchingLinear;\n        }\n      } else {\n        log.warn(\"Could not find skin for drawable with id: \".concat(this._id));\n        this.isTouching = this._isTouchingNever;\n      }\n    }\n   \n  }, {\n    key: \"_skinWasAltered\",\n    value: function _skinWasAltered() {\n      this._rotationCenterDirty = true;\n      this._skinScaleDirty = true;\n      this.setConvexHullDirty();\n      this.setTransformDirty();\n    }\n   \n  }, {\n    key: \"id\",\n    get: function get() {\n      return this._id;\n    }\n   \n  }, {\n    key: \"skin\",\n    get: function get() {\n      return this._skin;\n    }\n   \n    ,\n    set: function set(newSkin) {\n      if (this._skin !== newSkin) {\n        if (this._skin) {\n          this._skin.removeListener(Skin.Events.WasAltered, this._skinWasAltered);\n        }\n        this._skin = newSkin;\n        if (this._skin) {\n          this._skin.addListener(Skin.Events.WasAltered, this._skinWasAltered);\n        }\n        this._skinWasAltered();\n      }\n    }\n   \n  }, {\n    key: \"scale\",\n    get: function get() {\n      return [this._scale[0], this._scale[1]];\n    }\n  }], [{\n    key: \"color4fFromID\",\n    value: function color4fFromID(id) {\n      id -= RenderConstants.ID_NONE;\n      var r = (id >> 0 & 255) / 255.0;\n      var g = (id >> 8 & 255) / 255.0;\n      var b = (id >> 16 & 255) / 255.0;\n      return [r, g, b, 1.0];\n    }\n   \n  }, {\n    key: \"color3bToID\",\n    value: function color3bToID(r, g, b) {\n      var id;\n      id = (r & 255) << 0;\n      id |= (g & 255) << 8;\n      id |= (b & 255) << 16;\n      return id + RenderConstants.ID_NONE;\n    }\n   \n  }, {\n    key: \"sampleColor4b\",\n    value: function sampleColor4b(vec, drawable, dst, effectMask) {\n      var localPosition = getLocalPosition(drawable, vec);\n      if (localPosition[0] < 0 || localPosition[1] < 0 || localPosition[0] > 1 || localPosition[1] > 1) {\n        dst[0] = 0;\n        dst[1] = 0;\n        dst[2] = 0;\n        dst[3] = 0;\n        return dst;\n      }\n      var textColor = \n      \n      drawable.skin._silhouette.colorAtNearest(localPosition, dst); \n      if (drawable.enabledEffects === 0) return textColor;\n      return EffectTransform.transformColor(drawable, textColor, effectMask);\n    }\n  }]);\n  return Drawable;\n}();\nmodule.exports = Drawable;\n })