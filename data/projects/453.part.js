/* 453 */
 (function(module, exports, __webpack_require__) {
"use strict";
eval("\nmodule.exports = {};\nvar api = __webpack_require__(143);\nvar emailValidator = __webpack_require__(623);\nmodule.exports.validateUsernameLocally = function (username) {\n    if (!username || username === '') {\n        return { valid: false, errMsgId: 'general.required' };\n    } else if (username.length < 3) {\n        return { valid: false, errMsgId: 'registration.validationUsernameMinLength' };\n    } else if (username.length > 20) {\n        return { valid: false, errMsgId: 'registration.validationUsernameMaxLength' };\n    } else if (/\\s/i.test(username)) {\n        return { valid: false, errMsgId: 'registration.validationUsernameSpaces' };\n    } else if (!/^[\\w-]+$/i.test(username)) {\n        return { valid: false, errMsgId: 'registration.validationUsernameRegexp' };\n    }\n    return { valid: true };\n};\nmodule.exports.validateUsernameRemotely = function (username) {\n    return new Promise(function (resolve) {\n        api({\n            uri: '/accounts/checkusername/' + username + '/'\n        }, function (err, body, res) {\n            if (err || res.statusCode !== 200) {\n                resolve({ requestSucceeded: false, valid: false, errMsgId: 'general.error' });\n            }\n            // get the message in a way that will work for both scratchr2 and api\n            // versions of the checkusername endpoint\n            var msg = '';\n            if (body && body.msg) msg = body.msg;else if (body && body[0]) msg = body[0].msg;\n            switch (msg) {\n                case 'valid username':\n                    resolve({ requestSucceeded: true, valid: true });\n                    break;\n                case 'username exists':\n                    resolve({ requestSucceeded: true, valid: false, errMsgId: 'registration.validationUsernameExists' });\n                    break;\n                case 'bad username':\n                    // i.e., vulgar\n                    resolve({ requestSucceeded: true, valid: false, errMsgId: 'registration.validationUsernameNotAllowed' });\n                    break;\n                case 'invalid username':\n                default:\n                    resolve({ requestSucceeded: true, valid: false, errMsgId: 'registration.validationUsernameNotAllowed' });\n            }\n        });\n    });\n};\n/**\n * Validate password value, optionally also considering username value\n * @param  {string} password     password value to validate\n * @param  {string} username     username value to compare\n * @return {object}              {valid: boolean, errMsgId: string}\n */\nmodule.exports.validatePassword = function (password, username) {\n    if (!password) {\n        return { valid: false, errMsgId: 'general.required' };\n        // Using Array.from(string).length, instead of string.length, improves unicode\n        // character counting for a subset of unicode characters, so that they are counted\n        // as single characters by js.\n        // However, this only helps with a subset of unicode. Characters combinations,\n        // including diacritical marks or skintone/gender variations, will still appear\n        // to be multiple characters. See discussions:\n        // https://blog.jonnew.com/posts/poo-dot-length-equals-two\n        // https://stackoverflow.com/a/54370584/2308190\n    } else if (Array.from(password).length < 6) {\n        return { valid: false, errMsgId: 'registration.validationPasswordLength' };\n    } else if (password === 'password') {\n        return { valid: false, errMsgId: 'registration.validationPasswordNotEquals' };\n    } else if (username && password === username) {\n        return { valid: false, errMsgId: 'registration.validationPasswordNotUsername' };\n    }\n    return { valid: true };\n};\nmodule.exports.validatePasswordConfirm = function (password, passwordConfirm) {\n    if (!passwordConfirm) {\n        return { valid: false, errMsgId: 'general.required' };\n    } else if (password !== passwordConfirm) {\n        return { valid: false, errMsgId: 'registration.validationPasswordConfirmNotEquals' };\n    }\n    return { valid: true };\n};\nmodule.exports.validateEmailLocally = function (email) {\n    if (!email || email === '') {\n        return { valid: false, errMsgId: 'general.required' };\n    } else if (emailValidator.validate(email)) {\n        return { valid: true };\n    }\n    return { valid: false, errMsgId: 'registration.validationEmailInvalid' };\n};\nmodule.exports.validateEmailRemotely = function (email) {\n    return new Promise(function (resolve) {\n        api({\n            host: '', // not handled by API; use existing infrastructure\n            params: { email: email },\n            uri: '/accounts/check_email/'\n        }, function (err, body, res) {\n            if (err || res.statusCode !== 200 || !body || body.length < 1 || !body[0].msg) {\n                resolve({ requestSucceeded: false, valid: false, errMsgId: 'general.apiError' });\n            }\n            switch (body[0].msg) {\n                case 'valid email':\n                    resolve({ requestSucceeded: true, valid: true });\n                    break;\n                case 'Scratch is not allowed to send email to this address.': // e.g., bad TLD or block-listed\n                case 'Enter a valid email address.':\n                default:\n                    resolve({ requestSucceeded: true, valid: false, errMsgId: 'registration.validationEmailInvalid' });\n                    break;\n            }\n        });\n    });\n};\nvar responseErrorMsgs = module.exports.responseErrorMsgs = {\n    username: {\n        'username exists': { errMsgId: 'registration.errorUsernameExists' },\n        'bad username': { errMsgId: 'registration.errorBadUsername' }\n    },\n    password: {\n        'Ensure this value has at least 6 characters \\\\(it has \\\\d\\\\).': {\n            errMsgId: 'registration.errorPasswordTooShort'\n        }\n    },\n    recaptcha: {\n        'Incorrect, please try again.': { errMsgId: 'registration.errorCaptcha' }\n    }\n};\nmodule.exports.responseErrorMsg = function (fieldName, serverRawErr) {\n    if (fieldName && responseErrorMsgs[fieldName]) {\n        var serverErrPatterns = responseErrorMsgs[fieldName];\n        // use regex compare to find matching error string in responseErrorMsgs\n        var matchingKey = Object.keys(serverErrPatterns).find(function (errPattern) {\n            return RegExp(errPattern).test(serverRawErr);\n        });\n        if (matchingKey) return responseErrorMsgs[fieldName][matchingKey].errMsgId;\n    }\n    return null;\n};\n// ./src/lib/validate.js\n// module id = 453\n// module chunks = 0 1\n//# sourceURL=scratch:///./src/lib/validate.js?");
 })