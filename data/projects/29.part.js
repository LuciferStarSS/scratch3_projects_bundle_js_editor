/* 29 */
 (function(module, exports, __webpack_require__) {
"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(6);\nvar misc_1 = __webpack_require__(11);\nvar object_1 = __webpack_require__(19);\n/**\n * Holds additional event information. {@link Scope.applyToEvent} will be\n * called by the client before an event will be sent.\n */\nvar Scope = /** @class */ (function () {\n    function Scope() {\n        /** Flag if notifiying is happening. */\n        this.notifyingListeners = false;\n        /** Callback for client to receive scope changes. */\n        this.scopeListeners = [];\n        /** Callback list that will be called after {@link applyToEvent}. */\n        this.eventProcessors = [];\n        /** Array of breadcrumbs. */\n        this.breadcrumbs = [];\n        /** User */\n        this.user = {};\n        /** Tags */\n        this.tags = {};\n        /** Extra */\n        this.extra = {};\n    }\n    /** Add internal on change listener. */\n    Scope.prototype.addScopeListener = function (callback) {\n        this.scopeListeners.push(callback);\n    };\n    /** Add new event processor that will be called after {@link applyToEvent}. */\n    Scope.prototype.addEventProcessor = function (callback) {\n        this.eventProcessors.push(callback);\n        return this;\n    };\n    /**\n     * This will be called on every set call.\n     */\n    Scope.prototype.notifyScopeListeners = function () {\n        var _this = this;\n        if (!this.notifyingListeners) {\n            this.notifyingListeners = true;\n            setTimeout(function () {\n                _this.scopeListeners.forEach(function (callback) {\n                    callback(_this);\n                });\n                _this.notifyingListeners = false;\n            }, 0);\n        }\n    };\n    /**\n     * This will be called after {@link applyToEvent} is finished.\n     */\n    Scope.prototype.notifyEventProcessors = function (event, hint) {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var e_1, _a, processedEvent, _b, _c, processor, e_2, e_1_1;\n            return tslib_1.__generator(this, function (_d) {\n                switch (_d.label) {\n                    case 0:\n                        processedEvent = event;\n                        _d.label = 1;\n                    case 1:\n                        _d.trys.push([1, 8, 9, 10]);\n                        _b = tslib_1.__values(tslib_1.__spread(getGlobalEventProcessors(), this.eventProcessors)), _c = _b.next();\n                        _d.label = 2;\n                    case 2:\n                        if (!!_c.done) return [3 /*break*/, 7];\n                        processor = _c.value;\n                        _d.label = 3;\n                    case 3:\n                        _d.trys.push([3, 5, , 6]);\n                        return [4 /*yield*/, processor(tslib_1.__assign({}, processedEvent), hint)];\n                    case 4:\n                        processedEvent = _d.sent();\n                        if (processedEvent === null) {\n                            return [2 /*return*/, null];\n                        }\n                        return [3 /*break*/, 6];\n                    case 5:\n                        e_2 = _d.sent();\n                        return [3 /*break*/, 6];\n                    case 6:\n                        _c = _b.next();\n                        return [3 /*break*/, 2];\n                    case 7: return [3 /*break*/, 10];\n                    case 8:\n                        e_1_1 = _d.sent();\n                        e_1 = { error: e_1_1 };\n                        return [3 /*break*/, 10];\n                    case 9:\n                        try {\n                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                        }\n                        finally { if (e_1) throw e_1.error; }\n                        return [7 /*endfinally*/];\n                    case 10: return [2 /*return*/, processedEvent];\n                }\n            });\n        });\n    };\n    /**\n     * Updates user context information for future events.\n     * @param user User context object to merge into current context.\n     */\n    Scope.prototype.setUser = function (user) {\n        this.user = object_1.safeNormalize(user);\n        this.notifyScopeListeners();\n        return this;\n    };\n    /**\n     * Updates tags context information for future events.\n     * @param tags Tags context object to merge into current context.\n     */\n    Scope.prototype.setTag = function (key, value) {\n        var _a;\n        this.tags = tslib_1.__assign({}, this.tags, (_a = {}, _a[key] = object_1.safeNormalize(value), _a));\n        this.notifyScopeListeners();\n        return this;\n    };\n    /**\n     * Updates extra context information for future events.\n     * @param extra context object to merge into current context.\n     */\n    Scope.prototype.setExtra = function (key, extra) {\n        var _a;\n        this.extra = tslib_1.__assign({}, this.extra, (_a = {}, _a[key] = object_1.safeNormalize(extra), _a));\n        this.notifyScopeListeners();\n        return this;\n    };\n    /**\n     * Sets the fingerprint on the scope to send with the events.\n     * @param fingerprint string[] to group events in Sentry.\n     */\n    Scope.prototype.setFingerprint = function (fingerprint) {\n        this.fingerprint = object_1.safeNormalize(fingerprint);\n        this.notifyScopeListeners();\n        return this;\n    };\n    /**\n     * Sets the level on the scope for future events.\n     * @param level string {@link Severity}\n     */\n    Scope.prototype.setLevel = function (level) {\n        this.level = object_1.safeNormalize(level);\n        this.notifyScopeListeners();\n        return this;\n    };\n    /**\n     * Inherit values from the parent scope.\n     * @param scope to clone.\n     */\n    Scope.clone = function (scope) {\n        var newScope = new Scope();\n        object_1.assign(newScope, scope, {\n            scopeListeners: [],\n        });\n        if (scope) {\n            newScope.extra = object_1.assign(scope.extra);\n            newScope.tags = object_1.assign(scope.tags);\n            newScope.breadcrumbs = tslib_1.__spread(scope.breadcrumbs);\n            newScope.eventProcessors = tslib_1.__spread(scope.eventProcessors);\n        }\n        return newScope;\n    };\n    /** Clears the current scope and resets its properties. */\n    Scope.prototype.clear = function () {\n        this.breadcrumbs = [];\n        this.tags = {};\n        this.extra = {};\n        this.user = {};\n        this.level = undefined;\n        this.fingerprint = undefined;\n        this.notifyScopeListeners();\n    };\n    /**\n     * Sets the breadcrumbs in the scope\n     * @param breadcrumbs Breadcrumb\n     * @param maxBreadcrumbs number of max breadcrumbs to merged into event.\n     */\n    Scope.prototype.addBreadcrumb = function (breadcrumb, maxBreadcrumbs) {\n        this.breadcrumbs =\n            maxBreadcrumbs !== undefined && maxBreadcrumbs >= 0\n                ? tslib_1.__spread(this.breadcrumbs, [object_1.safeNormalize(breadcrumb)]).slice(-maxBreadcrumbs)\n                : tslib_1.__spread(this.breadcrumbs, [object_1.safeNormalize(breadcrumb)]);\n        this.notifyScopeListeners();\n    };\n    /**\n     * Applies fingerprint from the scope to the event if there's one,\n     * uses message if there's one instead or get rid of empty fingerprint\n     */\n    Scope.prototype.applyFingerprint = function (event) {\n        // Make sure it's an array first and we actually have something in place\n        event.fingerprint = event.fingerprint\n            ? Array.isArray(event.fingerprint)\n                ? event.fingerprint\n                : [event.fingerprint]\n            : [];\n        // If we have something on the scope, then merge it with event\n        if (this.fingerprint) {\n            event.fingerprint = event.fingerprint.concat(this.fingerprint);\n        }\n        else if (event.message) {\n            // If not, but we have message, use it instead\n            event.fingerprint = event.fingerprint.concat(event.message);\n        }\n        // If we have no data at all, remove empty array default\n        if (event.fingerprint && !event.fingerprint.length) {\n            delete event.fingerprint;\n        }\n    };\n    /**\n     * Applies the current context and fingerprint to the event.\n     * Note that breadcrumbs will be added by the client.\n     * Also if the event has already breadcrumbs on it, we do not merge them.\n     * @param event SentryEvent\n     * @param hint May contain additional informartion about the original exception.\n     * @param maxBreadcrumbs number of max breadcrumbs to merged into event.\n     */\n    Scope.prototype.applyToEvent = function (event, hint, maxBreadcrumbs) {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var hasNoBreadcrumbs;\n            return tslib_1.__generator(this, function (_a) {\n                if (this.extra && Object.keys(this.extra).length) {\n                    event.extra = tslib_1.__assign({}, this.extra, event.extra);\n                }\n                if (this.tags && Object.keys(this.tags).length) {\n                    event.tags = tslib_1.__assign({}, this.tags, event.tags);\n                }\n                if (this.user && Object.keys(this.user).length) {\n                    event.user = tslib_1.__assign({}, this.user, event.user);\n                }\n                if (this.level) {\n                    event.level = this.level;\n                }\n                this.applyFingerprint(event);\n                hasNoBreadcrumbs = !event.breadcrumbs || event.breadcrumbs.length === 0;\n                if (hasNoBreadcrumbs && this.breadcrumbs.length > 0) {\n                    event.breadcrumbs =\n                        maxBreadcrumbs !== undefined && maxBreadcrumbs >= 0\n                            ? this.breadcrumbs.slice(-maxBreadcrumbs)\n                            : this.breadcrumbs;\n                }\n                return [2 /*return*/, this.notifyEventProcessors(event, hint)];\n            });\n        });\n    };\n    return Scope;\n}());\nexports.Scope = Scope;\n/**\n * Retruns the global event processors.\n */\nfunction getGlobalEventProcessors() {\n    var global = misc_1.getGlobalObject();\n    global.__SENTRY__ = global.__SENTRY__ || {};\n    global.__SENTRY__.globalEventProcessors = global.__SENTRY__.globalEventProcessors || [];\n    return global.__SENTRY__.globalEventProcessors;\n}\n/**\n * Add a EventProcessor to be kept globally.\n * @param callback EventProcessor to add\n */\nfunction addGlobalEventProcessor(callback) {\n    getGlobalEventProcessors().push(callback);\n}\nexports.addGlobalEventProcessor = addGlobalEventProcessor;\n/*# sourceMappingURL=scope.js.map*/\n// ./~/@sentry/hub/dist/scope.js\n// module id = 29\n// module chunks = 0 1 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39\n//# sourceURL=scratch:///./~/@sentry/hub/dist/scope.js?");
 })