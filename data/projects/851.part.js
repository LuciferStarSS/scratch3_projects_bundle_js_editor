/* 851 */
 (function(module, exports, __webpack_require__) {
"use strict";
eval("\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n// preview view can show either project page or editor page;\n// idea is that we shouldn't require a page reload to switch back and forth\nvar bindAll = __webpack_require__(9);\n//var classNames = __webpack_require__(5);\nvar React = __webpack_require__(0);\nvar PropTypes = __webpack_require__(1);\nvar connect = __webpack_require__(13).connect;\nvar injectIntl = __webpack_require__(4).injectIntl;\n//var parser = __webpack_require__(1362);\n//var queryString = __webpack_require__(1262);\n//var api = __webpack_require__(143);\n//var Page = __webpack_require__(27);\n//var storage = __webpack_require__(939).default;\n//var log = __webpack_require__(139);\nvar jar = __webpack_require__(137);\n//var thumbnailUrl = __webpack_require__(248);\nvar ProjectInfo = __webpack_require__(935);\n//var PreviewPresentation = __webpack_require__(992);\nvar projectShape =  __webpack_require__(255).projectShape;\n//var Registration = __webpack_require__(69);\n//var Scratch3Registration = __webpack_require__(560);\n//var ConnectedLogin = __webpack_require__(67);\n//var CanceledDeletionModal = __webpack_require__(66);\n//var NotAvailable = __webpack_require__(590);\nvar Meta = __webpack_require__(592);\nvar sessionActions = __webpack_require__(136);\n//var navigationActions = __webpack_require__(16);\n//var previewActions = __webpack_require__(271);\nvar frameless = __webpack_require__(54);\nvar GUI = __webpack_require__(557);\nvar IntlGUI = injectIntl(GUI.default);\n//var localStorageAvailable = 'localStorage' in window && window.localStorage !== null;\n//var initSentry = __webpack_require__(482);\n//var xhr = __webpack_require__(749);\n//initSentry();\nvar Preview = function (_React$Component) {\n    _inherits(Preview, _React$Component);\n    function Preview(props) {\n        _classCallCheck(this, Preview);\n        oVIEW=this;//预览视图导出\n        var _this = _possibleConstructorReturn(this, (Preview.__proto__ || Object.getPrototypeOf(Preview)).call(this, props));\n        bindAll(_this, ['addEventListeners',  'handleClickLogo', 'handleGreenFlag', 'handleProjectLoaded',   'setScreenFromOrientation']);\n        //var pathname = window.location.pathname.toLowerCase();\n        //var parts = pathname.split('/').filter(Boolean);\n        // parts[0]: 'projects'\n        // parts[1]: either :id or 'editor', invalid if neither specified\n        // parts[2]: undefined if no :id, otherwise either 'editor' or 'fullscreen'\n        // Get single-comment id from url hash, using the #comments-{id} scheme from scratch2\n        //var commentHashPrefix = '#comments-';\n        //var singleCommentId = window.location.hash.indexOf(commentHashPrefix) !== -1 && parseInt(window.location.hash.replace(commentHashPrefix, ''), 10);\n        //var adminPanelOpen = localStorageAvailable && localStorage.getItem('adminPanelToggled_projects') === 'open';\n        _this.state = {\n            //addToStudioOpen: false,\n            //adminModalOpen: false,\n            //adminPanelOpen: adminPanelOpen || false,\n            //clientFaved: false,\n            //clientLoved: false,\n            extensions: [],\n            //socialOpen: false,\n            //favoriteCount: 0,\n            isProjectLoaded: false,\n            //isRemixing: false,\n            //invalidProject: false,//parts.length === 1,\n            //justRemixed: false,\n            //justShared: false,\n            //loveCount: 0,\n            //modInfo: {\n            //    scriptCount: 0,\n            //    spriteCount: 0\n            //},\n            //showCloudDataAlert: false,\n            //showUsernameBlockAlert: false,\n            projectId:'0',// parts[1] === 'editor' ? '0' : parts[1],\n            //reportOpen: false,\n            //singleCommentId: singleCommentId,\n            greenFlagRecorded: false\n        };\n        /* In the beginning, if user is on mobile and landscape, go to fullscreen */\n        _this.setScreenFromOrientation();\n        return _this;\n    }\n    _createClass(Preview, [{\n        key: 'componentDidMount',\n        value: function componentDidMount() {\n            this.addEventListeners();\n        }\n    }, {\n        key: 'componentDidUpdate',\n        value: function componentDidUpdate(prevProps, prevState) {\n            if (this.state.projectId > 0 && (this.props.sessionStatus !== prevProps.sessionStatus && this.props.sessionStatus === sessionActions.Status.FETCHED || this.state.projectId !== prevState.projectId)) {\n                //this.fetchCommunityData();\n                this.getProjectData(this.state.projectId, true /* Show cloud/username alerts */);\n                //if (this.state.justShared) {\n                //    this.setState({ // eslint-disable-line react/no-did-update-set-state\n                //        justShared: false\n                //    });\n                //}\n            }\n            if (this.state.projectId === '0' && this.state.projectId !== prevState.projectId) {\n                this.props.resetProject();\n                //if (this.state.justRemixed || this.state.justShared) {\n                //    this.setState({ // eslint-disable-line react/no-did-update-set-state\n                //        justRemixed: false,\n                //        justShared: false\n                //    });\n                //}\n            }\n            /*if (this.props.projectInfo.id !== prevProps.projectInfo.id) {\n                if (typeof this.props.projectInfo.id === 'undefined') {\n                    this.initCounts(0, 0);\n                } else {\n                    var token = this.props.user ? this.props.user.token : null;\n                    this.initCounts(this.props.projectInfo.stats.favorites, this.props.projectInfo.stats.loves);\n                    this.props.getProjectStudios(this.props.projectInfo.id, this.props.authorUsername, this.props.isAdmin, token);\n                    if (this.props.projectInfo.remix.parent !== null) {\n                        this.props.getParentInfo(this.props.projectInfo.remix.parent);\n                    }\n                    if (this.props.projectInfo.remix.root !== null && this.props.projectInfo.remix.root !== this.props.projectInfo.remix.parent) {\n                        this.props.getOriginalInfo(this.props.projectInfo.remix.root);\n                    }\n                    if (this.state.singleCommentId) {\n                        this.props.getCommentById(this.state.projectId, this.state.singleCommentId, this.props.authorUsername, this.props.isAdmin, token);\n                    } else {\n                        this.props.getTopLevelComments(this.state.projectId, this.props.comments.length, this.props.authorUsername, this.props.isAdmin, token);\n                    }\n                }\n            }*/\n            /*if (this.props.faved !== prevProps.faved || this.props.loved !== prevProps.loved) {\n                this.setState({ // eslint-disable-line react/no-did-update-set-state\n                    clientFaved: this.props.faved,\n                    clientLoved: this.props.loved\n                });\n            }*/\n            /* eslint-enable react/no-did-update-set-state */\n            //if (this.props.playerMode !== prevProps.playerMode || this.props.fullScreen !== prevProps.fullScreen) {\n            //    this.pushHistory(history.state === null);\n            //}\n            // Switching out of editor mode, refresh data that comes from project json\n            if (this.props.playerMode && !prevProps.playerMode) {\n                this.getProjectData(this.state.projectId, false // Do not show cloud/username alerts again\n                );\n            }\n        }\n    }, {\n        key: 'componentWillUnmount',\n        value: function componentWillUnmount() {\n            this.removeEventListeners();\n        }\n    }, {\n        key: 'addEventListeners',\n        value: function addEventListeners() {\n            window.addEventListener('popstate', this.handlePopState);\n            window.addEventListener('orientationchange', this.setScreenFromOrientation);\n            window.addEventListener('message', this.handleMessage);\n        }\n    }, {\n        key: 'removeEventListeners',\n        value: function removeEventListeners() {\n            window.removeEventListener('popstate', this.handlePopState);\n            window.removeEventListener('orientationchange', this.setScreenFromOrientation);\n            window.removeEventListener('message', this.handleMessage);\n        }\n    }, /*{\n        key: 'handleUpdateProjectData',\n        value: function handleUpdateProjectData(projectId, vmState, params) {\n            var _this2 = this;\n            var opts = {\n                body: vmState,\n                // If we set json:true then the body is double-stringified, so don't\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                withCredentials: true\n            };\n            var creatingProject = projectId === null || typeof projectId === 'undefined';\n            var queryParams = {};\n            if (params.hasOwnProperty('originalId')) queryParams.original_id = params.originalId;\n            if (params.hasOwnProperty('isCopy')) queryParams.is_copy = params.isCopy;\n            if (params.hasOwnProperty('isRemix')) queryParams.is_remix = params.isRemix;\n            if (params.hasOwnProperty('title')) queryParams.title = params.title;\n            var qs = queryString.stringify(queryParams);\n            if (qs) qs = '?' + qs;\n            if (creatingProject) {\n                Object.assign(opts, {\n                    method: 'post',\n                    url: this.props.projectHost + '/' + qs\n                });\n            } else {\n                Object.assign(opts, {\n                    method: 'put',\n                    url: this.props.projectHost + '/' + projectId + qs\n                });\n            }\n            return new Promise(function (resolve, reject) {\n                xhr(opts, function (err, response) {\n                    if (err) return reject(err);\n                    if (response.statusCode !== 200) return reject(response.statusCode);\n                    var body = void 0;\n                    try {\n                        // Since we didn't set json: true, we have to parse manually\n                        body = JSON.parse(response.body);\n                    } catch (e) {\n                        return reject(e);\n                    }\n                    body.id = projectId;\n                    if (creatingProject) {\n                        body.id = body['content-name'];\n                    }\n                    resolve(body);\n                });\n            }).then(function (body) {\n                var fetchProjectInfo = function fetchProjectInfo(count, resolve) {\n                    api({\n                        uri: '/projects/' + body.id,\n                        authentication: _this2.props.user.token\n                    }, function (err, projectInfo, response) {\n                        if (err) {\n                            log.error('Could not fetch project after creating: ' + err);\n                            return resolve(body);\n                        }\n                        if (typeof body === 'undefined' || response.statusCode === 404) {\n                            // Retry after 500ms, 1.5s, 3.5s, 7.5s and then stop.\n                            if (count > 4) {\n                                return resolve(body);\n                            }\n                            return setTimeout(fetchProjectInfo.bind(_this2, count + 1, resolve), 500 * Math.pow(2, count));\n                        }\n                        return resolve(body);\n                    });\n                };\n                if (creatingProject) {\n                    return new Promise(function (resolve, reject) {\n                        return fetchProjectInfo(1, resolve, reject);\n                    });\n                }\n                return body;\n            });\n        }\n    },*/ {\n        key: 'setScreenFromOrientation',\n        value: function setScreenFromOrientation() {\n            /*\n            * If the user is on a mobile device, switching to\n            * landscape format should make the fullscreen mode active\n            */\n            var isMobileDevice = screen.height <= frameless.mobile || screen.width <= frameless.mobile;\n            var isAModalOpen = this.state.addToStudioOpen || this.state.reportOpen;\n            if (this.props.playerMode && isMobileDevice && !isAModalOpen) {\n                var isLandscape = screen.height < screen.width;\n                if (isLandscape) {\n                    this.props.setFullScreen(true);\n                } else {\n                    this.props.setFullScreen(false);\n                }\n            }\n        }\n    },/* {\n        key: 'getProjectData',\n        value: function getProjectData(projectId, showAlerts) {\n            var _this3 = this;\n            if (projectId <= 0) return 0;\n            storage.load(storage.AssetType.Project, projectId, storage.DataFormat.JSON).then(function (projectAsset) {\n                // NOTE: this is turning up null, breaking the line below.\n                var input = projectAsset.data;\n                if ((typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object' && !(input instanceof ArrayBuffer) && !ArrayBuffer.isView(input)) {\n                    // taken from scratch-vm\n                    // If the input is an object and not any ArrayBuffer\n                    // or an ArrayBuffer view (this includes all typed arrays and DataViews)\n                    // turn the object into a JSON string, because we suspect\n                    // this is a project.json as an object\n                    // validate expects a string or buffer as input\n                    // TODO not sure if we need to check that it also isn't a data view\n                    input = JSON.stringify(input); // NOTE: what is the point of doing this??\n                }\n                parser(projectAsset.data, false, function (err, projectData) {\n                    if (err) {\n                        log.error('Unhandled project parsing error: ' + err);\n                        return;\n                    }\n                    var newState = {\n                        modInfo: {} // Filled in below\n                    };\n                    var helpers = ProjectInfo[projectData[0].projectVersion];\n                    if (!helpers) return; // sb1 not handled\n                    newState.extensions = Array.from(helpers.extensions(projectData[0]));\n                    newState.modInfo.scriptCount = helpers.scriptCount(projectData[0]);\n                    newState.modInfo.spriteCount = helpers.spriteCount(projectData[0]);\n                    //var hasCloudData = helpers.cloudData(projectData[0]);\n                    //if (hasCloudData) {\n                    //    if (_this3.props.isLoggedIn) {\n                            // show cloud variables log link if logged in\n                    //        newState.extensions.push({\n                    //            action: {\n                    //                l10nId: 'project.cloudDataLink',\n                    //                uri: '/cloudmonitor/' + projectId + '/'\n                    //            },\n                    //            icon: 'clouddata.svg',\n                    //            l10nId: 'project.cloudVariables',\n                    //            linked: true\n                    //        });\n                    //    } else {\n                    //        newState.extensions.push({\n                    //            icon: 'clouddata.svg',\n                    //            l10nId: 'project.cloudVariables'\n                    //        });\n                    //    }\n                    //}\n                    //if (showAlerts) {\n                        // Check for username block only if user is logged in\n                    //    if (_this3.props.isLoggedIn) {\n                    //        newState.showUsernameBlockAlert = helpers.usernameBlock(projectData[0]);\n                    //    } else {\n                            // Check for cloud vars only if user is logged out\n                    //        newState.showCloudDataAlert = hasCloudData;\n                    //    }\n                    //}\n                    _this3.setState(newState);\n                });\n            });\n        }\n    },*/ {\n        key: 'handleClickLogo',\n        value: function handleClickLogo() {\n           \/\/window.location = '/';\n        }\n    }, {\n        key: 'handleGreenFlag',\n        value: function handleGreenFlag() {\n            //if (!this.state.greenFlagRecorded) {\n                //this.props.logProjectView(this.props.projectInfo.id, this.props.authorUsername, this.props.user.token);\n            //}\n            this.setState({\n                showUsernameBlockAlert: false,\n                showCloudDataAlert: false,\n                greenFlagRecorded: true\n            });\n        }\n    }, {\n        key: 'handleProjectLoaded',\n        value: function handleProjectLoaded() {\n            // Currently project view only needs to know when the project becomes loaded. It\n            // does not currently handle (or need to handle) the case where a project becomes unloaded.\n            this.setState({ isProjectLoaded: true });\n        }\n    }, {\n        key: 'handleSetLanguage',\n        value: function handleSetLanguage(locale) {\n            var opts = {};\n            if (window.location.hostname !== 'localhost') {\n                opts = { domain:  window.location.hostname };\n            }\n            jar.set('scratchlanguage', locale, opts);\n            scratchStatus(\"SETLOCALE\");\n        }\n    }, {\n        key: 'render',\n        value: function render() {\n            //if (this.props.projectNotAvailable || this.state.invalidProject) {\n            //    return React.createElement(\n            //        Page,\n            //        null,\n            //        React.createElement(\n            //            'div',\n            //            { className: 'preview' },\n            //            React.createElement(NotAvailable, null)\n            //        )\n            //    );\n            //}\n            return React.createElement(\n                React.Fragment,\n                null,\n                React.createElement(Meta, {\n                    projectInfo: this.props.projectInfo,\n                    userPresent: this.props.userPresent\n                }),\n                React.createElement(\n                    React.Fragment,\n                    null,\n                    React.createElement(IntlGUI, {\n                        assetHost: this.props.assetHost,\n                        authorId: this.props.authorId,\n                        //authorThumbnailUrl: this.props.authorThumbnailUrl,\n                        authorUsername: this.props.authorUsername,\n                        backpackHost: this.props.backpackHost,\n                        backpackVisible: this.props.canUseBackpack,\n                        basePath: '/',\n                        //canCreateCopy: this.props.canCreateCopy,\n                        //canCreateNew: this.props.canCreateNew,\n                        //canEditTitle: this.props.canEditTitleInEditor,\n                        //canRemix: this.props.canRemix,\n                        //canSave: this.props.canSave,\n                        //canShare: this.props.canShare,\n                        className: 'gui',\n                        cloudHost: this.props.cloudHost,\n                        //enableCommunity: this.props.enableCommunity,\n                        //hasCloudPermission: this.props.isScratcher,\n                        //isShared: this.props.isShared,\n                        projectHost: this.props.projectHost,\n                        projectId: this.state.projectId,\n                        projectTitle: this.props.projectInfo.title,\n                        //renderLogin: this.renderLogin,\n                        onClickLogo: this.handleClickLogo,\n                        onGreenFlag: this.handleGreenFlag,\n                        //onLogOut: this.props.handleLogOut,\n                        //onOpenRegistration: this.props.handleOpenRegistration,\n                        onProjectLoaded: this.handleProjectLoaded,\n                        //onRemixing: this.handleIsRemixing,\n                        onSetLanguage: this.handleSetLanguage,\n                        //onShare: this.handleShare,\n                        //onToggleLoginOpen: this.props.handleToggleLoginOpen,\n                        //onUpdateProjectData: this.handleUpdateProjectData,\n                        //onUpdateProjectId: this.handleUpdateProjectId,\n                        //onUpdateProjectThumbnail: this.props.handleUpdateProjectThumbnail,\n                        //onUpdateProjectTitle: this.handleUpdateProjectTitle\n                    })\n                    //this.props.registrationOpen && (this.props.useScratch3Registration ? React.createElement(Scratch3Registration, {\n                    //    isOpen: true\n                    //}) : React.createElement(Registration, null)\n                )\n                    //React.createElement(CanceledDeletionModal, null)\n            );\n        }\n    }]);\n    return Preview;\n}(React.Component);\nPreview.propTypes = {\n    assetHost: PropTypes.string.isRequired,\n    // If there's no author, this will be false`\n    authorId: PropTypes.oneOfType([PropTypes.string, PropTypes.bool]),\n    //authorThumbnailUrl: PropTypes.string,\n    // If there's no author, this will be false`\n    authorUsername: PropTypes.oneOfType([PropTypes.string, PropTypes.bool]),\n    backpackHost: PropTypes.string,\n    //canAddToStudio: PropTypes.bool,\n    //canCreateCopy: PropTypes.bool,\n    //canCreateNew: PropTypes.bool,\n    //canEditTitleInEditor: PropTypes.bool,\n    //canRemix: PropTypes.bool,\n    //canReport: PropTypes.bool,\n    //canSave: PropTypes.bool,\n    //canShare: PropTypes.bool,\n    //canToggleComments: PropTypes.bool,\n    //canUseBackpack: PropTypes.bool,\n    cloudHost: PropTypes.string,\n    //comments: PropTypes.arrayOf(PropTypes.object),\n    //enableCommunity: PropTypes.bool,\n    //faved: PropTypes.bool,\n    //favedLoaded: PropTypes.bool,\n    fullScreen: PropTypes.bool,\n    //getCommentById: PropTypes.func.isRequired,\n    //getCuratedStudios: PropTypes.func.isRequired,\n    //getFavedStatus: PropTypes.func.isRequired,\n    //getLovedStatus: PropTypes.func.isRequired,\n    //getMoreReplies: PropTypes.func.isRequired,\n    //getOriginalInfo: PropTypes.func.isRequired,\n    //getParentInfo: PropTypes.func.isRequired,\n    //getProjectInfo: PropTypes.func.isRequired,\n    //getProjectStudios: PropTypes.func.isRequired,\n    //getRemixes: PropTypes.func.isRequired,\n    //getTopLevelComments: PropTypes.func.isRequired,\n    //handleAddComment: PropTypes.func,\n    //handleDeleteComment: PropTypes.func,\n    //handleLogIn: PropTypes.func,\n    //handleLogOut: PropTypes.func,\n    //handleOpenRegistration: PropTypes.func,\n    //handleReportComment: PropTypes.func,\n    //handleRestoreComment: PropTypes.func,\n    //handleSeeAllComments: PropTypes.func,\n    //handleToggleLoginOpen: PropTypes.func,\n    //handleUpdateProjectThumbnail: PropTypes.func,\n    //isAdmin: PropTypes.bool,\n    //isEditable: PropTypes.bool,\n    //isLoggedIn: PropTypes.bool,\n    //isNewScratcher: PropTypes.bool,\n    //isScratcher: PropTypes.bool,\n    //isShared: PropTypes.bool,\n    //logProjectView: PropTypes.func,\n    //loved: PropTypes.bool,\n    //lovedLoaded: PropTypes.bool,\n    //moreCommentsToLoad: PropTypes.bool,\n    //original: projectShape,\n    //parent: projectShape,\n    playerMode: PropTypes.bool,\n    projectHost: PropTypes.string.isRequired,\n    projectInfo: projectShape,\n    //projectNotAvailable: PropTypes.bool,\n    //projectStudios: PropTypes.arrayOf(PropTypes.object),\n    //registrationOpen: PropTypes.bool,\n    //remixProject: PropTypes.func,\n    //remixes: PropTypes.arrayOf(PropTypes.object),\n    //replies: PropTypes.objectOf(PropTypes.array),\n    //reportProject: PropTypes.func,\n    resetProject: PropTypes.func,\n    //sessionStatus: PropTypes.string,\n    //setFavedStatus: PropTypes.func.isRequired,\n    setFullScreen: PropTypes.func.isRequired,\n    //setLovedStatus: PropTypes.func.isRequired,\n    setPlayer: PropTypes.func.isRequired,\n    //shareProject: PropTypes.func.isRequired,\n    //toggleStudio: PropTypes.func.isRequired,\n    //updateProject: PropTypes.func.isRequired,\n    //useScratch3Registration: PropTypes.bool,\n    user: PropTypes.shape({\n        id: PropTypes.number,\n        banned: PropTypes.bool,\n        username: PropTypes.string,\n        token: PropTypes.string,\n        thumbnailUrl: PropTypes.string,\n        dateJoined: PropTypes.string,\n        email: PropTypes.string,\n        classroomId: PropTypes.string\n    }),\n    //userOwnsProject: PropTypes.bool,\n    //userPresent: PropTypes.bool,\n    visibilityInfo: PropTypes.shape({\n        censored: PropTypes.bool,\n        censoredByAdmin: PropTypes.bool,\n        censoredByCommunity: PropTypes.bool,\n        message: PropTypes.string,\n        deleted: PropTypes.bool,\n        reshareable: PropTypes.bool\n    })\n};\nPreview.defaultProps = {\n    assetHost: \"./\"                            ,\n    backpackHost: \"./backpack\",\n    canUseBackpack: false,\n    cloudHost: \"./cloud\",\n    projectHost: \"./\",\n    sessionStatus: sessionActions.Status.NOT_FETCHED,\n    user: {},\n    userPresent: false\n};\nvar mapStateToProps = function mapStateToProps(state) {\n    var projectInfoPresent = state.preview.projectInfo && Object.keys(state.preview.projectInfo).length > 0 && state.preview.projectInfo.id > 0;\n    var userPresent = state.session.session.user !== null && typeof state.session.session.user !== 'undefined' && Object.keys(state.session.session.user).length > 0;\n    var isLoggedIn = state.session.status === sessionActions.Status.FETCHED && userPresent;\n    var isAdmin = isLoggedIn && state.session.session.permissions.admin;\n    var author = projectInfoPresent && state.preview.projectInfo.author;\n    var authorPresent = author && Object.keys(state.preview.projectInfo.author).length > 0;\n    var authorId = authorPresent && author.id && author.id.toString();\n    var authorUsername = authorPresent && author.username;\n    var userOwnsProject = isLoggedIn && authorPresent && state.session.session.user.id.toString() === authorId;\n    var isEditable = isLoggedIn && (authorUsername === state.session.session.user.username || state.permissions.admin === true);\n    // if we don't have projectInfo, assume it's shared until we know otherwise\n    var isShared = !projectInfoPresent || state.preview.projectInfo.is_published;\n    return {\n        authorId: authorId,\n        authorThumbnailUrl: '',//thumbnailUrl(authorId),\n        authorUsername: authorUsername,\n        //canAddToStudio: isLoggedIn && isShared,\n        //canCreateCopy: userOwnsProject && projectInfoPresent,\n        //canCreateNew: isLoggedIn,\n        // admins want to see author credit in editor; only let them edit title if they own project\n        //canEditTitleInEditor: isEditable && (userOwnsProject || !isAdmin),\n        //canRemix: isLoggedIn && projectInfoPresent && !userOwnsProject,\n        //canReport: isLoggedIn && !userOwnsProject,\n        //canSave: isLoggedIn && userOwnsProject,\n        //canShare: userOwnsProject && state.permissions.social,\n        //canToggleComments: userOwnsProject || isAdmin,\n        //canUseBackpack: isLoggedIn,\n        //comments: state.preview.comments,\n        //enableCommunity: projectInfoPresent,\n        //faved: state.preview.faved,\n        //favedLoaded: state.preview.status.faved === previewActions.Status.FETCHED,\n        fullScreen: state.scratchGui.mode.isFullScreen,\n        // project is editable iff logged in user is the author of the project, or\n        // logged in user is an admin.\n        //isEditable: isEditable,\n        //isLoggedIn: isLoggedIn,\n        //isAdmin: isAdmin,\n        //isNewScratcher: isLoggedIn && state.permissions.new_scratcher,\n        //isScratcher: isLoggedIn && state.permissions.scratcher,\n        //isShared: isShared,\n        //loved: state.preview.loved,\n        //lovedLoaded: state.preview.status.loved === previewActions.Status.FETCHED,\n        //moreCommentsToLoad: state.preview.moreCommentsToLoad,\n        //original: state.preview.original,\n        //parent: state.preview.parent,\n        playerMode: state.scratchGui.mode.isPlayerOnly,\n        projectInfo: state.preview.projectInfo,\n        //projectNotAvailable: state.preview.projectNotAvailable,\n        //projectStudios: state.preview.projectStudios,\n        //registrationOpen: state.navigation.registrationOpen,\n        //remixes: state.preview.remixes,\n        //replies: state.preview.replies,\n        //sessionStatus: state.session.status, // check if used\n        //useScratch3Registration: state.navigation.useScratch3Registration,\n        user: state.session.session.user,\n        //userOwnsProject: userOwnsProject,\n        //userPresent: userPresent,\n        //visibilityInfo: state.preview.visibilityInfo\n    };\n};\nvar mapDispatchToProps = function mapDispatchToProps(dispatch) {\n    return {\n        //getProjectInfo: function getProjectInfo(id, token) {\n        //   \/\/ dispatch(previewActions.getProjectInfo(id, token));\n        //},\n        //updateProject: function updateProject(id, formData, username, token) {\n        //    \/\/dispatch(previewActions.updateProject(id, formData, username, token));\n        //},\n        setPlayer: function setPlayer(player) {\n            dispatch(GUI.setPlayer(player));\n        },\n        setFullScreen: function setFullScreen(fullscreen) {\n            dispatch(GUI.setFullScreen(fullscreen));\n        }\n    };\n};\nmodule.exports.View = connect(mapStateToProps, mapDispatchToProps)(Preview);\n// replace old Scratch 2.0-style hashtag URLs with updated format\n//if (window.location.hash) {\n//    var pathname = window.location.pathname;\n//    if (pathname.substr(-1) !== '/') {\n//        pathname = pathname + '/';\n//    }\n//    if (window.location.hash === '#editor') {\n//        history.replaceState({}, document.title, pathname + 'editor' + window.location.search);\n//    }\n//    //if (window.location.hash === '#fullscreen') {\n//    //    history.replaceState({}, document.title, pathname + 'fullscreen' + window.location.search);\n//    //}\n//}\n// initialize GUI by calling its reducer functions depending on URL\nGUI.setAppElement(document.getElementById('app'));\nmodule.exports.initGuiState = function (guiInitialState) {\n    //var pathname = window.location.pathname.toLowerCase();\n    //var parts = pathname.split('/').filter(Boolean);\n    // parts[0]: 'projects'\n    // parts[1]: either :id or 'editor'\n    // parts[2]: undefined if no :id, otherwise either 'editor' or 'fullscreen'\n    //if (parts.indexOf('editor') === -1) {\n    //    guiInitialState = GUI.initPlayer(guiInitialState);\n    //}\n    //if (parts.indexOf('fullscreen') !== -1) {\n    //    guiInitialState = GUI.initFullScreen(guiInitialState);\n    //}\n    return guiInitialState;\n};\nmodule.exports.guiReducers = GUI.guiReducers;\nmodule.exports.guiInitialState = GUI.guiInitialState;\nmodule.exports.guiMiddleware = GUI.guiMiddleware;\nmodule.exports.initLocale = GUI.initLocale;\nmodule.exports.localesInitialState = GUI.localesInitialState;\n// ./src/views/preview/project-view.jsx\n// module id = 851\n// module chunks = 0\n//# sourceURL=scratch:///./src/views/preview/project-view.jsx?");
 })