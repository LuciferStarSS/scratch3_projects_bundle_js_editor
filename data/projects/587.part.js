/* 587 */
 (function(module, exports, __webpack_require__) {
"use strict";
eval("\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\nvar _formik = __webpack_require__(167);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\nvar bindAll = __webpack_require__(9);\nvar classNames = __webpack_require__(5);\nvar React = __webpack_require__(0);\nvar PropTypes = __webpack_require__(1);\nvar _require = __webpack_require__(4),\n    injectIntl = _require.injectIntl,\n    intlShape = _require.intlShape;\nvar validate = __webpack_require__(453);\nvar FormikInput = __webpack_require__(450);\nvar FormikCheckbox = __webpack_require__(485);\nvar JoinFlowStep = __webpack_require__(190);\n__webpack_require__(197);\n/*\n * Username step\n */\n/* eslint-disable react/prefer-stateless-function, no-useless-constructor */\nvar UsernameStep = function (_React$Component) {\n    _inherits(UsernameStep, _React$Component);\n    function UsernameStep(props) {\n        _classCallCheck(this, UsernameStep);\n        var _this = _possibleConstructorReturn(this, (UsernameStep.__proto__ || Object.getPrototypeOf(UsernameStep)).call(this, props));\n        bindAll(_this, ['handleFocused', 'handleSetUsernameRef', 'handleValidSubmit', 'validatePasswordIfPresent', 'validatePasswordConfirmIfPresent', 'validateUsernameIfPresent', 'validateUsernameRemotelyWithCache', 'validateForm']);\n        _this.state = {\n            focused: null\n        };\n        // simple object to memoize remote requests for usernames.\n        // keeps us from submitting multiple requests for same data.\n        _this.usernameRemoteCache = Object.create(null);\n        return _this;\n    }\n    _createClass(UsernameStep, [{\n        key: 'componentDidMount',\n        value: function componentDidMount() {\n            // Send info to analytics when we aren't on the standalone page.\n            // If we are on the standalone join page, the page load will take care of this.\n            if (window.location.pathname.indexOf('/join') === -1) {\n                if (this.props.sendAnalytics) {\n                    this.props.sendAnalytics('join-username-modal');\n                }\n            }\n            // automatically start with focus on username field\n            if (this.usernameInput) this.usernameInput.focus();\n        }\n        // track the currently focused input field, to determine whether each field should\n        // display a tooltip. (We only display it if a field is focused and has never been touched.)\n    }, {\n        key: 'handleFocused',\n        value: function handleFocused(fieldName) {\n            this.setState({ focused: fieldName });\n        }\n    }, {\n        key: 'handleSetUsernameRef',\n        value: function handleSetUsernameRef(usernameInputRef) {\n            this.usernameInput = usernameInputRef;\n        }\n        // simple function to memoize remote requests for usernames\n    }, {\n        key: 'validateUsernameRemotelyWithCache',\n        value: function validateUsernameRemotelyWithCache(username) {\n            var _this2 = this;\n            if (_typeof(this.usernameRemoteCache[username]) === 'object') {\n                return Promise.resolve(this.usernameRemoteCache[username]);\n            }\n            // username is not in our cache\n            return validate.validateUsernameRemotely(username).then(function (remoteResult) {\n                // cache result, if it successfully heard back from server\n                if (remoteResult.requestSucceeded) {\n                    _this2.usernameRemoteCache[username] = remoteResult;\n                }\n                return remoteResult;\n            });\n        }\n        // we allow username to be empty on blur, since you might not have typed anything yet\n    }, {\n        key: 'validateUsernameIfPresent',\n        value: function validateUsernameIfPresent(username) {\n            var _this3 = this;\n            if (!username) return null; // skip validation if username is blank; null indicates valid\n            // if username is not blank, run both local and remote validations\n            var localResult = validate.validateUsernameLocally(username);\n            return this.validateUsernameRemotelyWithCache(username).then(function (remoteResult) {\n                // there may be multiple validation errors. Prioritize vulgarity, then\n                // length, then having invalid chars, then all other remote reports\n                if (remoteResult.valid === false && remoteResult.errMsgId === 'registration.validationUsernameVulgar') {\n                    return _this3.props.intl.formatMessage({ id: remoteResult.errMsgId });\n                } else if (localResult.valid === false) {\n                    return _this3.props.intl.formatMessage({ id: localResult.errMsgId });\n                } else if (remoteResult.valid === false) {\n                    return _this3.props.intl.formatMessage({ id: remoteResult.errMsgId });\n                }\n                return null;\n            });\n        }\n    }, {\n        key: 'validatePasswordIfPresent',\n        value: function validatePasswordIfPresent(password, username) {\n            if (!password) return null; // skip validation if password is blank; null indicates valid\n            var localResult = validate.validatePassword(password, username);\n            if (localResult.valid) return null;\n            return this.props.intl.formatMessage({ id: localResult.errMsgId });\n        }\n    }, {\n        key: 'validatePasswordConfirmIfPresent',\n        value: function validatePasswordConfirmIfPresent(password, passwordConfirm) {\n            if (!passwordConfirm) return null; // allow blank password if not submitting yet\n            var localResult = validate.validatePasswordConfirm(password, passwordConfirm);\n            if (localResult.valid) return null;\n            return this.props.intl.formatMessage({ id: localResult.errMsgId });\n        }\n        // called asynchonously when form submit is initially requested,\n        // along with all of the individual field validation functions\n    }, {\n        key: 'validateForm',\n        value: function validateForm(values) {\n            // in addition to field-level username/password validations, we need to additionally\n            // check that these values aren't blank.\n            var errors = {};\n            var usernameResult = validate.validateUsernameLocally(values.username);\n            if (!usernameResult.valid) {\n                errors.username = this.props.intl.formatMessage({ id: usernameResult.errMsgId });\n            }\n            var passwordResult = validate.validatePassword(values.password, values.username);\n            if (!passwordResult.valid) {\n                errors.password = this.props.intl.formatMessage({ id: passwordResult.errMsgId });\n            }\n            var passwordConfirmResult = validate.validatePasswordConfirm(values.password, values.passwordConfirm);\n            if (!passwordConfirmResult.valid) {\n                errors.passwordConfirm = this.props.intl.formatMessage({ id: passwordConfirmResult.errMsgId });\n            }\n            return errors;\n        }\n        // called after all validations pass with no errors\n    }, {\n        key: 'handleValidSubmit',\n        value: function handleValidSubmit(formData, formikBag) {\n            formikBag.setSubmitting(false); // formik makes us do this ourselves\n            delete formData.showPassword;\n            this.props.onNextStep(formData);\n        }\n    }, {\n        key: 'render',\n        value: function render() {\n            var _this4 = this;\n            return React.createElement(\n                _formik.Formik,\n                {\n                    initialValues: {\n                        username: '',\n                        password: '',\n                        passwordConfirm: '',\n                        showPassword: true\n                    },\n                    validate: this.validateForm,\n                    validateOnBlur: false,\n                    validateOnChange: false,\n                    onSubmit: this.handleValidSubmit\n                },\n                function (props) {\n                    var errors = props.errors,\n                        handleSubmit = props.handleSubmit,\n                        isSubmitting = props.isSubmitting,\n                        setFieldError = props.setFieldError,\n                        setFieldTouched = props.setFieldTouched,\n                        setFieldValue = props.setFieldValue,\n                        touched = props.touched,\n                        validateField = props.validateField,\n                        values = props.values;\n                    return React.createElement(\n                        JoinFlowStep,\n                        {\n                            description: _this4.props.intl.formatMessage({\n                                id: 'registration.usernameStepDescriptionNonEducator'\n                            }),\n                            innerClassName: 'join-flow-inner-username-step',\n                            title: _this4.props.intl.formatMessage({ id: 'general.joinScratch' }),\n                            waiting: isSubmitting,\n                            onSubmit: handleSubmit\n                        },\n                        React.createElement(\n                            'div',\n                            null,\n                            React.createElement(\n                                'div',\n                                { className: 'join-flow-input-title' },\n                                _this4.props.intl.formatMessage({ id: 'registration.createUsername' })\n                            ),\n                            React.createElement(FormikInput, {\n                                autoCapitalize: 'off',\n                                autoComplete: 'off',\n                                autoCorrect: 'off',\n                                className: classNames('join-flow-input'),\n                                error: errors.username,\n                                id: 'username',\n                                name: 'username',\n                                placeholder: _this4.props.intl.formatMessage({ id: 'general.username' }),\n                                spellCheck: false,\n                                toolTip: _this4.state.focused === 'username' && !touched.username && _this4.props.intl.formatMessage({ id: 'registration.usernameAdviceShort' }),\n                                validate: _this4.validateUsernameIfPresent,\n                                validationClassName: 'validation-full-width-input'\n                                /* eslint-disable react/jsx-no-bind */\n                                , onBlur: function onBlur() {\n                                    return validateField('username');\n                                },\n                                onChange: function onChange(e) {\n                                    setFieldValue('username', e.target.value.substring(0, 30));\n                                    setFieldTouched('username');\n                                    setFieldError('username', null);\n                                },\n                                onFocus: function onFocus() {\n                                    return _this4.handleFocused('username');\n                                }\n                                /* eslint-enable react/jsx-no-bind */\n                                , onSetRef: _this4.handleSetUsernameRef\n                            }),\n                            React.createElement(\n                                'div',\n                                { className: 'join-flow-password-section' },\n                                React.createElement(\n                                    'div',\n                                    { className: 'join-flow-input-title' },\n                                    _this4.props.intl.formatMessage({ id: 'registration.choosePasswordStepTitle' })\n                                ),\n                                React.createElement(FormikInput, {\n                                    autoCapitalize: 'off',\n                                    autoComplete: values.showPassword ? 'off' : 'new-password',\n                                    autoCorrect: 'off',\n                                    className: classNames('join-flow-input', { 'join-flow-input-password': !values.showPassword && values.password.length > 0 }),\n                                    error: errors.password,\n                                    id: 'password',\n                                    name: 'password',\n                                    placeholder: _this4.props.intl.formatMessage({ id: 'general.password' }),\n                                    spellCheck: false,\n                                    toolTip: _this4.state.focused === 'password' && !touched.password && _this4.props.intl.formatMessage({ id: 'registration.passwordAdviceShort' }),\n                                    type: values.showPassword ? 'text' : 'password'\n                                    /* eslint-disable react/jsx-no-bind */\n                                    , validate: function validate(password) {\n                                        return _this4.validatePasswordIfPresent(password, values.username);\n                                    },\n                                    validationClassName: 'validation-full-width-input',\n                                    onBlur: function onBlur() {\n                                        return validateField('password');\n                                    },\n                                    onChange: function onChange(e) {\n                                        setFieldValue('password', e.target.value);\n                                        setFieldTouched('password');\n                                        setFieldError('password', null);\n                                    },\n                                    onFocus: function onFocus() {\n                                        return _this4.handleFocused('password');\n                                    }\n                                    /* eslint-enable react/jsx-no-bind */\n                                }),\n                                React.createElement(FormikInput, {\n                                    autoCapitalize: 'off',\n                                    autoComplete: values.showPassword ? 'off' : 'new-password',\n                                    autoCorrect: 'off',\n                                    className: classNames('join-flow-input', 'join-flow-password-confirm', {\n                                        'join-flow-input-password': !values.showPassword && values.passwordConfirm.length > 0,\n                                        'fail': errors.passwordConfirm\n                                    }),\n                                    error: errors.passwordConfirm,\n                                    id: 'passwordConfirm',\n                                    name: 'passwordConfirm',\n                                    placeholder: _this4.props.intl.formatMessage({\n                                        id: 'registration.confirmPasswordInstruction'\n                                    }),\n                                    spellCheck: false,\n                                    toolTip: _this4.state.focused === 'passwordConfirm' && !touched.passwordConfirm && _this4.props.intl.formatMessage({\n                                        id: 'registration.confirmPasswordInstruction'\n                                    }),\n                                    type: values.showPassword ? 'text' : 'password'\n                                    /* eslint-disable react/jsx-no-bind */\n                                    , validate: function validate() {\n                                        return _this4.validatePasswordConfirmIfPresent(values.password, values.passwordConfirm);\n                                    },\n                                    validationClassName: 'validation-full-width-input',\n                                    onBlur: function onBlur() {\n                                        return validateField('passwordConfirm');\n                                    },\n                                    onChange: function onChange(e) {\n                                        setFieldValue('passwordConfirm', e.target.value);\n                                        setFieldTouched('passwordConfirm');\n                                        setFieldError('passwordConfirm', null);\n                                    },\n                                    onFocus: function onFocus() {\n                                        return _this4.handleFocused('passwordConfirm');\n                                    }\n                                    /* eslint-enable react/jsx-no-bind */\n                                }),\n                                React.createElement(FormikCheckbox, {\n                                    id: 'showPassword',\n                                    label: _this4.props.intl.formatMessage({ id: 'registration.showPassword' }),\n                                    labelClassName: 'join-flow-input-title',\n                                    name: 'showPassword'\n                                })\n                            )\n                        )\n                    );\n                }\n            );\n        }\n    }]);\n    return UsernameStep;\n}(React.Component);\nUsernameStep.propTypes = {\n    intl: intlShape,\n    onNextStep: PropTypes.func,\n    sendAnalytics: PropTypes.func.isRequired\n};\nvar IntlUsernameStep = injectIntl(UsernameStep);\nmodule.exports = IntlUsernameStep;\n// ./src/components/join-flow/username-step.jsx\n// module id = 587\n// module chunks = 0 1\n//# sourceURL=scratch:///./src/components/join-flow/username-step.jsx?");
 })