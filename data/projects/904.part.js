/* 904 */
 (function(module, exports, __webpack_require__) {
"use strict";
eval("\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\nvar nets = __webpack_require__(1245);\nvar Asset = __webpack_require__(550);\nvar Helper = __webpack_require__(577);\n/**\n * @typedef {function} UrlFunction - A function which computes a URL from asset information.\n * @param {Asset} - The asset for which the URL should be computed.\n * @returns {string} - The URL for the asset.\n */\nvar WebHelper = function (_Helper) {\n    _inherits(WebHelper, _Helper);\n    function WebHelper(parent) {\n        _classCallCheck(this, WebHelper);\n        /**\n         * @type {Array.<SourceRecord>}\n         * @typedef {object} SourceRecord\n         * @property {Array.<string>} types - The types of asset provided by this source, from AssetType's name field.\n         * @property {UrlFunction} urlFunction - A function which computes a URL from an Asset.\n         */\n        var _this = _possibleConstructorReturn(this, (WebHelper.__proto__ || Object.getPrototypeOf(WebHelper)).call(this, parent));\n        _this.sources = [];\n        return _this;\n    }\n    /**\n     * Register a web-based source for assets. Sources will be checked in order of registration.\n     * @param {Array.<AssetType>} types - The types of asset provided by this source.\n     * @param {UrlFunction} urlFunction - A function which computes a URL from an Asset.\n     */\n    _createClass(WebHelper, [{\n        key: 'addSource',\n        value: function addSource(types, urlFunction) {\n            this.sources.push({\n                types: types.map(function (assetType) {\n                    return assetType.name;\n                }),\n                urlFunction: urlFunction\n            });\n        }\n        /**\n         * Fetch an asset but don't process dependencies.\n         * @param {AssetType} assetType - The type of asset to fetch.\n         * @param {string} assetId - The ID of the asset to fetch: a project ID, MD5, etc.\n         * @param {DataFormat} dataFormat - The file format / file extension of the asset to fetch: PNG, JPG, etc.\n         * @return {Promise.<Asset>} A promise for the contents of the asset.\n         */\n    }, {\n        key: 'load',\n        value: function load(assetType, assetId, dataFormat) {\n            /** @type {Array.<{url:string, result:*}>} List of URLs attempted & errors encountered. */\n            var errors = [];\n            var sources = this.sources.slice();\n            var asset = new Asset(assetType, assetId, dataFormat);\n            var sourceIndex = 0;\n            return new Promise(function (fulfill, reject) {\n                var tryNextSource = function tryNextSource() {\n                    /** @type {UrlFunction} */\n                    var urlFunction = void 0;\n                    while (sourceIndex < sources.length) {\n                        var source = sources[sourceIndex];\n                        ++sourceIndex;\n                        if (source.types.indexOf(assetType.name) >= 0) {\n                            urlFunction = source.urlFunction;\n                            break;\n                        }\n                    }\n                    if (urlFunction) {\n                        var url = urlFunction(asset);\n                        if (url === false) {\n                            tryNextSource();\n                            return;\n                        }\n                        nets({ url: url }, function (err, resp, body) {\n                            // body is a Buffer\n                            if (err || Math.floor(resp.statusCode / 100) !== 2) {\n                                tryNextSource();\n                            } else {\n                                asset.setData(body, dataFormat);\n                                fulfill(asset);\n                            }\n                        });\n                    } else if (errors.length > 0) {\n                        reject(errors);\n                    } else {\n                        fulfill(null); // no sources matching asset\n                    }\n                };\n                tryNextSource();\n            });\n        }\n    }]);\n    return WebHelper;\n}(Helper);\nmodule.exports = WebHelper;\n// ./~/scratch-storage/src/WebHelper.js\n// module id = 904\n// module chunks = 0\n//# sourceURL=scratch:///./~/scratch-storage/src/WebHelper.js?");
 })