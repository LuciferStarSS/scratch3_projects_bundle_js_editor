/* 901 */
 (function(module, exports, __webpack_require__) {
"use strict";
eval("(function(Buffer) {\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\nvar md5 = __webpack_require__(1170);\nvar Asset = __webpack_require__(550);\nvar AssetType = __webpack_require__(751);\nvar DataFormat = __webpack_require__(576);\nvar Helper = __webpack_require__(577);\n/**\n * @typedef {object} BuiltinAssetRecord\n * @property {AssetType} type - The type of the asset.\n * @property {DataFormat} format - The format of the asset's data.\n * @property {?string} id - The asset's unique ID.\n * @property {Buffer} data - The asset's data.\n */\n/**\n * @type {BuiltinAssetRecord[]}\n */\nvar DefaultAssets = [{\n    type: AssetType.ImageBitmap,\n    format: DataFormat.PNG,\n    id: null,\n    data: new Buffer(__webpack_require__(897) // eslint-disable-line global-require\n    )\n}, {\n    type: AssetType.Sound,\n    format: DataFormat.WAV,\n    id: null,\n    data: new Buffer(__webpack_require__(896) // eslint-disable-line global-require\n    )\n}, {\n    type: AssetType.ImageVector,\n    format: DataFormat.SVG,\n    id: null,\n    data: new Buffer(__webpack_require__(898) // eslint-disable-line global-require\n    )\n}];\n/**\n * @type {BuiltinAssetRecord[]}\n */\nvar BuiltinAssets = DefaultAssets.concat([]);\nvar BuiltinHelper = function (_Helper) {\n    _inherits(BuiltinHelper, _Helper);\n    function BuiltinHelper(parent) {\n        _classCallCheck(this, BuiltinHelper);\n        /**\n         * In-memory storage for all built-in assets.\n         * @type {Object.<AssetType, AssetIdMap>} Maps asset type to a map of asset ID to actual assets.\n         * @typedef {Object.<string, BuiltinAssetRecord>} AssetIdMap - Maps asset ID to asset.\n         */\n        var _this = _possibleConstructorReturn(this, (BuiltinHelper.__proto__ || Object.getPrototypeOf(BuiltinHelper)).call(this, parent));\n        _this.assets = {};\n        BuiltinAssets.forEach(function (assetRecord) {\n            assetRecord.id = _this.cache(assetRecord.type, assetRecord.format, assetRecord.data, assetRecord.id);\n        });\n        return _this;\n    }\n    /**\n     * Call `setDefaultAssetId` on the parent `ScratchStorage` instance to register all built-in default assets.\n     */\n    _createClass(BuiltinHelper, [{\n        key: 'registerDefaultAssets',\n        value: function registerDefaultAssets() {\n            var numAssets = DefaultAssets.length;\n            for (var assetIndex = 0; assetIndex < numAssets; ++assetIndex) {\n                var assetRecord = DefaultAssets[assetIndex];\n                this.parent.setDefaultAssetId(assetRecord.type, assetRecord.id);\n            }\n        }\n        /**\n         * Synchronously fetch a cached asset for a given asset id. Returns null if not found.\n         * @param {string} assetId - The id for the asset to fetch.\n         * @returns {?Asset} The asset for assetId, if it exists.\n         */\n    }, {\n        key: 'get',\n        value: function get(assetId) {\n            var asset = null;\n            if (this.assets.hasOwnProperty(assetId)) {\n                /** @type{BuiltinAssetRecord} */\n                var assetRecord = this.assets[assetId];\n                asset = new Asset(assetRecord.type, assetRecord.id, assetRecord.format, assetRecord.data);\n            }\n            return asset;\n        }\n        /**\n         * Cache an asset for future lookups by ID.\n         * @param {AssetType} assetType - The type of the asset to cache.\n         * @param {DataFormat} dataFormat - The dataFormat of the data for the cached asset.\n         * @param {Buffer} data - The data for the cached asset.\n         * @param {string} id - The id for the cached asset.\n         * @returns {string} The calculated id of the cached asset, or the supplied id if the asset is mutable.\n         */\n    }, {\n        key: 'cache',\n        value: function cache(assetType, dataFormat, data, id) {\n            if (!dataFormat) throw new Error('Data cached without specifying its format');\n            if (id) {\n                if (this.assets.hasOwnProperty(id) && assetType.immutable) return id;\n            } else if (assetType.immutable) {\n                id = md5(data);\n            }\n            this.assets[id] = {\n                type: assetType,\n                format: dataFormat,\n                id: id,\n                data: data\n            };\n            return id;\n        }\n        /**\n         * Fetch an asset but don't process dependencies.\n         * @param {AssetType} assetType - The type of asset to fetch.\n         * @param {string} assetId - The ID of the asset to fetch: a project ID, MD5, etc.\n         * @return {Promise.<Asset>} A promise for the contents of the asset.\n         */\n    }, {\n        key: 'load',\n        value: function load(assetType, assetId) {\n            return Promise.resolve(this.get(assetId));\n        }\n    }]);\n    return BuiltinHelper;\n}(Helper);\nmodule.exports = BuiltinHelper;\n}.call(exports, __webpack_require__(269).Buffer))\n// ./~/scratch-storage/src/BuiltinHelper.js\n// module id = 901\n// module chunks = 0\n//# sourceURL=scratch:///./~/scratch-storage/src/BuiltinHelper.js?");
 })